diff --git a/src/.DS_Store b/src/.DS_Store
new file mode 100644
index 0000000..51c9263
Binary files /dev/null and b/src/.DS_Store differ
diff --git a/src/common/address.c b/src/common/address.c
index cfa8fd1..70675c0 100644
--- a/src/common/address.c
+++ b/src/common/address.c
@@ -148,7 +148,9 @@ tor_addr_make_af_unix(tor_addr_t *a)
 }
 
 /** Set the tor_addr_t in <b>a</b> to contain the socket address contained in
- * <b>sa</b>. Return 0 on success and -1 on failure. */
+ * <b>sa</b>.  IF <b>port_out</b> is non-NULL and <b>sa</b> contains a port,
+ * set *<b>port_out</b> to that port. Return 0 on success and -1 on
+ * failure. */
 int
 tor_addr_from_sockaddr(tor_addr_t *a, const struct sockaddr *sa,
                        uint16_t *port_out)
@@ -1039,6 +1041,8 @@ tor_addr_compare_masked(const tor_addr_t *addr1, const tor_addr_t *addr2,
         return r;
       }
       case AF_INET6: {
+        if (mbits > 128)
+          mbits = 128;
         const uint8_t *a1 = tor_addr_to_in6_addr8(addr1);
         const uint8_t *a2 = tor_addr_to_in6_addr8(addr2);
         const int bytes = mbits >> 3;
@@ -1272,7 +1276,7 @@ typedef ULONG (WINAPI *GetAdaptersAddresses_fn_t)(
  * into smartlist of <b>tor_addr_t</b> structures.
  */
 STATIC smartlist_t *
-ifaddrs_to_smartlist(const struct ifaddrs *ifa)
+ifaddrs_to_smartlist(const struct ifaddrs *ifa, sa_family_t family)
 {
   smartlist_t *result = smartlist_new();
   const struct ifaddrs *i;
@@ -1286,6 +1290,8 @@ ifaddrs_to_smartlist(const struct ifaddrs *ifa)
     if (i->ifa_addr->sa_family != AF_INET &&
         i->ifa_addr->sa_family != AF_INET6)
       continue;
+    if (family != AF_UNSPEC && i->ifa_addr->sa_family != family)
+      continue;
     if (tor_addr_from_sockaddr(&tmp, i->ifa_addr, NULL) < 0)
       continue;
     smartlist_add(result, tor_memdup(&tmp, sizeof(tmp)));
@@ -1299,7 +1305,7 @@ ifaddrs_to_smartlist(const struct ifaddrs *ifa)
  * <b>tor_addr_t</b> structures.
  */
 STATIC smartlist_t *
-get_interface_addresses_ifaddrs(int severity)
+get_interface_addresses_ifaddrs(int severity, sa_family_t family)
 {
 
   /* Most free Unixy systems provide getifaddrs, which gives us a linked list
@@ -1312,7 +1318,7 @@ get_interface_addresses_ifaddrs(int severity)
     return NULL;
   }
 
-  result = ifaddrs_to_smartlist(ifa);
+  result = ifaddrs_to_smartlist(ifa, family);
 
   freeifaddrs(ifa);
 
@@ -1354,7 +1360,7 @@ ip_adapter_addresses_to_smartlist(const IP_ADAPTER_ADDRESSES *addresses)
  * <b>tor_addr_t</b>  structures.
  */
 STATIC smartlist_t *
-get_interface_addresses_win32(int severity)
+get_interface_addresses_win32(int severity, sa_family_t family)
 {
 
   /* Windows XP began to provide GetAdaptersAddresses. Windows 2000 had a
@@ -1388,7 +1394,7 @@ get_interface_addresses_win32(int severity)
   /* Guess how much space we need. */
   size = 15*1024;
   addresses = tor_malloc(size);
-  res = fn(AF_UNSPEC, FLAGS, NULL, addresses, &size);
+  res = fn(family, FLAGS, NULL, addresses, &size);
   if (res == ERROR_BUFFER_OVERFLOW) {
     /* we didn't guess that we needed enough space; try again */
     tor_free(addresses);
@@ -1462,15 +1468,26 @@ ifreq_to_smartlist(char *buf, size_t buflen)
  * <b>tor_addr_t</b> structures.
  */
 STATIC smartlist_t *
-get_interface_addresses_ioctl(int severity)
+get_interface_addresses_ioctl(int severity, sa_family_t family)
 {
   /* Some older unixy systems make us use ioctl(SIOCGIFCONF) */
   struct ifconf ifc;
   int fd;
   smartlist_t *result = NULL;
 
-  /* This interface, AFAICT, only supports AF_INET addresses */
-  fd = socket(AF_INET, SOCK_DGRAM, 0);
+  /* This interface, AFAICT, only supports AF_INET addresses,
+   * except on AIX. For Solaris, we could use SIOCGLIFCONF. */
+
+  /* Bail out if family is neither AF_INET nor AF_UNSPEC since
+   * ioctl() technique supports non-IPv4 interface addresses on
+   * a small number of niche systems only. If family is AF_UNSPEC,
+   * fall back to getting AF_INET addresses only. */
+  if (family == AF_UNSPEC)
+    family = AF_INET;
+  else if (family != AF_INET)
+    return NULL;
+
+  fd = socket(family, SOCK_DGRAM, 0);
   if (fd < 0) {
     tor_log(severity, LD_NET, "socket failed: %s", strerror(errno));
     goto done;
@@ -1505,21 +1522,23 @@ get_interface_addresses_ioctl(int severity)
 /** Try to ask our network interfaces what addresses they are bound to.
  * Return a new smartlist of tor_addr_t on success, and NULL on failure.
  * (An empty smartlist indicates that we successfully learned that we have no
- * addresses.)  Log failure messages at <b>severity</b>. */
+ * addresses.)  Log failure messages at <b>severity</b>. Only return the
+ * interface addresses of requested <b>family</b> and ignore the addresses
+ * of other address families. */
 MOCK_IMPL(smartlist_t *,
-get_interface_addresses_raw,(int severity))
+get_interface_addresses_raw,(int severity, sa_family_t family))
 {
   smartlist_t *result = NULL;
 #if defined(HAVE_IFADDRS_TO_SMARTLIST)
-  if ((result = get_interface_addresses_ifaddrs(severity)))
+  if ((result = get_interface_addresses_ifaddrs(severity, family)))
     return result;
 #endif
 #if defined(HAVE_IP_ADAPTER_TO_SMARTLIST)
-  if ((result = get_interface_addresses_win32(severity)))
+  if ((result = get_interface_addresses_win32(severity, family)))
     return result;
 #endif
 #if defined(HAVE_IFCONF_TO_SMARTLIST)
-  if ((result = get_interface_addresses_ioctl(severity)))
+  if ((result = get_interface_addresses_ioctl(severity, family)))
     return result;
 #endif
   (void) severity;
@@ -1527,7 +1546,7 @@ get_interface_addresses_raw,(int severity))
 }
 
 /** Return true iff <b>a</b> is a multicast address.  */
-STATIC int
+int
 tor_addr_is_multicast(const tor_addr_t *a)
 {
   sa_family_t family = tor_addr_family(a);
@@ -1544,8 +1563,9 @@ tor_addr_is_multicast(const tor_addr_t *a)
 }
 
 /** Attempt to retrieve IP address of current host by utilizing some
- * UDP socket trickery. Only look for address of given <b>family</b>.
- * Set result to *<b>addr</b>. Return 0 on success, -1 on failure.
+ * UDP socket trickery. Only look for address of given <b>family</b>
+ * (only AF_INET and AF_INET6 are supported). Set result to *<b>addr</b>.
+ * Return 0 on success, -1 on failure.
  */
 MOCK_IMPL(int,
 get_interface_address6_via_udp_socket_hack,(int severity,
@@ -1683,15 +1703,9 @@ MOCK_IMPL(smartlist_t *,get_interface_address6_list,(int severity,
   tor_addr_t addr;
 
   /* Try to do this the smart way if possible. */
-  if ((addrs = get_interface_addresses_raw(severity))) {
+  if ((addrs = get_interface_addresses_raw(severity, family))) {
     SMARTLIST_FOREACH_BEGIN(addrs, tor_addr_t *, a)
     {
-      if (family != AF_UNSPEC && family != tor_addr_family(a)) {
-        SMARTLIST_DEL_CURRENT(addrs, a);
-        tor_free(a);
-        continue;
-      }
-
       if (tor_addr_is_loopback(a) ||
           tor_addr_is_multicast(a)) {
         SMARTLIST_DEL_CURRENT(addrs, a);
@@ -1717,15 +1731,27 @@ MOCK_IMPL(smartlist_t *,get_interface_address6_list,(int severity,
   }
 
   /* Okay, the smart way is out. */
-  if (get_interface_address6_via_udp_socket_hack(severity,family,&addr))
-     return smartlist_new();
-  if (!include_internal && tor_addr_is_internal(&addr, 0)) {
-    return smartlist_new();
-  } else {
-    addrs = smartlist_new();
-    smartlist_add(addrs, tor_dup_addr(&addr));
-    return addrs;
+  addrs = smartlist_new();
+
+  if (family == AF_INET || family == AF_UNSPEC) {
+    if (get_interface_address6_via_udp_socket_hack(severity,AF_INET,
+                                                   &addr) == 0) {
+      if (include_internal || !tor_addr_is_internal(&addr, 0)) {
+        smartlist_add(addrs, tor_dup_addr(&addr));
+      }
+    }
   }
+
+  if (family == AF_INET6 || family == AF_UNSPEC) {
+    if (get_interface_address6_via_udp_socket_hack(severity,AF_INET6,
+                                                   &addr) == 0) {
+      if (include_internal || !tor_addr_is_internal(&addr, 0)) {
+        smartlist_add(addrs, tor_dup_addr(&addr));
+      }
+    }
+  }
+
+  return addrs;
 }
 
 /* ======
@@ -1781,7 +1807,7 @@ tor_addr_port_parse(int severity, const char *addrport,
 }
 
 /** Given an address of the form "host[:port]", try to divide it into its host
- * ane port portions, setting *<b>address_out</b> to a newly allocated string
+ * and port portions, setting *<b>address_out</b> to a newly allocated string
  * holding the address portion and *<b>port_out</b> to the port (or 0 if no
  * port is given).  Return 0 on success, -1 on failure. */
 int
diff --git a/src/common/address.h b/src/common/address.h
index d2841e1..7609013 100644
--- a/src/common/address.h
+++ b/src/common/address.h
@@ -73,13 +73,13 @@ typedef struct tor_addr_port_t
 
 #define TOR_ADDR_NULL {AF_UNSPEC, {0}}
 
-static INLINE const struct in6_addr *tor_addr_to_in6(const tor_addr_t *a);
-static INLINE uint32_t tor_addr_to_ipv4n(const tor_addr_t *a);
-static INLINE uint32_t tor_addr_to_ipv4h(const tor_addr_t *a);
-static INLINE uint32_t tor_addr_to_mapped_ipv4h(const tor_addr_t *a);
-static INLINE sa_family_t tor_addr_family(const tor_addr_t *a);
-static INLINE const struct in_addr *tor_addr_to_in(const tor_addr_t *a);
-static INLINE int tor_addr_eq_ipv4h(const tor_addr_t *a, uint32_t u);
+static inline const struct in6_addr *tor_addr_to_in6(const tor_addr_t *a);
+static inline uint32_t tor_addr_to_ipv4n(const tor_addr_t *a);
+static inline uint32_t tor_addr_to_ipv4h(const tor_addr_t *a);
+static inline uint32_t tor_addr_to_mapped_ipv4h(const tor_addr_t *a);
+static inline sa_family_t tor_addr_family(const tor_addr_t *a);
+static inline const struct in_addr *tor_addr_to_in(const tor_addr_t *a);
+static inline int tor_addr_eq_ipv4h(const tor_addr_t *a, uint32_t u);
 
 socklen_t tor_addr_to_sockaddr(const tor_addr_t *a, uint16_t port,
                                struct sockaddr *sa_out, socklen_t len);
@@ -91,7 +91,7 @@ char *tor_sockaddr_to_str(const struct sockaddr *sa);
 
 /** Return an in6_addr* equivalent to <b>a</b>, or NULL if <b>a</b> is not
  * an IPv6 address. */
-static INLINE const struct in6_addr *
+static inline const struct in6_addr *
 tor_addr_to_in6(const tor_addr_t *a)
 {
   return a->family == AF_INET6 ? &a->addr.in6_addr : NULL;
@@ -115,14 +115,14 @@ tor_addr_to_in6(const tor_addr_t *a)
 
 /** Return an IPv4 address in network order for <b>a</b>, or 0 if
  * <b>a</b> is not an IPv4 address. */
-static INLINE uint32_t
+static inline uint32_t
 tor_addr_to_ipv4n(const tor_addr_t *a)
 {
   return a->family == AF_INET ? a->addr.in_addr.s_addr : 0;
 }
 /** Return an IPv4 address in host order for <b>a</b>, or 0 if
  * <b>a</b> is not an IPv4 address. */
-static INLINE uint32_t
+static inline uint32_t
 tor_addr_to_ipv4h(const tor_addr_t *a)
 {
   return ntohl(tor_addr_to_ipv4n(a));
@@ -131,7 +131,7 @@ tor_addr_to_ipv4h(const tor_addr_t *a)
  * 0 if <b>a</b> is not an IPv6 address.
  *
  * (Does not check whether the address is really a mapped address */
-static INLINE uint32_t
+static inline uint32_t
 tor_addr_to_mapped_ipv4h(const tor_addr_t *a)
 {
   if (a->family == AF_INET6) {
@@ -149,21 +149,21 @@ tor_addr_to_mapped_ipv4h(const tor_addr_t *a)
 }
 /** Return the address family of <b>a</b>.  Possible values are:
  * AF_INET6, AF_INET, AF_UNSPEC. */
-static INLINE sa_family_t
+static inline sa_family_t
 tor_addr_family(const tor_addr_t *a)
 {
   return a->family;
 }
 /** Return an in_addr* equivalent to <b>a</b>, or NULL if <b>a</b> is not
  * an IPv4 address. */
-static INLINE const struct in_addr *
+static inline const struct in_addr *
 tor_addr_to_in(const tor_addr_t *a)
 {
   return a->family == AF_INET ? &a->addr.in_addr : NULL;
 }
 /** Return true iff <b>a</b> is an IPv4 address equal to the host-ordered
  * address in <b>u</b>. */
-static INLINE int
+static inline int
 tor_addr_eq_ipv4h(const tor_addr_t *a, uint32_t u)
 {
   return a->family == AF_INET ? (tor_addr_to_ipv4h(a) == u) : 0;
@@ -221,6 +221,7 @@ int tor_addr_is_internal_(const tor_addr_t *ip, int for_listening,
                           const char *filename, int lineno);
 #define tor_addr_is_internal(addr, for_listening) \
   tor_addr_is_internal_((addr), (for_listening), SHORT_FILE__, __LINE__)
+int tor_addr_is_multicast(const tor_addr_t *a);
 
 /** Longest length that can be required for a reverse lookup name. */
 /* 32 nybbles, 32 dots, 8 characters of "ip6.arpa", 1 NUL: 73 characters. */
@@ -288,7 +289,7 @@ char *tor_dup_ip(uint32_t addr) ATTR_MALLOC;
 MOCK_DECL(int,get_interface_address,(int severity, uint32_t *addr));
 /** Free a smartlist of IP addresses returned by get_interface_address_list.
  */
-static INLINE void
+static inline void
 free_interface_address_list(smartlist_t *addrs)
 {
   free_interface_address6_list(addrs);
@@ -301,7 +302,7 @@ free_interface_address_list(smartlist_t *addrs)
  * Returns NULL on failure.
  * Use free_interface_address_list to free the returned list.
  */
-static INLINE smartlist_t *
+static inline smartlist_t *
 get_interface_address_list(int severity, int include_internal)
 {
   return get_interface_address6_list(severity, AF_INET, include_internal);
@@ -310,27 +311,31 @@ get_interface_address_list(int severity, int include_internal)
 tor_addr_port_t *tor_addr_port_new(const tor_addr_t *addr, uint16_t port);
 
 #ifdef ADDRESS_PRIVATE
-MOCK_DECL(smartlist_t *,get_interface_addresses_raw,(int severity));
-STATIC int tor_addr_is_multicast(const tor_addr_t *a);
+MOCK_DECL(smartlist_t *,get_interface_addresses_raw,(int severity,
+                                                     sa_family_t family));
 MOCK_DECL(int,get_interface_address6_via_udp_socket_hack,(int severity,
                                                           sa_family_t family,
                                                           tor_addr_t *addr));
 
 #ifdef HAVE_IFADDRS_TO_SMARTLIST
-STATIC smartlist_t *ifaddrs_to_smartlist(const struct ifaddrs *ifa);
-STATIC smartlist_t *get_interface_addresses_ifaddrs(int severity);
+STATIC smartlist_t *ifaddrs_to_smartlist(const struct ifaddrs *ifa,
+                                         sa_family_t family);
+STATIC smartlist_t *get_interface_addresses_ifaddrs(int severity,
+                                                    sa_family_t family);
 #endif
 
 #ifdef HAVE_IP_ADAPTER_TO_SMARTLIST
 STATIC smartlist_t *ip_adapter_addresses_to_smartlist(
                                         const IP_ADAPTER_ADDRESSES *addresses);
-STATIC smartlist_t *get_interface_addresses_win32(int severity);
+STATIC smartlist_t *get_interface_addresses_win32(int severity,
+                                                  sa_family_t family);
 #endif
 
 #ifdef HAVE_IFCONF_TO_SMARTLIST
 STATIC smartlist_t *ifreq_to_smartlist(char *ifr,
                                        size_t buflen);
-STATIC smartlist_t *get_interface_addresses_ioctl(int severity);
+STATIC smartlist_t *get_interface_addresses_ioctl(int severity,
+                                                  sa_family_t family);
 #endif
 
 #endif // ADDRESS_PRIVATE
diff --git a/src/common/aes.c b/src/common/aes.c
index 5f2c3f2..fd20433 100644
--- a/src/common/aes.c
+++ b/src/common/aes.c
@@ -81,47 +81,34 @@
 
 #ifdef USE_EVP_AES_CTR
 
-struct aes_cnt_cipher {
-  EVP_CIPHER_CTX evp;
-};
+/* We don't actually define the struct here. */
 
 aes_cnt_cipher_t *
 aes_new_cipher(const char *key, const char *iv)
 {
-  aes_cnt_cipher_t *cipher;
-  cipher = tor_malloc_zero(sizeof(aes_cnt_cipher_t));
-  EVP_EncryptInit(&cipher->evp, EVP_aes_128_ctr(),
+  EVP_CIPHER_CTX *cipher = EVP_CIPHER_CTX_new();
+  EVP_EncryptInit(cipher, EVP_aes_128_ctr(),
                   (const unsigned char*)key, (const unsigned char *)iv);
-  return cipher;
+  return (aes_cnt_cipher_t *) cipher;
 }
 void
-aes_cipher_free(aes_cnt_cipher_t *cipher)
+aes_cipher_free(aes_cnt_cipher_t *cipher_)
 {
-  if (!cipher)
+  if (!cipher_)
     return;
-  EVP_CIPHER_CTX_cleanup(&cipher->evp);
-  memwipe(cipher, 0, sizeof(aes_cnt_cipher_t));
-  tor_free(cipher);
-}
-void
-aes_crypt(aes_cnt_cipher_t *cipher, const char *input, size_t len,
-          char *output)
-{
-  int outl;
-
-  tor_assert(len < INT_MAX);
-
-  EVP_EncryptUpdate(&cipher->evp, (unsigned char*)output,
-                    &outl, (const unsigned char *)input, (int)len);
+  EVP_CIPHER_CTX *cipher = (EVP_CIPHER_CTX *) cipher_;
+  EVP_CIPHER_CTX_cleanup(cipher);
+  EVP_CIPHER_CTX_free(cipher);
 }
 void
-aes_crypt_inplace(aes_cnt_cipher_t *cipher, char *data, size_t len)
+aes_crypt_inplace(aes_cnt_cipher_t *cipher_, char *data, size_t len)
 {
   int outl;
+  EVP_CIPHER_CTX *cipher = (EVP_CIPHER_CTX *) cipher_;
 
   tor_assert(len < INT_MAX);
 
-  EVP_EncryptUpdate(&cipher->evp, (unsigned char*)data,
+  EVP_EncryptUpdate(cipher, (unsigned char*)data,
                     &outl, (unsigned char*)data, (int)len);
 }
 int
@@ -182,10 +169,6 @@ struct aes_cnt_cipher {
  * we're testing it or because we have hardware acceleration configured */
 static int should_use_EVP = 0;
 
-/** True iff we have tested the counter-mode implementation and found that it
- * doesn't have the counter-mode bug from OpenSSL 1.0.0. */
-static int should_use_openssl_CTR = 0;
-
 /** Check whether we should use the EVP interface for AES. If <b>force_val</b>
  * is nonnegative, we use use EVP iff it is true.  Otherwise, we use EVP
  * if there is an engine enabled for aes-ecb. */
@@ -250,13 +233,9 @@ evaluate_ctr_for_aes(void)
 
   if (fast_memneq(output, encrypt_zero, 16)) {
     /* Counter mode is buggy */
-    log_notice(LD_CRYPTO, "This OpenSSL has a buggy version of counter mode; "
-               "not using it.");
-  } else {
-    /* Counter mode is okay */
-    log_info(LD_CRYPTO, "This OpenSSL has a good implementation of counter "
-               "mode; using it.");
-    should_use_openssl_CTR = 1;
+    log_err(LD_CRYPTO, "This OpenSSL has a buggy version of counter mode; "
+                  "quitting tor.");
+    exit(1);
   }
   return 0;
 }
@@ -267,29 +246,6 @@ evaluate_ctr_for_aes(void)
 #define COUNTER(c, n) ((c)->counter ## n)
 #endif
 
-/**
- * Helper function: set <b>cipher</b>'s internal buffer to the encrypted
- * value of the current counter.
- */
-static INLINE void
-aes_fill_buf_(aes_cnt_cipher_t *cipher)
-{
-  /* We don't currently use OpenSSL's counter mode implementation because:
-   *  1) some versions have known bugs
-   *  2) its attitude towards IVs is not our own
-   *  3) changing the counter position was not trivial, last time I looked.
-   * None of these issues are insurmountable in principle.
-   */
-
-  if (cipher->using_evp) {
-    int outl=16, inl=16;
-    EVP_EncryptUpdate(&cipher->key.evp, cipher->buf, &outl,
-                      cipher->ctr_buf.buf, inl);
-  } else {
-    AES_encrypt(cipher->ctr_buf.buf, cipher->buf, &cipher->key.aes);
-  }
-}
-
 static void aes_set_key(aes_cnt_cipher_t *cipher, const char *key,
                         int key_bits);
 static void aes_set_iv(aes_cnt_cipher_t *cipher, const char *iv);
@@ -342,10 +298,7 @@ aes_set_key(aes_cnt_cipher_t *cipher, const char *key, int key_bits)
 
   cipher->pos = 0;
 
-  if (should_use_openssl_CTR)
-    memset(cipher->buf, 0, sizeof(cipher->buf));
-  else
-    aes_fill_buf_(cipher);
+  memset(cipher->buf, 0, sizeof(cipher->buf));
 }
 
 /** Release storage held by <b>cipher</b>
@@ -381,63 +334,6 @@ evp_block128_fn(const uint8_t in[16],
   EVP_EncryptUpdate(ctx, out, &outl, in, inl);
 }
 
-/** Encrypt <b>len</b> bytes from <b>input</b>, storing the result in
- * <b>output</b>.  Uses the key in <b>cipher</b>, and advances the counter
- * by <b>len</b> bytes as it encrypts.
- */
-void
-aes_crypt(aes_cnt_cipher_t *cipher, const char *input, size_t len,
-          char *output)
-{
-  if (should_use_openssl_CTR) {
-    if (cipher->using_evp) {
-      /* In openssl 1.0.0, there's an if'd out EVP_aes_128_ctr in evp.h.  If
-       * it weren't disabled, it might be better just to use that.
-       */
-      CRYPTO_ctr128_encrypt((const unsigned char *)input,
-                            (unsigned char *)output,
-                            len,
-                            &cipher->key.evp,
-                            cipher->ctr_buf.buf,
-                            cipher->buf,
-                            &cipher->pos,
-                            evp_block128_fn);
-    } else {
-      AES_ctr128_encrypt((const unsigned char *)input,
-                         (unsigned char *)output,
-                         len,
-                         &cipher->key.aes,
-                         cipher->ctr_buf.buf,
-                         cipher->buf,
-                         &cipher->pos);
-    }
-    return;
-  } else {
-    int c = cipher->pos;
-    if (PREDICT_UNLIKELY(!len)) return;
-
-    while (1) {
-      do {
-        if (len-- == 0) { cipher->pos = c; return; }
-        *(output++) = *(input++) ^ cipher->buf[c];
-      } while (++c != 16);
-      cipher->pos = c = 0;
-      if (PREDICT_UNLIKELY(! ++COUNTER(cipher, 0))) {
-        if (PREDICT_UNLIKELY(! ++COUNTER(cipher, 1))) {
-          if (PREDICT_UNLIKELY(! ++COUNTER(cipher, 2))) {
-            ++COUNTER(cipher, 3);
-            UPDATE_CTR_BUF(cipher, 3);
-          }
-          UPDATE_CTR_BUF(cipher, 2);
-        }
-        UPDATE_CTR_BUF(cipher, 1);
-      }
-      UPDATE_CTR_BUF(cipher, 0);
-      aes_fill_buf_(cipher);
-    }
-  }
-}
-
 /** Encrypt <b>len</b> bytes from <b>input</b>, storing the results in place.
  * Uses the key in <b>cipher</b>, and advances the counter by <b>len</b> bytes
  * as it encrypts.
@@ -445,32 +341,26 @@ aes_crypt(aes_cnt_cipher_t *cipher, const char *input, size_t len,
 void
 aes_crypt_inplace(aes_cnt_cipher_t *cipher, char *data, size_t len)
 {
-  if (should_use_openssl_CTR) {
-    aes_crypt(cipher, data, len, data);
-    return;
+  if (cipher->using_evp) {
+    /* In openssl 1.0.0, there's an if'd out EVP_aes_128_ctr in evp.h.  If
+     * it weren't disabled, it might be better just to use that.
+     */
+    CRYPTO_ctr128_encrypt((const unsigned char *)data,
+                          (unsigned char *)data,
+                          len,
+                          &cipher->key.evp,
+                          cipher->ctr_buf.buf,
+                          cipher->buf,
+                          &cipher->pos,
+                          evp_block128_fn);
   } else {
-    int c = cipher->pos;
-    if (PREDICT_UNLIKELY(!len)) return;
-
-    while (1) {
-      do {
-        if (len-- == 0) { cipher->pos = c; return; }
-        *(data++) ^= cipher->buf[c];
-      } while (++c != 16);
-      cipher->pos = c = 0;
-      if (PREDICT_UNLIKELY(! ++COUNTER(cipher, 0))) {
-        if (PREDICT_UNLIKELY(! ++COUNTER(cipher, 1))) {
-          if (PREDICT_UNLIKELY(! ++COUNTER(cipher, 2))) {
-            ++COUNTER(cipher, 3);
-            UPDATE_CTR_BUF(cipher, 3);
-          }
-          UPDATE_CTR_BUF(cipher, 2);
-        }
-        UPDATE_CTR_BUF(cipher, 1);
-      }
-      UPDATE_CTR_BUF(cipher, 0);
-      aes_fill_buf_(cipher);
-    }
+    AES_ctr128_encrypt((const unsigned char *)data,
+                       (unsigned char *)data,
+                       len,
+                       &cipher->key.aes,
+                       cipher->ctr_buf.buf,
+                       cipher->buf,
+                       &cipher->pos);
   }
 }
 
@@ -487,9 +377,6 @@ aes_set_iv(aes_cnt_cipher_t *cipher, const char *iv)
 #endif
   cipher->pos = 0;
   memcpy(cipher->ctr_buf.buf, iv, 16);
-
-  if (!should_use_openssl_CTR)
-    aes_fill_buf_(cipher);
 }
 
 #endif
diff --git a/src/common/aes.h b/src/common/aes.h
index df2f3aa..bd04565 100644
--- a/src/common/aes.h
+++ b/src/common/aes.h
@@ -13,13 +13,10 @@
  * \brief Headers for aes.c
  */
 
-struct aes_cnt_cipher;
 typedef struct aes_cnt_cipher aes_cnt_cipher_t;
 
 aes_cnt_cipher_t* aes_new_cipher(const char *key, const char *iv);
 void aes_cipher_free(aes_cnt_cipher_t *cipher);
-void aes_crypt(aes_cnt_cipher_t *cipher, const char *input, size_t len,
-               char *output);
 void aes_crypt_inplace(aes_cnt_cipher_t *cipher, char *data, size_t len);
 
 int evaluate_evp_for_aes(int force_value);
diff --git a/src/common/backtrace.c b/src/common/backtrace.c
index a2d5378..94de1eb 100644
--- a/src/common/backtrace.c
+++ b/src/common/backtrace.c
@@ -62,16 +62,16 @@ static tor_mutex_t cb_buf_mutex;
  * ucontext_t structure.
  */
 void
-clean_backtrace(void **stack, int depth, const ucontext_t *ctx)
+clean_backtrace(void **stack, size_t depth, const ucontext_t *ctx)
 {
 #ifdef PC_FROM_UCONTEXT
 #if defined(__linux__)
-  const int n = 1;
+  const size_t n = 1;
 #elif defined(__darwin__) || defined(__APPLE__) || defined(__OpenBSD__) \
   || defined(__FreeBSD__)
-  const int n = 2;
+  const size_t n = 2;
 #else
-  const int n = 1;
+  const size_t n = 1;
 #endif
   if (depth <= n)
     return;
@@ -89,14 +89,14 @@ clean_backtrace(void **stack, int depth, const ucontext_t *ctx)
 void
 log_backtrace(int severity, int domain, const char *msg)
 {
-  int depth;
+  size_t depth;
   char **symbols;
-  int i;
+  size_t i;
 
   tor_mutex_acquire(&cb_buf_mutex);
 
   depth = backtrace(cb_buf, MAX_DEPTH);
-  symbols = backtrace_symbols(cb_buf, depth);
+  symbols = backtrace_symbols(cb_buf, (int)depth);
 
   tor_log(severity, domain, "%s. Stack trace:", msg);
   if (!symbols) {
@@ -120,7 +120,7 @@ static void
 crash_handler(int sig, siginfo_t *si, void *ctx_)
 {
   char buf[40];
-  int depth;
+  size_t depth;
   ucontext_t *ctx = (ucontext_t *) ctx_;
   int n_fds, i;
   const int *fds = NULL;
@@ -139,7 +139,7 @@ crash_handler(int sig, siginfo_t *si, void *ctx_)
 
   n_fds = tor_log_get_sigsafe_err_fds(&fds);
   for (i=0; i < n_fds; ++i)
-    backtrace_symbols_fd(cb_buf, depth, fds[i]);
+    backtrace_symbols_fd(cb_buf, (int)depth, fds[i]);
 
   abort();
 }
@@ -174,8 +174,8 @@ install_bt_handler(void)
      * libc has pre-loaded the symbols we need to dump things, so that later
      * reads won't be denied by the sandbox code */
     char **symbols;
-    int depth = backtrace(cb_buf, MAX_DEPTH);
-    symbols = backtrace_symbols(cb_buf, depth);
+    size_t depth = backtrace(cb_buf, MAX_DEPTH);
+    symbols = backtrace_symbols(cb_buf, (int) depth);
     if (symbols)
       free(symbols);
   }
@@ -215,9 +215,10 @@ int
 configure_backtrace_handler(const char *tor_version)
 {
   tor_free(bt_version);
-  if (!tor_version)
-    tor_version = "";
-  tor_asprintf(&bt_version, "Tor %s", tor_version);
+  if (tor_version)
+    tor_asprintf(&bt_version, "Tor %s", tor_version);
+  else
+    tor_asprintf(&bt_version, "Tor");
 
   return install_bt_handler();
 }
diff --git a/src/common/backtrace.h b/src/common/backtrace.h
index a9151d7..838e18e 100644
--- a/src/common/backtrace.h
+++ b/src/common/backtrace.h
@@ -13,7 +13,7 @@ void clean_up_backtrace_handler(void);
 #ifdef EXPOSE_CLEAN_BACKTRACE
 #if defined(HAVE_EXECINFO_H) && defined(HAVE_BACKTRACE) && \
   defined(HAVE_BACKTRACE_SYMBOLS_FD) && defined(HAVE_SIGACTION)
-void clean_backtrace(void **stack, int depth, const ucontext_t *ctx);
+void clean_backtrace(void **stack, size_t depth, const ucontext_t *ctx);
 #endif
 #endif
 
diff --git a/src/common/compat.c b/src/common/compat.c
index 7d72b4b..b20da04 100644
--- a/src/common/compat.c
+++ b/src/common/compat.c
@@ -71,6 +71,9 @@
 #ifdef HAVE_SYS_STATVFS_H
 #include <sys/statvfs.h>
 #endif
+#ifdef HAVE_SYS_CAPABILITY_H
+#include <sys/capability.h>
+#endif
 
 #ifdef _WIN32
 #include <conio.h>
@@ -714,7 +717,8 @@ strtok_helper(char *cp, const char *sep)
 }
 
 /** Implementation of strtok_r for platforms whose coders haven't figured out
- * how to write one.  Hey guys!  You can use this code here for free! */
+ * how to write one.  Hey, retrograde libc developers!  You can use this code
+ * here for free! */
 char *
 tor_strtok_r_impl(char *str, const char *sep, char **lasts)
 {
@@ -1078,7 +1082,7 @@ static int n_sockets_open = 0;
 static tor_mutex_t *socket_accounting_mutex = NULL;
 
 /** Helper: acquire the socket accounting lock. */
-static INLINE void
+static inline void
 socket_accounting_lock(void)
 {
   if (PREDICT_UNLIKELY(!socket_accounting_mutex))
@@ -1087,7 +1091,7 @@ socket_accounting_lock(void)
 }
 
 /** Helper: release the socket accounting lock. */
-static INLINE void
+static inline void
 socket_accounting_unlock(void)
 {
   tor_mutex_release(socket_accounting_mutex);
@@ -1099,6 +1103,7 @@ socket_accounting_unlock(void)
 int
 tor_close_socket_simple(tor_socket_t s)
 {
+  printf("Close socket (SIMPLE)!\n");
   int r = 0;
 
   /* On Windows, you have to call close() on fds returned by open(),
@@ -1127,6 +1132,7 @@ tor_close_socket_simple(tor_socket_t s)
 int
 tor_close_socket(tor_socket_t s)
 {
+  printf("Close socket!\n");
   int r = tor_close_socket_simple(s);
 
   socket_accounting_lock();
@@ -1163,7 +1169,7 @@ tor_close_socket(tor_socket_t s)
 #ifdef DEBUG_SOCKET_COUNTING
 /** Helper: if DEBUG_SOCKET_COUNTING is enabled, remember that <b>s</b> is
  * now an open socket. */
-static INLINE void
+static inline void
 mark_socket_open(tor_socket_t s)
 {
   /* XXXX This bitarray business will NOT work on windows: sockets aren't
@@ -1219,6 +1225,7 @@ tor_socket_t
 tor_open_socket_with_extensions(int domain, int type, int protocol,
                                 int cloexec, int nonblock)
 {
+  printf("Opening socket!\n");
   tor_socket_t s;
 
   /* We are about to create a new file descriptor so make sure we have
@@ -1486,6 +1493,20 @@ tor_socketpair(int family, int type, int protocol, tor_socket_t fd[2])
 }
 
 #ifdef NEED_ERSATZ_SOCKETPAIR
+
+static inline socklen_t
+SIZEOF_SOCKADDR(int domain)
+{
+  switch (domain) {
+    case AF_INET:
+      return sizeof(struct sockaddr_in);
+    case AF_INET6:
+      return sizeof(struct sockaddr_in6);
+    default:
+      return 0;
+  }
+}
+
 /**
  * Helper used to implement socketpair on systems that lack it, by
  * making a direct connection to localhost.
@@ -1501,13 +1522,21 @@ tor_ersatz_socketpair(int family, int type, int protocol, tor_socket_t fd[2])
     tor_socket_t listener = TOR_INVALID_SOCKET;
     tor_socket_t connector = TOR_INVALID_SOCKET;
     tor_socket_t acceptor = TOR_INVALID_SOCKET;
-    struct sockaddr_in listen_addr;
-    struct sockaddr_in connect_addr;
+    tor_addr_t listen_tor_addr;
+    struct sockaddr_storage connect_addr_ss, listen_addr_ss;
+    struct sockaddr *listen_addr = (struct sockaddr *) &listen_addr_ss;
+    uint16_t listen_port = 0;
+    tor_addr_t connect_tor_addr;
+    uint16_t connect_port = 0;
+    struct sockaddr *connect_addr = (struct sockaddr *) &connect_addr_ss;
     socklen_t size;
     int saved_errno = -1;
+    int ersatz_domain = AF_INET;
 
-    memset(&connect_addr, 0, sizeof(connect_addr));
-    memset(&listen_addr, 0, sizeof(listen_addr));
+    memset(&connect_tor_addr, 0, sizeof(connect_tor_addr));
+    memset(&connect_addr_ss, 0, sizeof(connect_addr_ss));
+    memset(&listen_tor_addr, 0, sizeof(listen_tor_addr));
+    memset(&listen_addr_ss, 0, sizeof(listen_addr_ss));
 
     if (protocol
 #ifdef AF_UNIX
@@ -1524,47 +1553,71 @@ tor_ersatz_socketpair(int family, int type, int protocol, tor_socket_t fd[2])
       return -EINVAL;
     }
 
-    listener = tor_open_socket(AF_INET, type, 0);
-    if (!SOCKET_OK(listener))
-      return -tor_socket_errno(-1);
-    memset(&listen_addr, 0, sizeof(listen_addr));
-    listen_addr.sin_family = AF_INET;
-    listen_addr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);
-    listen_addr.sin_port = 0;   /* kernel chooses port.  */
-    if (bind(listener, (struct sockaddr *) &listen_addr, sizeof (listen_addr))
-        == -1)
+    listener = tor_open_socket(ersatz_domain, type, 0);
+    if (!SOCKET_OK(listener)) {
+      int first_errno = tor_socket_errno(-1);
+      if (first_errno == SOCK_ERRNO(EPROTONOSUPPORT)
+          && ersatz_domain == AF_INET) {
+        /* Assume we're on an IPv6-only system */
+        ersatz_domain = AF_INET6;
+        listener = tor_open_socket(ersatz_domain, type, 0);
+        if (!SOCKET_OK(listener)) {
+          /* Keep the previous behaviour, which was to return the IPv4 error.
+           * (This may be less informative on IPv6-only systems.)
+           * XX/teor - is there a better way to decide which errno to return?
+           * (I doubt we care much either way, once there is an error.)
+           */
+          return -first_errno;
+        }
+      }
+    }
+    /* If there is no 127.0.0.1 or ::1, this will and must fail. Otherwise, we
+     * risk exposing a socketpair on a routable IP address. (Some BSD jails
+     * use a routable address for localhost. Fortunately, they have the real
+     * AF_UNIX socketpair.) */
+    if (ersatz_domain == AF_INET) {
+      tor_addr_from_ipv4h(&listen_tor_addr, INADDR_LOOPBACK);
+    } else {
+      tor_addr_parse(&listen_tor_addr, "[::1]");
+    }
+    tor_assert(tor_addr_is_loopback(&listen_tor_addr));
+    size = tor_addr_to_sockaddr(&listen_tor_addr,
+                         0 /* kernel chooses port.  */,
+                         listen_addr,
+                         sizeof(listen_addr_ss));
+    if (bind(listener, listen_addr, size) == -1)
       goto tidy_up_and_fail;
     if (listen(listener, 1) == -1)
       goto tidy_up_and_fail;
 
-    connector = tor_open_socket(AF_INET, type, 0);
+    connector = tor_open_socket(ersatz_domain, type, 0);
     if (!SOCKET_OK(connector))
       goto tidy_up_and_fail;
     /* We want to find out the port number to connect to.  */
-    size = sizeof(connect_addr);
-    if (getsockname(listener, (struct sockaddr *) &connect_addr, &size) == -1)
+    size = sizeof(connect_addr_ss);
+    if (getsockname(listener, connect_addr, &size) == -1)
       goto tidy_up_and_fail;
-    if (size != sizeof (connect_addr))
+    if (size != SIZEOF_SOCKADDR (connect_addr->sa_family))
       goto abort_tidy_up_and_fail;
-    if (connect(connector, (struct sockaddr *) &connect_addr,
-                sizeof(connect_addr)) == -1)
+    if (connect(connector, connect_addr, size) == -1)
       goto tidy_up_and_fail;
 
-    size = sizeof(listen_addr);
-    acceptor = tor_accept_socket(listener,
-                                 (struct sockaddr *) &listen_addr, &size);
+    size = sizeof(listen_addr_ss);
+    acceptor = tor_accept_socket(listener, listen_addr, &size);
     if (!SOCKET_OK(acceptor))
       goto tidy_up_and_fail;
-    if (size != sizeof(listen_addr))
+    if (size != SIZEOF_SOCKADDR(listen_addr->sa_family))
       goto abort_tidy_up_and_fail;
     /* Now check we are talking to ourself by matching port and host on the
        two sockets.  */
-    if (getsockname(connector, (struct sockaddr *) &connect_addr, &size) == -1)
+    if (getsockname(connector, connect_addr, &size) == -1)
       goto tidy_up_and_fail;
-    if (size != sizeof (connect_addr)
-        || listen_addr.sin_family != connect_addr.sin_family
-        || listen_addr.sin_addr.s_addr != connect_addr.sin_addr.s_addr
-        || listen_addr.sin_port != connect_addr.sin_port) {
+    /* Set *_tor_addr and *_port to the address and port that was used */
+    tor_addr_from_sockaddr(&listen_tor_addr, listen_addr, &listen_port);
+    tor_addr_from_sockaddr(&connect_tor_addr, connect_addr, &connect_port);
+    if (size != SIZEOF_SOCKADDR (connect_addr->sa_family)
+        || tor_addr_compare(&listen_tor_addr, &connect_tor_addr, CMP_SEMANTIC)
+        || listen_port != connect_port) {
       goto abort_tidy_up_and_fail;
     }
     tor_close_socket(listener);
@@ -1590,6 +1643,9 @@ tor_ersatz_socketpair(int family, int type, int protocol, tor_socket_t fd[2])
       tor_close_socket(acceptor);
     return -saved_errno;
 }
+
+#undef SIZEOF_SOCKADDR
+
 #endif
 
 /* Return the maximum number of allowed sockets. */
@@ -1917,17 +1973,99 @@ tor_getpwuid(uid_t uid)
 }
 #endif
 
+/** Return true iff we were compiled with capability support, and capabilities
+ * seem to work. **/
+int
+have_capability_support(void)
+{
+#ifdef HAVE_LINUX_CAPABILITIES
+  cap_t caps = cap_get_proc();
+  if (caps == NULL)
+    return 0;
+  cap_free(caps);
+  return 1;
+#else
+  return 0;
+#endif
+}
+
+#ifdef HAVE_LINUX_CAPABILITIES
+/** Helper. Drop all capabilities but a small set, and set PR_KEEPCAPS as
+ * appropriate.
+ *
+ * If pre_setuid, retain only CAP_NET_BIND_SERVICE, CAP_SETUID, and
+ * CAP_SETGID, and use PR_KEEPCAPS to ensure that capabilities persist across
+ * setuid().
+ *
+ * If not pre_setuid, retain only CAP_NET_BIND_SERVICE, and disable
+ * PR_KEEPCAPS.
+ *
+ * Return 0 on success, and -1 on failure.
+ */
+static int
+drop_capabilities(int pre_setuid)
+{
+  /* We keep these three capabilities, and these only, as we setuid.
+   * After we setuid, we drop all but the first. */
+  const cap_value_t caplist[] = {
+    CAP_NET_BIND_SERVICE, CAP_SETUID, CAP_SETGID
+  };
+  const char *where = pre_setuid ? "pre-setuid" : "post-setuid";
+  const int n_effective = pre_setuid ? 3 : 1;
+  const int n_permitted = pre_setuid ? 3 : 1;
+  const int n_inheritable = 1;
+  const int keepcaps = pre_setuid ? 1 : 0;
+
+  /* Sets whether we keep capabilities across a setuid. */
+  if (prctl(PR_SET_KEEPCAPS, keepcaps) < 0) {
+    log_warn(LD_CONFIG, "Unable to call prctl() %s: %s",
+             where, strerror(errno));
+    return -1;
+  }
+
+  cap_t caps = cap_get_proc();
+  if (!caps) {
+    log_warn(LD_CONFIG, "Unable to call cap_get_proc() %s: %s",
+             where, strerror(errno));
+    return -1;
+  }
+  cap_clear(caps);
+
+  cap_set_flag(caps, CAP_EFFECTIVE, n_effective, caplist, CAP_SET);
+  cap_set_flag(caps, CAP_PERMITTED, n_permitted, caplist, CAP_SET);
+  cap_set_flag(caps, CAP_INHERITABLE, n_inheritable, caplist, CAP_SET);
+
+  int r = cap_set_proc(caps);
+  cap_free(caps);
+  if (r < 0) {
+    log_warn(LD_CONFIG, "No permission to set capabilities %s: %s",
+             where, strerror(errno));
+    return -1;
+  }
+
+  return 0;
+}
+#endif
+
 /** Call setuid and setgid to run as <b>user</b> and switch to their
  * primary group.  Return 0 on success.  On failure, log and return -1.
+ *
+ * If SWITCH_ID_KEEP_BINDLOW is set in 'flags', try to use the capability
+ * system to retain the abilitity to bind low ports.
+ *
+ * If SWITCH_ID_WARN_IF_NO_CAPS is set in flags, also warn if we have
+ * don't have capability support.
  */
 int
-switch_id(const char *user)
+switch_id(const char *user, const unsigned flags)
 {
 #ifndef _WIN32
   const struct passwd *pw = NULL;
   uid_t old_uid;
   gid_t old_gid;
   static int have_already_switched_id = 0;
+  const int keep_bindlow = !!(flags & SWITCH_ID_KEEP_BINDLOW);
+  const int warn_if_no_caps = !!(flags & SWITCH_ID_WARN_IF_NO_CAPS);
 
   tor_assert(user);
 
@@ -1951,6 +2089,20 @@ switch_id(const char *user)
     return -1;
   }
 
+#ifdef HAVE_LINUX_CAPABILITIES
+  (void) warn_if_no_caps;
+  if (keep_bindlow) {
+    if (drop_capabilities(1))
+      return -1;
+  }
+#else
+  (void) keep_bindlow;
+  if (warn_if_no_caps) {
+    log_warn(LD_CONFIG, "KeepBindCapabilities set, but no capability support "
+             "on this system.");
+  }
+#endif
+
   /* Properly switch egid,gid,euid,uid here or bail out */
   if (setgroups(1, &pw->pw_gid)) {
     log_warn(LD_GENERAL, "Error setting groups to gid %d: \"%s\".",
@@ -2004,6 +2156,12 @@ switch_id(const char *user)
 
   /* We've properly switched egid, gid, euid, uid, and supplementary groups if
    * we're here. */
+#ifdef HAVE_LINUX_CAPABILITIES
+  if (keep_bindlow) {
+    if (drop_capabilities(0))
+      return -1;
+  }
+#endif
 
 #if !defined(CYGWIN) && !defined(__CYGWIN__)
   /* If we tried to drop privilege to a group/user other than root, attempt to
@@ -2051,9 +2209,9 @@ switch_id(const char *user)
 
 #else
   (void)user;
+  (void)flags;
 
-  log_warn(LD_CONFIG,
-           "User specified but switching users is unsupported on your OS.");
+  log_warn(LD_CONFIG, "Switching users is unsupported on your OS.");
   return -1;
 #endif
 }
@@ -2537,8 +2695,7 @@ static int uname_result_is_set = 0;
 
 /** Return a pointer to a description of our platform.
  */
-const char *
-get_uname(void)
+MOCK_IMPL(const char *, get_uname, (void))
 {
 #ifdef HAVE_UNAME
   struct utsname u;
diff --git a/src/common/compat.h b/src/common/compat.h
index c7c468c..8f35dfd 100644
--- a/src/common/compat.h
+++ b/src/common/compat.h
@@ -75,9 +75,7 @@
 
 /* inline is __inline on windows. */
 #ifdef _WIN32
-#define INLINE __inline
-#else
-#define INLINE inline
+#define inline __inline
 #endif
 
 /* Try to get a reasonable __func__ substitute in place. */
@@ -118,6 +116,7 @@
 #define ATTR_CONST __attribute__((const))
 #define ATTR_MALLOC __attribute__((malloc))
 #define ATTR_NORETURN __attribute__((noreturn))
+#define ATTR_WUR __attribute__((warn_unused_result))
 /* Alas, nonnull is not at present a good idea for us.  We'd like to get
  * warnings when we pass NULL where we shouldn't (which nonnull does, albeit
  * spottily), but we don't want to tell the compiler to make optimizations
@@ -153,6 +152,7 @@
 #define ATTR_NORETURN
 #define ATTR_NONNULL(x)
 #define ATTR_UNUSED
+#define ATTR_WUR
 #define PREDICT_LIKELY(exp) (exp)
 #define PREDICT_UNLIKELY(exp) (exp)
 #endif
@@ -288,7 +288,7 @@ const void *tor_memmem(const void *haystack, size_t hlen, const void *needle,
                        size_t nlen) ATTR_NONNULL((1,3));
 static const void *tor_memstr(const void *haystack, size_t hlen,
                            const char *needle) ATTR_NONNULL((1,3));
-static INLINE const void *
+static inline const void *
 tor_memstr(const void *haystack, size_t hlen, const char *needle)
 {
   return tor_memmem(haystack, hlen, needle, strlen(needle));
@@ -299,7 +299,7 @@ tor_memstr(const void *haystack, size_t hlen, const char *needle)
 #define DECLARE_CTYPE_FN(name)                                          \
   static int TOR_##name(char c);                                        \
   extern const uint32_t TOR_##name##_TABLE[];                           \
-  static INLINE int TOR_##name(char c) {                                \
+  static inline int TOR_##name(char c) {                                \
     uint8_t u = c;                                                      \
     return !!(TOR_##name##_TABLE[(u >> 5) & 7] & (1u << (u & 31)));     \
   }
@@ -601,7 +601,7 @@ typedef enum {
 } socks5_reply_status_t;
 
 /* ===== OS compatibility */
-const char *get_uname(void);
+MOCK_DECL(const char *, get_uname, (void));
 
 uint16_t get_uint16(const void *cp) ATTR_NONNULL((1));
 uint32_t get_uint32(const void *cp) ATTR_NONNULL((1));
@@ -613,7 +613,7 @@ void set_uint64(void *cp, uint64_t v) ATTR_NONNULL((1));
 /* These uint8 variants are defined to make the code more uniform. */
 #define get_uint8(cp) (*(const uint8_t*)(cp))
 static void set_uint8(void *cp, uint8_t v);
-static INLINE void
+static inline void
 set_uint8(void *cp, uint8_t v)
 {
   *(uint8_t*)cp = v;
@@ -625,7 +625,18 @@ typedef unsigned long rlim_t;
 int get_max_sockets(void);
 int set_max_file_descriptors(rlim_t limit, int *max);
 int tor_disable_debugger_attach(void);
-int switch_id(const char *user);
+
+#if defined(HAVE_SYS_CAPABILITY_H) && defined(HAVE_CAP_SET_PROC)
+#define HAVE_LINUX_CAPABILITIES
+#endif
+
+int have_capability_support(void);
+
+/** Flag for switch_id; see switch_id() for documentation */
+#define SWITCH_ID_KEEP_BINDLOW    (1<<0)
+/** Flag for switch_id; see switch_id() for documentation */
+#define SWITCH_ID_WARN_IF_NO_CAPS (1<<1)
+int switch_id(const char *user, unsigned flags);
 #ifdef HAVE_PWD_H
 char *get_user_homedir(const char *username);
 #endif
diff --git a/src/common/compat_libevent.c b/src/common/compat_libevent.c
index a366b6c..29e5c5f 100644
--- a/src/common/compat_libevent.c
+++ b/src/common/compat_libevent.c
@@ -11,6 +11,7 @@
 
 #include "orconfig.h"
 #include "compat.h"
+#define COMPAT_LIBEVENT_PRIVATE
 #include "compat_libevent.h"
 
 #include "crypto.h"
@@ -28,39 +29,11 @@
 #include <event.h>
 #endif
 
-/** A number representing a version of Libevent.
-
-    This is a 4-byte number, with the first three bytes representing the
-    major, minor, and patchlevel respectively of the library.  The fourth
-    byte is unused.
-
-    This is equivalent to the format of LIBEVENT_VERSION_NUMBER on Libevent
-    2.0.1 or later.  For versions of Libevent before 1.4.0, which followed the
-    format of "1.0, 1.0a, 1.0b", we define 1.0 to be equivalent to 1.0.0, 1.0a
-    to be equivalent to 1.0.1, and so on.
-*/
-typedef uint32_t le_version_t;
-
-/** @{ */
-/** Macros: returns the number of a libevent version as a le_version_t */
-#define V(major, minor, patch) \
-  (((major) << 24) | ((minor) << 16) | ((patch) << 8))
-#define V_OLD(major, minor, patch) \
-  V((major), (minor), (patch)-'a'+1)
-/** @} */
-
-/** Represetns a version of libevent so old we can't figure out what version
- * it is. */
-#define LE_OLD V(0,0,0)
-/** Represents a version of libevent so weird we can't figure out what version
- * it is. */
-#define LE_OTHER V(0,0,99)
-
 /** A string which, if it appears in a libevent log, should be ignored. */
 static const char *suppress_msg = NULL;
 /** Callback function passed to event_set_log() so we can intercept
  * log messages from libevent. */
-static void
+STATIC void
 libevent_logging_callback(int severity, const char *msg)
 {
   char buf[1024];
@@ -291,7 +264,7 @@ tor_libevent_get_method(void)
 /** Return the le_version_t for the version of libevent specified in the
  * string <b>v</b>.  If the version is very new or uses an unrecognized
  * version, format, return LE_OTHER. */
-static le_version_t
+STATIC le_version_t
 tor_decode_libevent_version(const char *v)
 {
   unsigned major, minor, patchlevel;
@@ -322,7 +295,7 @@ tor_decode_libevent_version(const char *v)
  * Two different versions with different numbers are sure not to be binary
  * compatible.  Two different versions with the same numbers have a decent
  * chance of binary compatibility.*/
-static int
+STATIC int
 le_versions_compatibility(le_version_t v)
 {
   if (v == LE_OTHER)
diff --git a/src/common/compat_libevent.h b/src/common/compat_libevent.h
index 39181ef..8ee02c0 100644
--- a/src/common/compat_libevent.h
+++ b/src/common/compat_libevent.h
@@ -91,5 +91,42 @@ void tor_gettimeofday_cache_set(const struct timeval *tv);
 #endif
 void tor_gettimeofday_cached_monotonic(struct timeval *tv);
 
+#ifdef COMPAT_LIBEVENT_PRIVATE
+/** A number representing a version of Libevent.
+
+    This is a 4-byte number, with the first three bytes representing the
+    major, minor, and patchlevel respectively of the library.  The fourth
+    byte is unused.
+
+    This is equivalent to the format of LIBEVENT_VERSION_NUMBER on Libevent
+    2.0.1 or later.  For versions of Libevent before 1.4.0, which followed the
+    format of "1.0, 1.0a, 1.0b", we define 1.0 to be equivalent to 1.0.0, 1.0a
+    to be equivalent to 1.0.1, and so on.
+*/
+typedef uint32_t le_version_t;
+
+/** @{ */
+/** Macros: returns the number of a libevent version as a le_version_t */
+#define V(major, minor, patch) \
+  (((major) << 24) | ((minor) << 16) | ((patch) << 8))
+#define V_OLD(major, minor, patch) \
+  V((major), (minor), (patch)-'a'+1)
+/** @} */
+
+/** Represetns a version of libevent so old we can't figure out what version
+ * it is. */
+#define LE_OLD V(0,0,0)
+/** Represents a version of libevent so weird we can't figure out what version
+ * it is. */
+#define LE_OTHER V(0,0,99)
+
+STATIC void
+libevent_logging_callback(int severity, const char *msg);
+STATIC le_version_t
+tor_decode_libevent_version(const char *v);
+STATIC int
+le_versions_compatibility(le_version_t v);
+#endif
+
 #endif
 
diff --git a/src/common/compat_openssl.h b/src/common/compat_openssl.h
new file mode 100644
index 0000000..d5333a2
--- /dev/null
+++ b/src/common/compat_openssl.h
@@ -0,0 +1,46 @@
+/* Copyright (c) 2001, Matej Pfajfar.
+ * Copyright (c) 2001-2004, Roger Dingledine.
+ * Copyright (c) 2004-2006, Roger Dingledine, Nick Mathewson.
+ * Copyright (c) 2007-2015, The Tor Project, Inc. */
+/* See LICENSE for licensing information */
+
+#ifndef TOR_COMPAT_OPENSSL_H
+#define TOR_COMPAT_OPENSSL_H
+
+#include <openssl/opensslv.h>
+
+/**
+ * \file compat_openssl.h
+ *
+ * \brief compatability definitions for working with different openssl forks
+ **/
+
+#if OPENSSL_VERSION_NUMBER < OPENSSL_V_SERIES(1,0,0)
+#error "We require OpenSSL >= 1.0.0"
+#endif
+
+#if OPENSSL_VERSION_NUMBER >= OPENSSL_V_SERIES(1,1,0) && \
+   ! defined(LIBRESSL_VERSION_NUMBER)
+/* We define this macro if we're trying to build with the majorly refactored
+ * API in OpenSSL 1.1 */
+#define OPENSSL_1_1_API
+#endif
+
+#ifndef OPENSSL_1_1_API
+#define OPENSSL_VERSION SSLEAY_VERSION
+#define OpenSSL_version(v) SSLeay_version(v)
+#define OpenSSL_version_num() SSLeay()
+#define RAND_OpenSSL() RAND_SSLeay()
+#define STATE_IS_SW_SERVER_HELLO(st)       \
+  (((st) == SSL3_ST_SW_SRVR_HELLO_A) ||    \
+   ((st) == SSL3_ST_SW_SRVR_HELLO_B))
+#define OSSL_HANDSHAKE_STATE int
+#define CONST_IF_OPENSSL_1_1_API
+#else
+#define STATE_IS_SW_SERVER_HELLO(st) \
+  ((st) == TLS_ST_SW_SRVR_HELLO)
+#define CONST_IF_OPENSSL_1_1_API const
+#endif
+
+#endif
+
diff --git a/src/common/compat_pthreads.c b/src/common/compat_pthreads.c
index 4b32fc9..b1d87d3 100644
--- a/src/common/compat_pthreads.c
+++ b/src/common/compat_pthreads.c
@@ -185,7 +185,8 @@ tor_cond_init(tor_cond_t *cond)
     return -1;
   }
 
-#if defined(HAVE_CLOCK_GETTIME) && defined(CLOCK_MONOTONIC)
+#if defined(HAVE_CLOCK_GETTIME) && defined(CLOCK_MONOTONIC) \
+  && defined(HAVE_PTHREAD_CONDATTR_SETCLOCK)
   /* Use monotonic time so when we timedwait() on it, any clock adjustment
    * won't affect the timeout value. */
   if (pthread_condattr_setclock(&condattr, CLOCK_MONOTONIC)) {
diff --git a/src/common/container.c b/src/common/container.c
index 636dfb6..9f40dfa 100644
--- a/src/common/container.c
+++ b/src/common/container.c
@@ -55,11 +55,12 @@ smartlist_free,(smartlist_t *sl))
 void
 smartlist_clear(smartlist_t *sl)
 {
+  memset(sl->list, 0, sizeof(void *) * sl->num_used);
   sl->num_used = 0;
 }
 
 /** Make sure that <b>sl</b> can hold at least <b>size</b> entries. */
-static INLINE void
+static inline void
 smartlist_ensure_capacity(smartlist_t *sl, int size)
 {
 #if SIZEOF_SIZE_T > SIZEOF_INT
@@ -82,9 +83,11 @@ smartlist_ensure_capacity(smartlist_t *sl, int size)
       while (size > higher)
         higher *= 2;
     }
-    sl->capacity = higher;
     sl->list = tor_reallocarray(sl->list, sizeof(void *),
-                                ((size_t)sl->capacity));
+                                ((size_t)higher));
+    memset(sl->list + sl->capacity, 0,
+           sizeof(void *) * (higher - sl->capacity));
+    sl->capacity = higher;
   }
 #undef ASSERT_CAPACITY
 #undef MAX_CAPACITY
@@ -123,6 +126,7 @@ smartlist_remove(smartlist_t *sl, const void *element)
     if (sl->list[i] == element) {
       sl->list[i] = sl->list[--sl->num_used]; /* swap with the end */
       i--; /* so we process the new i'th element */
+      sl->list[sl->num_used] = NULL;
     }
 }
 
@@ -132,9 +136,11 @@ void *
 smartlist_pop_last(smartlist_t *sl)
 {
   tor_assert(sl);
-  if (sl->num_used)
-    return sl->list[--sl->num_used];
-  else
+  if (sl->num_used) {
+    void *tmp = sl->list[--sl->num_used];
+    sl->list[sl->num_used] = NULL;
+    return tmp;
+  } else
     return NULL;
 }
 
@@ -165,6 +171,7 @@ smartlist_string_remove(smartlist_t *sl, const char *element)
       tor_free(sl->list[i]);
       sl->list[i] = sl->list[--sl->num_used]; /* swap with the end */
       i--; /* so we process the new i'th element */
+      sl->list[sl->num_used] = NULL;
     }
   }
 }
@@ -321,6 +328,7 @@ smartlist_intersect(smartlist_t *sl1, const smartlist_t *sl2)
     if (!smartlist_contains(sl2, sl1->list[i])) {
       sl1->list[i] = sl1->list[--sl1->num_used]; /* swap with the end */
       i--; /* so we process the new i'th element */
+      sl1->list[sl1->num_used] = NULL;
     }
 }
 
@@ -345,6 +353,7 @@ smartlist_del(smartlist_t *sl, int idx)
   tor_assert(idx>=0);
   tor_assert(idx < sl->num_used);
   sl->list[idx] = sl->list[--sl->num_used];
+  sl->list[sl->num_used] = NULL;
 }
 
 /** Remove the <b>idx</b>th element of sl; if idx is not the last element,
@@ -360,6 +369,7 @@ smartlist_del_keeporder(smartlist_t *sl, int idx)
   --sl->num_used;
   if (idx < sl->num_used)
     memmove(sl->list+idx, sl->list+idx+1, sizeof(void*)*(sl->num_used-idx));
+  sl->list[sl->num_used] = NULL;
 }
 
 /** Insert the value <b>val</b> as the new <b>idx</b>th element of
@@ -857,7 +867,7 @@ smartlist_sort_pointers(smartlist_t *sl)
 /** Helper. <b>sl</b> may have at most one violation of the heap property:
  * the item at <b>idx</b> may be greater than one or both of its children.
  * Restore the heap property. */
-static INLINE void
+static inline void
 smartlist_heapify(smartlist_t *sl,
                   int (*compare)(const void *a, const void *b),
                   int idx_field_offset,
@@ -937,9 +947,11 @@ smartlist_pqueue_pop(smartlist_t *sl,
   *IDXP(top)=-1;
   if (--sl->num_used) {
     sl->list[0] = sl->list[sl->num_used];
+    sl->list[sl->num_used] = NULL;
     UPDATE_IDX(0);
     smartlist_heapify(sl, compare, idx_field_offset, 0);
   }
+  sl->list[sl->num_used] = NULL;
   return top;
 }
 
@@ -959,9 +971,11 @@ smartlist_pqueue_remove(smartlist_t *sl,
   --sl->num_used;
   *IDXP(item) = -1;
   if (idx == sl->num_used) {
+    sl->list[sl->num_used] = NULL;
     return;
   } else {
     sl->list[idx] = sl->list[sl->num_used];
+    sl->list[sl->num_used] = NULL;
     UPDATE_IDX(idx);
     smartlist_heapify(sl, compare, idx_field_offset, idx);
   }
@@ -1054,35 +1068,35 @@ DEFINE_MAP_STRUCTS(digestmap_t, char key[DIGEST_LEN], digestmap_);
 DEFINE_MAP_STRUCTS(digest256map_t, uint8_t key[DIGEST256_LEN], digest256map_);
 
 /** Helper: compare strmap_entry_t objects by key value. */
-static INLINE int
+static inline int
 strmap_entries_eq(const strmap_entry_t *a, const strmap_entry_t *b)
 {
   return !strcmp(a->key, b->key);
 }
 
 /** Helper: return a hash value for a strmap_entry_t. */
-static INLINE unsigned int
+static inline unsigned int
 strmap_entry_hash(const strmap_entry_t *a)
 {
   return (unsigned) siphash24g(a->key, strlen(a->key));
 }
 
 /** Helper: compare digestmap_entry_t objects by key value. */
-static INLINE int
+static inline int
 digestmap_entries_eq(const digestmap_entry_t *a, const digestmap_entry_t *b)
 {
   return tor_memeq(a->key, b->key, DIGEST_LEN);
 }
 
 /** Helper: return a hash value for a digest_map_t. */
-static INLINE unsigned int
+static inline unsigned int
 digestmap_entry_hash(const digestmap_entry_t *a)
 {
   return (unsigned) siphash24g(a->key, DIGEST_LEN);
 }
 
 /** Helper: compare digestmap_entry_t objects by key value. */
-static INLINE int
+static inline int
 digest256map_entries_eq(const digest256map_entry_t *a,
                         const digest256map_entry_t *b)
 {
@@ -1090,7 +1104,7 @@ digest256map_entries_eq(const digest256map_entry_t *a,
 }
 
 /** Helper: return a hash value for a digest_map_t. */
-static INLINE unsigned int
+static inline unsigned int
 digest256map_entry_hash(const digest256map_entry_t *a)
 {
   return (unsigned) siphash24g(a->key, DIGEST256_LEN);
@@ -1113,49 +1127,49 @@ HT_GENERATE2(digest256map_impl, digest256map_entry_t, node,
              digest256map_entry_hash,
              digest256map_entries_eq, 0.6, tor_reallocarray_, tor_free_)
 
-static INLINE void
+static inline void
 strmap_entry_free(strmap_entry_t *ent)
 {
   tor_free(ent->key);
   tor_free(ent);
 }
-static INLINE void
+static inline void
 digestmap_entry_free(digestmap_entry_t *ent)
 {
   tor_free(ent);
 }
-static INLINE void
+static inline void
 digest256map_entry_free(digest256map_entry_t *ent)
 {
   tor_free(ent);
 }
 
-static INLINE void
+static inline void
 strmap_assign_tmp_key(strmap_entry_t *ent, const char *key)
 {
   ent->key = (char*)key;
 }
-static INLINE void
+static inline void
 digestmap_assign_tmp_key(digestmap_entry_t *ent, const char *key)
 {
   memcpy(ent->key, key, DIGEST_LEN);
 }
-static INLINE void
+static inline void
 digest256map_assign_tmp_key(digest256map_entry_t *ent, const uint8_t *key)
 {
   memcpy(ent->key, key, DIGEST256_LEN);
 }
-static INLINE void
+static inline void
 strmap_assign_key(strmap_entry_t *ent, const char *key)
 {
   ent->key = tor_strdup(key);
 }
-static INLINE void
+static inline void
 digestmap_assign_key(digestmap_entry_t *ent, const char *key)
 {
   memcpy(ent->key, key, DIGEST_LEN);
 }
-static INLINE void
+static inline void
 digest256map_assign_key(digest256map_entry_t *ent, const uint8_t *key)
 {
   memcpy(ent->key, key, DIGEST256_LEN);
diff --git a/src/common/container.h b/src/common/container.h
index bf4f047..af7d5c3 100644
--- a/src/common/container.h
+++ b/src/common/container.h
@@ -53,21 +53,21 @@ void smartlist_subtract(smartlist_t *sl1, const smartlist_t *sl2);
 #ifdef DEBUG_SMARTLIST
 /** Return the number of items in sl.
  */
-static INLINE int smartlist_len(const smartlist_t *sl);
-static INLINE int smartlist_len(const smartlist_t *sl) {
+static inline int smartlist_len(const smartlist_t *sl);
+static inline int smartlist_len(const smartlist_t *sl) {
   tor_assert(sl);
   return (sl)->num_used;
 }
 /** Return the <b>idx</b>th element of sl.
  */
-static INLINE void *smartlist_get(const smartlist_t *sl, int idx);
-static INLINE void *smartlist_get(const smartlist_t *sl, int idx) {
+static inline void *smartlist_get(const smartlist_t *sl, int idx);
+static inline void *smartlist_get(const smartlist_t *sl, int idx) {
   tor_assert(sl);
   tor_assert(idx>=0);
   tor_assert(sl->num_used > idx);
   return sl->list[idx];
 }
-static INLINE void smartlist_set(smartlist_t *sl, int idx, void *val) {
+static inline void smartlist_set(smartlist_t *sl, int idx, void *val) {
   tor_assert(sl);
   tor_assert(idx>=0);
   tor_assert(sl->num_used > idx);
@@ -81,7 +81,7 @@ static INLINE void smartlist_set(smartlist_t *sl, int idx, void *val) {
 
 /** Exchange the elements at indices <b>idx1</b> and <b>idx2</b> of the
  * smartlist <b>sl</b>. */
-static INLINE void smartlist_swap(smartlist_t *sl, int idx1, int idx2)
+static inline void smartlist_swap(smartlist_t *sl, int idx1, int idx2)
 {
   if (idx1 != idx2) {
     void *elt = smartlist_get(sl, idx1);
@@ -500,64 +500,64 @@ void* strmap_remove_lc(strmap_t *map, const char *key);
 #define DECLARE_TYPED_DIGESTMAP_FNS(prefix, maptype, valtype)           \
   typedef struct maptype maptype;                                       \
   typedef struct prefix##iter_t *prefix##iter_t;                        \
-  ATTR_UNUSED static INLINE maptype*                                    \
+  ATTR_UNUSED static inline maptype*                                    \
   prefix##new(void)                                                     \
   {                                                                     \
     return (maptype*)digestmap_new();                                   \
   }                                                                     \
-  ATTR_UNUSED static INLINE digestmap_t*                                \
+  ATTR_UNUSED static inline digestmap_t*                                \
   prefix##to_digestmap(maptype *map)                                    \
   {                                                                     \
     return (digestmap_t*)map;                                           \
   }                                                                     \
-  ATTR_UNUSED static INLINE valtype*                                    \
+  ATTR_UNUSED static inline valtype*                                    \
   prefix##get(maptype *map, const char *key)     \
   {                                                                     \
     return (valtype*)digestmap_get((digestmap_t*)map, key);             \
   }                                                                     \
-  ATTR_UNUSED static INLINE valtype*                                    \
+  ATTR_UNUSED static inline valtype*                                    \
   prefix##set(maptype *map, const char *key, valtype *val)              \
   {                                                                     \
     return (valtype*)digestmap_set((digestmap_t*)map, key, val);        \
   }                                                                     \
-  ATTR_UNUSED static INLINE valtype*                                    \
+  ATTR_UNUSED static inline valtype*                                    \
   prefix##remove(maptype *map, const char *key)                         \
   {                                                                     \
     return (valtype*)digestmap_remove((digestmap_t*)map, key);          \
   }                                                                     \
-  ATTR_UNUSED static INLINE void                                        \
+  ATTR_UNUSED static inline void                                        \
   prefix##free(maptype *map, void (*free_val)(void*))                   \
   {                                                                     \
     digestmap_free((digestmap_t*)map, free_val);                        \
   }                                                                     \
-  ATTR_UNUSED static INLINE int                                         \
+  ATTR_UNUSED static inline int                                         \
   prefix##isempty(maptype *map)                                         \
   {                                                                     \
     return digestmap_isempty((digestmap_t*)map);                        \
   }                                                                     \
-  ATTR_UNUSED static INLINE int                                         \
+  ATTR_UNUSED static inline int                                         \
   prefix##size(maptype *map)                                            \
   {                                                                     \
     return digestmap_size((digestmap_t*)map);                           \
   }                                                                     \
-  ATTR_UNUSED static INLINE                                             \
+  ATTR_UNUSED static inline                                             \
   prefix##iter_t *prefix##iter_init(maptype *map)                       \
   {                                                                     \
     return (prefix##iter_t*) digestmap_iter_init((digestmap_t*)map);    \
   }                                                                     \
-  ATTR_UNUSED static INLINE                                             \
+  ATTR_UNUSED static inline                                             \
   prefix##iter_t *prefix##iter_next(maptype *map, prefix##iter_t *iter) \
   {                                                                     \
     return (prefix##iter_t*) digestmap_iter_next(                       \
                        (digestmap_t*)map, (digestmap_iter_t*)iter);     \
   }                                                                     \
-  ATTR_UNUSED static INLINE prefix##iter_t*                             \
+  ATTR_UNUSED static inline prefix##iter_t*                             \
   prefix##iter_next_rmv(maptype *map, prefix##iter_t *iter)             \
   {                                                                     \
     return (prefix##iter_t*) digestmap_iter_next_rmv(                   \
                        (digestmap_t*)map, (digestmap_iter_t*)iter);     \
   }                                                                     \
-  ATTR_UNUSED static INLINE void                                        \
+  ATTR_UNUSED static inline void                                        \
   prefix##iter_get(prefix##iter_t *iter,                                \
                    const char **keyp,                                   \
                    valtype **valp)                                      \
@@ -566,7 +566,7 @@ void* strmap_remove_lc(strmap_t *map, const char *key);
     digestmap_iter_get((digestmap_iter_t*) iter, keyp, &v);             \
     *valp = v;                                                          \
   }                                                                     \
-  ATTR_UNUSED static INLINE int                                         \
+  ATTR_UNUSED static inline int                                         \
   prefix##iter_done(prefix##iter_t *iter)                               \
   {                                                                     \
     return digestmap_iter_done((digestmap_iter_t*)iter);                \
@@ -584,7 +584,7 @@ void* strmap_remove_lc(strmap_t *map, const char *key);
 /** A random-access array of one-bit-wide elements. */
 typedef unsigned int bitarray_t;
 /** Create a new bit array that can hold <b>n_bits</b> bits. */
-static INLINE bitarray_t *
+static inline bitarray_t *
 bitarray_init_zero(unsigned int n_bits)
 {
   /* round up to the next int. */
@@ -594,7 +594,7 @@ bitarray_init_zero(unsigned int n_bits)
 /** Expand <b>ba</b> from holding <b>n_bits_old</b> to <b>n_bits_new</b>,
  * clearing all new bits.  Returns a possibly changed pointer to the
  * bitarray. */
-static INLINE bitarray_t *
+static inline bitarray_t *
 bitarray_expand(bitarray_t *ba,
                 unsigned int n_bits_old, unsigned int n_bits_new)
 {
@@ -611,26 +611,26 @@ bitarray_expand(bitarray_t *ba,
   return (bitarray_t*) ptr;
 }
 /** Free the bit array <b>ba</b>. */
-static INLINE void
+static inline void
 bitarray_free(bitarray_t *ba)
 {
   tor_free(ba);
 }
 /** Set the <b>bit</b>th bit in <b>b</b> to 1. */
-static INLINE void
+static inline void
 bitarray_set(bitarray_t *b, int bit)
 {
   b[bit >> BITARRAY_SHIFT] |= (1u << (bit & BITARRAY_MASK));
 }
 /** Set the <b>bit</b>th bit in <b>b</b> to 0. */
-static INLINE void
+static inline void
 bitarray_clear(bitarray_t *b, int bit)
 {
   b[bit >> BITARRAY_SHIFT] &= ~ (1u << (bit & BITARRAY_MASK));
 }
 /** Return true iff <b>bit</b>th bit in <b>b</b> is nonzero.  NOTE: does
  * not necessarily return 1 on true. */
-static INLINE unsigned int
+static inline unsigned int
 bitarray_is_set(bitarray_t *b, int bit)
 {
   return b[bit >> BITARRAY_SHIFT] & (1u << (bit & BITARRAY_MASK));
@@ -645,7 +645,7 @@ typedef struct {
 
 #define BIT(n) ((n) & set->mask)
 /** Add the digest <b>digest</b> to <b>set</b>. */
-static INLINE void
+static inline void
 digestset_add(digestset_t *set, const char *digest)
 {
   const uint64_t x = siphash24g(digest, 20);
@@ -661,7 +661,7 @@ digestset_add(digestset_t *set, const char *digest)
 
 /** If <b>digest</b> is in <b>set</b>, return nonzero.  Otherwise,
  * <em>probably</em> return zero. */
-static INLINE int
+static inline int
 digestset_contains(const digestset_t *set, const char *digest)
 {
   const uint64_t x = siphash24g(digest, 20);
@@ -689,33 +689,33 @@ double find_nth_double(double *array, int n_elements, int nth);
 int32_t find_nth_int32(int32_t *array, int n_elements, int nth);
 uint32_t find_nth_uint32(uint32_t *array, int n_elements, int nth);
 long find_nth_long(long *array, int n_elements, int nth);
-static INLINE int
+static inline int
 median_int(int *array, int n_elements)
 {
   return find_nth_int(array, n_elements, (n_elements-1)/2);
 }
-static INLINE time_t
+static inline time_t
 median_time(time_t *array, int n_elements)
 {
   return find_nth_time(array, n_elements, (n_elements-1)/2);
 }
-static INLINE double
+static inline double
 median_double(double *array, int n_elements)
 {
   return find_nth_double(array, n_elements, (n_elements-1)/2);
 }
-static INLINE uint32_t
+static inline uint32_t
 median_uint32(uint32_t *array, int n_elements)
 {
   return find_nth_uint32(array, n_elements, (n_elements-1)/2);
 }
-static INLINE int32_t
+static inline int32_t
 median_int32(int32_t *array, int n_elements)
 {
   return find_nth_int32(array, n_elements, (n_elements-1)/2);
 }
 
-static INLINE uint32_t
+static inline uint32_t
 third_quartile_uint32(uint32_t *array, int n_elements)
 {
   return find_nth_uint32(array, n_elements, (n_elements*3)/4);
diff --git a/src/common/crypto.c b/src/common/crypto.c
index 815c2ec..06446ba 100644
--- a/src/common/crypto.c
+++ b/src/common/crypto.c
@@ -21,18 +21,13 @@
 #undef OCSP_RESPONSE
 #endif
 
-#include <openssl/opensslv.h>
-
 #define CRYPTO_PRIVATE
 #include "crypto.h"
+#include "compat_openssl.h"
 #include "crypto_curve25519.h"
 #include "crypto_ed25519.h"
 #include "crypto_format.h"
 
-#if OPENSSL_VERSION_NUMBER < OPENSSL_V_SERIES(1,0,0)
-#error "We require OpenSSL >= 1.0.0"
-#endif
-
 #include <openssl/err.h>
 #include <openssl/rsa.h>
 #include <openssl/pem.h>
@@ -48,6 +43,7 @@
 #include <ctype.h>
 #endif
 #ifdef HAVE_UNISTD_H
+#define _GNU_SOURCE
 #include <unistd.h>
 #endif
 #ifdef HAVE_FCNTL_H
@@ -56,6 +52,9 @@
 #ifdef HAVE_SYS_FCNTL_H
 #include <sys/fcntl.h>
 #endif
+#ifdef HAVE_SYS_SYSCALL_H
+#include <sys/syscall.h>
+#endif
 
 #include "torlog.h"
 #include "aes.h"
@@ -65,6 +64,8 @@
 #include "sandbox.h"
 #include "util_format.h"
 
+#include "keccak-tiny/keccak-tiny.h"
+
 #ifdef ANDROID
 /* Android's OpenSSL seems to have removed all of its Engine support. */
 #define DISABLE_ENGINES
@@ -73,6 +74,9 @@
 /** Longest recognized */
 #define MAX_DNS_LABEL_SIZE 63
 
+/** Largest strong entropy request */
+#define MAX_STRONGEST_RAND_SIZE 256
+
 /** Macro: is k a valid RSA public or private key? */
 #define PUBLIC_KEY_OK(k) ((k) && (k)->key && (k)->key->n)
 /** Macro: is k a valid RSA private key? */
@@ -110,7 +114,7 @@ static int tor_check_dh_key(int severity, BIGNUM *bn);
 
 /** Return the number of bytes added by padding method <b>padding</b>.
  */
-static INLINE int
+static inline int
 crypto_get_rsa_padding_overhead(int padding)
 {
   switch (padding)
@@ -122,7 +126,7 @@ crypto_get_rsa_padding_overhead(int padding)
 
 /** Given a padding method <b>padding</b>, return the correct OpenSSL constant.
  */
-static INLINE int
+static inline int
 crypto_get_rsa_padding(int padding)
 {
   switch (padding)
@@ -227,7 +231,7 @@ const char *
 crypto_openssl_get_version_str(void)
 {
   if (crypto_openssl_version_str == NULL) {
-    const char *raw_version = SSLeay_version(SSLEAY_VERSION);
+    const char *raw_version = OpenSSL_version(OPENSSL_VERSION);
     crypto_openssl_version_str = parse_openssl_version_str(raw_version);
   }
   return crypto_openssl_version_str;
@@ -248,14 +252,16 @@ crypto_openssl_get_header_version_str(void)
 
 /** Make sure that openssl is using its default PRNG. Return 1 if we had to
  * adjust it; 0 otherwise. */
-static int
+STATIC int
 crypto_force_rand_ssleay(void)
 {
-  if (RAND_get_rand_method() != RAND_SSLeay()) {
+  RAND_METHOD *default_method;
+  default_method = RAND_OpenSSL();
+  if (RAND_get_rand_method() != default_method) {
     log_notice(LD_CRYPTO, "It appears that one of our engines has provided "
                "a replacement the OpenSSL RNG. Resetting it to the default "
                "implementation.");
-    RAND_set_rand_method(RAND_SSLeay());
+    RAND_set_rand_method(default_method);
     return 1;
   }
   return 0;
@@ -270,8 +276,7 @@ crypto_init_siphash_key(void)
   if (have_seeded_siphash)
     return 0;
 
-  if (crypto_rand((char*) &key, sizeof(key)) < 0)
-    return -1;
+  crypto_rand((char*) &key, sizeof(key));
   siphash_set_global_key(&key);
   have_seeded_siphash = 1;
   return 0;
@@ -291,16 +296,18 @@ crypto_early_init(void)
 
     setup_openssl_threading();
 
-    if (SSLeay() == OPENSSL_VERSION_NUMBER &&
-        !strcmp(SSLeay_version(SSLEAY_VERSION), OPENSSL_VERSION_TEXT)) {
+    unsigned long version_num = OpenSSL_version_num();
+    const char *version_str = OpenSSL_version(OPENSSL_VERSION);
+    if (version_num == OPENSSL_VERSION_NUMBER &&
+        !strcmp(version_str, OPENSSL_VERSION_TEXT)) {
       log_info(LD_CRYPTO, "OpenSSL version matches version from headers "
-                 "(%lx: %s).", SSLeay(), SSLeay_version(SSLEAY_VERSION));
+                 "(%lx: %s).", version_num, version_str);
     } else {
       log_warn(LD_CRYPTO, "OpenSSL version from headers does not match the "
                "version we're running with. If you get weird crashes, that "
                "might be why. (Compiled with %lx: %s; running with %lx: %s).",
                (unsigned long)OPENSSL_VERSION_NUMBER, OPENSSL_VERSION_TEXT,
-               SSLeay(), SSLeay_version(SSLEAY_VERSION));
+               version_num, version_str);
     }
 
     crypto_force_rand_ssleay();
@@ -322,7 +329,8 @@ int
 crypto_global_init(int useAccel, const char *accelName, const char *accelDir)
 {
   if (!crypto_global_initialized_) {
-    crypto_early_init();
+    if (crypto_early_init() < 0)
+      return -1;
 
     crypto_global_initialized_ = 1;
 
@@ -365,8 +373,12 @@ crypto_global_init(int useAccel, const char *accelName, const char *accelDir)
          used by Tor and the set of algorithms available in the engine */
       log_engine("RSA", ENGINE_get_default_RSA());
       log_engine("DH", ENGINE_get_default_DH());
+#ifdef OPENSSL_1_1_API
+      log_engine("EC", ENGINE_get_default_EC());
+#else
       log_engine("ECDH", ENGINE_get_default_ECDH());
       log_engine("ECDSA", ENGINE_get_default_ECDSA());
+#endif
       log_engine("RAND", ENGINE_get_default_RAND());
       log_engine("RAND (which we will not use)", ENGINE_get_default_RAND());
       log_engine("SHA1", ENGINE_get_digest_engine(NID_sha1));
@@ -404,11 +416,7 @@ crypto_global_init(int useAccel, const char *accelName, const char *accelDir)
 void
 crypto_thread_cleanup(void)
 {
-#if OPENSSL_VERSION_NUMBER >= OPENSSL_V_SERIES(1,1,0)
   ERR_remove_thread_state(NULL);
-#else
-  ERR_remove_state(0);
-#endif
 }
 
 /** used by tortls.c: wrap an RSA* in a crypto_pk_t. */
@@ -432,9 +440,10 @@ crypto_pk_get_rsa_(crypto_pk_t *env)
 }
 
 /** used by tortls.c: get an equivalent EVP_PKEY* for a crypto_pk_t.  Iff
- * private is set, include the private-key portion of the key. */
-EVP_PKEY *
-crypto_pk_get_evp_pkey_(crypto_pk_t *env, int private)
+ * private is set, include the private-key portion of the key. Return a valid
+ * pointer on success, and NULL on failure. */
+MOCK_IMPL(EVP_PKEY *,
+          crypto_pk_get_evp_pkey_,(crypto_pk_t *env, int private))
 {
   RSA *key = NULL;
   EVP_PKEY *pkey = NULL;
@@ -470,8 +479,8 @@ crypto_dh_get_dh_(crypto_dh_t *dh)
 /** Allocate and return storage for a public key.  The key itself will not yet
  * be set.
  */
-crypto_pk_t *
-crypto_pk_new(void)
+MOCK_IMPL(crypto_pk_t *,
+          crypto_pk_new,(void))
 {
   RSA *rsa;
 
@@ -553,8 +562,8 @@ crypto_cipher_free(crypto_cipher_t *env)
 /** Generate a <b>bits</b>-bit new public/private keypair in <b>env</b>.
  * Return 0 on success, -1 on failure.
  */
-int
-crypto_pk_generate_key_with_bits(crypto_pk_t *env, int bits)
+MOCK_IMPL(int,
+          crypto_pk_generate_key_with_bits,(crypto_pk_t *env, int bits))
 {
   tor_assert(env);
 
@@ -656,7 +665,8 @@ crypto_pk_read_private_key_from_filename(crypto_pk_t *env,
   return 0;
 }
 
-/** Helper function to implement crypto_pk_write_*_key_to_string. */
+/** Helper function to implement crypto_pk_write_*_key_to_string. Return 0 on
+ * success, -1 on failure. */
 static int
 crypto_pk_write_key_to_string_impl(crypto_pk_t *env, char **dest,
                                    size_t *len, int is_public)
@@ -897,7 +907,8 @@ crypto_pk_dup_key(crypto_pk_t *env)
   return env;
 }
 
-/** Make a real honest-to-goodness copy of <b>env</b>, and return it. */
+/** Make a real honest-to-goodness copy of <b>env</b>, and return it.
+ * Returns NULL on failure. */
 crypto_pk_t *
 crypto_pk_copy_full(crypto_pk_t *env)
 {
@@ -1189,7 +1200,8 @@ crypto_pk_public_hybrid_encrypt(crypto_pk_t *env,
   return -1;
 }
 
-/** Invert crypto_pk_public_hybrid_encrypt. */
+/** Invert crypto_pk_public_hybrid_encrypt. Returns the number of bytes
+ * written on success, -1 on failure. */
 int
 crypto_pk_private_hybrid_decrypt(crypto_pk_t *env,
                                  char *to,
@@ -1332,7 +1344,7 @@ crypto_pk_get_all_digests(crypto_pk_t *pk, digests_t *digests_out)
 }
 
 /** Copy <b>in</b> to the <b>outlen</b>-byte buffer <b>out</b>, adding spaces
- * every four spaces. */
+ * every four characters. */
 void
 crypto_add_spaces_to_fp(char *out, size_t outlen, const char *in)
 {
@@ -1484,7 +1496,7 @@ crypto_cipher_get_key(crypto_cipher_t *env)
 
 /** Encrypt <b>fromlen</b> bytes from <b>from</b> using the cipher
  * <b>env</b>; on success, store the result to <b>to</b> and return 0.
- * On failure, return -1.
+ * Does not check for failure.
  */
 int
 crypto_cipher_encrypt(crypto_cipher_t *env, char *to,
@@ -1497,13 +1509,14 @@ crypto_cipher_encrypt(crypto_cipher_t *env, char *to,
   tor_assert(to);
   tor_assert(fromlen < SIZE_T_CEILING);
 
-  aes_crypt(env->cipher, from, fromlen, to);
+  memcpy(to, from, fromlen);
+  aes_crypt_inplace(env->cipher, to, fromlen);
   return 0;
 }
 
 /** Decrypt <b>fromlen</b> bytes from <b>from</b> using the cipher
  * <b>env</b>; on success, store the result to <b>to</b> and return 0.
- * On failure, return -1.
+ * Does not check for failure.
  */
 int
 crypto_cipher_decrypt(crypto_cipher_t *env, char *to,
@@ -1514,19 +1527,19 @@ crypto_cipher_decrypt(crypto_cipher_t *env, char *to,
   tor_assert(to);
   tor_assert(fromlen < SIZE_T_CEILING);
 
-  aes_crypt(env->cipher, from, fromlen, to);
+  memcpy(to, from, fromlen);
+  aes_crypt_inplace(env->cipher, to, fromlen);
   return 0;
 }
 
 /** Encrypt <b>len</b> bytes on <b>from</b> using the cipher in <b>env</b>;
- * on success, return 0.  On failure, return -1.
+ * on success. Does not check for failure.
  */
-int
+void
 crypto_cipher_crypt_inplace(crypto_cipher_t *env, char *buf, size_t len)
 {
   tor_assert(len < SIZE_T_CEILING);
   aes_crypt_inplace(env->cipher, buf, len);
-  return 0;
 }
 
 /** Encrypt <b>fromlen</b> bytes (at least 1) from <b>from</b> with the key in
@@ -1591,7 +1604,7 @@ crypto_cipher_decrypt_with_iv(const char *key,
 
 /** Compute the SHA1 digest of the <b>len</b> bytes on data stored in
  * <b>m</b>.  Write the DIGEST_LEN byte result into <b>digest</b>.
- * Return 0 on success, -1 on failure.
+ * Return 0 on success, 1 on failure.
  */
 int
 crypto_digest(char *digest, const char *m, size_t len)
@@ -1603,15 +1616,37 @@ crypto_digest(char *digest, const char *m, size_t len)
 
 /** Compute a 256-bit digest of <b>len</b> bytes in data stored in <b>m</b>,
  * using the algorithm <b>algorithm</b>.  Write the DIGEST_LEN256-byte result
- * into <b>digest</b>.  Return 0 on success, -1 on failure. */
+ * into <b>digest</b>.  Return 0 on success, 1 on failure. */
 int
 crypto_digest256(char *digest, const char *m, size_t len,
                  digest_algorithm_t algorithm)
 {
   tor_assert(m);
   tor_assert(digest);
-  tor_assert(algorithm == DIGEST_SHA256);
-  return (SHA256((const unsigned char*)m,len,(unsigned char*)digest) == NULL);
+  tor_assert(algorithm == DIGEST_SHA256 || algorithm == DIGEST_SHA3_256);
+  if (algorithm == DIGEST_SHA256)
+    return (SHA256((const uint8_t*)m,len,(uint8_t*)digest) == NULL);
+  else
+    return (sha3_256((uint8_t *)digest, DIGEST256_LEN,(const uint8_t *)m, len)
+            == -1);
+}
+
+/** Compute a 512-bit digest of <b>len</b> bytes in data stored in <b>m</b>,
+ * using the algorithm <b>algorithm</b>.  Write the DIGEST_LEN512-byte result
+ * into <b>digest</b>.  Return 0 on success, 1 on failure. */
+int
+crypto_digest512(char *digest, const char *m, size_t len,
+                 digest_algorithm_t algorithm)
+{
+  tor_assert(m);
+  tor_assert(digest);
+  tor_assert(algorithm == DIGEST_SHA512 || algorithm == DIGEST_SHA3_512);
+  if (algorithm == DIGEST_SHA512)
+    return (SHA512((const unsigned char*)m,len,(unsigned char*)digest)
+            == NULL);
+  else
+    return (sha3_512((uint8_t*)digest, DIGEST512_LEN, (const uint8_t*)m, len)
+            == -1);
 }
 
 /** Set the digests_t in <b>ds_out</b> to contain every digest on the
@@ -1626,8 +1661,20 @@ crypto_digest_all(digests_t *ds_out, const char *m, size_t len)
   if (crypto_digest(ds_out->d[DIGEST_SHA1], m, len) < 0)
     return -1;
   for (i = DIGEST_SHA256; i < N_DIGEST_ALGORITHMS; ++i) {
-    if (crypto_digest256(ds_out->d[i], m, len, i) < 0)
-      return -1;
+      switch (i) {
+        case DIGEST_SHA256: /* FALLSTHROUGH */
+        case DIGEST_SHA3_256:
+          if (crypto_digest256(ds_out->d[i], m, len, i) < 0)
+            return -1;
+          break;
+        case DIGEST_SHA512:
+        case DIGEST_SHA3_512: /* FALLSTHROUGH */
+          if (crypto_digest512(ds_out->d[i], m, len, i) < 0)
+            return -1;
+          break;
+        default:
+          return -1;
+      }
   }
   return 0;
 }
@@ -1641,6 +1688,12 @@ crypto_digest_algorithm_get_name(digest_algorithm_t alg)
       return "sha1";
     case DIGEST_SHA256:
       return "sha256";
+    case DIGEST_SHA512:
+      return "sha512";
+    case DIGEST_SHA3_256:
+      return "sha3-256";
+    case DIGEST_SHA3_512:
+      return "sha3-512";
     default:
       tor_fragile_assert();
       return "??unknown_digest??";
@@ -1656,27 +1709,90 @@ crypto_digest_algorithm_parse_name(const char *name)
     return DIGEST_SHA1;
   else if (!strcmp(name, "sha256"))
     return DIGEST_SHA256;
+  else if (!strcmp(name, "sha512"))
+    return DIGEST_SHA512;
+  else if (!strcmp(name, "sha3-256"))
+    return DIGEST_SHA3_256;
+  else if (!strcmp(name, "sha3-512"))
+    return DIGEST_SHA3_512;
   else
     return -1;
 }
 
+/** Given an algorithm, return the digest length in bytes. */
+static inline size_t
+crypto_digest_algorithm_get_length(digest_algorithm_t alg)
+{
+  switch (alg) {
+    case DIGEST_SHA1:
+      return DIGEST_LEN;
+    case DIGEST_SHA256:
+      return DIGEST256_LEN;
+    case DIGEST_SHA512:
+      return DIGEST512_LEN;
+    case DIGEST_SHA3_256:
+      return DIGEST256_LEN;
+    case DIGEST_SHA3_512:
+      return DIGEST512_LEN;
+    default:
+      tor_assert(0);
+      return 0; /* Unreachable */
+  }
+}
+
 /** Intermediate information about the digest of a stream of data. */
 struct crypto_digest_t {
+  digest_algorithm_t algorithm; /**< Which algorithm is in use? */
+   /** State for the digest we're using.  Only one member of the
+    * union is usable, depending on the value of <b>algorithm</b>. Note also
+    * that space for other members might not even be allocated!
+    */
   union {
     SHA_CTX sha1; /**< state for SHA1 */
     SHA256_CTX sha2; /**< state for SHA256 */
-  } d; /**< State for the digest we're using.  Only one member of the
-        * union is usable, depending on the value of <b>algorithm</b>. */
-  digest_algorithm_bitfield_t algorithm : 8; /**< Which algorithm is in use? */
+    SHA512_CTX sha512; /**< state for SHA512 */
+    keccak_state sha3; /**< state for SHA3-[256,512] */
+  } d;
 };
 
+/**
+ * Return the number of bytes we need to malloc in order to get a
+ * crypto_digest_t for <b>alg</b>, or the number of bytes we need to wipe
+ * when we free one.
+ */
+static size_t
+crypto_digest_alloc_bytes(digest_algorithm_t alg)
+{
+  /* Helper: returns the number of bytes in the 'f' field of 'st' */
+#define STRUCT_FIELD_SIZE(st, f) (sizeof( ((st*)0)->f ))
+  /* Gives the length of crypto_digest_t through the end of the field 'd' */
+#define END_OF_FIELD(f) (STRUCT_OFFSET(crypto_digest_t, f) + \
+                         STRUCT_FIELD_SIZE(crypto_digest_t, f))
+  switch (alg) {
+    case DIGEST_SHA1:
+      return END_OF_FIELD(d.sha1);
+    case DIGEST_SHA256:
+      return END_OF_FIELD(d.sha2);
+    case DIGEST_SHA512:
+      return END_OF_FIELD(d.sha512);
+    case DIGEST_SHA3_256:
+    case DIGEST_SHA3_512:
+      return END_OF_FIELD(d.sha3);
+    default:
+      tor_assert(0);
+      return 0;
+  }
+#undef END_OF_FIELD
+#undef STRUCT_FIELD_SIZE
+}
+
 /** Allocate and return a new digest object to compute SHA1 digests.
  */
 crypto_digest_t *
 crypto_digest_new(void)
 {
   crypto_digest_t *r;
-  r = tor_malloc(sizeof(crypto_digest_t));
+  r = tor_malloc(crypto_digest_alloc_bytes(DIGEST_SHA1));
   SHA1_Init(&r->d.sha1);
   r->algorithm = DIGEST_SHA1;
   return r;
@@ -1688,9 +1804,28 @@ crypto_digest_t *
 crypto_digest256_new(digest_algorithm_t algorithm)
 {
   crypto_digest_t *r;
-  tor_assert(algorithm == DIGEST_SHA256);
-  r = tor_malloc(sizeof(crypto_digest_t));
-  SHA256_Init(&r->d.sha2);
+  tor_assert(algorithm == DIGEST_SHA256 || algorithm == DIGEST_SHA3_256);
+  r = tor_malloc(crypto_digest_alloc_bytes(algorithm));
+  if (algorithm == DIGEST_SHA256)
+    SHA256_Init(&r->d.sha2);
+  else
+    keccak_digest_init(&r->d.sha3, 256);
+  r->algorithm = algorithm;
+  return r;
+}
+
+/** Allocate and return a new digest object to compute 512-bit digests
+ * using <b>algorithm</b>. */
+crypto_digest_t *
+crypto_digest512_new(digest_algorithm_t algorithm)
+{
+  crypto_digest_t *r;
+  tor_assert(algorithm == DIGEST_SHA512 || algorithm == DIGEST_SHA3_512);
+  r = tor_malloc(crypto_digest_alloc_bytes(algorithm));
+  if (algorithm == DIGEST_SHA512)
+    SHA512_Init(&r->d.sha512);
+  else
+    keccak_digest_init(&r->d.sha3, 512);
   r->algorithm = algorithm;
   return r;
 }
@@ -1702,7 +1837,8 @@ crypto_digest_free(crypto_digest_t *digest)
 {
   if (!digest)
     return;
-  memwipe(digest, 0, sizeof(crypto_digest_t));
+  size_t bytes = crypto_digest_alloc_bytes(digest->algorithm);
+  memwipe(digest, 0, bytes);
   tor_free(digest);
 }
 
@@ -1726,6 +1862,13 @@ crypto_digest_add_bytes(crypto_digest_t *digest, const char *data,
     case DIGEST_SHA256:
       SHA256_Update(&digest->d.sha2, (void*)data, len);
       break;
+    case DIGEST_SHA512:
+      SHA512_Update(&digest->d.sha512, (void*)data, len);
+      break;
+    case DIGEST_SHA3_256: /* FALLSTHROUGH */
+    case DIGEST_SHA3_512:
+      keccak_digest_update(&digest->d.sha3, (const uint8_t *)data, len);
+      break;
     default:
       tor_fragile_assert();
       break;
@@ -1734,33 +1877,45 @@ crypto_digest_add_bytes(crypto_digest_t *digest, const char *data,
 
 /** Compute the hash of the data that has been passed to the digest
  * object; write the first out_len bytes of the result to <b>out</b>.
- * <b>out_len</b> must be \<= DIGEST256_LEN.
+ * <b>out_len</b> must be \<= DIGEST512_LEN.
  */
 void
 crypto_digest_get_digest(crypto_digest_t *digest,
                          char *out, size_t out_len)
 {
-  unsigned char r[DIGEST256_LEN];
+  unsigned char r[DIGEST512_LEN];
   crypto_digest_t tmpenv;
   tor_assert(digest);
   tor_assert(out);
+  tor_assert(out_len <= crypto_digest_algorithm_get_length(digest->algorithm));
+
+  /* The SHA-3 code handles copying into a temporary ctx, and also can handle
+   * short output buffers by truncating appropriately. */
+  if (digest->algorithm == DIGEST_SHA3_256 ||
+      digest->algorithm == DIGEST_SHA3_512) {
+    keccak_digest_sum(&digest->d.sha3, (uint8_t *)out, out_len);
+    return;
+  }
+
+  const size_t alloc_bytes = crypto_digest_alloc_bytes(digest->algorithm);
   /* memcpy into a temporary ctx, since SHA*_Final clears the context */
-  memcpy(&tmpenv, digest, sizeof(crypto_digest_t));
+  memcpy(&tmpenv, digest, alloc_bytes);
   switch (digest->algorithm) {
     case DIGEST_SHA1:
-      tor_assert(out_len <= DIGEST_LEN);
       SHA1_Final(r, &tmpenv.d.sha1);
       break;
     case DIGEST_SHA256:
-      tor_assert(out_len <= DIGEST256_LEN);
       SHA256_Final(r, &tmpenv.d.sha2);
       break;
+    case DIGEST_SHA512:
+      SHA512_Final(r, &tmpenv.d.sha512);
+      break;
+    case DIGEST_SHA3_256: /* FALLSTHROUGH */
+    case DIGEST_SHA3_512:
+      log_warn(LD_BUG, "Handling unexpected algorithm %d", digest->algorithm);
+      tor_assert(0); /* This is fatal, because it should never happen. */
     default:
-      log_warn(LD_BUG, "Called with unknown algorithm %d", digest->algorithm);
-      /* If fragile_assert is not enabled, then we should at least not
-       * leak anything. */
-      memwipe(r, 0xff, sizeof(r));
-      tor_fragile_assert();
+      tor_assert(0); /* Unreachable. */
       break;
   }
   memcpy(out, r, out_len);
@@ -1773,15 +1928,14 @@ crypto_digest_get_digest(crypto_digest_t *digest,
 crypto_digest_t *
 crypto_digest_dup(const crypto_digest_t *digest)
 {
-  crypto_digest_t *r;
   tor_assert(digest);
-  r = tor_malloc(sizeof(crypto_digest_t));
-  memcpy(r,digest,sizeof(crypto_digest_t));
-  return r;
+  const size_t alloc_bytes = crypto_digest_alloc_bytes(digest->algorithm);
+  return tor_memdup(digest, alloc_bytes);
 }
 
 /** Replace the state of the digest object <b>into</b> with the state
- * of the digest object <b>from</b>.
+ * of the digest object <b>from</b>.  Requires that 'into' and 'from'
+ * have the same digest type.
  */
 void
 crypto_digest_assign(crypto_digest_t *into,
@@ -1789,14 +1943,16 @@ crypto_digest_assign(crypto_digest_t *into,
 {
   tor_assert(into);
   tor_assert(from);
-  memcpy(into,from,sizeof(crypto_digest_t));
+  tor_assert(into->algorithm == from->algorithm);
+  const size_t alloc_bytes = crypto_digest_alloc_bytes(from->algorithm);
+  memcpy(into,from,alloc_bytes);
 }
 
 /** Given a list of strings in <b>lst</b>, set the <b>len_out</b>-byte digest
  * at <b>digest_out</b> to the hash of the concatenation of those strings,
  * plus the optional string <b>append</b>, computed with the algorithm
  * <b>alg</b>.
- * <b>out_len</b> must be \<= DIGEST256_LEN. */
+ * <b>out_len</b> must be \<= DIGEST512_LEN. */
 void
 crypto_digest_smartlist(char *digest_out, size_t len_out,
                         const smartlist_t *lst,
@@ -1811,7 +1967,7 @@ crypto_digest_smartlist(char *digest_out, size_t len_out,
  * optional string <b>prepend</b>, those strings,
  * and the optional string <b>append</b>, computed with the algorithm
  * <b>alg</b>.
- * <b>out_len</b> must be \<= DIGEST256_LEN. */
+ * <b>len_out</b> must be \<= DIGEST512_LEN. */
 void
 crypto_digest_smartlist_prefix(char *digest_out, size_t len_out,
                         const char *prepend,
@@ -1819,11 +1975,27 @@ crypto_digest_smartlist_prefix(char *digest_out, size_t len_out,
                         const char *append,
                         digest_algorithm_t alg)
 {
-  crypto_digest_t *d;
-  if (alg == DIGEST_SHA1)
-    d = crypto_digest_new();
-  else
-    d = crypto_digest256_new(alg);
+  crypto_digest_t *d = NULL;
+  switch (alg) {
+    case DIGEST_SHA1:
+      d = crypto_digest_new();
+      break;
+    case DIGEST_SHA256: /* FALLSTHROUGH */
+    case DIGEST_SHA3_256:
+      d = crypto_digest256_new(alg);
+      break;
+    case DIGEST_SHA512: /* FALLSTHROUGH */
+    case DIGEST_SHA3_512:
+      d = crypto_digest512_new(alg);
+      break;
+    default:
+      log_warn(LD_BUG, "Called with unknown algorithm %d", alg);
+      /* If fragile_assert is not enabled, wipe output and return
+       * without running any calculations */
+      memwipe(digest_out, 0xff, len_out);
+      tor_fragile_assert();
+      goto free;
+  }
   if (prepend)
     crypto_digest_add_bytes(d, prepend, strlen(prepend));
   SMARTLIST_FOREACH(lst, const char *, cp,
@@ -1831,23 +2003,78 @@ crypto_digest_smartlist_prefix(char *digest_out, size_t len_out,
   if (append)
     crypto_digest_add_bytes(d, append, strlen(append));
   crypto_digest_get_digest(d, digest_out, len_out);
+
+ free:
   crypto_digest_free(d);
 }
 
 /** Compute the HMAC-SHA-256 of the <b>msg_len</b> bytes in <b>msg</b>, using
  * the <b>key</b> of length <b>key_len</b>.  Store the DIGEST256_LEN-byte
- * result in <b>hmac_out</b>.
+ * result in <b>hmac_out</b>. Asserts on failure.
  */
 void
 crypto_hmac_sha256(char *hmac_out,
                    const char *key, size_t key_len,
                    const char *msg, size_t msg_len)
 {
+  unsigned char *rv = NULL;
   /* If we've got OpenSSL >=0.9.8 we can use its hmac implementation. */
   tor_assert(key_len < INT_MAX);
   tor_assert(msg_len < INT_MAX);
-  HMAC(EVP_sha256(), key, (int)key_len, (unsigned char*)msg, (int)msg_len,
-       (unsigned char*)hmac_out, NULL);
+  tor_assert(hmac_out);
+  rv = HMAC(EVP_sha256(), key, (int)key_len, (unsigned char*)msg, (int)msg_len,
+            (unsigned char*)hmac_out, NULL);
+  tor_assert(rv);
+}
+
+/** Internal state for a eXtendable-Output Function (XOF). */
+struct crypto_xof_t {
+  keccak_state s;
+};
+
+/** Allocate a new XOF object backed by SHAKE-256.  The security level
+ * provided is a function of the length of the output used.  Read and
+ * understand FIPS-202 A.2 "Additional Consideration for Extendable-Output
+ * Functions" before using this construct.
+ */
+crypto_xof_t *
+crypto_xof_new(void)
+{
+  crypto_xof_t *xof;
+  xof = tor_malloc(sizeof(crypto_xof_t));
+  keccak_xof_init(&xof->s, 256);
+  return xof;
+}
+
+/** Absorb bytes into a XOF object.  Must not be called after a call to
+ * crypto_xof_squeeze_bytes() for the same instance, and will assert
+ * if attempted.
+ */
+void
+crypto_xof_add_bytes(crypto_xof_t *xof, const uint8_t *data, size_t len)
+{
+  int i = keccak_xof_absorb(&xof->s, data, len);
+  tor_assert(i == 0);
+}
+
+/** Squeeze bytes out of a XOF object.  Calling this routine will render
+ * the XOF instance ineligible to absorb further data.
+ */
+void
+crypto_xof_squeeze_bytes(crypto_xof_t *xof, uint8_t *out, size_t len)
+{
+  int i = keccak_xof_squeeze(&xof->s, out, len);
+  tor_assert(i == 0);
+}
+
+/** Cleanse and deallocate a XOF object. */
+void
+crypto_xof_free(crypto_xof_t *xof)
+{
+  if (!xof)
+    return;
+  memwipe(xof, 0, sizeof(crypto_xof_t));
+  tor_free(xof);
 }
 
 /* DH */
@@ -1862,6 +2089,71 @@ static BIGNUM *dh_param_p_tls = NULL;
 /** Shared G parameter for our DH key exchanges. */
 static BIGNUM *dh_param_g = NULL;
 
+/** Validate a given set of Diffie-Hellman parameters.  This is moderately
+ * computationally expensive (milliseconds), so should only be called when
+ * the DH parameters change. Returns 0 on success, * -1 on failure.
+ */
+static int
+crypto_validate_dh_params(const BIGNUM *p, const BIGNUM *g)
+{
+  DH *dh = NULL;
+  int ret = -1;
+
+  /* Copy into a temporary DH object. */
+  if (!(dh = DH_new()))
+      goto out;
+  if (!(dh->p = BN_dup(p)))
+    goto out;
+  if (!(dh->g = BN_dup(g)))
+    goto out;
+
+  /* Perform the validation. */
+  int codes = 0;
+  if (!DH_check(dh, &codes))
+    goto out;
+  if (BN_is_word(dh->g, DH_GENERATOR_2)) {
+    /* Per https://wiki.openssl.org/index.php/Diffie-Hellman_parameters
+     *
+     * OpenSSL checks the prime is congruent to 11 when g = 2; while the
+     * IETF's primes are congruent to 23 when g = 2.
+     */
+    BN_ULONG residue = BN_mod_word(dh->p, 24);
+    if (residue == 11 || residue == 23)
+      codes &= ~DH_NOT_SUITABLE_GENERATOR;
+  }
+  if (codes != 0) /* Specifics on why the params suck is irrelevant. */
+    goto out;
+
+  /* Things are probably not evil. */
+  ret = 0;
+
+ out:
+  if (dh)
+    DH_free(dh);
+  return ret;
+}
+
+/** Set the global Diffie-Hellman generator, used for both TLS and internal
+ * DH stuff.
+ */
+static void
+crypto_set_dh_generator(void)
+{
+  BIGNUM *generator;
+  int r;
+
+  if (dh_param_g)
+    return;
+
+  generator = BN_new();
+  tor_assert(generator);
+
+  r = BN_set_word(generator, DH_GENERATOR);
+  tor_assert(r);
+
+  dh_param_g = generator;
+}
+
 /** Set the global TLS Diffie-Hellman modulus.  Use the Apache mod_ssl DH
  * modulus. */
 void
@@ -1894,6 +2186,8 @@ crypto_set_tls_dh_prime(void)
   tor_assert(tls_prime);
 
   dh_param_p_tls = tls_prime;
+  crypto_set_dh_generator();
+  tor_assert(0 == crypto_validate_dh_params(dh_param_p_tls, dh_param_g));
 }
 
 /** Initialize dh_param_p and dh_param_g if they are not already
@@ -1901,18 +2195,13 @@ crypto_set_tls_dh_prime(void)
 static void
 init_dh_param(void)
 {
-  BIGNUM *circuit_dh_prime, *generator;
+  BIGNUM *circuit_dh_prime;
   int r;
   if (dh_param_p && dh_param_g)
     return;
 
   circuit_dh_prime = BN_new();
-  generator = BN_new();
-  tor_assert(circuit_dh_prime && generator);
-
-  /* Set our generator for all DH parameters */
-  r = BN_set_word(generator, DH_GENERATOR);
-  tor_assert(r);
+  tor_assert(circuit_dh_prime);
 
   /* This is from rfc2409, section 6.2.  It's a safe prime, and
      supposedly it equals:
@@ -1928,7 +2217,8 @@ init_dh_param(void)
 
   /* Set the new values as the global DH parameters. */
   dh_param_p = circuit_dh_prime;
-  dh_param_g = generator;
+  crypto_set_dh_generator();
+  tor_assert(0 == crypto_validate_dh_params(dh_param_p, dh_param_g));
 
   if (!dh_param_p_tls) {
     crypto_set_tls_dh_prime();
@@ -1941,7 +2231,8 @@ init_dh_param(void)
  */
 #define DH_PRIVATE_KEY_BITS 320
 
-/** Allocate and return a new DH object for a key exchange.
+/** Allocate and return a new DH object for a key exchange. Returns NULL on
+ * failure.
  */
 crypto_dh_t *
 crypto_dh_new(int dh_type)
@@ -2164,7 +2455,7 @@ int
 crypto_expand_key_material_TAP(const uint8_t *key_in, size_t key_in_len,
                                uint8_t *key_out, size_t key_out_len)
 {
-  int i;
+  int i, r = -1;
   uint8_t *cp, *tmp = tor_malloc(key_in_len+1);
   uint8_t digest[DIGEST_LEN];
 
@@ -2176,19 +2467,16 @@ crypto_expand_key_material_TAP(const uint8_t *key_in, size_t key_in_len,
        ++i, cp += DIGEST_LEN) {
     tmp[key_in_len] = i;
     if (crypto_digest((char*)digest, (const char *)tmp, key_in_len+1))
-      goto err;
+      goto exit;
     memcpy(cp, digest, MIN(DIGEST_LEN, key_out_len-(cp-key_out)));
   }
-  memwipe(tmp, 0, key_in_len+1);
-  tor_free(tmp);
-  memwipe(digest, 0, sizeof(digest));
-  return 0;
 
- err:
+  r = 0;
+ exit:
   memwipe(tmp, 0, key_in_len+1);
   tor_free(tmp);
   memwipe(digest, 0, sizeof(digest));
-  return -1;
+  return r;
 }
 
 /** Expand some secret key material according to RFC5869, using SHA256 as the
@@ -2196,7 +2484,7 @@ crypto_expand_key_material_TAP(const uint8_t *key_in, size_t key_in_len,
  * secret key material; the <b>salt_in_len</b> bytes at <b>salt_in</b> and the
  * <b>info_in_len</b> bytes in <b>info_in_len</b> are the algorithm's "salt"
  * and "info" parameters respectively.  On success, write <b>key_out_len</b>
- * bytes to <b>key_out</b> and return 0.  On failure, return -1.
+ * bytes to <b>key_out</b> and return 0.  Assert on failure.
  */
 int
 crypto_expand_key_material_rfc5869_sha256(
@@ -2280,23 +2568,18 @@ crypto_seed_weak_rng(tor_weak_rng_t *rng)
 }
 
 /** Try to get <b>out_len</b> bytes of the strongest entropy we can generate,
- * storing it into <b>out</b>.
+ * via system calls, storing it into <b>out</b>. Return 0 on success, -1 on
+ * failure.  A maximum request size of 256 bytes is imposed.
  */
-int
-crypto_strongest_rand(uint8_t *out, size_t out_len)
+static int
+crypto_strongest_rand_syscall(uint8_t *out, size_t out_len)
 {
-#ifdef _WIN32
+  tor_assert(out_len <= MAX_STRONGEST_RAND_SIZE);
+
+#if defined(_WIN32)
   static int provider_set = 0;
   static HCRYPTPROV provider;
-#else
-  static const char *filenames[] = {
-    "/dev/srandom", "/dev/urandom", "/dev/random", NULL
-  };
-  int fd, i;
-  size_t n;
-#endif
 
-#ifdef _WIN32
   if (!provider_set) {
     if (!CryptAcquireContext(&provider, NULL, NULL, PROV_RSA_FULL,
                              CRYPT_VERIFYCONTEXT)) {
@@ -2311,7 +2594,84 @@ crypto_strongest_rand(uint8_t *out, size_t out_len)
   }
 
   return 0;
+#elif defined(__linux__) && defined(SYS_getrandom)
+  static int getrandom_works = 1; /* Be optimitic about our chances... */
+
+  /* getrandom() isn't as straight foward as getentropy(), and has
+   * no glibc wrapper.
+   *
+   * As far as I can tell from getrandom(2) and the source code, the
+   * requests we issue will always succeed (though it will block on the
+   * call if /dev/urandom isn't seeded yet), since we are NOT specifying
+   * GRND_NONBLOCK and the request is <= 256 bytes.
+   *
+   * The manpage is unclear on what happens if a signal interrupts the call
+   * while the request is blocked due to lack of entropy....
+   *
+   * We optimistically assume that getrandom() is available and functional
+   * because it is the way of the future, and 2 branch mispredicts pale in
+   * comparision to the overheads involved with failing to open
+   * /dev/srandom followed by opening and reading from /dev/urandom.
+   */
+  if (PREDICT_LIKELY(getrandom_works)) {
+    long ret;
+    /* A flag of '0' here means to read from '/dev/urandom', and to
+     * block if insufficient entropy is available to service the
+     * request.
+     */
+    const unsigned int flags = 0;
+    do {
+      ret = syscall(SYS_getrandom, out, out_len, flags);
+    } while (ret == -1 && ((errno == EINTR) ||(errno == EAGAIN)));
+
+    if (PREDICT_UNLIKELY(ret == -1)) {
+      tor_assert(errno != EAGAIN);
+      tor_assert(errno != EINTR);
+
+      /* Probably ENOSYS. */
+      log_warn(LD_CRYPTO, "Can't get entropy from getrandom().");
+      getrandom_works = 0; /* Don't bother trying again. */
+      return -1;
+    }
+
+    tor_assert(ret == (long)out_len);
+    return 0;
+  }
+
+  return -1; /* getrandom() previously failed unexpectedly. */
+#elif defined(HAVE_GETENTROPY)
+  /* getentropy() is what Linux's getrandom() wants to be when it grows up.
+   * the only gotcha is that requests are limited to 256 bytes.
+   */
+  return getentropy(out, out_len);
 #else
+  (void) out;
+#endif
+
+  /* This platform doesn't have a supported syscall based random. */
+  return -1;
+}
+
+/** Try to get <b>out_len</b> bytes of the strongest entropy we can generate,
+ * via the per-platform fallback mechanism, storing it into <b>out</b>.
+ * Return 0 on success, -1 on failure.  A maximum request size of 256 bytes
+ * is imposed.
+ */
+static int
+crypto_strongest_rand_fallback(uint8_t *out, size_t out_len)
+{
+#ifdef _WIN32
+  /* Windows exclusively uses crypto_strongest_rand_syscall(). */
+  (void)out;
+  (void)out_len;
+  return -1;
+#else
+  static const char *filenames[] = {
+    "/dev/srandom", "/dev/urandom", "/dev/random", NULL
+  };
+  int fd, i;
+  size_t n;
+
   for (i = 0; filenames[i]; ++i) {
     log_debug(LD_FS, "Opening %s for entropy", filenames[i]);
     fd = open(sandbox_intern_string(filenames[i]), O_RDONLY, 0);
@@ -2329,14 +2689,95 @@ crypto_strongest_rand(uint8_t *out, size_t out_len)
     return 0;
   }
 
-  log_warn(LD_CRYPTO, "Cannot get strong entropy: no entropy source found.");
   return -1;
 #endif
 }
 
+/** Try to get <b>out_len</b> bytes of the strongest entropy we can generate,
+ * storing it into <b>out</b>. Return 0 on success, -1 on failure.  A maximum
+ * request size of 256 bytes is imposed.
+ */
+static int
+crypto_strongest_rand_raw(uint8_t *out, size_t out_len)
+{
+  static const size_t sanity_min_size = 16;
+  static const int max_attempts = 3;
+  tor_assert(out_len <= MAX_STRONGEST_RAND_SIZE);
+
+  /* For buffers >= 16 bytes (128 bits), we sanity check the output by
+   * zero filling the buffer and ensuring that it actually was at least
+   * partially modified.
+   *
+   * Checking that any individual byte is non-zero seems like it would
+   * fail too often (p = out_len * 1/256) for comfort, but this is an
+   * "adjust according to taste" sort of check.
+   */
+  memwipe(out, 0, out_len);
+  for (int i = 0; i < max_attempts; i++) {
+    /* Try to use the syscall/OS favored mechanism to get strong entropy. */
+    if (crypto_strongest_rand_syscall(out, out_len) != 0) {
+      /* Try to use the less-favored mechanism to get strong entropy. */
+      if (crypto_strongest_rand_fallback(out, out_len) != 0) {
+        /* Welp, we tried.  Hopefully the calling code terminates the process
+         * since we're basically boned without good entropy.
+         */
+        log_warn(LD_CRYPTO,
+                 "Cannot get strong entropy: no entropy source found.");
+        return -1;
+      }
+    }
+
+    if ((out_len < sanity_min_size) || !tor_mem_is_zero((char*)out, out_len))
+      return 0;
+  }
+
+  /* We tried max_attempts times to fill a buffer >= 128 bits long,
+   * and each time it returned all '0's.  Either the system entropy
+   * source is busted, or the user should go out and buy a ticket to
+   * every lottery on the planet.
+   */
+  log_warn(LD_CRYPTO, "Strong OS entropy returned all zero buffer.");
+  return -1;
+}
+
+/** Try to get <b>out_len</b> bytes of the strongest entropy we can generate,
+ * storing it into <b>out</b>.
+ */
+void
+crypto_strongest_rand(uint8_t *out, size_t out_len)
+{
+#define DLEN SHA512_DIGEST_LENGTH
+  /* We're going to hash DLEN bytes from the system RNG together with some
+   * bytes from the openssl PRNG, in order to yield DLEN bytes.
+   */
+  uint8_t inp[DLEN*2];
+  uint8_t tmp[DLEN];
+  tor_assert(out);
+  while (out_len) {
+    crypto_rand((char*) inp, DLEN);
+    if (crypto_strongest_rand_raw(inp+DLEN, DLEN) < 0) {
+      log_err(LD_CRYPTO, "Failed to load strong entropy when generating an "
+              "important key. Exiting.");
+      /* Die with an assertion so we get a stack trace. */
+      tor_assert(0);
+    }
+    if (out_len >= DLEN) {
+      SHA512(inp, sizeof(inp), out);
+      out += DLEN;
+      out_len -= DLEN;
+    } else {
+      SHA512(inp, sizeof(inp), tmp);
+      memcpy(out, tmp, out_len);
+      break;
+    }
+  }
+  memwipe(tmp, 0, sizeof(tmp));
+  memwipe(inp, 0, sizeof(inp));
+#undef DLEN
+}
+
 /** Seed OpenSSL's random number generator with bytes from the operating
- * system.  <b>startup</b> should be true iff we have just started Tor and
- * have not yet allocated a bunch of fds.  Return 0 on success, -1 on failure.
+ * system.  Return 0 on success, -1 on failure.
  */
 int
 crypto_seed_rng(void)
@@ -2351,41 +2792,51 @@ crypto_seed_rng(void)
   if (rand_poll_ok == 0)
     log_warn(LD_CRYPTO, "RAND_poll() failed.");
 
-  load_entropy_ok = !crypto_strongest_rand(buf, sizeof(buf));
+  load_entropy_ok = !crypto_strongest_rand_raw(buf, sizeof(buf));
   if (load_entropy_ok) {
     RAND_seed(buf, sizeof(buf));
   }
 
   memwipe(buf, 0, sizeof(buf));
 
-  if (rand_poll_ok || load_entropy_ok)
+  if ((rand_poll_ok || load_entropy_ok) && RAND_status() == 1)
     return 0;
   else
     return -1;
 }
 
-/** Write <b>n</b> bytes of strong random data to <b>to</b>. Return 0 on
- * success, -1 on failure, with support for mocking for unit tests.
+/** Write <b>n</b> bytes of strong random data to <b>to</b>. Supports mocking
+ * for unit tests.
+ *
+ * This function is not allowed to fail; if it would fail to generate strong
+ * entropy, it must terminate the process instead.
  */
-MOCK_IMPL(int,
+MOCK_IMPL(void,
 crypto_rand, (char *to, size_t n))
 {
-  return crypto_rand_unmocked(to, n);
+  crypto_rand_unmocked(to, n);
 }
 
-/** Write <b>n</b> bytes of strong random data to <b>to</b>. Return 0 on
- * success, -1 on failure.  Most callers will want crypto_rand instead.
+/** Write <b>n</b> bytes of strong random data to <b>to</b>.  Most callers
+ * will want crypto_rand instead.
+ *
+ * This function is not allowed to fail; if it would fail to generate strong
+ * entropy, it must terminate the process instead.
  */
-int
+void
 crypto_rand_unmocked(char *to, size_t n)
 {
   int r;
+  if (n == 0)
+    return;
+
   tor_assert(n < INT_MAX);
   tor_assert(to);
   r = RAND_bytes((unsigned char*)to, (int)n);
-  if (r == 0)
-    crypto_log_errors(LOG_WARN, "generating random data");
-  return (r == 1) ? 0 : -1;
+  /* We consider a PRNG failure non-survivable. Let's assert so that we get a
+   * stack trace about where it happened.
+   */
+  tor_assert(r >= 0);
 }
 
 /** Return a pseudorandom integer, chosen uniformly from the values
@@ -2411,8 +2862,8 @@ crypto_rand_int(unsigned int max)
   }
 }
 
-/** Return a pseudorandom integer, chosen uniformly from the values <i>i</i>
- * such that <b>min</b> &lt;= <i>i</i> &lt <b>max</b>.
+/** Return a pseudorandom integer, chosen uniformly from the values i such
+ * that min <= i < max.
  *
  * <b>min</b> MUST be in range [0, <b>max</b>).
  * <b>max</b> MUST be in range (min, INT_MAX].
@@ -2489,7 +2940,7 @@ crypto_rand_double(void)
 /** Generate and return a new random hostname starting with <b>prefix</b>,
  * ending with <b>suffix</b>, and containing no fewer than
  * <b>min_rand_len</b> and no more than <b>max_rand_len</b> random base32
- * characters between.
+ * characters. Does not check for failure.
  *
  * Clip <b>max_rand_len</b> to MAX_DNS_LABEL_SIZE.
  **/
@@ -2556,6 +3007,7 @@ smartlist_shuffle(smartlist_t *sl)
 /**
  * Destroy the <b>sz</b> bytes of data stored at <b>mem</b>, setting them to
  * the value <b>byte</b>.
+ * If <b>mem</b> is NULL or <b>sz</b> is zero, nothing happens.
  *
  * This function is preferable to memset, since many compilers will happily
  * optimize out memset() when they can convince themselves that the data being
@@ -2573,17 +3025,45 @@ smartlist_shuffle(smartlist_t *sl)
 void
 memwipe(void *mem, uint8_t byte, size_t sz)
 {
+  if (sz == 0) {
+    return;
+  }
+  /* If sz is nonzero, then mem must not be NULL. */
+  tor_assert(mem != NULL);
+
+  /* Data this large is likely to be an underflow. */
+  tor_assert(sz < SIZE_T_CEILING);
+
   /* Because whole-program-optimization exists, we may not be able to just
    * have this function call "memset".  A smart compiler could inline it, then
    * eliminate dead memsets, and declare itself to be clever. */
 
+#if defined(SecureZeroMemory) || defined(HAVE_SECUREZEROMEMORY)
+  /* Here's what you do on windows. */
+  SecureZeroMemory(mem,sz);
+#elif defined(HAVE_RTLSECUREZEROMEMORY)
+  RtlSecureZeroMemory(mem,sz);
+#elif defined(HAVE_EXPLICIT_BZERO)
+  /* The BSDs provide this. */
+  explicit_bzero(mem, sz);
+#elif defined(HAVE_MEMSET_S)
+  /* This is in the C99 standard. */
+  memset_s(mem, sz, 0, sz);
+#else
   /* This is a slow and ugly function from OpenSSL that fills 'mem' with junk
    * based on the pointer value, then uses that junk to update a global
    * variable.  It's an elaborate ruse to trick the compiler into not
    * optimizing out the "wipe this memory" code.  Read it if you like zany
    * programming tricks! In later versions of Tor, we should look for better
-   * not-optimized-out memory wiping stuff. */
+   * not-optimized-out memory wiping stuff...
+   *
+   * ...or maybe not.  In practice, there are pure-asm implementations of
+   * OPENSSL_cleanse() on most platforms, which ought to do the job.
+   **/
+
   OPENSSL_cleanse(mem, sz);
+#endif
+
   /* Just in case some caller of memwipe() is relying on getting a buffer
    * filled with a particular value, fill the buffer.
    *
@@ -2618,6 +3098,10 @@ openssl_locking_cb_(int mode, int n, const char *file, int line)
     tor_mutex_release(openssl_mutexes_[n]);
 }
 
+#if 0
+/* This code is disabled, because OpenSSL never actually uses these callbacks.
+ */
+
 /** OpenSSL helper type: wraps a Tor mutex so that OpenSSL can use it
  * as a lock. */
 struct CRYPTO_dynlock_value {
@@ -2662,6 +3146,7 @@ openssl_dynlock_destroy_cb_(struct CRYPTO_dynlock_value *v,
   tor_mutex_free(v->lock);
   tor_free(v);
 }
+#endif
 
 static void
 tor_set_openssl_thread_id(CRYPTO_THREADID *threadid)
@@ -2671,7 +3156,7 @@ tor_set_openssl_thread_id(CRYPTO_THREADID *threadid)
 
 /** @{ */
 /** Helper: Construct mutexes, and set callbacks to help OpenSSL handle being
- * multithreaded. */
+ * multithreaded. Returns 0. */
 static int
 setup_openssl_threading(void)
 {
@@ -2683,23 +3168,22 @@ setup_openssl_threading(void)
     openssl_mutexes_[i] = tor_mutex_new();
   CRYPTO_set_locking_callback(openssl_locking_cb_);
   CRYPTO_THREADID_set_callback(tor_set_openssl_thread_id);
+#if 0
   CRYPTO_set_dynlock_create_callback(openssl_dynlock_create_cb_);
   CRYPTO_set_dynlock_lock_callback(openssl_dynlock_lock_cb_);
   CRYPTO_set_dynlock_destroy_callback(openssl_dynlock_destroy_cb_);
+#endif
   return 0;
 }
 
-/** Uninitialize the crypto library. Return 0 on success, -1 on failure.
+/** Uninitialize the crypto library. Return 0 on success. Does not detect
+ * failure.
  */
 int
 crypto_global_cleanup(void)
 {
   EVP_cleanup();
-#if OPENSSL_VERSION_NUMBER >= OPENSSL_V_SERIES(1,1,0)
   ERR_remove_thread_state(NULL);
-#else
-  ERR_remove_state(0);
-#endif
   ERR_free_strings();
 
   if (dh_param_p)
diff --git a/src/common/crypto.h b/src/common/crypto.h
index 6256f73..74b88bc 100644
--- a/src/common/crypto.h
+++ b/src/common/crypto.h
@@ -16,6 +16,7 @@
 #include <stdio.h>
 #include "torint.h"
 #include "testsupport.h"
+#include "compat.h"
 
 /*
   Macro to create an arbitrary OpenSSL version number as used by
@@ -54,6 +55,8 @@
 /** Length of the output of our second (improved) message digests.  (For now
  * this is just sha256, but it could be any other 256-bit digest.) */
 #define DIGEST256_LEN 32
+/** Length of the output of our 64-bit optimized message digests (SHA512). */
+#define DIGEST512_LEN 64
 /** Length of our symmetric cipher's keys. */
 #define CIPHER_KEY_LEN 16
 /** Length of our symmetric cipher's IV. */
@@ -69,6 +72,9 @@
 /** Length of a sha256 message digest when encoded in base64 with trailing =
  * signs removed. */
 #define BASE64_DIGEST256_LEN 43
+/** Length of a sha512 message digest when encoded in base64 with trailing =
+ * signs removed. */
+#define BASE64_DIGEST512_LEN 86
 
 /** Constant used to indicate OAEP padding for public-key encryption */
 #define PK_PKCS1_OAEP_PADDING 60002
@@ -83,43 +89,48 @@
 #define HEX_DIGEST_LEN 40
 /** Length of hex encoding of SHA256 digest, not including final NUL. */
 #define HEX_DIGEST256_LEN 64
+/** Length of hex encoding of SHA512 digest, not including final NUL. */
+#define HEX_DIGEST512_LEN 128
 
 typedef enum {
   DIGEST_SHA1 = 0,
   DIGEST_SHA256 = 1,
+  DIGEST_SHA512 = 2,
+  DIGEST_SHA3_256 = 3,
+  DIGEST_SHA3_512 = 4,
 } digest_algorithm_t;
-#define  N_DIGEST_ALGORITHMS (DIGEST_SHA256+1)
-#define digest_algorithm_bitfield_t ENUM_BF(digest_algorithm_t)
+#define  N_DIGEST_ALGORITHMS (DIGEST_SHA3_512+1)
 
 /** A set of all the digests we know how to compute, taken on a single
- * string.  Any digests that are shorter than 256 bits are right-padded
+ * string.  Any digests that are shorter than 512 bits are right-padded
  * with 0 bits.
  *
- * Note that this representation wastes 12 bytes for the SHA1 case, so
+ * Note that this representation wastes 44 bytes for the SHA1 case, so
  * don't use it for anything where we need to allocate a whole bunch at
  * once.
  **/
 typedef struct {
-  char d[N_DIGEST_ALGORITHMS][DIGEST256_LEN];
+  char d[N_DIGEST_ALGORITHMS][DIGEST512_LEN];
 } digests_t;
 
 typedef struct crypto_pk_t crypto_pk_t;
 typedef struct crypto_cipher_t crypto_cipher_t;
 typedef struct crypto_digest_t crypto_digest_t;
+typedef struct crypto_xof_t crypto_xof_t;
 typedef struct crypto_dh_t crypto_dh_t;
 
 /* global state */
 const char * crypto_openssl_get_version_str(void);
 const char * crypto_openssl_get_header_version_str(void);
-int crypto_early_init(void);
+int crypto_early_init(void) ATTR_WUR;
 int crypto_global_init(int hardwareAccel,
                        const char *accelName,
-                       const char *accelPath);
+                       const char *accelPath) ATTR_WUR;
 void crypto_thread_cleanup(void);
 int crypto_global_cleanup(void);
 
 /* environment setup */
-crypto_pk_t *crypto_pk_new(void);
+MOCK_DECL(crypto_pk_t *,crypto_pk_new,(void));
 void crypto_pk_free(crypto_pk_t *env);
 
 void crypto_set_tls_dh_prime(void);
@@ -128,7 +139,7 @@ crypto_cipher_t *crypto_cipher_new_with_iv(const char *key, const char *iv);
 void crypto_cipher_free(crypto_cipher_t *env);
 
 /* public key crypto */
-int crypto_pk_generate_key_with_bits(crypto_pk_t *env, int bits);
+MOCK_DECL(int, crypto_pk_generate_key_with_bits,(crypto_pk_t *env, int bits));
 #define crypto_pk_generate_key(env)                     \
   crypto_pk_generate_key_with_bits((env), (PK_BYTES*8))
 
@@ -194,7 +205,7 @@ int crypto_cipher_encrypt(crypto_cipher_t *env, char *to,
                           const char *from, size_t fromlen);
 int crypto_cipher_decrypt(crypto_cipher_t *env, char *to,
                           const char *from, size_t fromlen);
-int crypto_cipher_crypt_inplace(crypto_cipher_t *env, char *d, size_t len);
+void crypto_cipher_crypt_inplace(crypto_cipher_t *env, char *d, size_t len);
 
 int crypto_cipher_encrypt_with_iv(const char *key,
                                   char *to, size_t tolen,
@@ -207,6 +218,8 @@ int crypto_cipher_decrypt_with_iv(const char *key,
 int crypto_digest(char *digest, const char *m, size_t len);
 int crypto_digest256(char *digest, const char *m, size_t len,
                      digest_algorithm_t algorithm);
+int crypto_digest512(char *digest, const char *m, size_t len,
+                     digest_algorithm_t algorithm);
 int crypto_digest_all(digests_t *ds_out, const char *m, size_t len);
 struct smartlist_t;
 void crypto_digest_smartlist_prefix(char *digest_out, size_t len_out,
@@ -221,6 +234,7 @@ const char *crypto_digest_algorithm_get_name(digest_algorithm_t alg);
 int crypto_digest_algorithm_parse_name(const char *name);
 crypto_digest_t *crypto_digest_new(void);
 crypto_digest_t *crypto_digest256_new(digest_algorithm_t algorithm);
+crypto_digest_t *crypto_digest512_new(digest_algorithm_t algorithm);
 void crypto_digest_free(crypto_digest_t *digest);
 void crypto_digest_add_bytes(crypto_digest_t *digest, const char *data,
                              size_t len);
@@ -232,6 +246,10 @@ void crypto_digest_assign(crypto_digest_t *into,
 void crypto_hmac_sha256(char *hmac_out,
                         const char *key, size_t key_len,
                         const char *msg, size_t msg_len);
+crypto_xof_t *crypto_xof_new(void);
+void crypto_xof_add_bytes(crypto_xof_t *xof, const uint8_t *data, size_t len);
+void crypto_xof_squeeze_bytes(crypto_xof_t *xof, uint8_t *out, size_t len);
+void crypto_xof_free(crypto_xof_t *xof);
 
 /* Key negotiation */
 #define DH_TYPE_CIRCUIT 1
@@ -258,10 +276,10 @@ int crypto_expand_key_material_rfc5869_sha256(
                                     uint8_t *key_out, size_t key_out_len);
 
 /* random numbers */
-int crypto_seed_rng(void);
-MOCK_DECL(int,crypto_rand,(char *to, size_t n));
-int crypto_rand_unmocked(char *to, size_t n);
-int crypto_strongest_rand(uint8_t *out, size_t out_len);
+int crypto_seed_rng(void) ATTR_WUR;
+MOCK_DECL(void,crypto_rand,(char *to, size_t n));
+void crypto_rand_unmocked(char *to, size_t n);
+void crypto_strongest_rand(uint8_t *out, size_t out_len);
 int crypto_rand_int(unsigned int max);
 int crypto_rand_int_range(unsigned int min, unsigned int max);
 uint64_t crypto_rand_uint64_range(uint64_t min, uint64_t max);
@@ -289,11 +307,15 @@ struct evp_pkey_st;
 struct dh_st;
 struct rsa_st *crypto_pk_get_rsa_(crypto_pk_t *env);
 crypto_pk_t *crypto_new_pk_from_rsa_(struct rsa_st *rsa);
-struct evp_pkey_st *crypto_pk_get_evp_pkey_(crypto_pk_t *env,
-                                                int private);
+MOCK_DECL(struct evp_pkey_st *, crypto_pk_get_evp_pkey_,(crypto_pk_t *env,
+                                                         int private));
 struct dh_st *crypto_dh_get_dh_(crypto_dh_t *dh);
 
 void crypto_add_spaces_to_fp(char *out, size_t outlen, const char *in);
 
+#ifdef CRYPTO_PRIVATE
+STATIC int crypto_force_rand_ssleay(void);
+#endif
+
 #endif
 
diff --git a/src/common/crypto_curve25519.c b/src/common/crypto_curve25519.c
index ac0b08a..2002483 100644
--- a/src/common/crypto_curve25519.c
+++ b/src/common/crypto_curve25519.c
@@ -111,19 +111,11 @@ curve25519_public_key_is_ok(const curve25519_public_key_t *key)
 int
 curve25519_rand_seckey_bytes(uint8_t *out, int extra_strong)
 {
-  uint8_t k_tmp[CURVE25519_SECKEY_LEN];
+  if (extra_strong)
+    crypto_strongest_rand(out, CURVE25519_SECKEY_LEN);
+  else
+    crypto_rand((char*)out, CURVE25519_SECKEY_LEN);
 
-  if (crypto_rand((char*)out, CURVE25519_SECKEY_LEN) < 0)
-    return -1;
-  if (extra_strong && !crypto_strongest_rand(k_tmp, CURVE25519_SECKEY_LEN)) {
-    /* If they asked for extra-strong entropy and we have some, use it as an
-     * HMAC key to improve not-so-good entropy rather than using it directly,
-     * just in case the extra-strong entropy is less amazing than we hoped. */
-    crypto_hmac_sha256((char*) out,
-                       (const char *)k_tmp, sizeof(k_tmp),
-                       (const char *)out, CURVE25519_SECKEY_LEN);
-  }
-  memwipe(k_tmp, 0, sizeof(k_tmp));
   return 0;
 }
 
diff --git a/src/common/crypto_ed25519.c b/src/common/crypto_ed25519.c
index 1749efc..9df665f 100644
--- a/src/common/crypto_ed25519.c
+++ b/src/common/crypto_ed25519.c
@@ -96,6 +96,28 @@ get_ed_impl(void)
   return ed25519_impl;
 }
 
+#ifdef TOR_UNIT_TESTS
+static const ed25519_impl_t *saved_ed25519_impl = NULL;
+void
+crypto_ed25519_testing_force_impl(const char *name)
+{
+  tor_assert(saved_ed25519_impl == NULL);
+  saved_ed25519_impl = ed25519_impl;
+  if (! strcmp(name, "donna")) {
+    ed25519_impl = &impl_donna;
+  } else {
+    tor_assert(!strcmp(name, "ref10"));
+    ed25519_impl = &impl_ref10;
+  }
+}
+void
+crypto_ed25519_testing_restore_impl(void)
+{
+  ed25519_impl = saved_ed25519_impl;
+  saved_ed25519_impl = NULL;
+}
+#endif
+
 /**
  * Initialize a new ed25519 secret key in <b>seckey_out</b>.  If
  * <b>extra_strong</b>, take the RNG inputs directly from the operating
@@ -107,7 +129,9 @@ ed25519_secret_key_generate(ed25519_secret_key_t *seckey_out,
 {
   int r;
   uint8_t seed[32];
-  if (! extra_strong || crypto_strongest_rand(seed, sizeof(seed)) < 0)
+  if (extra_strong)
+    crypto_strongest_rand(seed, sizeof(seed));
+ else
     crypto_rand((char*)seed, sizeof(seed));
 
   r = get_ed_impl()->seckey_expand(seckey_out->seckey, seed);
diff --git a/src/common/crypto_ed25519.h b/src/common/crypto_ed25519.h
index bdac12e..4fa7ea1 100644
--- a/src/common/crypto_ed25519.h
+++ b/src/common/crypto_ed25519.h
@@ -111,5 +111,10 @@ int ed25519_pubkey_eq(const ed25519_public_key_t *key1,
 void ed25519_set_impl_params(int use_donna);
 void ed25519_init(void);
 
+#ifdef TOR_UNIT_TESTS
+void crypto_ed25519_testing_force_impl(const char *name);
+void crypto_ed25519_testing_restore_impl(void);
+#endif
+
 #endif
 
diff --git a/src/common/di_ops.c b/src/common/di_ops.c
index c9d1350..70f2da7 100644
--- a/src/common/di_ops.c
+++ b/src/common/di_ops.c
@@ -25,6 +25,9 @@
 int
 tor_memcmp(const void *a, const void *b, size_t len)
 {
+#ifdef HAVE_TIMINGSAFE_MEMCMP
+  return timingsafe_memcmp(a, b, len);
+#else
   const uint8_t *x = a;
   const uint8_t *y = b;
   size_t i = len;
@@ -83,6 +86,7 @@ tor_memcmp(const void *a, const void *b, size_t len)
   }
 
   return retval;
+#endif /* timingsafe_memcmp */
 }
 
 /**
diff --git a/src/common/include.am b/src/common/include.am
index 7de93ba..5afb30d 100644
--- a/src/common/include.am
+++ b/src/common/include.am
@@ -78,7 +78,8 @@ LIBOR_A_SOURCES = \
   $(threads_impl_source)				\
   $(readpassphrase_source)
 
-src/common/log.o: micro-revision.i
+src/common/src_common_libor_testing_a-log.$(OBJEXT) \
+  src/common/log.$(OBJEXT): micro-revision.i
 
 LIBOR_CRYPTO_A_SOURCES = \
   src/common/aes.c		\
@@ -118,6 +119,7 @@ COMMONHEADERS = \
   src/common/ciphers.inc			\
   src/common/compat.h				\
   src/common/compat_libevent.h			\
+  src/common/compat_openssl.h			\
   src/common/compat_threads.h			\
   src/common/container.h			\
   src/common/crypto.h				\
diff --git a/src/common/log.c b/src/common/log.c
index e23691b..4a8a7b1 100644
--- a/src/common/log.c
+++ b/src/common/log.c
@@ -64,7 +64,7 @@ typedef struct logfile_t {
 static void log_free(logfile_t *victim);
 
 /** Helper: map a log severity to descriptive string. */
-static INLINE const char *
+static inline const char *
 sev_to_string(int severity)
 {
   switch (severity) {
@@ -80,7 +80,7 @@ sev_to_string(int severity)
 }
 
 /** Helper: decide whether to include the function name in the log message. */
-static INLINE int
+static inline int
 should_log_function_name(log_domain_mask_t domain, int severity)
 {
   switch (severity) {
@@ -163,7 +163,7 @@ static void close_log(logfile_t *victim);
 
 static char *domain_to_string(log_domain_mask_t domain,
                              char *buf, size_t buflen);
-static INLINE char *format_msg(char *buf, size_t buf_len,
+static inline char *format_msg(char *buf, size_t buf_len,
            log_domain_mask_t domain, int severity, const char *funcname,
            const char *suffix,
            const char *format, va_list ap, size_t *msg_len_out)
@@ -199,7 +199,7 @@ set_log_time_granularity(int granularity_msec)
 /** Helper: Write the standard prefix for log lines to a
  * <b>buf_len</b> character buffer in <b>buf</b>.
  */
-static INLINE size_t
+static inline size_t
 log_prefix_(char *buf, size_t buf_len, int severity)
 {
   time_t t;
@@ -278,7 +278,7 @@ const char bug_suffix[] = " (on Tor " VERSION
  * than once.)  Return a pointer to the first character of the message
  * portion of the formatted string.
  */
-static INLINE char *
+static inline char *
 format_msg(char *buf, size_t buf_len,
            log_domain_mask_t domain, int severity, const char *funcname,
            const char *suffix,
@@ -393,7 +393,7 @@ pending_log_message_free(pending_log_message_t *msg)
 /** Return true iff <b>lf</b> would like to receive a message with the
  * specified <b>severity</b> in the specified <b>domain</b>.
  */
-static INLINE int
+static inline int
 logfile_wants_message(const logfile_t *lf, int severity,
                       log_domain_mask_t domain)
 {
@@ -416,7 +416,7 @@ logfile_wants_message(const logfile_t *lf, int severity,
  * we already deferred this message for pending callbacks and don't need to do
  * it again.  Otherwise, if we need to do it, do it, and set
  * <b>callbacks_deferred</b> to 1. */
-static INLINE void
+static inline void
 logfile_deliver(logfile_t *lf, const char *buf, size_t msg_len,
                 const char *msg_after_prefix, log_domain_mask_t domain,
                 int severity, int *callbacks_deferred)
@@ -1097,14 +1097,25 @@ add_file_log(const log_severity_list_t *severity, const char *filename,
 #ifdef HAVE_SYSLOG_H
 /**
  * Add a log handler to send messages to they system log facility.
+ *
+ * If this is the first log handler, opens syslog with ident Tor or
+ * Tor-<syslog_identity_tag> if that is not NULL.
  */
 int
-add_syslog_log(const log_severity_list_t *severity)
+add_syslog_log(const log_severity_list_t *severity,
+               const char* syslog_identity_tag)
 {
   logfile_t *lf;
-  if (syslog_count++ == 0)
+  if (syslog_count++ == 0) {
     /* This is the first syslog. */
-    openlog("Tor", LOG_PID | LOG_NDELAY, LOGFACILITY);
+    static char buf[256];
+    if (syslog_identity_tag) {
+      tor_snprintf(buf, sizeof(buf), "Tor-%s", syslog_identity_tag);
+    } else {
+      tor_snprintf(buf, sizeof(buf), "Tor");
+    }
+    openlog(buf, LOG_PID | LOG_NDELAY, LOGFACILITY);
+  }
 
   lf = tor_malloc_zero(sizeof(logfile_t));
   lf->fd = -1;
diff --git a/src/common/memarea.c b/src/common/memarea.c
index 6841ba5..a8e6d45 100644
--- a/src/common/memarea.c
+++ b/src/common/memarea.c
@@ -61,7 +61,7 @@
 #endif
 
 /** Increment <b>ptr</b> until it is aligned to MEMAREA_ALIGN. */
-static INLINE void *
+static inline void *
 realign_pointer(void *ptr)
 {
   uintptr_t x = (uintptr_t)ptr;
diff --git a/src/common/procmon.c b/src/common/procmon.c
index 2d0f021..346a0c6 100644
--- a/src/common/procmon.c
+++ b/src/common/procmon.c
@@ -192,7 +192,8 @@ tor_process_monitor_new(struct event_base *base,
                         tor_procmon_callback_t cb, void *cb_arg,
                         const char **msg)
 {
-  tor_process_monitor_t *procmon = tor_malloc(sizeof(tor_process_monitor_t));
+  tor_process_monitor_t *procmon = tor_malloc_zero(
+                                       sizeof(tor_process_monitor_t));
   struct parsed_process_specifier_t ppspec;
 
   tor_assert(msg != NULL);
diff --git a/src/common/sandbox.c b/src/common/sandbox.c
index b995762..d747a87 100644
--- a/src/common/sandbox.c
+++ b/src/common/sandbox.c
@@ -199,6 +199,10 @@ static int filter_nopar_gen[] = {
     SCMP_SYS(stat64),
 #endif
 
+#ifdef __NR_getrandom
+    SCMP_SYS(getrandom),
+#endif
+
     /*
      * These socket syscalls are not required on x86_64 and not supported with
      * some libseccomp versions (eg: 1.0.1)
@@ -1598,7 +1602,7 @@ sigsys_debugging(int nr, siginfo_t *info, void *void_context)
   const char *syscall_name;
   int syscall;
 #ifdef USE_BACKTRACE
-  int depth;
+  size_t depth;
   int n_fds, i;
   const int *fds = NULL;
 #endif
@@ -1630,7 +1634,7 @@ sigsys_debugging(int nr, siginfo_t *info, void *void_context)
 #ifdef USE_BACKTRACE
   n_fds = tor_log_get_sigsafe_err_fds(&fds);
   for (i=0; i < n_fds; ++i)
-    backtrace_symbols_fd(syscall_cb_buf, depth, fds[i]);
+    backtrace_symbols_fd(syscall_cb_buf, (int)depth, fds[i]);
 #endif
 
 #if defined(DEBUGGING_CLOSE)
diff --git a/src/common/torgzip.c b/src/common/torgzip.c
index 4f23407..5ba8ec4 100644
--- a/src/common/torgzip.c
+++ b/src/common/torgzip.c
@@ -91,7 +91,7 @@ tor_zlib_get_header_version_str(void)
 }
 
 /** Return the 'bits' value to tell zlib to use <b>method</b>.*/
-static INLINE int
+static inline int
 method_bits(compress_method_t method, zlib_compression_level_t level)
 {
   /* Bits+16 means "use gzip" in zlib >= 1.2 */
@@ -104,7 +104,7 @@ method_bits(compress_method_t method, zlib_compression_level_t level)
   }
 }
 
-static INLINE int
+static inline int
 get_memlevel(zlib_compression_level_t level)
 {
   switch (level) {
diff --git a/src/common/torint.h b/src/common/torint.h
index 6171700..418fe0f 100644
--- a/src/common/torint.h
+++ b/src/common/torint.h
@@ -336,6 +336,32 @@ typedef uint32_t uintptr_t;
 #endif /* time_t_is_signed */
 #endif /* ifndef(TIME_MAX) */
 
+#ifndef TIME_MIN
+
+#ifdef TIME_T_IS_SIGNED
+
+#if (SIZEOF_TIME_T == SIZEOF_INT)
+#define TIME_MIN ((time_t)INT_MIN)
+#elif (SIZEOF_TIME_T == SIZEOF_LONG)
+#define TIME_MIN ((time_t)LONG_MIN)
+#elif (SIZEOF_TIME_T == 8)
+#define TIME_MIN ((time_t)INT64_MIN)
+#else
+#error "Can't define (signed) TIME_MIN"
+#endif
+
+#else
+/* Unsigned case */
+#if (SIZEOF_TIME_T == 4)
+#define TIME_MIN ((time_t)UINT32_MIN)
+#elif (SIZEOF_TIME_T == 8)
+#define TIME_MIN ((time_t)UINT64_MIN)
+#else
+#error "Can't define (unsigned) TIME_MIN"
+#endif
+#endif /* time_t_is_signed */
+#endif /* ifndef(TIME_MIN) */
+
 #ifndef SIZE_MAX
 #if (SIZEOF_SIZE_T == 4)
 #define SIZE_MAX UINT32_MAX
diff --git a/src/common/torlog.h b/src/common/torlog.h
index 67edf14..3e86678 100644
--- a/src/common/torlog.h
+++ b/src/common/torlog.h
@@ -135,7 +135,8 @@ void add_stream_log(const log_severity_list_t *severity, const char *name,
 int add_file_log(const log_severity_list_t *severity, const char *filename,
                  const int truncate);
 #ifdef HAVE_SYSLOG_H
-int add_syslog_log(const log_severity_list_t *severity);
+int add_syslog_log(const log_severity_list_t *severity,
+                   const char* syslog_identity_tag);
 #endif
 int add_callback_log(const log_severity_list_t *severity, log_callback cb);
 void logs_set_domain_logging(int enabled);
@@ -183,25 +184,25 @@ void log_fn_ratelim_(struct ratelim_t *ratelim, int severity,
 /** Log a message at level <b>severity</b>, using a pretty-printed version
  * of the current function name. */
 #define log_fn(severity, domain, args...)               \
-  log_fn_(severity, domain, __PRETTY_FUNCTION__, args)
+  log_fn_(severity, domain, __FUNCTION__, args)
 /** As log_fn, but use <b>ratelim</b> (an instance of ratelim_t) to control
  * the frequency at which messages can appear.
  */
 #define log_fn_ratelim(ratelim, severity, domain, args...)      \
-  log_fn_ratelim_(ratelim, severity, domain, __PRETTY_FUNCTION__, args)
+  log_fn_ratelim_(ratelim, severity, domain, __FUNCTION__, args)
 #define log_debug(domain, args...)                                      \
   STMT_BEGIN                                                            \
     if (PREDICT_UNLIKELY(log_global_min_severity_ == LOG_DEBUG))        \
-      log_fn_(LOG_DEBUG, domain, __PRETTY_FUNCTION__, args);            \
+      log_fn_(LOG_DEBUG, domain, __FUNCTION__, args);            \
   STMT_END
 #define log_info(domain, args...)                           \
-  log_fn_(LOG_INFO, domain, __PRETTY_FUNCTION__, args)
+  log_fn_(LOG_INFO, domain, __FUNCTION__, args)
 #define log_notice(domain, args...)                         \
-  log_fn_(LOG_NOTICE, domain, __PRETTY_FUNCTION__, args)
+  log_fn_(LOG_NOTICE, domain, __FUNCTION__, args)
 #define log_warn(domain, args...)                           \
-  log_fn_(LOG_WARN, domain, __PRETTY_FUNCTION__, args)
+  log_fn_(LOG_WARN, domain, __FUNCTION__, args)
 #define log_err(domain, args...)                            \
-  log_fn_(LOG_ERR, domain, __PRETTY_FUNCTION__, args)
+  log_fn_(LOG_ERR, domain, __FUNCTION__, args)
 
 #else /* ! defined(__GNUC__) */
 
diff --git a/src/common/tortls.c b/src/common/tortls.c
index 536043e..827abc4 100644
--- a/src/common/tortls.c
+++ b/src/common/tortls.c
@@ -16,6 +16,8 @@
 
 #include "orconfig.h"
 
+#define TORTLS_PRIVATE
+
 #include <assert.h>
 #ifdef _WIN32 /*wrkard for dtls1.h >= 0.9.8m of "#include <winsock.h>"*/
   #include <winsock2.h>
@@ -38,9 +40,6 @@
 #include <openssl/opensslv.h>
 #include "crypto.h"
 
-#if OPENSSL_VERSION_NUMBER < OPENSSL_V_SERIES(1,0,0)
-#error "We require OpenSSL >= 1.0.0"
-#endif
 #ifdef OPENSSL_NO_EC
 #error "We require OpenSSL with ECC support"
 #endif
@@ -69,6 +68,7 @@
 #include "compat_libevent.h"
 #endif
 
+#define TORTLS_PRIVATE
 #include "tortls.h"
 #include "util.h"
 #include "torlog.h"
@@ -80,11 +80,6 @@
 #define X509_get_notAfter_const(cert) \
   ((const ASN1_TIME*) X509_get_notAfter((X509 *)cert))
 
-/* Enable the "v2" TLS handshake.
- */
-#define V2_HANDSHAKE_SERVER
-#define V2_HANDSHAKE_CLIENT
-
 /* Copied from or.h */
 #define LEGAL_NICKNAME_CHARACTERS \
   "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
@@ -113,29 +108,6 @@
 #define SSL3_FLAGS_ALLOW_UNSAFE_LEGACY_RENEGOTIATION 0x0010
 #endif
 
-/** Structure that we use for a single certificate. */
-struct tor_x509_cert_t {
-  X509 *cert;
-  uint8_t *encoded;
-  size_t encoded_len;
-  unsigned pkey_digests_set : 1;
-  digests_t cert_digests;
-  digests_t pkey_digests;
-};
-
-/** Holds a SSL_CTX object and related state used to configure TLS
- * connections.
- */
-typedef struct tor_tls_context_t {
-  int refcnt;
-  SSL_CTX *ctx;
-  tor_x509_cert_t *my_link_cert;
-  tor_x509_cert_t *my_id_cert;
-  tor_x509_cert_t *my_auth_cert;
-  crypto_pk_t *link_key;
-  crypto_pk_t *auth_key;
-} tor_tls_context_t;
-
 /** Return values for tor_tls_classify_client_ciphers.
  *
  * @{
@@ -154,60 +126,12 @@ typedef struct tor_tls_context_t {
 #define CIPHERS_UNRESTRICTED 3
 /** @} */
 
-#define TOR_TLS_MAGIC 0x71571571
-
-typedef enum {
-    TOR_TLS_ST_HANDSHAKE, TOR_TLS_ST_OPEN, TOR_TLS_ST_GOTCLOSE,
-    TOR_TLS_ST_SENTCLOSE, TOR_TLS_ST_CLOSED, TOR_TLS_ST_RENEGOTIATE,
-    TOR_TLS_ST_BUFFEREVENT
-} tor_tls_state_t;
-#define tor_tls_state_bitfield_t ENUM_BF(tor_tls_state_t)
-
-/** Holds a SSL object and its associated data.  Members are only
- * accessed from within tortls.c.
- */
-struct tor_tls_t {
-  uint32_t magic;
-  tor_tls_context_t *context; /** A link to the context object for this tls. */
-  SSL *ssl; /**< An OpenSSL SSL object. */
-  int socket; /**< The underlying file descriptor for this TLS connection. */
-  char *address; /**< An address to log when describing this connection. */
-  tor_tls_state_bitfield_t state : 3; /**< The current SSL state,
-                                       * depending on which operations
-                                       * have completed successfully. */
-  unsigned int isServer:1; /**< True iff this is a server-side connection */
-  unsigned int wasV2Handshake:1; /**< True iff the original handshake for
-                                  * this connection used the updated version
-                                  * of the connection protocol (client sends
-                                  * different cipher list, server sends only
-                                  * one certificate). */
-  /** True iff we should call negotiated_callback when we're done reading. */
-  unsigned int got_renegotiate:1;
-  /** Return value from tor_tls_classify_client_ciphers, or 0 if we haven't
-   * called that function yet. */
-  int8_t client_cipher_list_type;
-  /** Incremented every time we start the server side of a handshake. */
-  uint8_t server_handshake_count;
-  size_t wantwrite_n; /**< 0 normally, >0 if we returned wantwrite last
-                       * time. */
-  /** Last values retrieved from BIO_number_read()/write(); see
-   * tor_tls_get_n_raw_bytes() for usage.
-   */
-  unsigned long last_write_count;
-  unsigned long last_read_count;
-  /** If set, a callback to invoke whenever the client tries to renegotiate
-   * the handshake. */
-  void (*negotiated_callback)(tor_tls_t *tls, void *arg);
-  /** Argument to pass to negotiated_callback. */
-  void *callback_arg;
-};
-
 /** The ex_data index in which we store a pointer to an SSL object's
  * corresponding tor_tls_t object. */
-static int tor_tls_object_ex_data_index = -1;
+STATIC int tor_tls_object_ex_data_index = -1;
 
 /** Helper: Allocate tor_tls_object_ex_data_index. */
-static void
+STATIC void
 tor_tls_allocate_tor_tls_object_ex_data_index(void)
 {
   if (tor_tls_object_ex_data_index == -1) {
@@ -219,7 +143,7 @@ tor_tls_allocate_tor_tls_object_ex_data_index(void)
 
 /** Helper: given a SSL* pointer, return the tor_tls_t object using that
  * pointer. */
-static INLINE tor_tls_t *
+STATIC inline tor_tls_t *
 tor_tls_get_by_ssl(const SSL *ssl)
 {
   tor_tls_t *result = SSL_get_ex_data(ssl, tor_tls_object_ex_data_index);
@@ -230,21 +154,7 @@ tor_tls_get_by_ssl(const SSL *ssl)
 
 static void tor_tls_context_decref(tor_tls_context_t *ctx);
 static void tor_tls_context_incref(tor_tls_context_t *ctx);
-static X509* tor_tls_create_certificate(crypto_pk_t *rsa,
-                                        crypto_pk_t *rsa_sign,
-                                        const char *cname,
-                                        const char *cname_sign,
-                                        unsigned int cert_lifetime);
-
-static int tor_tls_context_init_one(tor_tls_context_t **ppcontext,
-                                    crypto_pk_t *identity,
-                                    unsigned int key_lifetime,
-                                    unsigned int flags,
-                                    int is_client);
-static tor_tls_context_t *tor_tls_context_new(crypto_pk_t *identity,
-                                              unsigned int key_lifetime,
-                                              unsigned int flags,
-                                              int is_client);
+
 static int check_cert_lifetime_internal(int severity, const X509 *cert,
                                    int past_tolerance, int future_tolerance);
 
@@ -252,8 +162,8 @@ static int check_cert_lifetime_internal(int severity, const X509 *cert,
  * to touch them.
  *
  * @{ */
-static tor_tls_context_t *server_tls_context = NULL;
-static tor_tls_context_t *client_tls_context = NULL;
+STATIC tor_tls_context_t *server_tls_context = NULL;
+STATIC tor_tls_context_t *client_tls_context = NULL;
 /**@}*/
 
 /** True iff tor_tls_init() has been called. */
@@ -347,7 +257,7 @@ tor_tls_log_one_error(tor_tls_t *tls, unsigned long err,
 /** Log all pending tls errors at level <b>severity</b> in log domain
  * <b>domain</b>.  Use <b>doing</b> to describe our current activities.
  */
-static void
+STATIC void
 tls_log_errors(tor_tls_t *tls, int severity, int domain, const char *doing)
 {
   unsigned long err;
@@ -359,7 +269,7 @@ tls_log_errors(tor_tls_t *tls, int severity, int domain, const char *doing)
 
 /** Convert an errno (or a WSAerrno on windows) into a TOR_TLS_* error
  * code. */
-static int
+STATIC int
 tor_errno_to_tls_error(int e)
 {
   switch (e) {
@@ -410,7 +320,7 @@ tor_tls_err_to_string(int err)
  * If an error has occurred, log it at level <b>severity</b> and describe the
  * current action as <b>doing</b>.
  */
-static int
+STATIC int
 tor_tls_get_error(tor_tls_t *tls, int r, int extra,
                   const char *doing, int severity, int domain)
 {
@@ -466,8 +376,9 @@ tor_tls_init(void)
 
 #if (SIZEOF_VOID_P >= 8 &&                              \
      OPENSSL_VERSION_NUMBER >= OPENSSL_V_SERIES(1,0,1))
-    long version = SSLeay();
+    long version = OpenSSL_version_num();
 
+    /* LCOV_EXCL_START : we can't test these lines on the same machine */
     if (version >= OPENSSL_V_SERIES(1,0,1)) {
       /* Warn if we could *almost* be running with much faster ECDH.
          If we're built for a 64-bit target, using OpenSSL 1.0.1, but we
@@ -494,6 +405,7 @@ tor_tls_init(void)
                    "support (using the enable-ec_nistp_64_gcc_128 option "
                    "when configuring it) would make ECDH much faster.");
     }
+    /* LCOV_EXCL_STOP */
 #endif
 
     tor_tls_allocate_tor_tls_object_ex_data_index();
@@ -524,7 +436,7 @@ tor_tls_free_all(void)
  * it: We always accept peer certs and complete the handshake.  We
  * don't validate them until later.
  */
-static int
+STATIC int
 always_accept_verify_cb(int preverify_ok,
                         X509_STORE_CTX *x509_ctx)
 {
@@ -539,16 +451,20 @@ tor_x509_name_new(const char *cname)
 {
   int nid;
   X509_NAME *name;
+  /* LCOV_EXCL_BR_START : these branches will only fail on OOM errors */
   if (!(name = X509_NAME_new()))
     return NULL;
   if ((nid = OBJ_txt2nid("commonName")) == NID_undef) goto error;
   if (!(X509_NAME_add_entry_by_NID(name, nid, MBSTRING_ASC,
                                    (unsigned char*)cname, -1, -1, 0)))
     goto error;
+  /* LCOV_EXCL_BR_STOP */
   return name;
  error:
+  /* LCOV_EXCL_START : these lines will only execute on out of memory errors*/
   X509_NAME_free(name);
   return NULL;
+  /* LCOV_EXCL_STOP */
 }
 
 /** Generate and sign an X509 certificate with the public key <b>rsa</b>,
@@ -559,12 +475,12 @@ tor_x509_name_new(const char *cname)
  *
  * Return a certificate on success, NULL on failure.
  */
-static X509 *
-tor_tls_create_certificate(crypto_pk_t *rsa,
-                           crypto_pk_t *rsa_sign,
-                           const char *cname,
-                           const char *cname_sign,
-                           unsigned int cert_lifetime)
+MOCK_IMPL(STATIC X509 *,
+          tor_tls_create_certificate,(crypto_pk_t *rsa,
+                                      crypto_pk_t *rsa_sign,
+                                      const char *cname,
+                                      const char *cname_sign,
+                                      unsigned int cert_lifetime))
 {
   /* OpenSSL generates self-signed certificates with random 64-bit serial
    * numbers, so let's do that too. */
@@ -601,8 +517,7 @@ tor_tls_create_certificate(crypto_pk_t *rsa,
     goto error;
 
   { /* our serial number is 8 random bytes. */
-    if (crypto_rand((char *)serial_tmp, sizeof(serial_tmp)) < 0)
-      goto error;
+    crypto_rand((char *)serial_tmp, sizeof(serial_tmp));
     if (!(serial_number = BN_bin2bn(serial_tmp, sizeof(serial_tmp), NULL)))
       goto error;
     if (!(BN_to_ASN1_INTEGER(serial_number, X509_get_serialNumber(x509))))
@@ -731,7 +646,9 @@ tor_x509_cert_free(tor_x509_cert_t *cert)
     X509_free(cert->cert);
   tor_free(cert->encoded);
   memwipe(cert, 0x03, sizeof(*cert));
+  /* LCOV_EXCL_BR_START since cert will never be NULL here */
   tor_free(cert);
+  /* LCOV_EXCL_BR_STOP */
 }
 
 /**
@@ -739,8 +656,8 @@ tor_x509_cert_free(tor_x509_cert_t *cert)
  *
  * Steals a reference to x509_cert.
  */
-static tor_x509_cert_t *
-tor_x509_cert_new(X509 *x509_cert)
+MOCK_IMPL(STATIC tor_x509_cert_t *,
+          tor_x509_cert_new,(X509 *x509_cert))
 {
   tor_x509_cert_t *cert;
   EVP_PKEY *pkey;
@@ -754,10 +671,12 @@ tor_x509_cert_new(X509 *x509_cert)
   length = i2d_X509(x509_cert, &buf);
   cert = tor_malloc_zero(sizeof(tor_x509_cert_t));
   if (length <= 0 || buf == NULL) {
+    /* LCOV_EXCL_START for the same reason as the exclusion above */
     tor_free(cert);
     log_err(LD_CRYPTO, "Couldn't get length of encoded x509 certificate");
     X509_free(x509_cert);
     return NULL;
+    /* LCOV_EXCL_STOP */
   }
   cert->encoded_len = (size_t) length;
   cert->encoded = tor_malloc(length);
@@ -864,7 +783,9 @@ tor_tls_context_decref(tor_tls_context_t *ctx)
     tor_x509_cert_free(ctx->my_auth_cert);
     crypto_pk_free(ctx->link_key);
     crypto_pk_free(ctx->auth_key);
+    /* LCOV_EXCL_BR_START since ctx will never be NULL here */
     tor_free(ctx);
+    /* LCOV_EXCL_BR_STOP */
   }
 }
 
@@ -960,11 +881,13 @@ tor_tls_cert_is_valid(int severity,
                       int check_rsa_1024)
 {
   check_no_tls_errors();
-
   EVP_PKEY *cert_key;
-  EVP_PKEY *signing_key = X509_get_pubkey(signing_cert->cert);
   int r, key_ok = 0;
 
+  if (!signing_cert || !cert)
+    goto bad;
+
+  EVP_PKEY *signing_key = X509_get_pubkey(signing_cert->cert);
   if (!signing_key)
     goto bad;
   r = X509_verify(cert->cert, signing_key);
@@ -988,7 +911,7 @@ tor_tls_cert_is_valid(int severity,
   } else if (cert_key) {
     int min_bits = 1024;
 #ifdef EVP_PKEY_EC
-    if (EVP_PKEY_type(cert_key->type) == EVP_PKEY_EC)
+    if (EVP_PKEY_base_id(cert_key) == EVP_PKEY_EC)
       min_bits = 128;
 #endif
     if (EVP_PKEY_bits(cert_key) >= min_bits)
@@ -1085,7 +1008,7 @@ tor_tls_context_init(unsigned flags,
  * it generates new certificates; all new connections will use
  * the new SSL context.
  */
-static int
+STATIC int
 tor_tls_context_init_one(tor_tls_context_t **ppcontext,
                          crypto_pk_t *identity,
                          unsigned int key_lifetime,
@@ -1119,7 +1042,7 @@ tor_tls_context_init_one(tor_tls_context_t **ppcontext,
  * <b>identity</b> should be set to the identity key used to sign the
  * certificate.
  */
-static tor_tls_context_t *
+STATIC tor_tls_context_t *
 tor_tls_context_new(crypto_pk_t *identity, unsigned int key_lifetime,
                     unsigned flags, int is_client)
 {
@@ -1200,23 +1123,6 @@ tor_tls_context_new(crypto_pk_t *identity, unsigned int key_lifetime,
   * historically been chosen for fingerprinting resistance. */
   SSL_CTX_set_options(result->ctx, SSL_OP_CIPHER_SERVER_PREFERENCE);
 
-  /* Disable TLS1.1 and TLS1.2 if they exist.  We need to do this to
-   * workaround a bug present in all OpenSSL 1.0.1 versions (as of 1
-   * June 2012), wherein renegotiating while using one of these TLS
-   * protocols will cause the client to send a TLS 1.0 ServerHello
-   * rather than a ServerHello written with the appropriate protocol
-   * version.  Once some version of OpenSSL does TLS1.1 and TLS1.2
-   * renegotiation properly, we can turn them back on when built with
-   * that version. */
-#if OPENSSL_VERSION_NUMBER < OPENSSL_V(1,0,1,'e')
-#ifdef SSL_OP_NO_TLSv1_2
-  SSL_CTX_set_options(result->ctx, SSL_OP_NO_TLSv1_2);
-#endif
-#ifdef SSL_OP_NO_TLSv1_1
-  SSL_CTX_set_options(result->ctx, SSL_OP_NO_TLSv1_1);
-#endif
-#endif
-
   /* Disable TLS tickets if they're supported.  We never want to use them;
    * using them can make our perfect forward secrecy a little worse, *and*
    * create an opportunity to fingerprint us (since it's unusual to use them
@@ -1343,11 +1249,13 @@ tor_tls_context_new(crypto_pk_t *identity, unsigned int key_lifetime,
 }
 
 /** Invoked when a TLS state changes: log the change at severity 'debug' */
-static void
+STATIC void
 tor_tls_debug_state_callback(const SSL *ssl, int type, int val)
 {
+  /* LCOV_EXCL_START since this depends on whether debug is captured or not */
   log_debug(LD_HANDSHAKE, "SSL %p is now in state %s [type=%d,val=%d].",
             ssl, SSL_state_string_long(ssl), type, val);
+  /* LCOV_EXCL_STOP */
 }
 
 /* Return the name of the negotiated ciphersuite in use on <b>tls</b> */
@@ -1357,13 +1265,11 @@ tor_tls_get_ciphersuite_name(tor_tls_t *tls)
   return SSL_get_cipher(tls->ssl);
 }
 
-#ifdef V2_HANDSHAKE_SERVER
-
 /* Here's the old V2 cipher list we sent from 0.2.1.1-alpha up to
  * 0.2.3.17-beta. If a client is using this list, we can't believe the ciphers
  * that it claims to support.  We'll prune this list to remove the ciphers
  * *we* don't recognize. */
-static uint16_t v2_cipher_list[] = {
+STATIC uint16_t v2_cipher_list[] = {
   0xc00a, /* TLS1_TXT_ECDHE_ECDSA_WITH_AES_256_CBC_SHA */
   0xc014, /* TLS1_TXT_ECDHE_RSA_WITH_AES_256_CBC_SHA */
   0x0039, /* TLS1_TXT_DHE_RSA_WITH_AES_256_SHA */
@@ -1399,11 +1305,12 @@ static int v2_cipher_list_pruned = 0;
 
 /** Return 0 if <b>m</b> does not support the cipher with ID <b>cipher</b>;
  * return 1 if it does support it, or if we have no way to tell. */
-static int
+STATIC int
 find_cipher_by_id(const SSL *ssl, const SSL_METHOD *m, uint16_t cipher)
 {
   const SSL_CIPHER *c;
 #ifdef HAVE_SSL_CIPHER_FIND
+  (void) m;
   {
     unsigned char cipherid[3];
     tor_assert(ssl);
@@ -1416,7 +1323,9 @@ find_cipher_by_id(const SSL *ssl, const SSL_METHOD *m, uint16_t cipher)
       tor_assert((SSL_CIPHER_get_id(c) & 0xffff) == cipher);
     return c != NULL;
   }
-#elif defined(HAVE_STRUCT_SSL_METHOD_ST_GET_CIPHER_BY_CHAR)
+#else
+
+# if defined(HAVE_STRUCT_SSL_METHOD_ST_GET_CIPHER_BY_CHAR)
   if (m && m->get_cipher_by_char) {
     unsigned char cipherid[3];
     set_uint16(cipherid, htons(cipher));
@@ -1427,9 +1336,9 @@ find_cipher_by_id(const SSL *ssl, const SSL_METHOD *m, uint16_t cipher)
     if (c)
       tor_assert((c->id & 0xffff) == cipher);
     return c != NULL;
-  } else
-#endif
-#if OPENSSL_VERSION_NUMBER < OPENSSL_V_SERIES(1,1,0)
+  }
+# endif
+# ifndef OPENSSL_1_1_API
   if (m && m->get_cipher && m->num_ciphers) {
     /* It would seem that some of the "let's-clean-up-openssl" forks have
      * removed the get_cipher_by_char function.  Okay, so now you get a
@@ -1444,11 +1353,12 @@ find_cipher_by_id(const SSL *ssl, const SSL_METHOD *m, uint16_t cipher)
     }
     return 0;
   }
-#endif
+# endif
   (void) ssl;
   (void) m;
   (void) cipher;
   return 1; /* No way to search */
+#endif
 }
 
 /** Remove from v2_cipher_list every cipher that we don't support, so that
@@ -1481,7 +1391,7 @@ prune_v2_cipher_list(const SSL *ssl)
  * client it is.  Return one of CIPHERS_ERR, CIPHERS_V1, CIPHERS_V2,
  * CIPHERS_UNRESTRICTED.
  **/
-static int
+STATIC int
 tor_tls_classify_client_ciphers(const SSL *ssl,
                                 STACK_OF(SSL_CIPHER) *peer_ciphers)
 {
@@ -1504,7 +1414,7 @@ tor_tls_classify_client_ciphers(const SSL *ssl,
   /* Now we need to see if there are any ciphers whose presence means we're
    * dealing with an updated Tor. */
   for (i = 0; i < sk_SSL_CIPHER_num(peer_ciphers); ++i) {
-    SSL_CIPHER *cipher = sk_SSL_CIPHER_value(peer_ciphers, i);
+    const SSL_CIPHER *cipher = sk_SSL_CIPHER_value(peer_ciphers, i);
     const char *ciphername = SSL_CIPHER_get_name(cipher);
     if (strcmp(ciphername, TLS1_TXT_DHE_RSA_WITH_AES_128_SHA) &&
         strcmp(ciphername, TLS1_TXT_DHE_RSA_WITH_AES_256_SHA) &&
@@ -1521,7 +1431,7 @@ tor_tls_classify_client_ciphers(const SSL *ssl,
   {
     const uint16_t *v2_cipher = v2_cipher_list;
     for (i = 0; i < sk_SSL_CIPHER_num(peer_ciphers); ++i) {
-      SSL_CIPHER *cipher = sk_SSL_CIPHER_value(peer_ciphers, i);
+      const SSL_CIPHER *cipher = sk_SSL_CIPHER_value(peer_ciphers, i);
       uint16_t id = SSL_CIPHER_get_id(cipher) & 0xffff;
       if (id == 0x00ff) /* extended renegotiation indicator. */
         continue;
@@ -1543,7 +1453,7 @@ tor_tls_classify_client_ciphers(const SSL *ssl,
     smartlist_t *elts = smartlist_new();
     char *s;
     for (i = 0; i < sk_SSL_CIPHER_num(peer_ciphers); ++i) {
-      SSL_CIPHER *cipher = sk_SSL_CIPHER_value(peer_ciphers, i);
+      const SSL_CIPHER *cipher = sk_SSL_CIPHER_value(peer_ciphers, i);
       const char *ciphername = SSL_CIPHER_get_name(cipher);
       smartlist_add(elts, (char*)ciphername);
     }
@@ -1563,7 +1473,7 @@ tor_tls_classify_client_ciphers(const SSL *ssl,
 /** Return true iff the cipher list suggested by the client for <b>ssl</b> is
  * a list that indicates that the client knows how to do the v2 TLS connection
  * handshake. */
-static int
+STATIC int
 tor_tls_client_is_using_v2_ciphers(const SSL *ssl)
 {
   STACK_OF(SSL_CIPHER) *ciphers;
@@ -1587,11 +1497,10 @@ tor_tls_client_is_using_v2_ciphers(const SSL *ssl)
  *         do not send or request extra certificates in v2 handshakes.</li>
  * <li>To detect renegotiation</li></ul>
  */
-static void
+STATIC void
 tor_tls_server_info_callback(const SSL *ssl, int type, int val)
 {
   tor_tls_t *tls;
-  int ssl_state;
   (void) val;
 
   tor_tls_debug_state_callback(ssl, type, val);
@@ -1599,11 +1508,9 @@ tor_tls_server_info_callback(const SSL *ssl, int type, int val)
   if (type != SSL_CB_ACCEPT_LOOP)
     return;
 
-  ssl_state = SSL_state(ssl);
-  if ((ssl_state != SSL3_ST_SW_SRVR_HELLO_A) &&
-      (ssl_state != SSL3_ST_SW_SRVR_HELLO_B))
+  OSSL_HANDSHAKE_STATE ssl_state = SSL_get_state(ssl);
+  if (! STATE_IS_SW_SERVER_HELLO(ssl_state))
     return;
-
   tls = tor_tls_get_by_ssl(ssl);
   if (tls) {
     /* Check whether we're watching for renegotiates.  If so, this is one! */
@@ -1633,11 +1540,12 @@ tor_tls_server_info_callback(const SSL *ssl, int type, int val)
     if (tls) {
       tls->wasV2Handshake = 1;
     } else {
+      /* LCOV_EXCL_START this line is not reachable */
       log_warn(LD_BUG, "Couldn't look up the tls for an SSL*. How odd!");
+      /* LCOV_EXCL_STOP */
     }
   }
 }
-#endif
 
 /** Callback to get invoked on a server after we've read the list of ciphers
  * the client supports, but before we pick our own ciphersuite.
@@ -1651,10 +1559,11 @@ tor_tls_server_info_callback(const SSL *ssl, int type, int val)
  * authentication on the fly.  But as long as we return 0, we won't actually be
  * setting up a shared secret, and all will be fine.
  */
-static int
+STATIC int
 tor_tls_session_secret_cb(SSL *ssl, void *secret, int *secret_len,
                           STACK_OF(SSL_CIPHER) *peer_ciphers,
-                          SSL_CIPHER **cipher, void *arg)
+                          CONST_IF_OPENSSL_1_1_API SSL_CIPHER **cipher,
+                          void *arg)
 {
   (void) secret;
   (void) secret_len;
@@ -1747,12 +1656,9 @@ tor_tls_new(int sock, int isServer)
     log_warn(LD_NET, "Newly created BIO has read count %lu, write count %lu",
              result->last_read_count, result->last_write_count);
   }
-#ifdef V2_HANDSHAKE_SERVER
   if (isServer) {
     SSL_set_info_callback(result->ssl, tor_tls_server_info_callback);
-  } else
-#endif
-  {
+  } else {
     SSL_set_info_callback(result->ssl, tor_tls_debug_state_callback);
   }
 
@@ -1791,13 +1697,11 @@ tor_tls_set_renegotiate_callback(tor_tls_t *tls,
   tls->negotiated_callback = cb;
   tls->callback_arg = arg;
   tls->got_renegotiate = 0;
-#ifdef V2_HANDSHAKE_SERVER
   if (cb) {
     SSL_set_info_callback(tls->ssl, tor_tls_server_info_callback);
   } else {
     SSL_set_info_callback(tls->ssl, tor_tls_debug_state_callback);
   }
-#endif
 }
 
 /** If this version of openssl requires it, turn on renegotiation on
@@ -1830,8 +1734,13 @@ tor_tls_block_renegotiation(tor_tls_t *tls)
 void
 tor_tls_assert_renegotiation_unblocked(tor_tls_t *tls)
 {
+#if defined(SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION) && \
+  SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION != 0
   long options = SSL_get_options(tls->ssl);
   tor_assert(0 != (options & SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION));
+#else
+  (void) tls;
+#endif
 }
 
 /** Return whether this tls initiated the connect (client) or
@@ -1884,7 +1793,6 @@ tor_tls_read,(tor_tls_t *tls, char *cp, size_t len))
   tor_assert(len<INT_MAX);
   r = SSL_read(tls->ssl, cp, (int)len);
   if (r > 0) {
-#ifdef V2_HANDSHAKE_SERVER
     if (tls->got_renegotiate) {
       /* Renegotiation happened! */
       log_info(LD_NET, "Got a TLS renegotiation from %s", ADDR(tls));
@@ -1892,7 +1800,6 @@ tor_tls_read,(tor_tls_t *tls, char *cp, size_t len))
         tls->negotiated_callback(tls, tls->callback_arg);
       tls->got_renegotiate = 0;
     }
-#endif
     return r;
   }
   err = tor_tls_get_error(tls, r, CATCH_ZERO, "reading", LOG_DEBUG, LD_NET);
@@ -1909,10 +1816,10 @@ tor_tls_read,(tor_tls_t *tls, char *cp, size_t len))
 
 /** Total number of bytes that we've used TLS to send.  Used to track TLS
  * overhead. */
-static uint64_t total_bytes_written_over_tls = 0;
+STATIC uint64_t total_bytes_written_over_tls = 0;
 /** Total number of bytes that TLS has put on the network for us. Used to
  * track TLS overhead. */
-static uint64_t total_bytes_written_by_tls = 0;
+STATIC uint64_t total_bytes_written_by_tls = 0;
 
 /** Underlying function for TLS writing.  Write up to <b>n</b>
  * characters from <b>cp</b> onto <b>tls</b>.  On success, returns the
@@ -1957,12 +1864,14 @@ int
 tor_tls_handshake(tor_tls_t *tls)
 {
   int r;
-  int oldstate;
   tor_assert(tls);
   tor_assert(tls->ssl);
   tor_assert(tls->state == TOR_TLS_ST_HANDSHAKE);
+
   check_no_tls_errors();
-  oldstate = SSL_state(tls->ssl);
+
+  OSSL_HANDSHAKE_STATE oldstate = SSL_get_state(tls->ssl);
+
   if (tls->isServer) {
     log_debug(LD_HANDSHAKE, "About to call SSL_accept on %p (%s)", tls,
               SSL_state_string_long(tls->ssl));
@@ -1972,7 +1881,10 @@ tor_tls_handshake(tor_tls_t *tls)
               SSL_state_string_long(tls->ssl));
     r = SSL_connect(tls->ssl);
   }
-  if (oldstate != SSL_state(tls->ssl))
+
+  OSSL_HANDSHAKE_STATE newstate = SSL_get_state(tls->ssl);
+
+  if (oldstate != newstate)
     log_debug(LD_HANDSHAKE, "After call, %p was in state %s",
               tls, SSL_state_string_long(tls->ssl));
   /* We need to call this here and not earlier, since OpenSSL has a penchant
@@ -2008,7 +1920,6 @@ tor_tls_finish_handshake(tor_tls_t *tls)
     SSL_set_info_callback(tls->ssl, NULL);
     SSL_set_verify(tls->ssl, SSL_VERIFY_PEER, always_accept_verify_cb);
     SSL_clear_mode(tls->ssl, SSL_MODE_NO_AUTO_CHAIN);
-#ifdef V2_HANDSHAKE_SERVER
     if (tor_tls_client_is_using_v2_ciphers(tls->ssl)) {
       /* This check is redundant, but back when we did it in the callback,
        * we might have not been able to look up the tor_tls_t if the code
@@ -2023,26 +1934,10 @@ tor_tls_finish_handshake(tor_tls_t *tls)
     } else {
       tls->wasV2Handshake = 0;
     }
-#endif
   } else {
-#ifdef V2_HANDSHAKE_CLIENT
-    /* If we got no ID cert, we're a v2 handshake. */
-    X509 *cert = SSL_get_peer_certificate(tls->ssl);
-    STACK_OF(X509) *chain = SSL_get_peer_cert_chain(tls->ssl);
-    int n_certs = sk_X509_num(chain);
-    if (n_certs > 1 || (n_certs == 1 && cert != sk_X509_value(chain, 0))) {
-      log_debug(LD_HANDSHAKE, "Server sent back multiple certificates; it "
-                "looks like a v1 handshake on %p", tls);
-      tls->wasV2Handshake = 0;
-    } else {
-      log_debug(LD_HANDSHAKE,
-                "Server sent back a single certificate; looks like "
-                "a v2 handshake on %p.", tls);
-      tls->wasV2Handshake = 1;
-    }
-    if (cert)
-      X509_free(cert);
-#endif
+    /* Client-side */
+    tls->wasV2Handshake = 1;
+    /* XXXX this can move, probably? -NM */
     if (SSL_set_cipher_list(tls->ssl, SERVER_CIPHER_LIST) == 0) {
       tls_log_errors(NULL, LOG_WARN, LD_HANDSHAKE, "re-setting ciphers");
       r = TOR_TLS_ERROR_MISC;
@@ -2052,52 +1947,6 @@ tor_tls_finish_handshake(tor_tls_t *tls)
   return r;
 }
 
-#ifdef USE_BUFFEREVENTS
-/** Put <b>tls</b>, which must be a client connection, into renegotiation
- * mode. */
-int
-tor_tls_start_renegotiating(tor_tls_t *tls)
-{
-  int r = SSL_renegotiate(tls->ssl);
-  if (r <= 0) {
-    return tor_tls_get_error(tls, r, 0, "renegotiating", LOG_WARN,
-                             LD_HANDSHAKE);
-  }
-  return 0;
-}
-#endif
-
-/** Client only: Renegotiate a TLS session.  When finished, returns
- * TOR_TLS_DONE.  On failure, returns TOR_TLS_ERROR, TOR_TLS_WANTREAD, or
- * TOR_TLS_WANTWRITE.
- */
-int
-tor_tls_renegotiate(tor_tls_t *tls)
-{
-  int r;
-  tor_assert(tls);
-  /* We could do server-initiated renegotiation too, but that would be tricky.
-   * Instead of "SSL_renegotiate, then SSL_do_handshake until done" */
-  tor_assert(!tls->isServer);
-
-  check_no_tls_errors();
-  if (tls->state != TOR_TLS_ST_RENEGOTIATE) {
-    int r = SSL_renegotiate(tls->ssl);
-    if (r <= 0) {
-      return tor_tls_get_error(tls, r, 0, "renegotiating", LOG_WARN,
-                               LD_HANDSHAKE);
-    }
-    tls->state = TOR_TLS_ST_RENEGOTIATE;
-  }
-  r = SSL_do_handshake(tls->ssl);
-  if (r == 1) {
-    tls->state = TOR_TLS_ST_OPEN;
-    return TOR_TLS_DONE;
-  } else
-    return tor_tls_get_error(tls, r, 0, "renegotiating handshake", LOG_INFO,
-                             LD_HANDSHAKE);
-}
-
 /** Shut down an open tls connection <b>tls</b>.  When finished, returns
  * TOR_TLS_DONE.  On failure, returns TOR_TLS_ERROR, TOR_TLS_WANTREAD,
  * or TOR_TLS_WANTWRITE.
@@ -2251,15 +2100,14 @@ log_cert_lifetime(int severity, const X509 *cert, const char *problem)
  *
  * Note that a reference is added to cert_out, so it needs to be
  * freed. id_cert_out doesn't. */
-static void
-try_to_extract_certs_from_tls(int severity, tor_tls_t *tls,
-                              X509 **cert_out, X509 **id_cert_out)
+MOCK_IMPL(STATIC void,
+try_to_extract_certs_from_tls,(int severity, tor_tls_t *tls,
+                               X509 **cert_out, X509 **id_cert_out))
 {
   X509 *cert = NULL, *id_cert = NULL;
   STACK_OF(X509) *chain = NULL;
   int num_in_chain, i;
   *cert_out = *id_cert_out = NULL;
-
   if (!(cert = SSL_get_peer_certificate(tls->ssl)))
     return;
   *cert_out = cert;
@@ -2476,114 +2324,7 @@ check_no_tls_errors_(const char *fname, int line)
 int
 tor_tls_used_v1_handshake(tor_tls_t *tls)
 {
-#if defined(V2_HANDSHAKE_SERVER) && defined(V2_HANDSHAKE_CLIENT)
   return ! tls->wasV2Handshake;
-#else
-  if (tls->isServer) {
-# ifdef V2_HANDSHAKE_SERVER
-    return ! tls->wasV2Handshake;
-# endif
-  } else {
-# ifdef V2_HANDSHAKE_CLIENT
-    return ! tls->wasV2Handshake;
-# endif
-  }
-  return 1;
-#endif
-}
-
-/** Return true iff <b>name</b> is a DN of a kind that could only
- * occur in a v3-handshake-indicating certificate */
-static int
-dn_indicates_v3_cert(X509_NAME *name)
-{
-#ifdef DISABLE_V3_LINKPROTO_CLIENTSIDE
-  (void)name;
-  return 0;
-#else
-  X509_NAME_ENTRY *entry;
-  int n_entries;
-  ASN1_OBJECT *obj;
-  ASN1_STRING *str;
-  unsigned char *s;
-  int len, r;
-
-  n_entries = X509_NAME_entry_count(name);
-  if (n_entries != 1)
-    return 1; /* More than one entry in the DN. */
-  entry = X509_NAME_get_entry(name, 0);
-
-  obj = X509_NAME_ENTRY_get_object(entry);
-  if (OBJ_obj2nid(obj) != OBJ_txt2nid("commonName"))
-    return 1; /* The entry isn't a commonName. */
-
-  str = X509_NAME_ENTRY_get_data(entry);
-  len = ASN1_STRING_to_UTF8(&s, str);
-  if (len < 0)
-    return 0;
-  if (len < 4) {
-    OPENSSL_free(s);
-    return 1;
-  }
-  r = fast_memneq(s + len - 4, ".net", 4);
-  OPENSSL_free(s);
-  return r;
-#endif
-}
-
-/** Return true iff the peer certificate we're received on <b>tls</b>
- * indicates that this connection should use the v3 (in-protocol)
- * authentication handshake.
- *
- * Only the connection initiator should use this, and only once the initial
- * handshake is done; the responder detects a v1 handshake by cipher types,
- * and a v3/v2 handshake by Versions cell vs renegotiation.
- */
-int
-tor_tls_received_v3_certificate(tor_tls_t *tls)
-{
-  check_no_tls_errors();
-
-  X509 *cert = SSL_get_peer_certificate(tls->ssl);
-  EVP_PKEY *key = NULL;
-  X509_NAME *issuer_name, *subject_name;
-  int is_v3 = 0;
-
-  if (!cert) {
-    log_warn(LD_BUG, "Called on a connection with no peer certificate");
-    goto done;
-  }
-
-  subject_name = X509_get_subject_name(cert);
-  issuer_name = X509_get_issuer_name(cert);
-
-  if (X509_name_cmp(subject_name, issuer_name) == 0) {
-    is_v3 = 1; /* purportedly self signed */
-    goto done;
-  }
-
-  if (dn_indicates_v3_cert(subject_name) ||
-      dn_indicates_v3_cert(issuer_name)) {
-    is_v3 = 1; /* DN is fancy */
-    goto done;
-  }
-
-  key = X509_get_pubkey(cert);
-  if (EVP_PKEY_bits(key) != 1024 ||
-      EVP_PKEY_type(key->type) != EVP_PKEY_RSA) {
-    is_v3 = 1; /* Key is fancy */
-    goto done;
-  }
-
- done:
-  tls_log_errors(tls, LOG_WARN, LD_NET, "checking for a v3 cert");
-
-  if (key)
-    EVP_PKEY_free(key);
-  if (cert)
-    X509_free(cert);
-
-  return is_v3;
 }
 
 /** Return the number of server handshakes that we've noticed doing on
@@ -2629,7 +2370,7 @@ SSL_get_server_random(SSL *s, uint8_t *out, size_t len)
 #endif
 
 #ifndef HAVE_SSL_SESSION_GET_MASTER_KEY
-static size_t
+STATIC size_t
 SSL_SESSION_get_master_key(SSL_SESSION *s, uint8_t *out, size_t len)
 {
   tor_assert(s);
@@ -2652,7 +2393,6 @@ tor_tls_get_tlssecrets,(tor_tls_t *tls, uint8_t *secrets_out))
 #define TLSSECRET_MAGIC "Tor V3 handshake TLS cross-certification"
   uint8_t buf[128];
   size_t len;
-
   tor_assert(tls);
 
   SSL *const ssl = tls->ssl;
@@ -2676,12 +2416,14 @@ tor_tls_get_tlssecrets,(tor_tls_t *tls, uint8_t *secrets_out))
     size_t r = SSL_get_client_random(ssl, buf, client_random_len);
     tor_assert(r == client_random_len);
   }
+
   {
     size_t r = SSL_get_server_random(ssl,
                                      buf+client_random_len,
                                      server_random_len);
     tor_assert(r == server_random_len);
   }
+
   uint8_t *master_key = tor_malloc_zero(master_key_len);
   {
     size_t r = SSL_SESSION_get_master_key(session, master_key, master_key_len);
diff --git a/src/common/tortls.h b/src/common/tortls.h
index 124b771..7239eb9 100644
--- a/src/common/tortls.h
+++ b/src/common/tortls.h
@@ -12,6 +12,7 @@
  **/
 
 #include "crypto.h"
+#include "compat_openssl.h"
 #include "compat.h"
 #include "testsupport.h"
 
@@ -51,6 +52,120 @@ typedef struct tor_x509_cert_t tor_x509_cert_t;
   case TOR_TLS_ERROR_IO
 
 #define TOR_TLS_IS_ERROR(rv) ((rv) < TOR_TLS_CLOSE)
+
+#ifdef TORTLS_PRIVATE
+#define TOR_TLS_MAGIC 0x71571571
+
+typedef enum {
+    TOR_TLS_ST_HANDSHAKE, TOR_TLS_ST_OPEN, TOR_TLS_ST_GOTCLOSE,
+    TOR_TLS_ST_SENTCLOSE, TOR_TLS_ST_CLOSED, TOR_TLS_ST_RENEGOTIATE,
+    TOR_TLS_ST_BUFFEREVENT
+} tor_tls_state_t;
+#define tor_tls_state_bitfield_t ENUM_BF(tor_tls_state_t)
+
+/** Holds a SSL_CTX object and related state used to configure TLS
+ * connections.
+ */
+typedef struct tor_tls_context_t {
+  int refcnt;
+  SSL_CTX *ctx;
+  tor_x509_cert_t *my_link_cert;
+  tor_x509_cert_t *my_id_cert;
+  tor_x509_cert_t *my_auth_cert;
+  crypto_pk_t *link_key;
+  crypto_pk_t *auth_key;
+} tor_tls_context_t;
+
+/** Structure that we use for a single certificate. */
+struct tor_x509_cert_t {
+  X509 *cert;
+  uint8_t *encoded;
+  size_t encoded_len;
+  unsigned pkey_digests_set : 1;
+  digests_t cert_digests;
+  digests_t pkey_digests;
+};
+
+/** Holds a SSL object and its associated data.  Members are only
+ * accessed from within tortls.c.
+ */
+struct tor_tls_t {
+  uint32_t magic;
+  tor_tls_context_t *context; /** A link to the context object for this tls. */
+  SSL *ssl; /**< An OpenSSL SSL object. */
+  int socket; /**< The underlying file descriptor for this TLS connection. */
+  char *address; /**< An address to log when describing this connection. */
+  tor_tls_state_bitfield_t state : 3; /**< The current SSL state,
+                                       * depending on which operations
+                                       * have completed successfully. */
+  unsigned int isServer:1; /**< True iff this is a server-side connection */
+  unsigned int wasV2Handshake:1; /**< True iff the original handshake for
+                                  * this connection used the updated version
+                                  * of the connection protocol (client sends
+                                  * different cipher list, server sends only
+                                  * one certificate). */
+  /** True iff we should call negotiated_callback when we're done reading. */
+  unsigned int got_renegotiate:1;
+  /** Return value from tor_tls_classify_client_ciphers, or 0 if we haven't
+   * called that function yet. */
+  int8_t client_cipher_list_type;
+  /** Incremented every time we start the server side of a handshake. */
+  uint8_t server_handshake_count;
+  size_t wantwrite_n; /**< 0 normally, >0 if we returned wantwrite last
+                       * time. */
+  /** Last values retrieved from BIO_number_read()/write(); see
+   * tor_tls_get_n_raw_bytes() for usage.
+   */
+  unsigned long last_write_count;
+  unsigned long last_read_count;
+  /** If set, a callback to invoke whenever the client tries to renegotiate
+   * the handshake. */
+  void (*negotiated_callback)(tor_tls_t *tls, void *arg);
+  /** Argument to pass to negotiated_callback. */
+  void *callback_arg;
+};
+
+STATIC int tor_errno_to_tls_error(int e);
+STATIC int tor_tls_get_error(tor_tls_t *tls, int r, int extra,
+                  const char *doing, int severity, int domain);
+STATIC tor_tls_t *tor_tls_get_by_ssl(const SSL *ssl);
+STATIC void tor_tls_allocate_tor_tls_object_ex_data_index(void);
+STATIC int always_accept_verify_cb(int preverify_ok, X509_STORE_CTX *x509_ctx);
+STATIC int tor_tls_classify_client_ciphers(const SSL *ssl,
+                                           STACK_OF(SSL_CIPHER) *peer_ciphers);
+STATIC int tor_tls_client_is_using_v2_ciphers(const SSL *ssl);
+MOCK_DECL(STATIC void, try_to_extract_certs_from_tls,
+          (int severity, tor_tls_t *tls, X509 **cert_out, X509 **id_cert_out));
+#ifndef HAVE_SSL_SESSION_GET_MASTER_KEY
+STATIC size_t SSL_SESSION_get_master_key(SSL_SESSION *s, uint8_t *out,
+                                         size_t len);
+#endif
+STATIC void tor_tls_debug_state_callback(const SSL *ssl, int type, int val);
+STATIC void tor_tls_server_info_callback(const SSL *ssl, int type, int val);
+STATIC int tor_tls_session_secret_cb(SSL *ssl, void *secret,
+                            int *secret_len,
+                            STACK_OF(SSL_CIPHER) *peer_ciphers,
+                            CONST_IF_OPENSSL_1_1_API SSL_CIPHER **cipher,
+                            void *arg);
+STATIC int find_cipher_by_id(const SSL *ssl, const SSL_METHOD *m,
+                             uint16_t cipher);
+MOCK_DECL(STATIC X509*, tor_tls_create_certificate,(crypto_pk_t *rsa,
+                                                    crypto_pk_t *rsa_sign,
+                                                    const char *cname,
+                                                    const char *cname_sign,
+                                                  unsigned int cert_lifetime));
+STATIC tor_tls_context_t *tor_tls_context_new(crypto_pk_t *identity,
+                   unsigned int key_lifetime, unsigned flags, int is_client);
+MOCK_DECL(STATIC tor_x509_cert_t *, tor_x509_cert_new,(X509 *x509_cert));
+STATIC int tor_tls_context_init_one(tor_tls_context_t **ppcontext,
+                                    crypto_pk_t *identity,
+                                    unsigned int key_lifetime,
+                                    unsigned int flags,
+                                    int is_client);
+STATIC void tls_log_errors(tor_tls_t *tls, int severity, int domain,
+                           const char *doing);
+#endif
+
 const char *tor_tls_err_to_string(int err);
 void tor_tls_get_state_description(tor_tls_t *tls, char *buf, size_t sz);
 
@@ -81,7 +196,6 @@ MOCK_DECL(int, tor_tls_read, (tor_tls_t *tls, char *cp, size_t len));
 int tor_tls_write(tor_tls_t *tls, const char *cp, size_t n);
 int tor_tls_handshake(tor_tls_t *tls);
 int tor_tls_finish_handshake(tor_tls_t *tls);
-int tor_tls_renegotiate(tor_tls_t *tls);
 void tor_tls_unblock_renegotiation(tor_tls_t *tls);
 void tor_tls_block_renegotiation(tor_tls_t *tls);
 void tor_tls_assert_renegotiation_unblocked(tor_tls_t *tls);
@@ -99,7 +213,6 @@ int tor_tls_get_buffer_sizes(tor_tls_t *tls,
 MOCK_DECL(double, tls_get_write_overhead_ratio, (void));
 
 int tor_tls_used_v1_handshake(tor_tls_t *tls);
-int tor_tls_received_v3_certificate(tor_tls_t *tls);
 int tor_tls_get_num_server_handshakes(tor_tls_t *tls);
 int tor_tls_server_got_renegotiate(tor_tls_t *tls);
 MOCK_DECL(int,tor_tls_get_tlssecrets,(tor_tls_t *tls, uint8_t *secrets_out));
diff --git a/src/common/util.c b/src/common/util.c
index b33c80f..04f48a4 100644
--- a/src/common/util.c
+++ b/src/common/util.c
@@ -207,7 +207,7 @@ tor_malloc_zero_(size_t size DMALLOC_PARAMS)
 #define SQRT_SIZE_MAX_P1 (((size_t)1) << (sizeof(size_t)*4))
 
 /** Return non-zero if and only if the product of the arguments is exact. */
-static INLINE int
+static inline int
 size_mul_check(const size_t x, const size_t y)
 {
   /* This first check is equivalent to
@@ -488,42 +488,58 @@ round_to_power_of_2(uint64_t u64)
 }
 
 /** Return the lowest x such that x is at least <b>number</b>, and x modulo
- * <b>divisor</b> == 0. */
+ * <b>divisor</b> == 0.  If no such x can be expressed as an unsigned, return
+ * UINT_MAX */
 unsigned
 round_to_next_multiple_of(unsigned number, unsigned divisor)
 {
+  tor_assert(divisor > 0);
+  if (UINT_MAX - divisor + 1 < number)
+    return UINT_MAX;
   number += divisor - 1;
   number -= number % divisor;
   return number;
 }
 
 /** Return the lowest x such that x is at least <b>number</b>, and x modulo
- * <b>divisor</b> == 0. */
+ * <b>divisor</b> == 0. If no such x can be expressed as a uint32_t, return
+ * UINT32_MAX */
 uint32_t
 round_uint32_to_next_multiple_of(uint32_t number, uint32_t divisor)
 {
+  tor_assert(divisor > 0);
+  if (UINT32_MAX - divisor + 1 < number)
+    return UINT32_MAX;
+
   number += divisor - 1;
   number -= number % divisor;
   return number;
 }
 
 /** Return the lowest x such that x is at least <b>number</b>, and x modulo
- * <b>divisor</b> == 0. */
+ * <b>divisor</b> == 0. If no such x can be expressed as a uint64_t, return
+ * UINT64_MAX */
 uint64_t
 round_uint64_to_next_multiple_of(uint64_t number, uint64_t divisor)
 {
+  tor_assert(divisor > 0);
+  if (UINT64_MAX - divisor + 1 < number)
+    return UINT64_MAX;
   number += divisor - 1;
   number -= number % divisor;
   return number;
 }
 
 /** Return the lowest x in [INT64_MIN, INT64_MAX] such that x is at least
- * <b>number</b>, and x modulo <b>divisor</b> == 0. */
+ * <b>number</b>, and x modulo <b>divisor</b> == 0. If no such x can be
+ * expressed as an int64_t, return INT64_MAX */
 int64_t
 round_int64_to_next_multiple_of(int64_t number, int64_t divisor)
 {
   tor_assert(divisor > 0);
-  if (number >= 0 && INT64_MAX - divisor + 1 >= number)
+  if (INT64_MAX - divisor + 1 < number)
+    return INT64_MAX;
+  if (number >= 0)
     number += divisor - 1;
   number -= number % divisor;
   return number;
@@ -537,33 +553,44 @@ int64_t
 sample_laplace_distribution(double mu, double b, double p)
 {
   double result;
-
   tor_assert(p >= 0.0 && p < 1.0);
+
   /* This is the "inverse cumulative distribution function" from:
    * http://en.wikipedia.org/wiki/Laplace_distribution */
-  result =  mu - b * (p > 0.5 ? 1.0 : -1.0)
-                   * tor_mathlog(1.0 - 2.0 * fabs(p - 0.5));
-
-  if (result >= INT64_MAX)
-    return INT64_MAX;
-  else if (result <= INT64_MIN)
+  if (p <= 0.0) {
+    /* Avoid taking log(0.0) == -INFINITY, as some processors or compiler
+     * options can cause the program to trap. */
     return INT64_MIN;
-  else
-    return (int64_t) result;
+  }
+
+  result = mu - b * (p > 0.5 ? 1.0 : -1.0)
+                  * tor_mathlog(1.0 - 2.0 * fabs(p - 0.5));
+
+  return clamp_double_to_int64(result);
 }
 
-/** Add random noise between INT64_MIN and INT64_MAX coming from a
- * Laplace distribution with mu = 0 and b = <b>delta_f</b>/<b>epsilon</b>
- * to <b>signal</b> based on the provided <b>random</b> value in
- * [0.0, 1.0[. */
+/** Add random noise between INT64_MIN and INT64_MAX coming from a Laplace
+ * distribution with mu = 0 and b = <b>delta_f</b>/<b>epsilon</b> to
+ * <b>signal</b> based on the provided <b>random</b> value in [0.0, 1.0[.
+ * The epsilon value must be between ]0.0, 1.0]. delta_f must be greater
+ * than 0. */
 int64_t
 add_laplace_noise(int64_t signal, double random, double delta_f,
                   double epsilon)
 {
-  int64_t noise = sample_laplace_distribution(
-               0.0, /* just add noise, no further signal */
-               delta_f / epsilon, random);
+  int64_t noise;
+
+  /* epsilon MUST be between ]0.0, 1.0] */
+  tor_assert(epsilon > 0.0 && epsilon <= 1.0);
+  /* delta_f MUST be greater than 0. */
+  tor_assert(delta_f > 0.0);
 
+  /* Just add noise, no further signal */
+  noise = sample_laplace_distribution(0.0,
+                                      delta_f / epsilon,
+                                      random);
+
+  /* Clip (signal + noise) to [INT64_MIN, INT64_MAX] */
   if (noise > 0 && INT64_MAX - noise < signal)
     return INT64_MAX;
   else if (noise < 0 && INT64_MIN - noise > signal)
@@ -2116,7 +2143,7 @@ check_private_dir(const char *dirname, cpd_check_t check,
     return -1;
   }
   if ( (check & (CPD_GROUP_OK|CPD_GROUP_READ))
-       && (st.st_gid != running_gid) ) {
+       && (st.st_gid != running_gid) && (st.st_gid != 0)) {
     struct group *gr;
     char *process_groupname = NULL;
     gr = getgrgid(running_gid);
@@ -4424,7 +4451,7 @@ tor_get_exit_code(process_handle_t *process_handle,
 /** Helper: return the number of characters in <b>s</b> preceding the first
  * occurrence of <b>ch</b>. If <b>ch</b> does not occur in <b>s</b>, return
  * the length of <b>s</b>. Should be equivalent to strspn(s, "ch"). */
-static INLINE size_t
+static inline size_t
 str_num_before(const char *s, char ch)
 {
   const char *cp = strchr(s, ch);
@@ -5385,3 +5412,38 @@ tor_weak_random_range(tor_weak_rng_t *rng, int32_t top)
   return result;
 }
 
+/** Cast a given double value to a int64_t. Return 0 if number is NaN.
+ * Returns either INT64_MIN or INT64_MAX if number is outside of the int64_t
+ * range. */
+int64_t
+clamp_double_to_int64(double number)
+{
+  int exp;
+
+  /* NaN is a special case that can't be used with the logic below. */
+  if (isnan(number)) {
+    return 0;
+  }
+
+  /* Time to validate if result can overflows a int64_t value. Fun with
+   * float! Find that exponent exp such that
+   *    number == x * 2^exp
+   * for some x with abs(x) in [0.5, 1.0). Note that this implies that the
+   * magnitude of number is strictly less than 2^exp.
+   *
+   * If number is infinite, the call to frexp is legal but the contents of
+   * exp are unspecified. */
+  frexp(number, &exp);
+
+  /* If the magnitude of number is strictly less than 2^63, the truncated
+   * version of number is guaranteed to be representable. The only
+   * representable integer for which this is not the case is INT64_MIN, but
+   * it is covered by the logic below. */
+  if (isfinite(number) && exp <= 63) {
+    return number;
+  }
+
+  /* Handle infinities and finite numbers with magnitude >= 2^63. */
+  return signbit(number) ? INT64_MIN : INT64_MAX;
+}
+
diff --git a/src/common/util.h b/src/common/util.h
index 8bb4505..165bc0d 100644
--- a/src/common/util.h
+++ b/src/common/util.h
@@ -185,6 +185,7 @@ int64_t sample_laplace_distribution(double mu, double b, double p);
 int64_t add_laplace_noise(int64_t signal, double random, double delta_f,
                           double epsilon);
 int n_bits_set_u8(uint8_t v);
+int64_t clamp_double_to_int64(double number);
 
 /* Compute the CEIL of <b>a</b> divided by <b>b</b>, for nonnegative <b>a</b>
  * and positive <b>b</b>.  Works on integer types only. Not defined if a+b can
diff --git a/src/common/util_format.c b/src/common/util_format.c
index dc544a6..8d99138 100644
--- a/src/common/util_format.c
+++ b/src/common/util_format.c
@@ -465,7 +465,7 @@ base16_encode(char *dest, size_t destlen, const char *src, size_t srclen)
 }
 
 /** Helper: given a hex digit, return its value, or -1 if it isn't hex. */
-static INLINE int
+static inline int
 hex_decode_digit_(char c)
 {
   switch (c) {
diff --git a/src/common/util_process.c b/src/common/util_process.c
index 849a5c0..1e3b02c 100644
--- a/src/common/util_process.c
+++ b/src/common/util_process.c
@@ -45,13 +45,13 @@ struct waitpid_callback_t {
   unsigned running;
 };
 
-static INLINE unsigned int
+static inline unsigned int
 process_map_entry_hash_(const waitpid_callback_t *ent)
 {
   return (unsigned) ent->pid;
 }
 
-static INLINE unsigned int
+static inline unsigned int
 process_map_entries_eq_(const waitpid_callback_t *a,
                         const waitpid_callback_t *b)
 {
diff --git a/src/config/geoip b/src/config/geoip
index 303c573..41070ed 100644
--- a/src/config/geoip
+++ b/src/config/geoip
@@ -1,4 +1,4 @@
-# Last updated based on October 9 2015 Maxmind GeoLite2 Country
+# Last updated based on February 2 2016 Maxmind GeoLite2 Country
 # wget https://geolite.maxmind.com/download/geoip/database/GeoLite2-Country.mmdb.gz
 # gunzip GeoLite2-Country.mmdb.gz
 # python mmdb-convert.py GeoLite2-Country.mmdb
@@ -39,8 +39,7 @@
 18219008,18350079,IN
 18350080,18874367,CN
 18874368,18907135,MY
-18907136,18923519,SG
-18923520,18939903,HK
+18907136,18939903,SG
 18939904,19005439,JP
 19005440,19005440,CN
 19005441,19136511,TW
@@ -222,7 +221,9 @@
 84471808,84473855,IQ
 84475904,84498681,DE
 84498682,84498682,NL
-84498683,84545535,DE
+84498683,84517997,DE
+84517998,84517998,NL
+84517999,84545535,DE
 84545536,84549631,GB
 84549632,84551679,GE
 84551680,84557823,DE
@@ -266,6 +267,7 @@
 85387264,85389311,SE
 85389312,85391359,DE
 85391360,85393407,NL
+85394432,85394439,IT
 85395456,85395711,TR
 85395968,85396223,BE
 85396480,85397503,ES
@@ -648,8 +650,7 @@
 87568384,87570431,GB
 87570432,87572479,ES
 87572480,87588863,MD
-87588864,87589887,IR
-87589888,87590143,GB
+87588864,87590143,IR
 87590144,87590399,US
 87590400,87590911,GB
 87590912,87592959,RU
@@ -722,9 +723,21 @@
 87949312,87965695,GB
 87965696,87967743,DE
 87967744,87969791,IT
-87969792,87973887,IM
-87973888,87982079,DE
-87982080,88014847,RU
+87969792,87972863,IM
+87972864,87973375,GI
+87973376,87973887,IM
+87973888,87981567,DE
+87981568,87982079,TR
+87982080,87988479,RU
+87988480,87988735,US
+87988736,87988863,LV
+87988864,87988991,LT
+87988992,87989247,RU
+87989248,87989503,US
+87989504,87989759,FR
+87989760,87990015,US
+87990016,87990271,DE
+87990272,88014847,RU
 88014848,88016895,LY
 88016896,88018943,IR
 88018944,88020991,GB
@@ -742,7 +755,9 @@
 88061952,88063999,PL
 88064000,88080383,HU
 88080384,88604671,GB
-88604672,88866815,RU
+88604672,88670207,RU
+88670208,88670208,IR
+88670209,88866815,RU
 88866816,88932351,KZ
 88932352,88940543,RU
 88940544,88948735,GB
@@ -836,6 +851,7 @@
 90718208,90718719,DE
 90718720,90719231,FR
 90719232,90719487,AT
+90719488,90719999,SE
 90720000,90720255,GB
 90720256,90722303,IQ
 90722304,90724351,FI
@@ -855,7 +871,9 @@
 90757120,90759167,AT
 90759168,90761215,NL
 90761216,90763263,KZ
-90763264,90764287,IL
+90763264,90763519,IL
+90763520,90763775,US
+90763776,90764287,IL
 90764288,90764799,US
 90764800,90765311,IL
 90765312,90767359,PL
@@ -1008,7 +1026,9 @@
 92739200,92739215,DE
 92739216,92740447,FR
 92740448,92740455,IT
-92740456,92740915,FR
+92740456,92740611,FR
+92740612,92740615,CZ
+92740616,92740915,FR
 92740916,92740923,DE
 92740924,92741203,FR
 92741204,92741207,IT
@@ -1079,7 +1099,9 @@
 92760324,92760327,DE
 92760328,92761215,FR
 92761216,92761343,DE
-92761344,92762127,FR
+92761344,92761390,FR
+92761391,92761391,FI
+92761392,92762127,FR
 92762128,92762135,ES
 92762136,92762383,FR
 92762384,92762391,ES
@@ -1319,7 +1341,10 @@
 95389184,95389695,DE
 95389696,95389951,GB
 95389952,95390207,US
-95390208,95393023,DE
+95390208,95391231,DE
+95391232,95391487,AE
+95391488,95391999,RU
+95392000,95393023,DE
 95393024,95393151,GB
 95393152,95393279,RS
 95393280,95393407,GB
@@ -1335,7 +1360,10 @@
 95395584,95395839,GB
 95395840,95398399,DE
 95398400,95398655,GB
-95398656,95399695,DE
+95398656,95398911,US
+95398912,95399423,DE
+95399424,95399679,US
+95399680,95399695,DE
 95399696,95399807,US
 95399808,95399951,DE
 95399952,95400063,CA
@@ -1369,7 +1397,8 @@
 95403264,95403391,US
 95403392,95403519,DE
 95403520,95403775,GB
-95403776,95404799,DE
+95403776,95404031,US
+95404032,95404799,DE
 95404800,95405055,GB
 95405056,95405311,DE
 95405312,95405439,US
@@ -1380,9 +1409,16 @@
 95406336,95407103,GB
 95407104,95407359,DE
 95407360,95407871,US
-95407872,95408639,DE
+95407872,95407999,DE
+95408000,95408127,US
+95408128,95408255,DE
+95408256,95408383,US
+95408384,95408511,DE
+95408512,95408639,US
 95408640,95409151,GB
-95409152,95410175,DE
+95409152,95409279,DE
+95409280,95409407,US
+95409408,95410175,DE
 95410176,95410431,US
 95410432,95410447,CH
 95410448,95410559,DE
@@ -1592,7 +1628,9 @@
 96779520,96779523,NL
 96779524,96779839,FR
 96779840,96779903,NL
-96779904,96782199,FR
+96779904,96780355,FR
+96780356,96780359,BE
+96780360,96782199,FR
 96782200,96782207,CZ
 96782208,96782911,FR
 96782912,96782915,LT
@@ -1680,7 +1718,8 @@
 98738176,98740223,NO
 98740224,98740479,ES
 98740480,98740735,US
-98740736,98741503,DE
+98740736,98741247,DE
+98741248,98741503,ES
 98741504,98741759,US
 98741760,98742271,DE
 98742272,98744319,GB
@@ -1700,7 +1739,9 @@
 98992432,98992639,US
 98992640,98993151,DE
 98993152,98993175,US
-98993176,98997759,DE
+98993176,98993407,DE
+98993408,98993663,GB
+98993664,98997759,DE
 98997760,98998271,FR
 98998272,98998527,DE
 98998528,98998783,GB
@@ -1714,7 +1755,11 @@
 99025920,99025935,FI
 99025936,99026047,DE
 99026048,99026175,US
-99026176,99026943,DE
+99026176,99026303,DE
+99026304,99026431,US
+99026432,99026559,DE
+99026560,99026687,US
+99026688,99026943,DE
 99026944,99027199,GB
 99027200,99027215,HR
 99027216,99027455,CA
@@ -1725,14 +1770,19 @@
 99028096,99028223,US
 99028224,99028239,GB
 99028240,99028351,DE
-99028352,99028479,US
-99028480,99028735,DE
+99028352,99028735,US
 99028736,99028751,SE
 99028752,99028863,DE
 99028864,99028991,US
 99028992,99029503,GB
 99029504,99029519,IE
-99029520,99030783,DE
+99029520,99029887,DE
+99029888,99030015,US
+99030016,99030143,DE
+99030144,99030271,US
+99030272,99030399,DE
+99030400,99030527,US
+99030528,99030783,DE
 99030784,99030895,US
 99030896,99030911,DE
 99030912,99031039,US
@@ -1743,7 +1793,11 @@
 99031808,99031823,GB
 99031824,99031935,DE
 99031936,99032063,US
-99032064,99043839,DE
+99032064,99032319,DE
+99032320,99032575,ES
+99032576,99033343,DE
+99033344,99033599,IT
+99033600,99043839,DE
 99043840,99043847,AT
 99043848,99044111,DE
 99044112,99044223,US
@@ -1758,7 +1812,9 @@
 99049472,99049983,GB
 99049984,99053055,DE
 99053056,99053567,GB
-99053568,99090431,DE
+99053568,99085567,DE
+99085568,99085823,GB
+99085824,99090431,DE
 99090432,99614719,IR
 99614720,99876863,SE
 99876864,100139007,SA
@@ -1788,7 +1844,9 @@
 100532224,100548863,RO
 100548864,100548875,TR
 100548876,100548876,RO
-100548877,100549119,TR
+100548877,100549038,TR
+100549039,100549039,RO
+100549040,100549119,TR
 100549120,100559255,RO
 100559256,100559263,EG
 100559264,100559551,RO
@@ -1845,7 +1903,9 @@
 135441408,135441663,CA
 135441664,135556607,US
 135556608,135556863,CA
-135556864,135603199,US
+135556864,135558399,US
+135558400,135558655,NL
+135558656,135603199,US
 135603200,135604223,CA
 135604224,135604479,US
 135604480,135604735,CA
@@ -1861,7 +1921,9 @@
 135926272,135926783,VI
 135926784,135945727,US
 135945728,135945983,CA
-135945984,136175615,US
+135945984,136054015,US
+136054016,136054271,GB
+136054272,136175615,US
 136175616,136175871,CA
 136175872,136237055,US
 136237056,136239103,CA
@@ -1918,7 +1980,40 @@
 219249920,219250175,GB
 219250176,219512063,US
 219512064,219512319,GB
-219512320,234881023,US
+219512320,222494719,US
+222494720,222527487,SG
+222527488,222625791,US
+222625792,222658559,NL
+222658560,222691327,IE
+222691328,222707711,HK
+222707712,222740479,AU
+222740480,222756863,IE
+222756864,222789631,IN
+222789632,222806015,JP
+222806016,222871551,US
+222871552,222879743,HK
+222879744,222887935,AU
+222887936,222896127,JP
+222896128,222912511,US
+222912512,222920703,AU
+222920704,222937087,NL
+222937088,222941183,AU
+222941184,222953471,US
+222953472,223019007,IE
+223019008,223051775,HK
+223051776,223084543,AU
+223084544,223150079,SG
+223150080,223166463,AU
+223166464,223215615,US
+223215616,223248383,JP
+223248384,223281151,US
+223281152,223346687,IE
+223346688,223477759,NL
+223477760,223805439,US
+223805440,223838207,GB
+223838208,224198655,US
+224198656,224264191,NL
+224264192,234881023,US
 234881024,234883071,CN
 234883072,234884095,JP
 234884096,234885119,CN
@@ -1939,7 +2034,15 @@
 234947584,234950655,JP
 234950656,234951679,AU
 234951680,234952703,HK
+234952704,234953727,CN
+234953728,234954751,SG
 234954752,234971135,NZ
+234971136,234972159,CN
+234972160,234973183,BD
+234973184,234974207,PK
+234974208,234975231,CN
+234975232,234976255,SG
+234976256,234979327,IN
 234979328,235012095,MY
 235012096,235077631,AU
 235077632,235143167,JP
@@ -1959,6 +2062,14 @@
 241602560,241604607,MY
 241604608,241605631,ID
 241605632,241606655,CN
+241606656,241607679,IN
+241607680,241608703,JP
+241608704,241609727,PH
+241609728,241610751,PK
+241610752,241611775,JP
+241611776,241612799,CN
+241612800,241613823,HK
+241613824,241614847,IN
 241614848,241623039,JP
 241623040,241627135,IN
 241627136,241631231,HK
@@ -1981,13 +2092,19 @@
 243990528,244318207,IN
 244318208,245366783,CN
 245366784,247463935,VN
+247463936,247464959,IN
+247464960,247465983,CN
+247465984,247467007,HK
+247467008,247469055,IN
+247469056,247470079,HK
+247470080,247472127,IN
 247472128,247476223,JP
 247479296,247480319,CN
 247480320,247482367,MY
 247482368,247483391,PG
 247483392,247484415,CN
 247484416,247488511,KR
-247488512,247496703,JP
+247488512,247496703,HK
 247496704,247504895,PK
 247504896,247508991,AU
 247508992,247513087,US
@@ -2051,14 +2168,20 @@
 288198144,288198655,CL
 288198656,288199679,US
 288199680,288200703,CO
-288200704,288212991,US
+288200704,288205422,US
+288205423,288205423,CO
+288205424,288205424,BR
+288205425,288205425,MX
+288205426,288205426,CL
+288205427,288212991,US
 288212992,288215039,CA
 288215040,288223231,US
 288223232,288227327,CA
 288227328,289652735,US
 289652736,289653759,NL
 289653760,289654271,DE
-289654272,289655807,US
+289654272,289654783,US
+289654784,289655807,CZ
 289655808,289656831,DE
 289656832,289657855,BE
 289657856,289658879,AE
@@ -2068,12 +2191,14 @@
 289665024,289667071,US
 289667072,289669119,GB
 289669120,289783807,US
-289783808,289783935,GB
-289783936,289791999,US
+289783808,289787903,GB
+289787904,289791999,US
 289792000,289794047,AE
-289794048,289796095,US
+289794048,289795071,US
+289795072,289796095,GB
 289796096,289798143,TR
-289798144,289948927,US
+289798144,289800191,SA
+289800192,289948927,US
 289948928,289949055,AT
 289949056,289949183,US
 289949184,289949695,RU
@@ -2139,7 +2264,16 @@
 290377728,290379775,GB
 290379776,290423807,US
 290423808,290424831,SE
-290424832,344195839,US
+290424832,300646399,US
+300646400,300650495,JP
+300650496,300654591,SG
+300654592,300658687,US
+300658688,300662783,AU
+300662784,300666879,GB
+300666880,300670975,NL
+300670976,300675071,IE
+300675072,300679167,IL
+300679168,344195839,US
 344195840,344196095,CA
 344196096,344260607,US
 344260608,344260863,GB
@@ -2579,11 +2713,21 @@
 391938048,391946239,CA
 391946240,391961711,US
 391961712,391961719,RO
-391961720,392257535,US
-392257536,392261631,BR
-392261632,392390538,US
-392390539,392390539,HK
-392390540,392429567,US
+391961720,392245247,US
+392245248,392249343,SG
+392249344,392257535,HK
+392257536,392265727,BR
+392265728,392298495,NL
+392298496,392306687,US
+392306688,392310015,HK
+392310016,392310271,US
+392310272,392310527,NL
+392310528,392312831,US
+392312832,392314879,JP
+392314880,392331263,SG
+392331264,392388607,US
+392388608,392396799,HK
+392396800,392429567,US
 392429568,392433663,NL
 392433664,392441855,US
 392441856,392445951,IE
@@ -2600,7 +2744,9 @@
 392515584,392523775,JP
 392523776,392548351,US
 392548352,392556543,AU
-392556544,392659871,US
+392556544,392579345,US
+392579346,392579346,JP
+392579347,392659871,US
 392659872,392659903,NL
 392659904,392765439,US
 392765440,392765695,GB
@@ -2608,7 +2754,12 @@
 394264576,394264831,CA
 394270720,394271231,NL
 394296320,394296831,NL
-396361728,396361983,US
+394526720,394526975,US
+394788864,394789119,US
+395051008,395051263,CA
+395313152,397410303,US
+397410304,397410559,CA
+397934592,397934847,US
 398458880,398500351,US
 398500352,398500863,NL
 398500864,398617599,US
@@ -2759,7 +2910,13 @@
 400911616,400911871,CR
 400911872,400912127,US
 400912128,400912383,SG
-400912384,401129727,US
+400912384,401114367,US
+401114368,401114623,DE
+401114624,401115903,US
+401115904,401116159,GB
+401116160,401125119,US
+401125120,401125375,DE
+401125376,401129727,US
 401129728,401129983,FR
 401129984,401130495,US
 401130496,401130751,DE
@@ -2776,7 +2933,7 @@
 401144576,401144831,MA
 401144832,401145087,OM
 401145088,401145343,CO
-401145344,401145599,SC
+401145344,401145599,GB
 401145600,401145855,YE
 401145856,401211391,CA
 401211392,401232375,US
@@ -2803,7 +2960,9 @@
 402098176,402098431,BN
 402098432,402098687,BH
 402098688,402098943,AW
-402098944,402105087,US
+402098944,402099711,US
+402099712,402099967,GB
+402099968,402105087,US
 402105088,402105343,GB
 402105344,402107391,US
 402107392,402107647,IT
@@ -3035,6 +3194,9 @@
 452997120,453001215,IN
 453001216,453009407,AU
 453009408,453017599,BD
+453017600,453019647,CN
+453019648,453023743,IN
+453023744,453024767,TW
 453050368,453115903,KR
 453115904,453246975,VN
 453246976,453509119,IN
@@ -3044,7 +3206,11 @@
 455215360,455215615,RU
 455215616,455245823,NP
 455245824,455258111,JP
-455258112,455262207,SG
+455258112,455258623,SG
+455258624,455258688,KH
+455258689,455260672,SG
+455260673,455260736,KH
+455260737,455262207,SG
 455262208,455270399,JP
 455270400,455272447,AU
 455272448,455274495,CN
@@ -3067,9 +3233,11 @@
 456542208,456544255,CN
 456544256,456548351,AU
 456548352,456553471,JP
+456553472,456554495,ID
 456554496,456555519,PK
 456555520,456556543,JP
 456556544,456560639,AU
+456560640,456562687,BD
 456562688,456564735,CN
 456564736,456572927,IN
 456572928,456589311,CN
@@ -3081,7 +3249,7 @@
 459284480,459292671,JP
 459292672,459293695,NZ
 459293696,459297791,JP
-459297792,459298815,IN
+459297792,459299839,IN
 459299840,459300863,PK
 459300864,459309055,SG
 459309056,459325439,KR
@@ -3099,7 +3267,9 @@
 459542528,459543295,HK
 459543296,459543551,TW
 459543552,459544575,HK
+459544576,459545599,IN
 459545600,459547647,JP
+459547648,459548671,AU
 459548672,459550719,TH
 459550720,459554815,JP
 459554816,459571199,TW
@@ -3124,6 +3294,7 @@
 460155904,460156927,AU
 460156928,460158975,KH
 460158976,460159999,JP
+460160000,460161023,CN
 460161024,460193791,MO
 460193792,460210175,JP
 460210176,460214271,HK
@@ -3140,6 +3311,7 @@
 460263424,460267519,NP
 460267520,460275711,ID
 460275712,460277759,AU
+460277760,460278783,IN
 460278784,460279807,JP
 460279808,460283903,AU
 460283904,460292095,KR
@@ -3154,6 +3326,8 @@
 460345344,460349439,CN
 460349440,460351487,AU
 460351488,460353535,JP
+460353536,460355583,CN
+460355584,460356607,IN
 460356608,460357631,JP
 460357632,460423167,KR
 460423168,460439551,CN
@@ -3172,6 +3346,7 @@
 460595200,460595711,SG
 460595712,460596223,JP
 460596224,460597247,AU
+460597248,460598271,IN
 460598272,460599295,CN
 460599296,460601343,IN
 460601344,460602367,AF
@@ -3199,8 +3374,9 @@
 460983296,460984319,HK
 460984320,460988415,PG
 460988416,460994559,JP
-460994560,460995327,MY
-460995328,460995583,SG
+460994560,460995071,MY
+460995072,460995583,SG
+460995584,460996607,IN
 460996608,461008895,JP
 461008896,461012991,AU
 461012992,461045759,KR
@@ -3214,7 +3390,9 @@
 461058048,461062143,HK
 461062144,461078527,IN
 461078528,461094911,FJ
-461094912,461096959,HK
+461094912,461095423,HK
+461095424,461095935,SG
+461095936,461096959,HK
 461096960,461099007,TW
 461099008,461100031,JP
 461100032,461101055,MN
@@ -3307,7 +3485,25 @@
 520339456,520343551,UA
 520343552,520355839,GB
 520355840,520421375,ES
-520421376,520486911,BE
+520421376,520422222,BE
+520422223,520422223,RO
+520422224,520423935,BE
+520423936,520424191,RO
+520424192,520425983,BE
+520425984,520426239,RO
+520426240,520427007,BE
+520427008,520427263,RO
+520427264,520428799,BE
+520428800,520429055,RO
+520429056,520429567,BE
+520429568,520429823,RO
+520429824,520431103,BE
+520431104,520431359,RO
+520431360,520432895,BE
+520432896,520433151,RO
+520433152,520433663,BE
+520433664,520433919,RO
+520433920,520486911,BE
 520486912,520488959,NL
 520488960,520489983,IT
 520489984,520490495,RU
@@ -3318,7 +3514,8 @@
 520491392,520491647,IT
 520491648,520491775,IS
 520491776,520492031,IE
-520492032,520493055,GB
+520492032,520492799,IT
+520492800,520493055,GB
 520493056,520493311,BE
 520493312,520493567,GB
 520493568,520493695,DE
@@ -3412,7 +3609,7 @@
 520978432,520980479,RU
 520980480,520982527,IT
 520982528,520984575,RU
-520984576,520986623,NG
+520984576,520986623,GB
 520986624,520988671,PS
 520988672,520990719,DE
 520990720,520992767,RU
@@ -3440,7 +3637,9 @@
 521037568,521037823,TH
 521037824,521039871,RO
 521039872,521043967,IR
-521043968,521048063,RO
+521043968,521045286,RO
+521045287,521045287,IT
+521045288,521048063,RO
 521048064,521052159,IR
 521052160,521056255,RO
 521056256,521057279,LT
@@ -3486,8 +3685,7 @@
 521563136,521564159,NL
 521564160,521565183,GR
 521565184,521565439,GB
-521565440,521565695,US
-521565696,521566207,GR
+521565440,521566207,GR
 521566208,521568255,LU
 521568256,521601023,PT
 521601024,521666559,RU
@@ -3523,7 +3721,9 @@
 521717760,521718783,IQ
 521718784,521719807,IR
 521719808,521721855,UA
-521721856,521725951,GB
+521721856,521724159,GB
+521724160,521724415,AU
+521724416,521725951,GB
 521725952,521727999,IR
 521728000,521732095,FR
 521732096,521736191,GB
@@ -3592,7 +3792,8 @@
 522719232,522721279,UA
 522721280,522741759,RU
 522741760,522743807,UA
-522743808,522764287,RU
+522743808,522747903,RU
+522747904,522764287,UA
 522780672,522782719,RU
 522782720,522784767,UA
 522784768,522786815,BG
@@ -3619,7 +3820,9 @@
 522840064,522842111,PL
 522842112,522846207,RU
 522846208,522854399,PL
-522854400,522858495,RU
+522854400,522858438,RU
+522858439,522858439,MD
+522858440,522858495,RU
 522858496,522866687,UA
 522866688,522870783,LV
 522870784,522874879,RU
@@ -3796,10 +3999,8 @@
 529827840,529828863,CZ
 529828864,529829887,RU
 529829888,529830911,CZ
-529830912,529839103,RU
-529839104,529840127,CZ
-529840128,529841151,RU
-529841152,529842175,UA
+529830912,529838079,RU
+529838080,529842175,UA
 529842176,529843199,IN
 529843200,529844223,RU
 529844224,529845247,CZ
@@ -3969,8 +4170,7 @@
 532185088,532201471,IR
 532201472,532209663,RU
 532209664,532210687,DE
-532210688,532211711,RU
-532211712,532212223,LU
+532210688,532212223,RU
 532212224,532212479,ME
 532212480,532212735,NL
 532212736,532213759,RU
@@ -4125,7 +4325,9 @@
 533682176,533684223,ES
 533684224,533692415,IT
 533692416,533725183,RU
-533725184,533807103,SE
+533725184,533734393,SE
+533734394,533734394,DK
+533734395,533807103,SE
 533807104,533811199,LT
 533811200,533815295,DE
 533815296,533815296,TR
@@ -4146,7 +4348,9 @@
 533858752,533858815,AT
 533858816,533858895,TR
 533858896,533858903,AT
-533858904,533859647,TR
+533858904,533859071,TR
+533859072,533859087,AT
+533859088,533859647,TR
 533859648,533859663,AT
 533859664,533860351,TR
 533862400,533864447,GB
@@ -4173,7 +4377,9 @@
 533970944,533987327,SE
 533987328,534118399,DE
 534118400,534151167,KW
-534151168,534163455,DE
+534151168,534158591,DE
+534158592,534158847,NL
+534158848,534163455,DE
 534163456,534167551,ES
 534167552,534181887,DE
 534181888,534183935,IR
@@ -4315,7 +4521,9 @@
 540733440,540737535,NL
 540737536,540737757,BZ
 540737758,540737758,BR
-540737759,540803071,BZ
+540737759,540783936,BZ
+540783937,540783937,BR
+540783938,540803071,BZ
 540803072,540811263,US
 540811264,540814084,SG
 540814085,540814086,TH
@@ -4444,7 +4652,9 @@
 621330432,621346815,PL
 621346816,621355007,RU
 621355008,621357055,UA
-621357056,621361151,RU
+621357056,621358079,RU
+621358080,621358591,US
+621358592,621361151,RU
 621361152,621363199,GB
 621363200,621381631,RU
 621381632,621383679,FR
@@ -4467,7 +4677,8 @@
 621410304,621412351,IR
 621412352,621428735,NL
 621428736,621429759,IR
-621429760,621430783,DE
+621429760,621430527,DE
+621430528,621430783,GB
 621430784,621432831,ES
 621432832,621436927,IT
 621436928,621445119,DE
@@ -4557,7 +4768,9 @@
 622518272,622518527,GB
 622518528,622519281,NL
 622519282,622519282,GB
-622519283,622520319,NL
+622519283,622519351,NL
+622519352,622519359,FR
+622519360,622520319,NL
 622520320,622522367,RU
 622522368,622524415,FR
 622524416,622526463,ES
@@ -4732,7 +4945,9 @@
 624653312,624653823,GB
 624653824,624656975,FR
 624656976,624656979,PT
-624656980,624657607,FR
+624656980,624657543,FR
+624657544,624657547,ES
+624657548,624657607,FR
 624657608,624657615,BE
 624657616,624657711,FR
 624657712,624657715,ES
@@ -4760,7 +4975,9 @@
 624661788,624661788,RO
 624661789,624661955,FR
 624661956,624661959,PL
-624661960,624663951,FR
+624661960,624663863,FR
+624663864,624663867,DE
+624663868,624663951,FR
 624663952,624663955,ES
 624663956,624664527,FR
 624664528,624664531,ES
@@ -4886,7 +5103,9 @@
 624686668,624686671,ES
 624686672,624686711,FR
 624686712,624686715,ES
-624686716,624687343,FR
+624686716,624686783,FR
+624686784,624686815,ES
+624686816,624687343,FR
 624687344,624687346,CZ
 624687347,624687347,ES
 624687348,624687827,FR
@@ -4929,7 +5148,13 @@
 624738304,624740351,NL
 624740352,624742399,DE
 624742400,624746495,RU
-624746496,624754687,US
+624746496,624748182,US
+624748183,624748183,NL
+624748184,624750236,US
+624750237,624750237,NL
+624750238,624750241,US
+624750242,624750242,NL
+624750243,624754687,US
 624754688,624787455,AZ
 624787456,624791551,DE
 624791552,624795647,ES
@@ -5269,7 +5494,7 @@
 630999680,631001087,RO
 631001088,631005183,MD
 631005184,631006207,IT
-631006208,631007231,MD
+631006208,631007231,IR
 631007232,631007487,KR
 631007488,631007743,RO
 631007744,631007871,GB
@@ -5293,7 +5518,8 @@
 631036160,631036415,RO
 631036416,631036543,GB
 631036544,631039999,RO
-631040000,631043071,MD
+631040000,631042047,IR
+631042048,631043071,MD
 631043072,631043839,RO
 631043840,631045119,MD
 631045120,631046143,RO
@@ -5516,7 +5742,9 @@
 635856896,635858943,TR
 635858944,635860991,RU
 635860992,635863039,BE
-635863040,635893503,RU
+635863040,635864831,RU
+635864832,635865087,NL
+635865088,635893503,RU
 635893504,635893759,AZ
 635893760,635894527,RU
 635894528,635894783,KZ
@@ -5655,7 +5883,9 @@
 641776640,641777407,CA
 641777408,641777663,US
 641777664,641777919,CA
-641777920,641828351,US
+641777920,641779199,US
+641779200,641779327,CA
+641779328,641828351,US
 641828352,641828607,MX
 641828608,641829057,US
 641829058,641829058,MX
@@ -5739,7 +5969,9 @@
 644084480,644084735,GU
 644084736,644236031,US
 644236032,644236287,CA
-644236288,644247551,US
+644236288,644239615,US
+644239616,644239871,CA
+644239872,644247551,US
 644247552,644247807,CA
 644247808,644248831,US
 644248832,644249087,CA
@@ -5849,7 +6081,9 @@
 645225472,645225727,CA
 645225728,645229311,US
 645229312,645229823,CA
-645229824,645483263,US
+645229824,645481405,US
+645481406,645481406,CA
+645481407,645483263,US
 645483264,645483519,CA
 645483520,645484543,US
 645484544,645485055,CA
@@ -5919,16 +6153,79 @@
 662700032,666894335,CN
 666894336,671088639,ID
 671088640,675807231,US
-675807232,675938303,SG
-675938304,679313407,US
-679313408,679346175,SG
-679346176,679362559,US
-679362560,679378943,SG
-679378944,679453668,US
-679453669,679453669,IE
-679453670,679455449,US
-679455450,679455450,IE
-679455451,687865855,US
+675807232,675938303,CN
+675938304,675954687,NL
+675954688,675975167,JP
+675975168,675979263,IE
+675979264,676177756,US
+676177757,676177757,RE
+676177758,676249599,US
+676249600,676265983,AU
+676265984,676298751,US
+676298752,676331519,IE
+676331520,676347903,NL
+676347904,676368383,JP
+676368384,676462591,US
+676462592,676528127,NL
+676528128,676544511,US
+676544512,676560895,HK
+676560896,676659199,US
+676659200,676696063,IE
+676696064,676708351,US
+676708352,676724735,CA
+676724736,676773887,US
+676773888,676790271,CA
+676790272,676823039,US
+676823040,676831231,IE
+676831232,676840447,US
+676840448,676841471,SG
+676841472,678428671,US
+678428672,678436863,IE
+678436864,678437887,US
+678437888,678438015,IE
+678438016,678438207,NL
+678438208,678438271,IE
+678438272,678438399,AU
+678438400,678438591,US
+678438592,678438655,NL
+678438656,678438783,IN
+678438784,678445055,US
+678445056,678453247,IE
+678453248,678461439,NL
+678461440,678494207,US
+678494208,678518783,IE
+678518784,678543359,NL
+678543360,678592511,US
+678592512,678623193,NL
+678623194,678623194,US
+678623195,678625279,NL
+678625280,678633471,IE
+678633472,678641663,NL
+678641664,678649855,AU
+678649856,678658047,IE
+678658048,678690815,JP
+678690816,678756351,US
+678756352,678764543,IE
+678764544,678821887,US
+678821888,678854655,NL
+678854656,678887423,US
+678887424,678952959,NL
+678952960,679018495,IE
+679018496,679182335,US
+679182336,679215103,AU
+679215104,679313407,US
+679313408,679346175,CN
+679346176,679362559,JP
+679362560,679378943,CN
+679378944,679395327,KR
+679395328,679403519,IN
+679403520,679411711,AU
+679411712,679428095,SG
+679428096,679436287,AU
+679436288,679440383,IE
+679440384,679444479,US
+679444480,679477247,IE
+679477248,687865855,US
 687865856,689963007,ZA
 689963008,691011583,EG
 691011584,691617791,ZA
@@ -6568,6 +6865,7 @@
 702447616,702449663,EG
 702449664,702451711,ZA
 702451712,702453759,NG
+702453760,702455807,ZA
 702455808,702457855,KE
 702457856,702459903,EG
 702459904,702461951,TZ
@@ -6668,7 +6966,9 @@
 703759360,703760383,ZA
 703760384,703761407,GH
 703761408,703762431,RW
-703762432,703764479,ZA
+703762432,703764095,MU
+703764096,703764223,ZA
+703764224,703764479,MU
 703764480,703766527,LY
 703766528,703770623,ZA
 703770624,703774719,BJ
@@ -6809,7 +7109,9 @@
 736175104,736176127,MY
 736176128,736177151,BN
 736177152,736178175,HK
-736178176,736179199,AU
+736178176,736178431,AU
+736178432,736178432,NZ
+736178433,736179199,AU
 736179200,736180223,IN
 736180224,736181247,HK
 736181248,736182271,AU
@@ -6975,7 +7277,11 @@
 736494592,736495103,ID
 736495104,736495359,NR
 736495360,736495615,ID
-736495616,736498687,HK
+736495616,736495871,HK
+736495872,736496127,KR
+736496128,736496383,JP
+736496384,736496639,PH
+736496640,736498687,HK
 736498688,736499711,CN
 736499712,736500479,SG
 736500480,736500735,TH
@@ -7062,7 +7368,10 @@
 737100800,737101823,IN
 737101824,737102847,BD
 737102848,737104895,IN
-737104896,737106943,HK
+737104896,737105919,HK
+737105920,737106175,IN
+737106176,737106431,HK
+737106432,737106943,IN
 737106944,737108991,NZ
 737108992,737110015,SG
 737110016,737111039,JP
@@ -7085,7 +7394,8 @@
 737142784,737143039,HK
 737143040,737143807,MY
 737143808,737146879,IN
-737146880,737147903,NZ
+737146880,737147519,US
+737147520,737147903,NZ
 737147904,737148927,MY
 737148928,737149951,CN
 737149952,737151999,IN
@@ -7123,7 +7433,9 @@
 737209344,737220607,CN
 737220608,737222655,IN
 737222656,737223679,TW
-737223680,737225727,IN
+737223680,737224703,IN
+737224704,737224959,MY
+737224960,737225727,IN
 737225728,737225983,KR
 737225984,737226751,HK
 737226752,737227775,CN
@@ -7145,13 +7457,12 @@
 737257472,737262591,CN
 737262592,737263615,AU
 737263616,737264639,IN
-737264640,737265663,CN
+737264640,737265663,HK
 737265664,737266687,AU
 737266688,737267711,HK
 737267712,737276927,CN
 737276928,737277951,IN
 737277952,737279999,CN
-737280000,737281023,HK
 737281024,737282047,SG
 737282048,737288191,CN
 737288192,737289215,HK
@@ -7181,7 +7492,7 @@
 737337344,737339391,IN
 737339392,737341439,HK
 737341440,737342463,MN
-737342464,737344511,IN
+737342464,737343487,IN
 737344512,737345535,CN
 737345536,737346559,AU
 737346560,737350655,CN
@@ -7190,7 +7501,9 @@
 737351680,737352703,CN
 737352704,737354751,HK
 737354752,737355775,IN
-737355776,737359871,HK
+737355776,737356287,HK
+737356288,737356799,GB
+737356800,737359871,HK
 737359872,737361919,NZ
 737361920,737364991,HK
 737364992,737368063,IN
@@ -7202,6 +7515,7 @@
 737376256,737377279,HK
 737377280,737378303,PH
 737378304,737379327,CN
+737379328,737380351,BD
 737380352,737381375,CN
 737381376,737382399,ID
 737382400,737384447,CN
@@ -7268,9 +7582,7 @@
 737514496,737515519,IN
 737515520,737516543,AU
 737516544,737517567,IN
-737517568,737517823,AU
-737517824,737518079,NZ
-737518080,737520639,AU
+737517568,737520639,AU
 737520640,737521663,NZ
 737521664,737522687,AU
 737522688,737525759,ID
@@ -7339,8 +7651,7 @@
 737635328,737637375,CN
 737637376,737638399,AU
 737638400,737639423,PK
-737639424,737640447,NZ
-737640448,737641471,AU
+737639424,737641471,AU
 737641472,737642495,HK
 737642496,737645567,IN
 737645568,737647615,CN
@@ -7358,10 +7669,9 @@
 737679360,737680383,ID
 737680384,737681407,CN
 737681408,737683455,IN
-737683456,737685503,JP
+737683456,737684479,JP
 737685504,737686527,CN
 737686528,737687551,AU
-737687552,737688575,CN
 737688576,737690623,HK
 737690624,737692671,IN
 737692672,737712127,CN
@@ -7395,7 +7705,6 @@
 737758208,737760255,HK
 737760256,737761279,IN
 737761280,737762303,HK
-737762304,737763327,AU
 737763328,737765375,HK
 737765376,737768447,TH
 737768448,737769471,AU
@@ -7457,7 +7766,7 @@
 737846272,737847295,IN
 737847296,737850367,CN
 737850368,737851391,IN
-737851392,737853439,HK
+737851392,737852415,HK
 737853440,737854463,SG
 737854464,737855487,JP
 737855488,737856511,CN
@@ -7473,7 +7782,8 @@
 737866752,737867775,CN
 737867776,737868799,AU
 737868800,737870847,IN
-737870848,737874431,CN
+737870848,737873919,CN
+737873920,737874431,HK
 737874432,737874943,IN
 737874944,737876991,HK
 737876992,737878015,KR
@@ -7513,7 +7823,6 @@
 737918976,737919999,CN
 737920000,737921023,HK
 737921024,737922047,AU
-737922048,737923071,KR
 737923072,737924095,MY
 737924096,737927167,IN
 737927168,737929215,HK
@@ -7587,7 +7896,7 @@
 738078720,738079743,IN
 738079744,738080767,CN
 738080768,738081791,TL
-738081792,738082815,WS
+738081792,738082815,TW
 738082816,738083839,CN
 738083840,738084863,ID
 738084864,738085887,CN
@@ -7675,11 +7984,19 @@
 755105792,755179519,CA
 755179520,755236863,US
 756023296,757071871,US
-757071872,757088255,NL
+757071872,757073919,NL
+757073920,757073920,JP
+757073921,757088255,NL
 757088256,757090303,US
 757090304,757104639,NL
 757104640,757106687,US
-757106688,757125631,NL
+757106688,757118796,NL
+757118797,757118797,GB
+757118798,757121535,NL
+757121536,757121791,US
+757121792,757122047,NL
+757122048,757122303,US
+757122304,757125631,NL
 757125632,757126655,US
 757126656,757133311,NL
 757133312,757135359,AU
@@ -7848,7 +8165,11 @@
 758796288,758804479,CA
 758804480,758824959,US
 758824960,758841343,CA
-758841344,758874367,US
+758841344,758847487,US
+758847488,758847743,NL
+758847744,758847999,US
+758848000,758848255,CA
+758848256,758874367,US
 758874368,758874623,AM
 758874624,758875391,US
 758875392,758875647,AO
@@ -7962,8 +8283,7 @@
 759193856,759194111,SG
 759194112,759195647,ID
 759195648,759196671,IN
-759196672,759197695,HK
-759197696,759198207,CN
+759196672,759198207,HK
 759198208,759198719,IN
 759198720,759199743,NZ
 759199744,759200767,PH
@@ -7992,7 +8312,7 @@
 759234560,759235583,SG
 759235584,759236607,NZ
 759236608,759237631,IN
-759237632,759238655,NZ
+759237632,759238655,AU
 759693312,759726079,US
 759726080,759791615,CA
 759791616,759824639,US
@@ -8048,14 +8368,13 @@
 760119296,760127487,US
 760127488,760152063,CA
 760152064,760217599,US
-761266176,761790463,EG
+761266176,762314751,EG
 762314752,762315775,IN
 762316800,762320895,IN
 762320896,762321919,HK
 762321920,762323967,IN
 762323968,762324991,SG
 762324992,762330111,IN
-762330112,762331135,JP
 762331136,762332159,TH
 762332160,762333183,IN
 762333184,762334207,BD
@@ -8063,7 +8382,6 @@
 762335744,762336255,PH
 762336256,762337279,ID
 762337280,762345471,KR
-762345472,762346495,JP
 762346496,762347519,ID
 762347520,762348543,JP
 762348544,762349567,CN
@@ -8100,7 +8418,8 @@
 762397696,762398719,HK
 762398720,762399743,CN
 762399744,762400767,IN
-762400768,762401791,HK
+762400768,762401023,HK
+762401024,762401791,US
 762401792,762402815,TH
 762402816,762403839,IN
 762403840,762404863,AU
@@ -8108,17 +8427,17 @@
 762407936,762408959,CN
 762408960,762409983,HK
 762409984,762411007,JP
-762411008,762412031,IN
+762411008,762411519,HK
+762411520,762411775,IN
+762411776,762412031,HK
 762412032,762413055,PK
 762413056,762414079,HK
-762414080,762415103,JP
 762415104,762416127,IN
 762416128,762417151,HK
 762417152,762419199,CN
 762419200,762420223,IN
 762420224,762421247,TW
 762421248,762422271,HK
-762422272,762423295,JP
 762423296,762424319,CN
 762424320,762425343,JP
 762425344,762426367,CN
@@ -8154,10 +8473,11 @@
 762470400,762471423,CN
 762471424,762472447,MY
 762472448,762473471,CN
-762473472,762475519,JP
+762474496,762475519,JP
 762475520,762475775,AU
-762475776,762476031,HK
-762476032,762476543,ID
+762475776,762476031,SG
+762476032,762476287,ID
+762476288,762476543,SG
 762476544,762478591,PK
 762478592,762479615,KR
 762479616,762480639,PK
@@ -8382,7 +8702,6 @@
 762848512,762848767,IN
 762848768,762849279,BD
 762849280,762850303,IN
-762850304,762851327,JP
 762851328,762852351,IN
 762852352,762853375,HK
 762853376,762855423,IN
@@ -8407,7 +8726,7 @@
 762877952,762879231,HK
 762879232,762879487,JP
 762879488,762879743,HK
-762879744,762879999,CN
+762879744,762879999,JP
 762880000,762881023,IN
 762881024,762882047,CN
 762882048,762883071,HK
@@ -8416,7 +8735,10 @@
 762885120,762887167,HK
 762887168,762888191,IN
 762888192,762890239,JP
-762890240,762891263,AU
+762890240,762890495,KR
+762890496,762890751,TW
+762890752,762891007,HK
+762891008,762891263,MY
 762891264,762893311,HK
 762893312,762894335,IN
 762894336,762895359,HK
@@ -8426,7 +8748,7 @@
 762900480,762901503,CN
 762901504,762902527,ID
 762902528,762909695,IN
-762909696,762910719,CN
+762909696,762910719,HK
 762910720,762911743,VN
 762911744,762912767,IN
 762912768,762913791,HK
@@ -8490,7 +8812,8 @@
 763061248,763062271,MY
 763062272,763063295,AU
 763063296,763064319,IN
-763064320,763066367,HK
+763064320,763065343,HK
+763065344,763066367,TR
 763066368,763067391,CN
 763067392,763068415,MY
 763068416,763071487,CN
@@ -8581,7 +8904,8 @@
 763227136,763228159,VN
 763228160,763229183,JP
 763229184,763229695,NZ
-763229696,763230207,IN
+763229696,763229951,IN
+763229952,763230207,AU
 763230208,763231231,PH
 763231232,763232255,IN
 763232256,763234303,HK
@@ -8629,7 +8953,9 @@
 763290624,763291647,HK
 763291648,763293695,IN
 763293696,763294719,HK
-763294720,763297791,IN
+763294720,763297023,IN
+763297024,763297279,AF
+763297280,763297791,IN
 763297792,763298815,HK
 763298816,763299839,MY
 763299840,763301887,CN
@@ -8643,7 +8969,7 @@
 763321344,763322367,HK
 763322368,763323391,CN
 763323392,763326463,IN
-763326464,763327487,HK
+763326464,763327487,US
 763327488,763328511,CN
 763328512,763329535,IN
 763329536,763331583,CN
@@ -8688,7 +9014,11 @@
 772286720,772286975,LB
 772286976,772296703,RU
 772296704,772300799,UA
-772300800,772341759,RU
+772300800,772339967,RU
+772339968,772340223,NL
+772340224,772341247,RU
+772341248,772341503,US
+772341504,772341759,RU
 772341760,772407295,NO
 772407296,772472831,BG
 772472832,772538367,MT
@@ -8840,7 +9170,15 @@
 773111808,773115903,TJ
 773115904,773119999,PS
 773120000,773124095,GB
-773124096,773132287,DE
+773124096,773125247,CH
+773125248,773125375,GB
+773125376,773125503,CH
+773125504,773125567,GB
+773125568,773125855,CH
+773125856,773125887,RU
+773125888,773126143,FR
+773126144,773128191,CH
+773128192,773132287,DE
 773132288,773134335,IT
 773134336,773135359,CH
 773135360,773136383,IT
@@ -8877,7 +9215,7 @@
 773211136,773211391,FR
 773211392,773211647,US
 773211648,773211903,NL
-773211904,773212159,US
+773211904,773212159,SG
 773212160,773212671,NL
 773212672,773213183,GB
 773213184,773214207,US
@@ -9055,7 +9393,9 @@
 773935353,773935353,US
 773935354,773935728,FR
 773935729,773935729,GB
-773935730,773937663,FR
+773935730,773936145,FR
+773936146,773936146,US
+773936147,773937663,FR
 773937664,773937664,DE
 773937665,773937673,FR
 773937674,773937674,IE
@@ -9279,7 +9619,7 @@
 774864896,774881279,CZ
 774881280,774963199,RU
 774963200,774995967,GE
-774995968,775028735,RO
+774995968,775028735,SA
 775028736,775061503,PT
 775061504,775094271,RU
 775094272,775127039,RO
@@ -9326,8 +9666,8 @@
 778304306,778304306,SI
 778304307,778305535,AL
 778305536,778371071,IR
-778371072,778403839,GB
-778403840,778436607,DE
+778371072,778395647,GB
+778395648,778436607,DE
 778436608,778461183,RO
 778461184,778461439,TR
 778461440,778462207,EE
@@ -9362,7 +9702,9 @@
 778567680,778633215,TR
 778633216,778640127,FR
 778640128,778640383,GB
-778640384,778666259,FR
+778640384,778657399,FR
+778657400,778657403,PT
+778657404,778666259,FR
 778666260,778666263,ES
 778666264,778666479,FR
 778666480,778666495,DE
@@ -9446,7 +9788,9 @@
 778691620,778691623,IT
 778691624,778691711,FR
 778691712,778691727,GB
-778691728,778692499,FR
+778691728,778692143,FR
+778692144,778692159,DE
+778692160,778692499,FR
 778692500,778692503,ES
 778692504,778692519,FR
 778692520,778692527,NL
@@ -9822,7 +10166,9 @@
 785383424,785448959,GB
 785448960,785514495,IR
 785514496,785580031,IL
-785580032,785645567,UA
+785580032,785609020,UA
+785609021,785609021,US
+785609022,785645567,UA
 785645568,785711103,NO
 785711104,785776639,SY
 785776640,785842175,RO
@@ -10015,7 +10361,7 @@
 787087360,787095551,TR
 787095680,787095711,CH
 787096576,787097855,CH
-787098112,787098623,CH
+787098112,787098879,CH
 787099392,787100671,CH
 787101696,787102719,CH
 787103744,787111935,HR
@@ -10047,7 +10393,9 @@
 787192064,787192319,FR
 787192384,787192447,DE
 787192576,787192831,SE
+787192832,787193087,AE
 787193088,787193343,FI
+787193344,787193599,DE
 787193856,787195903,RU
 787195904,787197951,GB
 787197952,787199999,FR
@@ -10124,7 +10472,8 @@
 787750912,787755007,GB
 787755008,787759103,NL
 787759104,787767295,PS
-787767296,787771135,NL
+787767296,787768319,IT
+787768320,787771135,NL
 787771136,787771391,IT
 787771392,787775487,NL
 787775488,787808255,DE
@@ -10294,13 +10643,18 @@
 792723456,793247743,DE
 793247744,793313279,NZ
 793313280,793378815,DE
-793378816,794558463,CA
+793378816,794367999,CA
+794368000,794369023,HK
+794369024,794558463,CA
 794558464,796917759,CN
 796917760,797873663,CA
 797873664,797873919,US
-797873920,805306367,CA
+797873920,802160639,CA
+802160640,803209215,US
+803209216,805306367,CA
 805306368,822083583,US
 822083584,822084607,ID
+822084608,822085631,BD
 822085632,822087679,AU
 822087680,822089727,JP
 822089728,822090751,ID
@@ -10336,13 +10690,12 @@
 830406656,830472191,AU
 830472192,830472447,CN
 830472448,830472703,AU
-830472704,830473215,CN
+830472704,830474239,CN
 830474240,830475263,SG
 830475264,830476287,AU
 830476288,830480383,JP
 830480384,830488575,SG
-830488576,830492671,HK
-830492672,830496767,TW
+830488576,830496767,HK
 830496768,830498815,JP
 830498816,830499839,GU
 830499840,830500863,IN
@@ -10369,8 +10722,10 @@
 831519744,831520767,IN
 831520768,832045055,PH
 832045056,832307199,CN
-832307200,832311295,JP
+832307200,832308223,PK
+832308224,832311295,JP
 832311296,832312319,AU
+832312320,832313343,ID
 832313344,832315391,AU
 832315392,832319487,KH
 832319488,832320511,NU
@@ -10431,9 +10786,12 @@
 839112192,839112447,CA
 839112448,839340031,US
 839340032,839341055,ES
-839341056,839342079,US
+839341056,839341311,US
+839341312,839341567,DE
+839341568,839342079,US
 839342080,839343103,DE
-839343104,839348223,US
+839343104,839344127,NL
+839344128,839348223,US
 839348224,839348479,DE
 839348480,839348735,AT
 839348736,839348991,GB
@@ -10441,8 +10799,7 @@
 839349248,839350271,DE
 839350272,839351295,NL
 839351296,839352063,DE
-839352064,839352319,US
-839352320,839357439,NL
+839352064,839357439,NL
 839357440,839358463,FR
 839358464,839359487,GB
 839359488,839360511,DE
@@ -10485,12 +10842,16 @@
 846561280,846594047,CA
 846594048,846626815,US
 846626816,846627071,CN
-846627072,848915455,US
+846627072,846644755,US
+846644756,846644756,PT
+846644757,848915455,US
 848915456,848916479,CA
 848916480,850506751,US
 850506752,850507263,CA
 850507264,855638015,US
-855638016,860905167,GB
+855638016,858230746,GB
+858230747,858230747,SA
+858230748,860905167,GB
 860905168,860905171,FR
 860905172,867041279,GB
 867041280,867172351,NO
@@ -10510,36 +10871,116 @@
 872288872,872288875,DE
 872288876,872290111,FR
 872290112,872290143,ES
-872290144,872300031,FR
+872290144,872291151,FR
+872291152,872291167,FI
+872291168,872300031,FR
 872300032,872300063,ES
-872300064,872306183,FR
+872300064,872300649,FR
+872300650,872300650,PT
+872300651,872306183,FR
 872306184,872306191,GB
-872306192,872316797,FR
+872306192,872309883,FR
+872309884,872309884,PT
+872309885,872316797,FR
 872316798,872316798,PT
-872316799,872415231,FR
+872316799,872326151,FR
+872326152,872326155,CZ
+872326156,872326176,FR
+872326177,872326179,PT
+872326180,872327807,FR
+872327808,872327811,FI
+872327812,872327815,IE
+872327816,872327831,FR
+872327832,872327835,IT
+872327836,872330279,FR
+872330280,872330283,GB
+872330284,872342335,FR
+872342336,872342367,ES
+872342368,872344603,FR
+872344604,872344607,GB
+872344608,872346978,FR
+872346979,872346979,DE
+872346980,872357423,FR
+872357424,872357427,PT
+872357428,872357429,FR
+872357430,872357433,PT
+872357434,872364863,FR
+872364864,872364927,NL
+872364928,872374608,FR
+872374609,872374618,ES
+872374619,872375295,FR
+872375296,872375423,NL
+872375424,872377297,FR
+872377298,872377299,ES
+872377300,872380607,FR
+872380608,872380671,ES
+872380672,872384095,FR
+872384096,872384127,ES
+872384128,872388415,FR
+872388416,872388447,ES
+872388448,872403606,FR
+872403607,872403607,PT
+872403608,872415231,FR
 872415232,873463807,US
-873463808,873725951,IE
+873463808,873646466,IE
+873646467,873646467,US
+873646468,873725951,IE
 873725952,874250239,US
 874250240,874381311,DE
 874381312,874512383,IE
-874512384,876609535,US
-876609536,876675071,AU
-876675072,876871679,US
+874512384,875560959,US
+875560960,875823103,IE
+875823104,876216319,US
+876216320,876347391,DE
+876347392,876478463,US
+876478464,876740607,AU
+876740608,876806143,US
+876806144,876871679,BR
 876871680,877002751,JP
 877002752,877264895,US
 877264896,877330431,SG
 877330432,877395967,US
-877395968,877428735,SG
-877428736,878454527,US
+877395968,877527039,SG
+877527040,877592575,US
+877592576,877658111,KR
+877658112,877920255,CN
+877920256,878444543,US
+878444544,878448639,KR
+878448640,878454527,US
 878454528,878454783,BR
-878454784,878649855,US
+878454784,878456831,IE
+878456832,878457855,US
+878457856,878458879,AU
+878458880,878459903,SG
+878459904,878460927,JP
+878460928,878461951,BR
+878461952,878462975,DE
+878462976,878463999,BR
+878464000,878512127,US
+878512128,878513151,SG
+878513152,878576895,US
+878576896,878577151,IE
+878577152,878577407,KR
+878577408,878577663,BR
+878577664,878577919,JP
+878577920,878578431,US
+878578432,878578687,SG
+878578688,878578943,US
+878578944,878579199,AU
+878579200,878648831,US
+878648832,878649343,JP
+878649344,878649855,US
 878649856,878650111,JP
 878650112,878650367,SG
 878650368,878651391,AU
 878651392,878655487,US
 878655488,878656511,JP
 878656512,878657023,IE
-878657024,878702591,US
+878657024,878690303,US
+878690304,878694399,KR
+878694400,878695423,US
+878695424,878696447,SG
+878696448,878702591,US
 878702592,878702847,BR
 878702848,878703103,AU
 878703104,878703359,SG
@@ -10548,7 +10989,9 @@
 878703872,878704639,US
 878704640,878704895,DE
 878704896,878705151,CN
-878705152,878706431,US
+878705152,878705663,US
+878705664,878705919,KR
+878705920,878706431,US
 878706432,878706447,BR
 878706448,878706463,AU
 878706464,878706479,SG
@@ -10557,7 +11000,15 @@
 878706512,878706559,US
 878706560,878706575,DE
 878706576,878706591,CN
-878706592,889192447,US
+878706592,884998143,US
+884998144,885129215,JP
+885129216,885260287,US
+885260288,885522431,JP
+885522432,886046719,US
+886046720,886571007,IE
+886571008,886833151,US
+886833152,886964223,SG
+886964224,889192447,US
 889192448,905969663,DE
 905969664,910163967,US
 910163968,910197237,JP
@@ -10579,9 +11030,7 @@
 915898368,915931135,SG
 915931136,916029439,US
 916029440,916062207,AU
-916062208,916156392,IE
-916156393,916156393,GB
-916156394,916191009,IE
+916062208,916191009,IE
 916191010,916191010,GB
 916191011,916193279,IE
 916193280,916979711,US
@@ -10614,8 +11063,8 @@
 921165824,921167871,JP
 921167872,921169919,US
 921169920,921170943,SG
-921170944,921172991,US
-921172992,921173247,AU
+921170944,921171967,US
+921171968,921173247,AU
 921173248,921173503,BR
 921173504,921174015,US
 921174016,921305087,BR
@@ -10634,7 +11083,9 @@
 921658112,921658879,IE
 921658880,921661951,US
 921661952,921662207,IE
-921662208,921747455,US
+921662208,921662463,US
+921662464,921665535,KR
+921665536,921747455,US
 921747456,921748479,AU
 921748480,921748735,US
 921748736,921748991,IE
@@ -10649,7 +11100,8 @@
 921755904,921756159,JP
 921756160,921756671,SG
 921756672,921758719,US
-921758720,921759999,DE
+921758720,921759743,KR
+921759744,921759999,DE
 921760000,921760767,US
 921760768,921761791,BR
 921761792,922091519,US
@@ -10692,7 +11144,9 @@
 960671744,960676607,DE
 960676608,960676863,PL
 960676864,960692223,DE
-960692224,960724991,FR
+960692224,960699940,FR
+960699941,960699941,IT
+960699942,960724991,FR
 960724992,960726783,NL
 960726784,960727039,ZA
 960727040,960727295,US
@@ -10805,11 +11259,18 @@
 961716224,961720319,CF
 961720320,961724415,TD
 961724416,961740799,ZA
-961740800,961806335,BE
+961740800,961781759,BE
+961781760,961785855,LS
+961785856,961806335,BE
 961806336,961810431,MR
-961810432,961826815,BE
+961810432,961818623,BE
+961818624,961822719,MZ
+961822720,961826815,NA
 961826816,961830911,NE
-961830912,961892351,BE
+961830912,961835007,NG
+961835008,961867775,BE
+961867776,961871871,TZ
+961871872,961892351,BE
 961892352,961896447,ZW
 961896448,961900543,NG
 961900544,961937407,BE
@@ -10819,7 +11280,9 @@
 961950720,961953791,FI
 961953792,961961983,DK
 961961984,961970175,NO
-961970176,962002943,BE
+961970176,961971455,SE
+961971456,961971711,BE
+961971712,962002943,SE
 962002944,962035711,RU
 962035712,962039807,EE
 962039808,962043903,LV
@@ -10830,7 +11293,9 @@
 962084864,962088959,GE
 962088960,962097151,BE
 962097152,962101247,IL
-962101248,962134015,BE
+962101248,962117631,BE
+962117632,962121727,QA
+962121728,962134015,BE
 962134016,962138111,AE
 962138112,962203647,BE
 962203648,962207999,AT
@@ -10852,11 +11317,11 @@
 962281472,962285567,DO
 962285568,962359295,BE
 962359296,962363391,IN
-962363392,962364416,BE
-962364417,962364417,ID
-962364418,962392063,BE
+962363392,962367487,ID
+962367488,962392063,BE
 962392064,962396159,PK
-962396160,962408447,BE
+962396160,962400255,PH
+962400256,962408447,BE
 962408448,962412543,TH
 962412544,962416639,UZ
 962416640,962461695,BE
@@ -10929,11 +11394,15 @@
 978588672,978590719,IN
 978590720,978591743,PK
 978591744,978592767,BD
-978592768,978593791,NZ
+978592768,978593023,US
+978593024,978593279,NZ
+978593280,978593535,AU
+978593536,978593791,AE
 978593792,978594815,MY
 978594816,978595839,KR
 978595840,978596863,NZ
 978596864,978597887,HK
+978597888,978599935,IN
 978599936,978640895,AU
 978640896,978644991,NZ
 978644992,978714623,JP
@@ -11025,9 +11494,62 @@
 999784448,999800831,JP
 999800832,999817215,KR
 999817216,999821311,BD
+999821312,999827455,CN
+999827456,999828479,IN
+999828480,999828735,HK
+999828736,999828991,PH
+999828992,999829503,MY
+999829504,999830527,HK
+999830528,999832575,IN
+999832576,999833599,BD
+999833600,999837695,CN
+999837696,999838719,IN
 999839744,999845887,BD
+999845888,999847935,CN
+999847936,999848959,IN
+999848960,999849983,HK
 999849984,999866367,KR
 999866368,999882751,HK
+999882752,999883775,IN
+999883776,999884799,CN
+999884800,999885823,AU
+999885824,999886847,IN
+999886848,999887871,BD
+999887872,999888895,NZ
+999888896,999889407,ID
+999889408,999889919,MY
+999889920,999890943,BD
+999890944,999891967,CN
+999891968,999892991,IN
+999892992,999895039,JP
+999895040,999898111,HK
+999898112,999902207,CN
+999902208,999903231,SG
+999903232,999904255,ID
+999904256,999905279,MN
+999905280,999906303,MM
+999906304,999907327,CN
+999907328,999908351,IN
+999908352,999909375,BD
+999909376,999910399,SG
+999910400,999911423,MM
+999911424,999912447,MN
+999912448,999913471,CN
+999913472,999914495,IN
+999914496,999915519,AF
+999915520,999916543,ID
+999916544,999917567,TL
+999917568,999918591,CN
+999918592,999919615,JP
+999919616,999921663,HK
+999921664,999923711,CN
+999923712,999924735,HK
+999924736,999932927,CN
+999932928,999933951,HK
+999933952,999934975,BD
+999934976,999935999,JP
+999936000,999937023,TH
+999937024,999948287,VN
 999948288,1000013823,AU
 1000013824,1000079359,CN
 1000079360,1000341503,JP
@@ -11127,7 +11649,9 @@
 1024262144,1024327679,SG
 1024327680,1024327935,US
 1024327936,1024327943,AU
-1024327944,1024344063,US
+1024327944,1024339967,US
+1024339968,1024340991,ZA
+1024340992,1024344063,US
 1024344064,1024352255,SG
 1024352256,1024360447,AU
 1024360448,1024361167,JP
@@ -11148,7 +11672,15 @@
 1024375552,1024375807,AU
 1024375808,1024376831,JP
 1024376832,1024378879,PH
-1024393216,1024458751,HK
+1024378880,1024380927,IN
+1024380928,1024381951,KR
+1024381952,1024385023,CN
+1024385024,1024386047,JP
+1024386048,1024387071,IN
+1024387072,1024389119,VN
+1024389120,1024391167,CN
+1024391168,1024392191,ID
+1024392192,1024458751,HK
 1024458752,1024491519,SG
 1024491520,1024589823,IN
 1024589824,1024655359,HK
@@ -11194,7 +11726,21 @@
 1026420736,1026422783,JP
 1026422784,1026424831,AU
 1026424832,1026490367,JP
-1026490368,1026523135,TH
+1026490368,1026492415,TH
+1026492416,1026493439,SG
+1026493440,1026498559,TH
+1026498560,1026501631,SG
+1026501632,1026505727,TH
+1026505728,1026506751,SG
+1026506752,1026507775,TH
+1026507776,1026508799,SG
+1026508800,1026510847,JP
+1026510848,1026512895,SG
+1026512896,1026514943,JP
+1026514944,1026516991,TH
+1026516992,1026518015,SG
+1026518016,1026519039,JP
+1026519040,1026523135,SG
 1026523136,1026539519,CN
 1026539520,1026555903,KR
 1026555904,1027080191,CN
@@ -11712,7 +12258,9 @@
 1046757376,1046765567,IT
 1046765568,1046773759,ES
 1046773760,1046781951,FR
-1046781952,1046798335,GB
+1046781952,1046790143,GB
+1046790144,1046792191,CN
+1046792192,1046798335,GB
 1046798336,1046806527,HU
 1046806528,1046814719,IT
 1046814720,1046822911,SE
@@ -11777,6 +12325,10 @@
 1047658496,1047724031,EG
 1047728128,1047732223,SE
 1047740544,1047740671,DE
+1047758911,1047758911,CZ
+1047759119,1047759119,AT
+1047759125,1047759125,AT
+1047759834,1047759834,CZ
 1047781856,1047781871,DE
 1047782690,1047782690,GB
 1047787520,1047787775,ES
@@ -11881,7 +12433,11 @@
 1049378816,1049395199,EG
 1049395200,1049411583,NL
 1049411584,1049419775,GB
-1049419776,1049427967,RU
+1049419776,1049423615,RU
+1049423616,1049423856,UA
+1049423857,1049423857,RU
+1049423858,1049423871,UA
+1049423872,1049427967,RU
 1049427968,1049436159,CZ
 1049436160,1049444351,DE
 1049444352,1049460735,RU
@@ -12232,8 +12788,8 @@
 1053900800,1053917183,NO
 1053917184,1053925375,UZ
 1053925376,1053927159,SE
-1053927160,1053927167,FI
-1053927168,1053933567,SE
+1053927160,1053927199,FI
+1053927200,1053933567,SE
 1053933568,1053949951,CZ
 1053949952,1053968188,FR
 1053968189,1053968189,PT
@@ -12269,7 +12825,11 @@
 1054375936,1054381567,GB
 1054381568,1054381571,CA
 1054381572,1054381572,SG
-1054381573,1054381823,CA
+1054381573,1054381587,CA
+1054381588,1054381588,HK
+1054381589,1054381619,CA
+1054381620,1054381620,US
+1054381621,1054381823,CA
 1054381824,1054384127,GB
 1054384128,1054400511,DE
 1054400512,1054408703,GB
@@ -12488,7 +13048,9 @@
 1066358528,1066369023,JM
 1066369024,1066830303,US
 1066830304,1066830311,SG
-1066830312,1066831183,US
+1066830312,1066831071,US
+1066831072,1066831079,JP
+1066831080,1066831183,US
 1066831184,1066831191,JP
 1066831192,1066831335,US
 1066831336,1066831343,JP
@@ -13302,7 +13864,9 @@
 1082683392,1082687487,CA
 1082687488,1082753023,US
 1082753024,1082785791,CA
-1082785792,1082790911,US
+1082785792,1082788655,US
+1082788656,1082788663,SG
+1082788664,1082790911,US
 1082790912,1082791167,AU
 1082791168,1082791423,IN
 1082791424,1082945535,US
@@ -13345,7 +13909,9 @@
 1086042112,1086046207,CA
 1086046208,1086050815,US
 1086050816,1086051327,CA
-1086051328,1086421503,US
+1086051328,1086267391,US
+1086267392,1086271487,CA
+1086271488,1086421503,US
 1086421504,1086422015,MP
 1086422016,1086922751,US
 1086922752,1086930943,CA
@@ -13365,7 +13931,9 @@
 1087419136,1087419391,GB
 1087419392,1087419903,US
 1087419904,1087420159,CA
-1087420160,1087440895,US
+1087420160,1087430191,US
+1087430192,1087430195,FR
+1087430196,1087440895,US
 1087440896,1087442943,PR
 1087442944,1087444223,US
 1087444224,1087444479,GB
@@ -13375,13 +13943,15 @@
 1087496704,1087496959,CA
 1087496960,1087501471,US
 1087501472,1087501479,GB
-1087501480,1087501567,US
-1087501568,1087501695,HK
+1087501480,1087501535,US
+1087501536,1087501695,HK
 1087501696,1087508161,US
 1087508162,1087508162,JP
 1087508163,1087514623,US
 1087514624,1087516671,BB
-1087516672,1087593983,US
+1087516672,1087591237,US
+1087591238,1087591238,FR
+1087591239,1087593983,US
 1087593984,1087594239,MX
 1087594240,1087596031,US
 1087596032,1087596287,DE
@@ -13405,7 +13975,9 @@
 1087726016,1087726047,FR
 1087726048,1087735743,US
 1087735744,1087735807,CA
-1087735808,1087758335,US
+1087735808,1087743569,US
+1087743570,1087743570,GB
+1087743571,1087758335,US
 1087758336,1087766527,PR
 1087766528,1087783423,US
 1087783424,1087783679,ZA
@@ -14010,9 +14582,9 @@
 1114513472,1114513555,US
 1114513556,1114513559,SA
 1114513560,1114513567,US
-1114513568,1114513663,SA
-1114513664,1114514431,US
-1114514432,1114515455,SA
+1114513568,1114513599,SA
+1114513600,1114514687,US
+1114514688,1114515455,SA
 1114515456,1114515463,US
 1114515464,1114515471,CA
 1114515472,1114517503,US
@@ -14072,7 +14644,14 @@
 1116024064,1116024319,PG
 1116024320,1116027135,US
 1116027136,1116027903,DE
-1116027904,1116168191,US
+1116027904,1116031743,US
+1116031744,1116031999,GB
+1116032000,1116032255,US
+1116032256,1116032511,NL
+1116032512,1116032767,US
+1116032768,1116033023,GB
+1116033024,1116037119,HK
+1116037120,1116168191,US
 1116168192,1116176383,CA
 1116176384,1116897279,US
 1116897280,1116905471,CA
@@ -14114,7 +14693,7 @@
 1117823232,1117823487,CA
 1117823488,1117823743,CN
 1117823744,1117823999,US
-1117824000,1117824511,GR
+1117824000,1117824511,CA
 1117824512,1117829375,US
 1117829376,1117829631,GR
 1117829632,1117978623,US
@@ -14275,9 +14854,7 @@
 1120307968,1120308223,PH
 1120308224,1120310015,US
 1120310016,1120310783,PH
-1120310784,1120312063,US
-1120312064,1120312319,PH
-1120312320,1120312575,US
+1120310784,1120312575,US
 1120312576,1120312831,PH
 1120312832,1120315391,US
 1120315392,1120317439,SG
@@ -14452,7 +15029,10 @@
 1123589632,1123589887,DE
 1123589888,1123590143,US
 1123590144,1123598335,VI
-1123598336,1123635639,US
+1123598336,1123598591,CA
+1123598592,1123635626,US
+1123635627,1123635627,PL
+1123635628,1123635639,US
 1123635640,1123635640,RU
 1123635641,1123635660,US
 1123635661,1123635661,RU
@@ -14460,7 +15040,9 @@
 1123635671,1123635671,RU
 1123635672,1123635887,US
 1123635888,1123635888,AU
-1123635889,1123651583,US
+1123635889,1123638730,US
+1123638731,1123638731,RE
+1123638732,1123651583,US
 1123651584,1123651839,JM
 1123651840,1123652095,BB
 1123652096,1123653119,JM
@@ -14503,7 +15085,9 @@
 1125117184,1125117439,MA
 1125117440,1125120255,US
 1125120256,1125120511,MA
-1125120512,1125156304,US
+1125120512,1125147624,US
+1125147625,1125147625,GB
+1125147626,1125156304,US
 1125156305,1125156305,DE
 1125156306,1125237919,US
 1125237920,1125237923,GB
@@ -14552,7 +15136,9 @@
 1128641536,1128792063,CA
 1128792064,1128817407,US
 1128817408,1128817663,NL
-1128817664,1130537471,US
+1128817664,1130535935,US
+1130535936,1130536191,FR
+1130536192,1130537471,US
 1130537472,1130537983,GU
 1130537984,1130538751,US
 1130538752,1130539007,GU
@@ -14756,8 +15342,8 @@
 1151897600,1152073727,US
 1152073728,1152077823,CA
 1152077824,1152085152,US
-1152085153,1152085153,KN
-1152085154,1152114687,US
+1152085153,1152085168,KN
+1152085169,1152114687,US
 1152114688,1152117759,CA
 1152117760,1152117952,IL
 1152117953,1152117953,CA
@@ -14926,9 +15512,7 @@
 1160425472,1160429567,CA
 1160429568,1160486911,US
 1160486912,1160487423,AU
-1160487424,1160505343,US
-1160505344,1160505855,AU
-1160505856,1160547839,US
+1160487424,1160547839,US
 1160547840,1160548351,MX
 1160548352,1160563199,US
 1160563200,1160563711,MP
@@ -14999,7 +15583,13 @@
 1161430912,1161430943,CA
 1161430944,1161430975,US
 1161430976,1161431039,CA
-1161431040,1161433087,US
+1161431040,1161431295,US
+1161431296,1161431359,CA
+1161431360,1161432063,US
+1161432064,1161432126,CA
+1161432127,1161432319,US
+1161432320,1161432575,IN
+1161432576,1161433087,US
 1161433088,1161437183,CA
 1161437184,1161453567,US
 1161453568,1161457663,CA
@@ -15105,17 +15695,13 @@
 1162883840,1162884863,BB
 1162884864,1162885887,VC
 1162885888,1162887167,BB
-1162887168,1163398655,US
-1163398656,1163398911,BD
-1163398912,1163400959,US
+1162887168,1163399167,US
+1163399168,1163399423,WS
+1163399424,1163400959,US
 1163400960,1163401215,BD
 1163401216,1163401471,US
 1163401472,1163401727,ID
-1163401728,1163401983,US
-1163401984,1163402239,BD
-1163402240,1163402495,US
-1163402496,1163402751,BD
-1163402752,1163407359,US
+1163401728,1163407359,US
 1163407360,1163411455,CA
 1163411456,1163468799,US
 1163468800,1163469055,PR
@@ -15353,9 +15939,7 @@
 1170227200,1170231295,NL
 1170231296,1170461183,US
 1170461184,1170461695,CO
-1170461696,1170461951,US
-1170461952,1170462719,IL
-1170462720,1170465791,US
+1170461696,1170465791,US
 1170465792,1170466047,CY
 1170466048,1170467839,US
 1170467840,1170468351,DO
@@ -15584,7 +16168,15 @@
 1210256128,1210256383,CA
 1210256384,1210259967,US
 1210259968,1210260223,CA
-1210260224,1210420223,US
+1210260224,1210314751,US
+1210314752,1210315007,GB
+1210315008,1210315775,US
+1210315776,1210316031,GB
+1210316032,1210316287,US
+1210316288,1210316543,NL
+1210316544,1210316799,US
+1210316800,1210317823,ID
+1210317824,1210420223,US
 1210420224,1210420479,IT
 1210420480,1210421503,US
 1210421504,1210421551,CA
@@ -15761,7 +16353,11 @@
 1246937088,1246945279,CA
 1246945280,1247073023,US
 1247073024,1247073279,CA
-1247073280,1247490047,US
+1247073280,1247101439,US
+1247101440,1247101695,CA
+1247101696,1247129599,US
+1247129600,1247133695,NL
+1247133696,1247490047,US
 1247494144,1248864255,US
 1248864256,1248866303,CA
 1248866304,1248879615,US
@@ -15781,9 +16377,7 @@
 1248936960,1248939007,CA
 1248939008,1248946175,US
 1248946176,1248947199,VG
-1248947200,1248956415,US
-1248956416,1248957439,CA
-1248957440,1248958463,US
+1248947200,1248958463,US
 1248958464,1248959487,CA
 1248959488,1248964607,US
 1248964608,1248966655,CA
@@ -15817,7 +16411,9 @@
 1249107968,1249130495,US
 1249130496,1249131519,JM
 1249131520,1249139711,US
-1249139712,1249140735,MF
+1249139712,1249140268,MF
+1249140269,1249140269,FR
+1249140270,1249140735,MF
 1249140736,1249142015,US
 1249142016,1249142271,GB
 1249142272,1249146879,US
@@ -16136,9 +16732,7 @@
 1279967232,1279967487,CA
 1279967488,1279968127,US
 1279968128,1279968255,CA
-1279968256,1279969167,US
-1279969168,1279969183,CA
-1279969184,1279969343,US
+1279968256,1279969343,US
 1279969344,1279969407,CA
 1279969408,1279969663,US
 1279969664,1279969791,CA
@@ -16184,7 +16778,9 @@
 1280102400,1280126975,US
 1280126976,1280131071,JP
 1280131072,1280139263,CA
-1280139264,1291845631,US
+1280139264,1280242175,US
+1280242176,1280242176,CA
+1280242177,1291845631,US
 1291845632,1292894207,DE
 1292894208,1293156351,NO
 1293156352,1293549567,DE
@@ -16216,7 +16812,9 @@
 1294893056,1294925823,RS
 1294925824,1294958591,DE
 1294958592,1294991359,UA
-1294991360,1295047679,CZ
+1294991360,1295024639,CZ
+1295024640,1295024895,SK
+1295024896,1295047679,CZ
 1295047680,1295048191,SK
 1295048192,1295056895,CZ
 1295056896,1295122431,GR
@@ -16260,7 +16858,12 @@
 1296249024,1296249087,GB
 1296249088,1296249279,FR
 1296249280,1296249343,DE
-1296249344,1296249599,FR
+1296249344,1296249407,FR
+1296249408,1296249423,GB
+1296249424,1296249463,FR
+1296249464,1296249471,GB
+1296249472,1296249567,FR
+1296249568,1296249599,NO
 1296249600,1296249615,GB
 1296249616,1296250367,FR
 1296250368,1296250399,CZ
@@ -16416,9 +17019,11 @@
 1296728064,1296730111,SE
 1296730112,1296732159,DE
 1296732160,1296734207,IT
-1296734208,1296736255,FR
+1296734208,1296736255,US
 1296736256,1296738303,NO
-1296738304,1296740351,CH
+1296738304,1296738815,CH
+1296738816,1296739327,FI
+1296739328,1296740351,CH
 1296740352,1296744447,RU
 1296744448,1296746495,GB
 1296748544,1296750591,FR
@@ -16663,7 +17268,9 @@
 1299019776,1299020031,NL
 1299020032,1299021055,BE
 1299021056,1299021823,NL
-1299021824,1299026111,CH
+1299021824,1299025148,CH
+1299025149,1299025149,DE
+1299025150,1299026111,CH
 1299026112,1299026127,ES
 1299026128,1299038207,CH
 1299038208,1299054591,FI
@@ -16857,12 +17464,28 @@
 1307807744,1307811839,SE
 1307811840,1307815935,NL
 1307816192,1307816447,GB
-1307817216,1307817471,DE
+1307816960,1307817215,NL
+1307817216,1307817219,DE
+1307817220,1307817223,CZ
+1307817224,1307817231,DE
+1307817232,1307817251,CZ
+1307817252,1307817255,HU
+1307817256,1307817259,CZ
+1307817260,1307817471,DE
+1307817728,1307817983,DE
 1307817984,1307818048,GB
 1307818049,1307818049,BE
 1307818050,1307818239,GB
 1307819008,1307819263,GB
-1307819264,1307819519,NL
+1307819264,1307819287,NL
+1307819288,1307819331,DE
+1307819332,1307819343,NL
+1307819344,1307819355,DE
+1307819356,1307819395,NL
+1307819396,1307819399,DE
+1307819400,1307819407,NL
+1307819408,1307819431,DE
+1307819432,1307819519,NL
 1307819520,1307819775,GB
 1307820032,1307824127,PT
 1307824128,1307828223,HU
@@ -17107,7 +17730,9 @@
 1311371264,1311373311,SE
 1311373312,1311375359,FR
 1311375360,1311506431,DE
-1311506432,1311637503,CZ
+1311506432,1311593431,CZ
+1311593432,1311593432,US
+1311593433,1311637503,CZ
 1311637504,1312292863,DE
 1312292864,1312304383,LT
 1312304384,1312304639,GB
@@ -17285,7 +17910,9 @@
 1318593984,1318593991,GB
 1318593992,1318594007,NL
 1318594008,1318594015,GB
-1318594016,1318596543,NL
+1318594016,1318594335,NL
+1318594336,1318594343,US
+1318594344,1318596543,NL
 1318596544,1318596559,SE
 1318596560,1318597343,NL
 1318597344,1318597359,US
@@ -17426,11 +18053,7 @@
 1331931136,1331933183,SE
 1331933184,1331935231,TR
 1331935232,1331937279,NL
-1331937280,1331938063,NG
-1331938064,1331938079,GB
-1331938080,1331938431,NG
-1331938432,1331938559,GB
-1331938560,1331939327,NG
+1331937280,1331939327,GB
 1331939328,1331941375,BE
 1331941376,1331943423,ES
 1331943424,1331945471,RU
@@ -17454,7 +18077,7 @@
 1332616320,1332616447,US
 1332616448,1332616959,UA
 1332616960,1332617087,RU
-1332617088,1332617215,UA
+1332617088,1332617215,CA
 1332617216,1332621311,CZ
 1332625408,1332629503,RU
 1332629504,1332633599,DE
@@ -17493,8 +18116,10 @@
 1334099968,1334108159,IR
 1334108160,1334116351,BE
 1334116352,1334124543,AX
-1334124544,1334125567,DE
-1334125568,1334126591,ES
+1334124544,1334125823,DE
+1334125824,1334125915,ES
+1334125916,1334125916,DE
+1334125917,1334126591,ES
 1334126592,1334127359,DE
 1334127360,1334127615,AT
 1334127616,1334130687,DE
@@ -17589,10 +18214,9 @@
 1334710272,1334714367,RU
 1334714368,1334718463,DE
 1334718464,1334722559,KZ
-1334722560,1334723583,NL
-1334723584,1334723839,BE
+1334722560,1334723839,NL
 1334723840,1334724095,DK
-1334724096,1334724351,NO
+1334724096,1334724351,NL
 1334724352,1334724607,SE
 1334724608,1334724863,US
 1334724864,1334725631,NL
@@ -17719,9 +18343,7 @@
 1337241563,1337241563,RO
 1337241564,1337458687,IL
 1337458688,1337982975,PL
-1337982976,1339416319,DE
-1339416320,1339416575,LU
-1339416576,1342177279,DE
+1337982976,1342177279,DE
 1342177280,1342628207,GB
 1342628208,1342628223,IE
 1342628224,1342701567,GB
@@ -17862,7 +18484,9 @@
 1346596864,1346600959,IT
 1346600960,1346605055,MU
 1346605056,1346609151,CH
-1346609152,1346617343,FR
+1346609152,1346614527,FR
+1346614528,1346614783,BE
+1346614784,1346617343,FR
 1346617344,1346621439,SE
 1346621440,1346625535,RU
 1346625536,1346629631,DE
@@ -17981,7 +18605,9 @@
 1347149568,1347149823,IN
 1347149824,1347151423,HU
 1347151424,1347158015,AT
-1347158016,1347162111,CH
+1347158016,1347159935,CH
+1347159936,1347160063,AT
+1347160064,1347162111,CH
 1347162112,1347166207,IT
 1347166208,1347174399,GR
 1347174400,1347182591,IT
@@ -18459,6 +19085,7 @@
 1348190208,1348194303,RU
 1348194304,1348198399,GR
 1348198400,1348202495,NO
+1348205258,1348205258,DE
 1348206592,1348218879,RU
 1348218880,1348222975,DE
 1348222976,1348231167,LU
@@ -18504,6 +19131,7 @@
 1348395008,1348399103,BY
 1348399104,1348403199,MD
 1348403200,1348404223,ZA
+1348405248,1348407295,ZA
 1348407296,1348411391,BG
 1348411392,1348415487,RU
 1348415488,1348419583,GB
@@ -18566,7 +19194,9 @@
 1353271776,1353271807,AT
 1353271808,1353272079,GB
 1353272080,1353272095,ES
-1353272096,1353275247,GB
+1353272096,1353273407,GB
+1353273408,1353273423,BE
+1353273424,1353275247,GB
 1353275248,1353275255,ES
 1353275256,1353277439,GB
 1353277440,1353279487,CH
@@ -18584,7 +19214,9 @@
 1353298896,1353298911,SE
 1353298912,1353298943,GB
 1353298944,1353299455,SE
-1353299456,1353300079,GB
+1353299456,1353300063,GB
+1353300064,1353300071,SE
+1353300072,1353300079,GB
 1353300080,1353300095,SE
 1353300096,1353306623,GB
 1353306624,1353306879,BE
@@ -18652,8 +19284,10 @@
 1357323520,1357323775,GB
 1357323776,1357323791,FI
 1357324288,1357324295,RU
-1357324296,1357325311,GB
+1357324296,1357324319,PL
+1357324320,1357325311,GB
 1357326336,1357326337,ES
+1357326338,1357326339,SL
 1357326848,1357327103,GB
 1357327360,1357327615,FR
 1357328384,1357328671,GB
@@ -18661,7 +19295,7 @@
 1357329408,1357329415,BE
 1357330944,1357331199,GB
 1357335808,1357336063,IT
-1357337600,1357337631,NL
+1357337600,1357337635,NL
 1357340672,1357341695,GB
 1357342976,1357343231,GB
 1357343488,1357343503,GB
@@ -18673,11 +19307,12 @@
 1357347456,1357347583,FR
 1357347616,1357347659,FR
 1357347664,1357347671,FR
+1357347680,1357347727,FR
 1357347840,1357348095,PL
 1357348384,1357348415,ES
 1357348480,1357348607,ES
-1357350400,1357350623,GB
-1357350656,1357350783,GB
+1357350400,1357350639,GB
+1357350656,1357350847,GB
 1357351168,1357351423,PL
 1357355520,1357355775,FR
 1357360064,1357360383,GB
@@ -18698,10 +19333,10 @@
 1357373536,1357373539,ES
 1357373540,1357373543,PT
 1357373544,1357373555,GB
-1357373568,1357373695,GB
-1357373952,1357375135,GB
+1357373560,1357375207,GB
+1357375232,1357375295,GB
 1357377536,1357377679,FR
-1357377696,1357378559,FR
+1357377696,1357378623,FR
 1357381632,1357414399,NO
 1357414400,1357447167,LV
 1357447168,1357479935,IE
@@ -18815,8 +19450,8 @@
 1358036992,1358041087,IR
 1358041088,1358045183,FI
 1358045184,1358049279,SK
-1358049280,1358062591,RU
-1358062592,1358065663,UA
+1358049280,1358064639,RU
+1358064640,1358065663,UA
 1358065664,1358069759,BA
 1358069760,1358086143,DE
 1358086144,1358090239,CH
@@ -19056,13 +19691,17 @@
 1359101952,1359118335,GB
 1359118336,1359118655,DE
 1359118656,1359118719,GR
-1359118720,1359119199,DE
+1359118720,1359118847,DE
+1359118848,1359119103,IT
+1359119104,1359119199,DE
 1359119200,1359119231,NL
 1359119232,1359119359,DE
 1359119360,1359120383,NL
 1359120384,1359121407,DK
 1359121408,1359122431,ES
-1359122432,1359134719,DE
+1359122432,1359123967,DE
+1359123968,1359124479,ES
+1359124480,1359134719,DE
 1359134720,1359151103,CZ
 1359151104,1359167487,DE
 1359167488,1359183871,GB
@@ -19174,7 +19813,9 @@
 1360282496,1360282623,DE
 1360282624,1360284671,NL
 1360284672,1360284927,DK
-1360284928,1360285695,NL
+1360284928,1360285183,NL
+1360285184,1360285247,ES
+1360285248,1360285695,NL
 1360285696,1360289791,DE
 1360289792,1360293887,RU
 1360293888,1360302079,DE
@@ -19338,7 +19979,9 @@
 1360986632,1360986635,US
 1360986636,1360992255,GB
 1360992256,1360992511,DE
-1360992512,1360994303,GB
+1360992512,1360993095,GB
+1360993096,1360993099,DE
+1360993100,1360994303,GB
 1360994304,1360998399,CZ
 1360998400,1361002495,FI
 1361002496,1361006591,GB
@@ -19473,9 +20116,13 @@
 1365015920,1365016575,US
 1365016576,1365020671,ES
 1365020672,1365024767,CZ
-1365024768,1365028863,DE
+1365024768,1365025151,DE
+1365025152,1365025215,AT
+1365025216,1365028863,DE
 1365028864,1365032959,NL
-1365032960,1365041151,PT
+1365032960,1365039615,PT
+1365039616,1365039871,BE
+1365039872,1365041151,PT
 1365041152,1365044735,FR
 1365044736,1365044799,LU
 1365044800,1365044927,FR
@@ -19818,13 +20465,19 @@
 1375258112,1375258623,RE
 1375258624,1375260062,FR
 1375260063,1375260063,RE
-1375260064,1375260927,FR
+1375260064,1375260685,FR
+1375260686,1375260686,RE
+1375260687,1375260927,FR
 1375260928,1375262463,RE
 1375262464,1375262975,FR
 1375262976,1375263487,RE
 1375263488,1375264255,FR
 1375264256,1375264511,RE
-1375264512,1375264767,FR
+1375264512,1375264550,FR
+1375264551,1375264551,RE
+1375264552,1375264727,FR
+1375264728,1375264728,RE
+1375264729,1375264767,FR
 1375264768,1375265791,RE
 1375265792,1375266303,FR
 1375266304,1375266815,RE
@@ -19836,7 +20489,9 @@
 1375270400,1375270655,RE
 1375270656,1375270911,FR
 1375270912,1375271679,RE
-1375271680,1375731711,FR
+1375271680,1375271964,FR
+1375271965,1375271965,RE
+1375271966,1375731711,FR
 1375731712,1378877439,GB
 1378877440,1379926015,IT
 1379926016,1380188159,FR
@@ -20047,7 +20702,9 @@
 1385267200,1385275391,SE
 1385275392,1385283583,IT
 1385283584,1385286143,DE
-1385286144,1385290631,GB
+1385286144,1385290288,GB
+1385290289,1385290289,RE
+1385290290,1385290631,GB
 1385290632,1385290632,IS
 1385290633,1385291343,GB
 1385291344,1385291344,IS
@@ -20110,7 +20767,23 @@
 1386414080,1386438399,GB
 1386438400,1386438655,FR
 1386438656,1386448895,GB
-1386448896,1386450943,IL
+1386448896,1386449151,IL
+1386449152,1386449343,NL
+1386449344,1386449347,GB
+1386449348,1386449359,NL
+1386449360,1386449363,GB
+1386449364,1386449367,BE
+1386449368,1386449371,AU
+1386449372,1386449375,AT
+1386449376,1386449379,NL
+1386449380,1386449383,CH
+1386449384,1386449387,FR
+1386449388,1386449391,NL
+1386449392,1386449395,ES
+1386449396,1386449399,PT
+1386449400,1386449403,RU
+1386449404,1386449407,DE
+1386449408,1386450943,IL
 1386450944,1386479615,GB
 1386479616,1386545151,NO
 1386545152,1386552319,DE
@@ -20194,7 +20867,9 @@
 1388681216,1388683263,DE
 1388683264,1388683903,CH
 1388683904,1388683919,DE
-1388683920,1388685599,CH
+1388683920,1388684080,CH
+1388684081,1388684081,AT
+1388684082,1388685599,CH
 1388685600,1388685631,GB
 1388685632,1388688127,CH
 1388688128,1388688159,NL
@@ -20274,9 +20949,13 @@
 1389199872,1389200159,US
 1389200160,1389218815,AE
 1389218816,1389219839,AF
-1389219840,1389228415,AE
+1389219840,1389223935,AE
+1389223936,1389224191,DE
+1389224192,1389228415,AE
 1389228416,1389228479,LB
-1389228480,1389232127,AE
+1389228480,1389231359,AE
+1389231360,1389231615,DE
+1389231616,1389232127,AE
 1389232128,1389264895,DE
 1389264896,1389265151,TZ
 1389265152,1389266943,GB
@@ -20300,7 +20979,8 @@
 1389445120,1389461503,RU
 1389461504,1389477887,SE
 1389477888,1389494271,BY
-1389494272,1389510655,DE
+1389494272,1389494527,RO
+1389494528,1389510655,DE
 1389510656,1389527039,NL
 1389527040,1389543423,RO
 1389543424,1389576191,DE
@@ -20331,7 +21011,9 @@
 1389789184,1389805567,PL
 1389805568,1389806591,DE
 1389806592,1389806847,SA
-1389806848,1389817855,DE
+1389806848,1389817603,DE
+1389817604,1389817604,NO
+1389817605,1389817855,DE
 1389817856,1389819903,GB
 1389819904,1389821951,DE
 1389821952,1389838335,NL
@@ -20559,6 +21241,13 @@
 1401939968,1401942015,UA
 1401942016,1401942047,CZ
 1401942528,1401943039,GB
+1401943048,1401943055,IT
+1401943056,1401943063,ES
+1401943064,1401943067,NL
+1401943072,1401943079,HU
+1401943080,1401943087,FR
+1401943096,1401943103,DE
+1401943104,1401943111,HU
 1401943552,1401943807,US
 1401944064,1401946111,BG
 1401946112,1401962495,FR
@@ -20603,7 +21292,9 @@
 1402421248,1402422271,FR
 1402422272,1402429439,GB
 1402429440,1402430463,US
-1402430464,1402437631,GB
+1402430464,1402433600,GB
+1402433601,1402433601,FR
+1402433602,1402437631,GB
 1402437632,1402454015,DK
 1402454016,1402470399,GB
 1402470400,1402994687,FR
@@ -20671,9 +21362,9 @@
 1404043264,1404051455,EE
 1404051456,1404059647,HR
 1404059648,1404076031,NO
-1404076032,1404077055,SE
-1404077056,1404081151,LV
-1404081152,1404082175,SE
+1404076032,1404076543,SE
+1404076544,1404081663,LV
+1404081664,1404082175,SE
 1404082176,1404083199,DE
 1404083200,1404084223,SE
 1404084224,1404092415,NO
@@ -20709,11 +21400,14 @@
 1404215296,1404219391,LV
 1404219392,1404220415,SE
 1404220416,1404221439,EE
-1404221440,1404227583,SE
-1404227584,1404231679,LV
+1404221440,1404222463,SE
+1404222464,1404222975,LV
+1404222976,1404227071,SE
+1404227072,1404231679,LV
 1404231680,1404232191,SE
 1404232192,1404232703,NO
-1404232704,1404234751,SE
+1404232704,1404233215,LV
+1404233216,1404234751,SE
 1404234752,1404239871,HR
 1404239872,1404305407,SE
 1404305408,1404313599,EE
@@ -20753,8 +21447,8 @@
 1404780544,1404788735,SE
 1404788736,1404796927,NL
 1404796928,1404801023,EE
-1404801024,1404803583,SE
-1404803584,1404804095,LV
+1404801024,1404803071,SE
+1404803072,1404804095,LV
 1404804096,1404805119,SE
 1404805120,1404813311,AT
 1404813312,1404815871,EE
@@ -20984,7 +21678,9 @@
 1407549440,1407582207,RU
 1407582208,1407614975,PL
 1407614976,1407680511,ES
-1407680512,1407686119,GB
+1407680512,1407681023,GB
+1407681024,1407681087,ES
+1407681088,1407686119,GB
 1407686120,1407686123,CH
 1407686124,1407686127,DE
 1407686128,1407686131,FR
@@ -21017,7 +21713,11 @@
 1408172032,1408237567,RU
 1408237568,1408270335,CZ
 1408270336,1408283135,PT
-1408283136,1408283391,GB
+1408283136,1408283197,GB
+1408283198,1408283198,PT
+1408283199,1408283329,GB
+1408283330,1408283330,PT
+1408283331,1408283391,GB
 1408283392,1408303103,PT
 1408303104,1408335871,LV
 1408335872,1408368639,SE
@@ -21060,9 +21760,13 @@
 1409377792,1409378047,RO
 1409378048,1409378679,HU
 1409378680,1409378687,RO
-1409378688,1409413119,HU
+1409378688,1409391103,HU
+1409391104,1409391359,BG
+1409391360,1409413119,HU
 1409413120,1409415167,BG
-1409415168,1409548287,HU
+1409415168,1409436159,HU
+1409436160,1409436415,BG
+1409436416,1409548287,HU
 1409548288,1409810431,FR
 1409810432,1409941503,GB
 1409941504,1410007039,PL
@@ -21107,7 +21811,9 @@
 1410539520,1410547711,GB
 1410547712,1410555903,CZ
 1410555904,1410564095,GB
-1410564096,1410572287,SE
+1410564096,1410568991,SE
+1410568992,1410569007,NO
+1410569008,1410572287,SE
 1410572288,1410588671,DE
 1410588672,1410596863,GB
 1410596864,1410605055,ES
@@ -21177,7 +21883,9 @@
 1411842048,1411850239,NL
 1411850240,1411858431,FR
 1411858432,1411870719,DE
-1411871744,1411871999,GB
+1411871744,1411871771,GB
+1411871772,1411871775,FR
+1411871776,1411871999,GB
 1411872057,1411872057,GB
 1411872160,1411872161,GB
 1411872196,1411872199,GB
@@ -21189,7 +21897,7 @@
 1411880960,1411880990,DE
 1411880991,1411880991,GB
 1411880992,1411881215,DE
-1411881216,1411881471,US
+1411881216,1411881471,GB
 1411881472,1411883007,DE
 1411883008,1411887103,PL
 1411887104,1411889151,IR
@@ -21296,14 +22004,8 @@
 1416953856,1417019391,RO
 1417019392,1417150463,DE
 1417150464,1417674751,ES
-1417674752,1420133375,DE
-1420133376,1420133631,LU
-1420133632,1421869055,DE
-1421869056,1422054911,BE
-1422054912,1422055167,NL
-1422055168,1422055423,BE
-1422055424,1422055679,NL
-1422055680,1422393343,BE
+1417674752,1421869055,DE
+1421869056,1422393343,BE
 1422393344,1422413567,DE
 1422413568,1422413695,AT
 1422413696,1422413727,US
@@ -21673,7 +22375,9 @@
 1432133632,1432150015,GB
 1432150016,1432158207,BA
 1432158208,1432158463,RO
-1432158464,1432159487,DE
+1432158464,1432158719,DE
+1432158720,1432158975,LB
+1432158976,1432159487,DE
 1432159488,1432159743,AE
 1432159744,1432166399,DE
 1432166400,1432174591,RU
@@ -21915,7 +22619,9 @@
 1438515200,1438553855,DE
 1438553856,1438554111,BR
 1438554112,1438554623,US
-1438554624,1438560255,DE
+1438554624,1438555135,DE
+1438555136,1438555391,US
+1438555392,1438560255,DE
 1438560256,1438562303,US
 1438562304,1438580735,DE
 1438580736,1438613503,NL
@@ -21984,24 +22690,51 @@
 1439346688,1439350783,RU
 1439354880,1439358975,PL
 1439358976,1439367167,RU
-1439367168,1439371519,NL
+1439367168,1439371263,NL
+1439371264,1439371519,CZ
 1439371520,1439371775,FR
 1439371776,1439372031,SE
 1439372032,1439372287,TR
 1439372288,1439372543,IT
 1439372544,1439372799,JP
-1439372800,1439373311,NL
-1439373312,1439373567,SE
+1439372800,1439372815,MT
+1439372816,1439372831,AD
+1439372832,1439372847,CY
+1439372848,1439372863,AM
+1439372864,1439372879,BY
+1439372880,1439372895,PK
+1439372896,1439372911,CZ
+1439372912,1439372927,GR
+1439372928,1439372943,IS
+1439372944,1439372959,IM
+1439372960,1439372975,JE
+1439372976,1439372991,XK
+1439372992,1439373007,MK
+1439373008,1439373008,MC
+1439373009,1439373023,MT
+1439373024,1439373039,ME
+1439373040,1439373040,SC
+1439373041,1439373055,MT
+1439373056,1439373311,IT
+1439373312,1439373567,AE
 1439373568,1439374335,NL
 1439374336,1439375359,IT
-1439375360,1439383551,NL
+1439375360,1439375615,ES
+1439375616,1439375871,KW
+1439375872,1439376127,OM
+1439376128,1439376383,SA
+1439376384,1439377407,CN
+1439377408,1439378431,IT
+1439378432,1439383551,NL
 1439383552,1439399935,FR
 1439399936,1439432703,DK
 1439432704,1439437823,RO
 1439437824,1439438335,FR
 1439438336,1439438847,RO
 1439438848,1439439359,FR
-1439439360,1439440383,RO
+1439439360,1439439615,RO
+1439439616,1439439871,PL
+1439439872,1439440383,RO
 1439440384,1439440895,IR
 1439440896,1439441919,RO
 1439441920,1439442943,ES
@@ -22038,7 +22771,11 @@
 1439482880,1439483903,RO
 1439483904,1439485951,ES
 1439485952,1439490047,IR
-1439490048,1439498239,RO
+1439490048,1439495423,RO
+1439495424,1439495679,GB
+1439495680,1439496959,RO
+1439496960,1439497215,GB
+1439497216,1439498239,RO
 1439498240,1439513599,DE
 1439513600,1439514623,GB
 1439514624,1439516671,IT
@@ -22089,7 +22826,8 @@
 1440546816,1440579583,NO
 1440579584,1440645119,PL
 1440645120,1440653311,GB
-1440653312,1440669695,RS
+1440653312,1440665599,RS
+1440665600,1440669695,DE
 1440669696,1440671743,NL
 1440671744,1440672767,EE
 1440672768,1440710655,NL
@@ -22117,9 +22855,7 @@
 1441439744,1441447935,LV
 1441447936,1441456127,BE
 1441456128,1441464319,NL
-1441464320,1441469439,SE
-1441469440,1441469695,DK
-1441469696,1441472511,SE
+1441464320,1441472511,SE
 1441472512,1441480703,RU
 1441480704,1441488895,TR
 1441488896,1441497087,GB
@@ -22264,9 +23000,11 @@
 1449722112,1449722367,IT
 1449722368,1449723135,RO
 1449723136,1449723391,DE
-1449723392,1449724927,RO
-1449724928,1449725183,GB
-1449725184,1449726463,RO
+1449723392,1449723647,RO
+1449723648,1449723903,GB
+1449723904,1449724927,RO
+1449724928,1449725439,GB
+1449725440,1449726463,RO
 1449726464,1449726719,NL
 1449726720,1449727999,RO
 1449728000,1449728255,MD
@@ -22316,7 +23054,8 @@
 1449793280,1449793535,NL
 1449793536,1449794047,IR
 1449794048,1449794303,PH
-1449794304,1449810943,RO
+1449794304,1449810687,RO
+1449810688,1449810943,PL
 1449810944,1449811199,MD
 1449811200,1449811455,BG
 1449811456,1449811967,GB
@@ -22330,7 +23069,9 @@
 1449815296,1449816063,GB
 1449816064,1449816575,RO
 1449816576,1449817855,GB
-1449817856,1449820927,RO
+1449817856,1449818111,RO
+1449818112,1449818367,DE
+1449818368,1449820927,RO
 1449820928,1449821183,DE
 1449821184,1449822719,RO
 1449822720,1449823743,GB
@@ -22340,7 +23081,9 @@
 1449828352,1449830399,SE
 1449830400,1449831935,RO
 1449831936,1449832447,GB
-1449832448,1449840639,RO
+1449832448,1449834495,RO
+1449834496,1449835519,ES
+1449835520,1449840639,RO
 1449840640,1449852927,MD
 1449852928,1449857023,IR
 1449857024,1449859583,RO
@@ -22374,7 +23117,9 @@
 1449902080,1449902335,RO
 1449902336,1449903103,GB
 1449903104,1449903359,MD
-1449903360,1449906175,RO
+1449903360,1449904127,RO
+1449904128,1449905151,NL
+1449905152,1449906175,RO
 1449906176,1449910271,IR
 1449910272,1449918463,RO
 1449918464,1449951231,JO
@@ -22390,7 +23135,9 @@
 1450041344,1450049535,DE
 1450049536,1450057727,RU
 1450057728,1450065919,EE
-1450065920,1450074111,DE
+1450065920,1450067135,DE
+1450067136,1450067199,AT
+1450067200,1450074111,DE
 1450074112,1450082303,RU
 1450082304,1450090495,IT
 1450090496,1450106879,RU
@@ -22514,9 +23261,7 @@
 1467744256,1467875327,GB
 1467875328,1467940863,BG
 1467940864,1468006399,GB
-1468006400,1469704959,DE
-1469704960,1469705215,PL
-1469705216,1472200703,DE
+1468006400,1472200703,DE
 1472200704,1472259071,IE
 1472259072,1472259327,GB
 1472259328,1472266239,IE
@@ -22662,9 +23407,9 @@
 1475338240,1475340287,RO
 1475340288,1475342335,GR
 1475342336,1475344383,PL
-1475344384,1475344639,RO
+1475344384,1475344639,ES
 1475344640,1475345919,NL
-1475345920,1475346431,RO
+1475345920,1475346431,GB
 1475346432,1475362815,RU
 1475362816,1475379199,FR
 1475379200,1475395583,RU
@@ -22703,7 +23448,9 @@
 1475657728,1475674111,SK
 1475674112,1475690495,DE
 1475690496,1475693055,CH
-1475693056,1475693311,DE
+1475693056,1475693069,DE
+1475693070,1475693070,CH
+1475693071,1475693311,DE
 1475693312,1475706879,CH
 1475706880,1475723263,RU
 1475723264,1475723839,GB
@@ -22724,7 +23471,9 @@
 1475724928,1475725183,RU
 1475725184,1475725311,GB
 1475725312,1475725439,RU
-1475725440,1475728639,GB
+1475725440,1475726591,GB
+1475726592,1475726847,RU
+1475726848,1475728639,GB
 1475728640,1475728767,PL
 1475728768,1475729407,GB
 1475729408,1475729535,UA
@@ -23296,7 +24045,7 @@
 1495333632,1495333887,RO
 1495333888,1495335935,MD
 1495335936,1495336447,RO
-1495336448,1495336959,NL
+1495336448,1495336959,GB
 1495336960,1495339007,RO
 1495339008,1495339263,DE
 1495339264,1495339519,MD
@@ -23330,7 +24079,9 @@
 1495376384,1495376639,GB
 1495376640,1495376895,RO
 1495376896,1495377407,GB
-1495377408,1495385599,RO
+1495377408,1495382015,RO
+1495382016,1495384063,ES
+1495384064,1495385599,RO
 1495385600,1495386623,GB
 1495386624,1495387135,RO
 1495387136,1495387647,IR
@@ -23504,7 +24255,9 @@
 1495647744,1495648255,IR
 1495648256,1495652863,RO
 1495652864,1495653375,IR
-1495653376,1495658495,RO
+1495653376,1495656959,RO
+1495656960,1495657215,GB
+1495657216,1495658495,RO
 1495658496,1495662591,IR
 1495662592,1495668735,RO
 1495668736,1495669247,IR
@@ -23521,13 +24274,19 @@
 1495683072,1495687167,IR
 1495687168,1495688703,RO
 1495688704,1495689215,IR
-1495689216,1495723519,RO
+1495689216,1495700308,RO
+1495700309,1495700309,GB
+1495700310,1495701247,RO
+1495701248,1495701503,FR
+1495701504,1495723519,RO
 1495723520,1495724031,FR
 1495724032,1495724543,RO
 1495724544,1495725055,IR
 1495725056,1495732223,RO
 1495732224,1495734271,ES
-1495734272,1495745791,RO
+1495734272,1495736319,RO
+1495736320,1495744511,ES
+1495744512,1495745791,RO
 1495745792,1495746047,GB
 1495746048,1495747583,RO
 1495747584,1495748607,MD
@@ -23545,7 +24304,7 @@
 1495759360,1495759487,TH
 1495759488,1495759615,ID
 1495759616,1495759871,RO
-1495759872,1495760127,MD
+1495759872,1495760127,ES
 1495760128,1495760895,RO
 1495760896,1495762943,DE
 1495762944,1495763967,GB
@@ -23590,7 +24349,7 @@
 1495816704,1495817215,IR
 1495817216,1495820799,RO
 1495820800,1495821311,IR
-1495821312,1495821823,RO
+1495821312,1495821823,DE
 1495821824,1495822335,IR
 1495822336,1495826431,RO
 1495826432,1495826943,IR
@@ -23598,7 +24357,9 @@
 1495827968,1495828479,DE
 1495828480,1495829503,RO
 1495829504,1495830015,GB
-1495830016,1495837695,RO
+1495830016,1495833672,RO
+1495833673,1495833673,IR
+1495833674,1495837695,RO
 1495837696,1495838719,IT
 1495838720,1495845631,RO
 1495845632,1495845887,GB
@@ -23648,7 +24409,8 @@
 1495953920,1495954175,GB
 1495954176,1495957503,RO
 1495957504,1495958527,MD
-1495958528,1495960575,RO
+1495958528,1495959551,RO
+1495959552,1495960575,IR
 1495960576,1495961087,SE
 1495961088,1495963135,RO
 1495963136,1495963647,IR
@@ -23657,7 +24419,9 @@
 1495967744,1495968767,NL
 1495968768,1495970815,RO
 1495970816,1495971839,MD
-1495971840,1495979007,RO
+1495971840,1495974911,RO
+1495974912,1495975935,IR
+1495975936,1495979007,RO
 1495979008,1495979263,NL
 1495979264,1495982079,RO
 1495982080,1495983103,MD
@@ -23702,13 +24466,16 @@
 1496057856,1496058111,DE
 1496058112,1496066815,RO
 1496066816,1496067071,QA
-1496067072,1496073983,RO
+1496067072,1496072383,RO
+1496072384,1496072447,ES
+1496072448,1496073983,RO
 1496073984,1496074239,ES
 1496074240,1496078335,RO
 1496078336,1496079359,MD
 1496079360,1496082175,RO
 1496082176,1496082431,GB
-1496082432,1496084479,RO
+1496082432,1496083967,RO
+1496083968,1496084479,FR
 1496084480,1496084991,IR
 1496084992,1496085247,MD
 1496085248,1496086015,RO
@@ -23742,7 +24509,9 @@
 1496150016,1496152063,IR
 1496152064,1496153599,RO
 1496153600,1496154111,IR
-1496154112,1496179199,RO
+1496154112,1496177663,RO
+1496177664,1496178687,ES
+1496178688,1496179199,RO
 1496179200,1496179711,SE
 1496179712,1496180223,RO
 1496180224,1496180735,IR
@@ -23756,7 +24525,6 @@
 1496197120,1496197631,MD
 1496197632,1496198143,RO
 1496198144,1496198655,IR
-1496198656,1496198911,RO
 1496198912,1496199167,GB
 1496199168,1496202239,RO
 1496202240,1496202751,IR
@@ -23791,7 +24559,9 @@
 1496295424,1496297471,GB
 1496297472,1496299519,MD
 1496299520,1496301567,SE
-1496301568,1496317951,RO
+1496301568,1496302591,RO
+1496302592,1496304639,IR
+1496304640,1496317951,RO
 1496317952,1497366527,DE
 1497366528,1498415103,PL
 1498415104,1499463679,FR
@@ -23958,7 +24728,9 @@
 1503133696,1503370138,PT
 1503370139,1503370139,GB
 1503370140,1503395839,PT
-1503395840,1503657983,FR
+1503395840,1503491082,FR
+1503491083,1503491083,GP
+1503491084,1503657983,FR
 1503657984,1503690751,SE
 1503690752,1503723519,IS
 1503723520,1503789055,PL
@@ -24277,7 +25049,9 @@
 1506445136,1506445151,DE
 1506445152,1506445167,GB
 1506445168,1506445183,DE
-1506445184,1506446143,GB
+1506445184,1506445199,GB
+1506445200,1506445215,DE
+1506445216,1506446143,GB
 1506446144,1506446151,FR
 1506446152,1506446823,GB
 1506446824,1506446831,NL
@@ -24297,7 +25071,9 @@
 1506456960,1506456975,IT
 1506456976,1506458244,GB
 1506458245,1506458245,CH
-1506458246,1506459207,GB
+1506458246,1506458359,GB
+1506458360,1506458367,CH
+1506458368,1506459207,GB
 1506459208,1506459247,BE
 1506459248,1506459295,GB
 1506459296,1506459327,BE
@@ -24329,7 +25105,11 @@
 1506469664,1506469695,IT
 1506469696,1506469759,GB
 1506469760,1506469775,IT
-1506469776,1506471871,GB
+1506469776,1506471455,GB
+1506471456,1506471487,IT
+1506471488,1506471551,GB
+1506471552,1506471679,IT
+1506471680,1506471871,GB
 1506471872,1506471903,IT
 1506471904,1506471983,GB
 1506471984,1506471999,NL
@@ -24455,7 +25235,11 @@
 1508753408,1508769791,KG
 1508769792,1508786175,PL
 1508786176,1508802559,DE
-1508802560,1508818943,GB
+1508802560,1508807231,GB
+1508807232,1508807247,CZ
+1508807248,1508811191,GB
+1508811192,1508811195,NL
+1508811196,1508818943,GB
 1508818944,1508830719,RO
 1508830720,1508831487,SK
 1508831488,1508835327,RO
@@ -24581,7 +25365,9 @@
 1510632448,1510633983,RE
 1510633984,1510634239,FR
 1510634240,1510635263,RE
-1510635264,1510637823,FR
+1510635264,1510635716,FR
+1510635717,1510635717,RE
+1510635718,1510637823,FR
 1510637824,1510638079,RE
 1510638080,1510638335,FR
 1510638336,1510638591,RE
@@ -24625,7 +25411,15 @@
 1510664704,1510665983,RE
 1510665984,1510666239,FR
 1510666240,1510668031,RE
-1510668032,1511981055,FR
+1510668032,1510668403,FR
+1510668404,1510668404,RE
+1510668405,1510669018,FR
+1510669019,1510669019,RE
+1510669020,1510669897,FR
+1510669898,1510669898,RE
+1510669899,1510670012,FR
+1510670013,1510670013,RE
+1510670014,1511981055,FR
 1511981056,1511981567,GP
 1511981568,1511981823,FR
 1511981824,1511982335,GP
@@ -24804,11 +25598,19 @@
 1514799104,1514930175,ES
 1514930176,1515002367,FR
 1515002368,1515002623,ES
-1515002624,1515030783,FR
+1515002624,1515009300,FR
+1515009301,1515009301,ES
+1515009302,1515030783,FR
 1515030784,1515031039,ES
-1515031040,1515051263,FR
+1515031040,1515035168,FR
+1515035169,1515035169,ES
+1515035170,1515038971,FR
+1515038972,1515038972,ES
+1515038973,1515051263,FR
 1515051264,1515051519,ES
-1515051520,1515057919,FR
+1515051520,1515052989,FR
+1515052990,1515052990,ES
+1515052991,1515057919,FR
 1515057920,1515058175,ES
 1515058176,1515059621,FR
 1515059622,1515059622,ES
@@ -24872,7 +25674,8 @@
 1518635008,1518637055,NL
 1518637056,1518641151,SE
 1518641152,1518649343,NL
-1518649344,1518723071,SE
+1518649344,1518665727,SE
+1518665728,1518723071,LV
 1518723072,1518727167,EE
 1518727168,1518731263,SE
 1518731264,1518747647,DE
@@ -24884,7 +25687,7 @@
 1518944256,1518960639,NL
 1518960640,1518961663,LT
 1518961664,1518962175,EE
-1518962176,1518962687,SE
+1518962176,1518962687,LV
 1518962688,1518964735,NO
 1518964736,1518966783,HR
 1518966784,1518967807,SE
@@ -24892,7 +25695,11 @@
 1518977024,1518985215,NL
 1518985216,1518989311,SE
 1518989312,1518993152,NL
-1518993153,1519190015,SE
+1518993153,1519058943,SE
+1519058944,1519083519,LV
+1519083520,1519091711,SE
+1519091712,1519124479,LV
+1519124480,1519190015,SE
 1519190016,1519198207,NL
 1519198208,1519200255,SE
 1519200256,1519206399,EE
@@ -24959,11 +25766,7 @@
 1522532352,1524629503,GB
 1524629504,1525678079,SE
 1525678080,1526726655,GB
-1526726656,1527519999,DE
-1527520000,1527520255,LU
-1527520256,1527572223,DE
-1527572224,1527572479,PL
-1527572480,1531183103,DE
+1526726656,1531183103,DE
 1531183104,1531445247,FR
 1531445248,1531707391,AE
 1531707392,1531969535,RU
@@ -25088,7 +25891,10 @@
 1533730816,1533732863,NL
 1533732864,1533734911,RU
 1533734912,1533739007,CZ
-1533739008,1533805567,RU
+1533739008,1533739263,IR
+1533739264,1533771775,RU
+1533771776,1533804543,IR
+1533804544,1533805567,RU
 1533805568,1533806591,NL
 1533806592,1533818879,RU
 1533818880,1533819903,NL
@@ -25353,8 +26159,7 @@
 1538940928,1538949119,RU
 1538949120,1538957311,AT
 1538957312,1538964991,DE
-1538964992,1538965247,GB
-1538965248,1538965503,DE
+1538964992,1538965503,GB
 1538965504,1538973695,IR
 1538973696,1538981887,JO
 1538981888,1538990079,BY
@@ -25500,7 +26305,7 @@
 1539392512,1539393535,UA
 1539393536,1539393791,DE
 1539393792,1539394047,PL
-1539394048,1539394303,RU
+1539394048,1539394303,GI
 1539394304,1539394559,RS
 1539394560,1539396607,UA
 1539396608,1539397631,PL
@@ -25525,7 +26330,6 @@
 1539418112,1539419135,RU
 1539419136,1539420159,UA
 1539420160,1539421183,RU
-1539421184,1539422207,GB
 1539422208,1539423231,PL
 1539423232,1539424255,IE
 1539425280,1539426303,PL
@@ -25553,7 +26357,8 @@
 1539449856,1539450367,DK
 1539450368,1539450879,SE
 1539450880,1539451391,UA
-1539451392,1539452415,RO
+1539451392,1539451903,GB
+1539451904,1539452415,RO
 1539452416,1539452927,GB
 1539452928,1539453439,CH
 1539453440,1539453951,UA
@@ -26030,7 +26835,6 @@
 1539756800,1539757055,BE
 1539757056,1539757567,RU
 1539757568,1539757823,SI
-1539757824,1539758079,UA
 1539758080,1539758335,HR
 1539758336,1539758591,PL
 1539758848,1539759103,BA
@@ -26486,8 +27290,10 @@
 1540094976,1540095999,RU
 1540096000,1540097023,SE
 1540097024,1540099071,DE
-1540099072,1540100095,UA
-1540100096,1540103167,RU
+1540099072,1540099583,UA
+1540099584,1540099711,US
+1540099712,1540099839,DE
+1540099840,1540103167,RU
 1540103168,1540105215,DE
 1540105216,1540106239,UA
 1540110336,1540111359,RU
@@ -27413,7 +28219,6 @@
 1540650240,1540650495,CH
 1540650496,1540650751,RU
 1540650752,1540651007,FR
-1540651008,1540651263,RO
 1540651264,1540651519,CH
 1540651520,1540651775,MK
 1540652032,1540652543,UA
@@ -27436,7 +28241,7 @@
 1540657664,1540657919,RU
 1540657920,1540658175,FR
 1540658176,1540658431,RO
-1540658432,1540659199,RU
+1540658688,1540659199,RU
 1540659200,1540659455,FR
 1540659712,1540659967,UA
 1540659968,1540660223,PL
@@ -27446,7 +28251,6 @@
 1540660992,1540661247,RO
 1540661248,1540661503,GB
 1540661760,1540662015,RO
-1540662016,1540662271,BG
 1540662272,1540662527,RO
 1540662528,1540662783,PL
 1540662784,1540663039,GB
@@ -27475,7 +28279,6 @@
 1540670208,1540670463,RU
 1540670464,1540670719,CH
 1540670720,1540670975,RU
-1540670976,1540671231,LV
 1540671232,1540671487,SI
 1540671488,1540671743,CH
 1540671744,1540671999,BG
@@ -27503,8 +28306,7 @@
 1540677888,1540678143,GE
 1540678400,1540678655,RO
 1540678656,1540678911,SE
-1540678912,1540679167,GB
-1540679168,1540679423,RU
+1540678912,1540679423,RU
 1540679680,1540679935,LT
 1540679936,1540680191,BG
 1540680192,1540680447,CH
@@ -27553,7 +28355,6 @@
 1540692224,1540692735,FR
 1540692736,1540692991,DE
 1540692992,1540693247,GB
-1540693248,1540693503,RU
 1540693504,1540693759,ES
 1540693760,1540694015,UZ
 1540694016,1540694271,CH
@@ -27611,7 +28412,6 @@
 1540708864,1540709119,FR
 1540709120,1540709375,DE
 1540709376,1540709631,UA
-1540709888,1540710143,UA
 1540710144,1540710399,NL
 1540710400,1540710655,PL
 1540710656,1540710911,FI
@@ -27660,7 +28460,6 @@
 1540725248,1540725503,UA
 1540725504,1540725759,SE
 1540725760,1540726015,PL
-1540726016,1540726271,TT
 1540726272,1540726527,RU
 1540726528,1540726783,CH
 1540726784,1540727039,CZ
@@ -27896,7 +28695,7 @@
 1540896512,1540896767,GB
 1540897024,1540897279,GB
 1540897280,1540897535,FR
-1540897536,1540897791,RU
+1540897536,1540897791,SC
 1540897792,1540898047,HU
 1540898048,1540898303,UA
 1540898304,1540898559,SE
@@ -27909,7 +28708,6 @@
 1540900352,1540900607,HU
 1540900608,1540900863,BG
 1540900864,1540901119,RU
-1540901120,1540901375,LV
 1540901376,1540901631,SI
 1540901632,1540901887,RO
 1540901888,1540902143,GR
@@ -28034,7 +28832,6 @@
 1540936192,1540936447,CY
 1540936448,1540936959,RU
 1540936960,1540937471,PL
-1540937472,1540937727,RU
 1540937728,1540937983,DE
 1540937984,1540938239,RU
 1540938240,1540938751,ES
@@ -28067,8 +28864,7 @@
 1540945664,1540945919,AT
 1540945920,1540946175,DE
 1540946176,1540946431,AT
-1540946432,1540946687,RU
-1540946688,1540946943,UA
+1540946432,1540946943,UA
 1540946944,1540947199,IL
 1540947200,1540947455,BG
 1540947456,1540947711,PL
@@ -28076,7 +28872,6 @@
 1540947968,1540948479,PL
 1540948480,1540948991,RU
 1540948992,1540949503,UA
-1540949504,1540950015,RU
 1540950016,1540951551,UA
 1540951552,1540952063,RS
 1540952064,1540952575,RU
@@ -28158,7 +28953,6 @@
 1540988672,1540988927,RU
 1540988928,1540989183,GB
 1540989184,1540989439,PL
-1540989440,1540989695,UA
 1540989696,1540989951,PL
 1540989952,1540990207,FR
 1540990208,1540990463,DE
@@ -29274,7 +30068,7 @@
 1541623296,1541623551,GB
 1541623552,1541623807,RU
 1541623808,1541624831,PL
-1541624832,1541625855,RU
+1541624832,1541625855,IR
 1541625856,1541626367,PL
 1541626368,1541626623,RO
 1541626624,1541627903,RU
@@ -30406,13 +31200,12 @@
 1542297088,1542297343,RU
 1542297344,1542297599,FI
 1542297600,1542297855,UA
-1542297856,1542298111,RU
 1542298112,1542300159,PL
 1542300160,1542300671,RU
 1542300672,1542301695,UA
 1542301696,1542302463,SK
 1542302464,1542303231,PL
-1542303744,1542303999,GB
+1542303232,1542303999,GB
 1542304000,1542304255,FR
 1542304256,1542305279,RU
 1542305280,1542305791,UA
@@ -30814,7 +31607,8 @@
 1542522112,1542522367,PL
 1542522368,1542522879,NL
 1542522880,1542523903,CZ
-1542523904,1542525951,RU
+1542523904,1542524415,RU
+1542524928,1542525951,RU
 1542525952,1542526463,IR
 1542526464,1542526719,RU
 1542526720,1542526975,CZ
@@ -31053,7 +31847,9 @@
 1546006528,1546008575,UA
 1546008576,1546014719,BY
 1546014720,1546015743,RU
-1546015744,1546018815,CZ
+1546015744,1546017791,CZ
+1546017792,1546018303,RU
+1546018304,1546018815,FR
 1546018816,1546027007,UA
 1546027008,1546059775,RU
 1546059776,1546063871,SE
@@ -31355,7 +32151,8 @@
 1550984192,1550984447,KR
 1550984448,1550985215,RO
 1550985216,1550987263,PS
-1550987264,1550988543,RO
+1550987264,1550988287,IR
+1550988288,1550988543,RO
 1550988544,1550988799,JP
 1550988800,1550990335,RO
 1550990336,1550991359,AU
@@ -31384,16 +32181,38 @@
 1551577088,1551580159,NL
 1551604480,1551604735,SE
 1551630336,1551892479,RU
-1551892480,1555696895,FR
+1551892480,1554514250,FR
+1554514251,1554514251,RE
+1554514252,1554971045,FR
+1554971046,1554971046,ES
+1554971047,1555073117,FR
+1555073118,1555073118,ES
+1555073119,1555073583,FR
+1555073584,1555073584,ES
+1555073585,1555108390,FR
+1555108391,1555108391,ES
+1555108392,1555111820,FR
+1555111821,1555111821,ES
+1555111822,1555696895,FR
 1555696896,1555697151,ES
-1555697152,1556086783,FR
+1555697152,1555739841,FR
+1555739842,1555739842,ES
+1555739843,1555760639,FR
+1555760640,1555760895,ES
+1555760896,1556086783,FR
 1556086784,1557069823,DE
 1557069824,1557076991,GB
 1557076992,1557077247,DE
 1557077248,1557135359,GB
-1557135360,1557921791,DE
+1557135360,1557313279,DE
+1557313280,1557313535,US
+1557313536,1557921791,DE
 1557921792,1558052863,NO
-1558052864,1558054399,FR
+1558052864,1558053760,FR
+1558053761,1558053761,PT
+1558053762,1558054351,FR
+1558054352,1558054352,PT
+1558054353,1558054399,FR
 1558054400,1558054655,DE
 1558054656,1558056102,FR
 1558056103,1558056103,ES
@@ -31406,7 +32225,9 @@
 1558081176,1558081183,BE
 1558081184,1558083775,FR
 1558083776,1558083791,DE
-1558083792,1558084655,FR
+1558083792,1558083959,FR
+1558083960,1558083963,CZ
+1558083964,1558084655,FR
 1558084656,1558084659,BE
 1558084660,1558085055,FR
 1558085056,1558085071,GB
@@ -31424,7 +32245,9 @@
 1558102508,1558102508,DE
 1558102509,1558103159,FR
 1558103160,1558103167,GB
-1558103168,1558112095,FR
+1558103168,1558107391,FR
+1558107392,1558107455,NL
+1558107456,1558112095,FR
 1558112096,1558112127,ES
 1558112128,1558112191,FR
 1558112192,1558112192,ES
@@ -31432,13 +32255,17 @@
 1558112208,1558112208,ES
 1558112209,1558112209,FR
 1558112210,1558112211,ES
-1558112212,1558118399,FR
+1558112212,1558115327,FR
+1558115328,1558115455,NL
+1558115456,1558118399,FR
 1558118400,1558119423,DE
 1558119424,1558122495,RU
 1558122496,1558123007,SG
 1558123008,1558123519,RU
 1558123520,1558125567,LU
-1558125568,1558141439,AT
+1558125568,1558126591,AT
+1558126592,1558128639,RU
+1558128640,1558141439,AT
 1558141440,1558141695,CY
 1558141696,1558147071,AT
 1558147072,1558147327,LU
@@ -31452,7 +32279,9 @@
 1558150144,1558150655,DE
 1558150656,1558151167,NL
 1558151168,1558172927,IT
-1558172928,1558173183,US
+1558172928,1558173099,US
+1558173100,1558173100,IT
+1558173101,1558173183,US
 1558173184,1558179839,IT
 1558179840,1558179955,NL
 1558179956,1558179959,IT
@@ -31552,9 +32381,7 @@
 1562378240,1564999679,IT
 1564999680,1565523967,UA
 1565523968,1565655039,RU
-1565655040,1565690367,AT
-1565690368,1565690623,SK
-1565690624,1565786111,AT
+1565655040,1565786111,AT
 1565786112,1565917183,BY
 1565917184,1566048255,RS
 1566048256,1566056447,RU
@@ -31776,7 +32603,9 @@
 1567490048,1567555583,IR
 1567555584,1567621119,AT
 1567621120,1567686655,SA
-1567686656,1567696383,RO
+1567686656,1567690751,RO
+1567690752,1567692799,ES
+1567692800,1567696383,RO
 1567696384,1567696895,MD
 1567696896,1567703039,RO
 1567703040,1567709183,MD
@@ -31987,8 +32816,7 @@
 1571422464,1571422719,UA
 1571422720,1571423231,RU
 1571423232,1571423487,UA
-1571423488,1571423999,RU
-1571424000,1571424255,KZ
+1571423488,1571424255,RU
 1571424256,1571424511,KG
 1571424512,1571424767,AM
 1571424768,1571425023,CZ
@@ -32008,7 +32836,8 @@
 1571428608,1571428863,UA
 1571428864,1571430399,CZ
 1571430400,1571430911,UA
-1571430912,1571431423,CZ
+1571430912,1571431167,BY
+1571431168,1571431423,UA
 1571431424,1571432447,KZ
 1571432448,1571434495,RU
 1571434496,1571435519,UA
@@ -32018,7 +32847,8 @@
 1571436544,1571438591,BA
 1571438592,1571440639,UA
 1571440640,1571440895,RU
-1571440896,1571441663,CZ
+1571440896,1571441407,CZ
+1571441408,1571441663,UA
 1571441664,1571441919,RU
 1571441920,1571442175,CZ
 1571442176,1571442687,NL
@@ -32060,11 +32890,16 @@
 1571469824,1571470335,CZ
 1571470336,1571470847,UA
 1571470848,1571475455,RU
-1571475456,1571476479,CZ
+1571475456,1571475967,UA
+1571475968,1571476479,CZ
 1571476480,1571479551,RU
 1571479552,1571483647,CZ
 1571483648,1571484159,RU
-1571484160,1571487743,CZ
+1571484160,1571485183,CZ
+1571485184,1571486719,RU
+1571486720,1571486975,CZ
+1571486976,1571487231,UA
+1571487232,1571487743,CZ
 1571487744,1571489023,SK
 1571489024,1571489279,UA
 1571489280,1571489535,BY
@@ -32080,8 +32915,8 @@
 1571514368,1571520511,BY
 1571520512,1571522047,UA
 1571522048,1571522815,RU
-1571522816,1571524095,CZ
-1571524096,1571524351,RU
+1571522816,1571523583,CZ
+1571523584,1571524351,RU
 1571524352,1571524607,CZ
 1571524608,1571526655,RU
 1571526656,1571526911,UA
@@ -32125,8 +32960,11 @@
 1571545856,1571546111,RU
 1571546112,1571546879,CZ
 1571546880,1571547135,RU
-1571547136,1571549183,CZ
-1571549184,1571553279,UA
+1571547136,1571548159,CZ
+1571548160,1571549183,RU
+1571549184,1571550207,UA
+1571550208,1571550463,RU
+1571550464,1571553279,UA
 1571553280,1571684351,IL
 1571684352,1571686399,ES
 1571686400,1571688447,GB
@@ -32203,10 +33041,8 @@
 1572020224,1572028415,SE
 1572028416,1572028927,GB
 1572028928,1572029183,UA
-1572029184,1572030156,GB
-1572030157,1572030157,RU
-1572030158,1572030463,GB
-1572030464,1572034815,RU
+1572029184,1572029951,GB
+1572029952,1572034815,RU
 1572034816,1572034943,BY
 1572034944,1572035071,US
 1572035072,1572035199,CZ
@@ -32258,10 +33094,8 @@
 1572384768,1572388863,DE
 1572388864,1572392959,DK
 1572392960,1572393471,NL
-1572393472,1572393727,US
-1572393728,1572393983,GB
-1572393984,1572394239,DE
-1572394240,1572394495,US
+1572393472,1572393983,GB
+1572393984,1572394495,DE
 1572394496,1572394751,FR
 1572394752,1572395263,US
 1572395264,1572395519,NL
@@ -32297,7 +33131,9 @@
 1572507648,1572511743,GB
 1572511744,1572515839,DE
 1572515840,1572519935,NL
-1572519936,1572524031,DE
+1572519936,1572520447,DE
+1572520448,1572520703,ES
+1572520704,1572524031,DE
 1572524032,1572528127,GE
 1572528128,1572532223,RU
 1572532224,1572536319,IT
@@ -32491,10 +33327,14 @@
 1578582016,1578584063,IT
 1578584064,1578584355,FR
 1578584356,1578584356,IT
-1578584357,1578584689,FR
+1578584357,1578584680,FR
+1578584681,1578584681,PT
+1578584682,1578584689,FR
 1578584690,1578584690,PT
 1578584691,1578585087,FR
-1578585088,1578586111,PT
+1578585088,1578585299,PT
+1578585300,1578585300,FR
+1578585301,1578586111,PT
 1578586112,1578588159,ES
 1578588160,1578590207,PL
 1578590208,1578590787,FR
@@ -32518,7 +33358,9 @@
 1578592200,1578592207,CH
 1578592208,1578592295,FR
 1578592296,1578592303,NL
-1578592304,1578592783,FR
+1578592304,1578592539,FR
+1578592540,1578592543,ES
+1578592544,1578592783,FR
 1578592784,1578592799,BE
 1578592800,1578593023,FR
 1578593024,1578593279,DE
@@ -32604,17 +33446,27 @@
 1580015616,1580048383,UA
 1580048384,1580064767,RU
 1580064768,1580072959,GB
-1580072960,1580083199,PT
-1580083200,1580089343,US
+1580072960,1580081151,PT
+1580081152,1580083199,TR
+1580083200,1580087565,US
+1580087566,1580087566,SE
+1580087567,1580089102,US
+1580089103,1580089103,SE
+1580089104,1580089343,US
 1580089344,1580097535,PT
-1580097536,1580105727,GB
+1580097536,1580101955,GB
+1580101956,1580101956,SE
+1580101957,1580105007,GB
+1580105008,1580105008,SE
+1580105009,1580105727,GB
 1580105728,1580109567,PT
 1580109568,1580109823,SE
 1580109824,1580113919,US
 1580113920,1580125695,PT
 1580125696,1580125951,TR
 1580125952,1580134399,PT
-1580134400,1580136447,ES
+1580134400,1580135423,SE
+1580135424,1580136447,ES
 1580136448,1580138495,PT
 1580138496,1580204031,IT
 1580204032,1580335103,SA
@@ -32920,6 +33772,7 @@
 1586233344,1586241535,FR
 1586241536,1586249727,SE
 1586249728,1586257919,SI
+1586257920,1586266111,LV
 1586266112,1586274303,RU
 1586274304,1586282495,BE
 1586282496,1586298879,RU
@@ -33035,10 +33888,12 @@
 1588652160,1588654079,RO
 1588654080,1588658175,DE
 1588658176,1588659199,RO
-1588659200,1588659711,NL
+1588659200,1588659711,GB
 1588659712,1588661247,RO
 1588661248,1588661503,NL
-1588661504,1588664319,RO
+1588661504,1588663807,RO
+1588663808,1588664063,GB
+1588664064,1588664319,RO
 1588664320,1588664575,TH
 1588664576,1588664831,VG
 1588664832,1588673535,RO
@@ -33169,7 +34024,9 @@
 1592074240,1592078335,SK
 1592078336,1592082431,NL
 1592082432,1592086527,GB
-1592086528,1592090623,CZ
+1592086528,1592087551,CZ
+1592087552,1592088063,PL
+1592088064,1592090623,CZ
 1592090624,1592094719,RU
 1592094720,1592098815,RS
 1592098816,1592102911,GB
@@ -33205,7 +34062,9 @@
 1592246272,1592250367,RU
 1592254464,1592258559,PL
 1592258560,1592262655,NL
-1592262656,1592270847,RU
+1592262656,1592268799,RU
+1592268800,1592269823,UZ
+1592269824,1592270847,RU
 1592270848,1592272895,PL
 1592272896,1592281087,RU
 1592281088,1592283135,UA
@@ -33365,16 +34224,29 @@
 1596456960,1596588031,PL
 1596588032,1596719103,BG
 1596719104,1596850175,IE
-1596850176,1596854271,CZ
+1596850176,1596850687,CZ
+1596850688,1596851199,UA
+1596851200,1596851455,RU
+1596851456,1596851711,CZ
+1596851712,1596851967,UA
+1596851968,1596852223,LV
+1596852224,1596854271,UA
 1596854272,1596858367,BY
 1596858368,1596858879,CZ
 1596858880,1596859391,RU
 1596859392,1596862463,CZ
 1596862464,1596876799,RU
-1596876800,1596878079,CZ
-1596878080,1596878335,RU
-1596878336,1596881919,CZ
-1596881920,1596887295,RU
+1596876800,1596877055,CZ
+1596877056,1596877311,RU
+1596877312,1596877823,CZ
+1596877824,1596878847,RU
+1596878848,1596879871,CZ
+1596879872,1596880895,RU
+1596880896,1596881407,UA
+1596881408,1596881919,CZ
+1596881920,1596886015,RU
+1596886016,1596886527,UA
+1596886528,1596887295,RU
 1596887296,1596887551,KZ
 1596887552,1596888063,UA
 1596888064,1596889087,RU
@@ -33439,8 +34311,8 @@
 1596967936,1596968959,UA
 1596968960,1596973055,BA
 1596973056,1596975103,BY
-1596975104,1596975615,CZ
-1596975616,1596978431,RU
+1596975104,1596975359,CZ
+1596975360,1596978431,RU
 1596978432,1596978944,CZ
 1596978945,1596978945,RU
 1596978946,1596981247,CZ
@@ -33956,7 +34828,7 @@
 1605369856,1605402623,FR
 1605402624,1605435391,SI
 1605435392,1605468159,GB
-1605468160,1605500927,RO
+1605468160,1605500927,SA
 1605500928,1605533695,PL
 1605533696,1605566463,HR
 1605566464,1605599231,RU
@@ -34005,7 +34877,9 @@
 1607606016,1607606271,FR
 1607606272,1607606783,DE
 1607606784,1607607039,GB
-1607607040,1607608319,IT
+1607607040,1607607295,IT
+1607607296,1607607551,PL
+1607607552,1607608319,IT
 1607608320,1607608575,HU
 1607608576,1607608831,SK
 1607608832,1607610367,IT
@@ -34272,6 +35146,7 @@
 1695547392,1697775615,CN
 1697775616,1697776639,ID
 1697776640,1697777663,JP
+1697777664,1697779711,CN
 1697779712,1697783807,ID
 1697783808,1697789951,JP
 1697789952,1697790975,CN
@@ -34424,6 +35299,7 @@
 1728171008,1728172031,AU
 1728172032,1728173055,VN
 1728173056,1728175103,AU
+1728175104,1728176127,TW
 1728176128,1728177151,HK
 1728177152,1728178175,AU
 1728178176,1728179199,LA
@@ -34461,6 +35337,7 @@
 1728246784,1728254975,JP
 1728254976,1728255999,MY
 1728256000,1728257023,HK
+1728257024,1728258047,JP
 1728258048,1728259071,IN
 1728259072,1728260095,KR
 1728260096,1728261119,IN
@@ -34477,7 +35354,8 @@
 1728286720,1728287743,AU
 1728287744,1728290815,CN
 1728290816,1728291839,AU
-1728291840,1728292863,SG
+1728291840,1728292607,US
+1728292608,1728292863,SG
 1728292864,1728293887,PG
 1728293888,1728294911,MY
 1728294912,1728295935,TH
@@ -34499,6 +35377,7 @@
 1728316416,1728317439,MY
 1728317440,1728319487,JP
 1728319488,1728320511,AU
+1728320512,1728322559,HK
 1728322560,1728323583,MY
 1728323584,1728324607,JP
 1728324608,1728325631,SG
@@ -34527,8 +35406,7 @@
 1728346624,1728347135,AU
 1728347136,1728348159,SG
 1728348160,1728349183,VN
-1728349184,1728349951,AU
-1728349952,1728350207,NP
+1728349184,1728350207,AU
 1728350208,1728351231,NZ
 1728351232,1728352255,MY
 1728352256,1728353279,BD
@@ -34553,6 +35431,7 @@
 1728369664,1728370687,AU
 1728370688,1728371711,TH
 1728371712,1728372735,IN
+1728372736,1728373759,CN
 1728373760,1728374783,TH
 1728374784,1728375039,SG
 1728375040,1728375295,IN
@@ -34583,12 +35462,14 @@
 1728399104,1728400383,NZ
 1728400384,1728400895,AU
 1728400896,1728401151,IN
+1728401152,1728401407,HK
 1728401408,1728402431,NZ
 1728402432,1728403455,IN
 1728403456,1728406527,AU
 1728406528,1728407551,TW
 1728407552,1728407807,AU
 1728407808,1728408063,MY
+1728408064,1728408319,AU
 1728408320,1728408575,ID
 1728408576,1728409599,NZ
 1728409600,1728410623,IN
@@ -34604,14 +35485,16 @@
 1728419072,1728419327,HK
 1728419328,1728419583,NP
 1728419584,1728419839,SG
+1728419840,1728420863,CN
 1728420864,1728421887,NZ
 1728421888,1728422911,JP
 1728422912,1728423935,AU
+1728423936,1728424959,CN
 1728424960,1728425983,AF
 1728425984,1728427007,JP
 1728427008,1728428031,MY
 1728428032,1728430079,IN
-1728431104,1728431615,AF
+1728430080,1728431103,CN
 1728431616,1728431871,HK
 1728431872,1728432127,SG
 1728432128,1728433151,IN
@@ -34622,14 +35505,19 @@
 1728437248,1728438271,HK
 1728438272,1728439295,NZ
 1728439296,1728439807,NP
+1728439808,1728440319,KH
 1728440320,1728441343,BD
 1728441344,1728442367,MY
 1728442368,1728443391,SG
 1728443392,1728444415,IN
-1728444416,1728445439,JP
+1728444416,1728444671,HK
+1728444672,1728444927,JP
+1728444928,1728445183,HK
+1728445184,1728445439,JP
 1728445440,1728446463,CN
 1728446464,1728446975,ID
 1728446976,1728447231,IN
+1728447232,1728447487,AU
 1728447488,1728448511,HK
 1728448512,1728449535,KH
 1728449536,1728450559,AU
@@ -34645,7 +35533,8 @@
 1728458752,1728459775,HK
 1728459776,1728460799,ID
 1728460800,1728462847,JP
-1728462848,1728463871,US
+1728462848,1728463359,NZ
+1728463360,1728463871,US
 1728463872,1728464895,JP
 1728464896,1728465919,KR
 1728465920,1728466943,CN
@@ -34653,16 +35542,20 @@
 1728467968,1728468735,HK
 1728468736,1728469247,IN
 1728469248,1728469503,NZ
+1728469504,1728470015,IN
 1728470016,1728471039,JP
 1728471040,1728472063,PH
 1728472064,1728473087,KR
+1728473088,1728473343,PH
 1728473344,1728473599,AU
 1728473600,1728474111,SG
+1728474112,1728475135,CN
 1728475136,1728476159,JP
 1728476160,1728476415,AU
 1728476416,1728476927,ID
 1728476928,1728477183,IN
-1728478208,1728480255,HK
+1728478208,1728479231,JP
+1728479232,1728480255,HK
 1728480256,1728481279,IN
 1728481280,1728483327,HK
 1728483328,1728484351,NZ
@@ -34692,6 +35585,7 @@
 1728501504,1728502783,AU
 1728502784,1728503807,CN
 1728503808,1728504831,JP
+1728504832,1728505855,CN
 1728505856,1728506879,NL
 1728506880,1728507903,MY
 1728507904,1728508927,JP
@@ -34734,6 +35628,7 @@
 1728544768,1728545791,IN
 1728545792,1728546815,JP
 1728546816,1728547839,AU
+1728547840,1728548863,CN
 1728548864,1728549119,KH
 1728549120,1728549375,IN
 1728549376,1728549631,PH
@@ -34753,6 +35648,7 @@
 1728558080,1728559103,IN
 1728559104,1728560127,ID
 1728560128,1728560639,AU
+1728560640,1728561151,KR
 1728561152,1728562175,AU
 1728562176,1728562431,VN
 1728562432,1728562687,VU
@@ -34788,6 +35684,7 @@
 1728593408,1728593663,IN
 1728593664,1728593919,ID
 1728593920,1728594943,JP
+1728594944,1728595967,CN
 1728595968,1728596479,NZ
 1728596480,1728598015,ID
 1728598016,1728599039,NZ
@@ -34799,6 +35696,7 @@
 1728606208,1728607231,PK
 1728607232,1728608255,IN
 1728608256,1728608511,SG
+1728608512,1728608767,BD
 1728608768,1728609023,ID
 1728609024,1728610303,IN
 1728610304,1728611327,TH
@@ -34811,7 +35709,9 @@
 1728618496,1728619519,MY
 1728619520,1728620543,IN
 1728620544,1728622591,AU
-1728622592,1728624639,SG
+1728622592,1728624439,SG
+1728624440,1728624447,JP
+1728624448,1728624639,SG
 1728624640,1728625663,JP
 1728625664,1728626175,IN
 1728626176,1728626431,JP
@@ -34839,15 +35739,18 @@
 1728643072,1728645119,VN
 1728645120,1728646143,CN
 1728646144,1728647167,IN
-1728647168,1728648191,AU
+1728647168,1728648703,AU
 1728648704,1728648959,ID
 1728648960,1728649215,PK
+1728649216,1728650239,CN
 1728650240,1728651263,JP
 1728651264,1728652287,KR
 1728652288,1728653311,ID
 1728653312,1728654335,NZ
 1728654336,1728655359,ID
+1728655360,1728655871,AU
 1728655872,1728656127,SB
+1728656128,1728656383,MY
 1728656384,1728661503,AU
 1728661504,1728662527,IN
 1728662528,1728665599,VN
@@ -34856,16 +35759,19 @@
 1728668672,1728669695,SG
 1728669696,1728670207,BD
 1728670208,1728670463,NZ
+1728670464,1728670719,ID
+1728670720,1728671743,CN
 1728671744,1728672767,BD
 1728672768,1728673791,TW
 1728673792,1728674815,JP
 1728674816,1728675839,ID
 1728675840,1728676863,KR
-1728677888,1728678911,BD
+1728676864,1728678911,BD
 1728678912,1728679935,PG
 1728679936,1728680959,ID
 1728680960,1728681983,MY
 1728681984,1728683007,CN
+1728683008,1728684031,VN
 1728684032,1728685055,AU
 1728685056,1728686079,JP
 1728686080,1728687103,AU
@@ -34873,6 +35779,7 @@
 1728689152,1728689407,JP
 1728689408,1728689663,BD
 1728689664,1728689919,PK
+1728689920,1728690175,ID
 1728690176,1728691199,BD
 1728691200,1728692223,KH
 1728693248,1728698367,VN
@@ -34901,6 +35808,7 @@
 1728716800,1728717823,AU
 1728717824,1728718847,JP
 1728718848,1728719871,MY
+1728719872,1728720895,VN
 1728720896,1728721919,AU
 1728721920,1728722943,BD
 1728722944,1728723199,ID
@@ -34918,8 +35826,8 @@
 1728734208,1728735231,SG
 1728735232,1728736255,ID
 1728736256,1728736511,HK
+1728736512,1728736767,IN
 1728736768,1728737023,ID
-1728737024,1728737279,CN
 1728737280,1728738303,JP
 1728738304,1728739327,IN
 1728739328,1728740351,ID
@@ -34936,6 +35844,7 @@
 1728750592,1728751615,JP
 1728751616,1728751871,IN
 1728751872,1728752639,ID
+1728752640,1728753663,HK
 1728753664,1728754687,PH
 1728754688,1728755711,IN
 1728755712,1728756735,ID
@@ -34953,21 +35862,24 @@
 1728762880,1728763903,VN
 1728763904,1728764927,KR
 1728764928,1728765439,SG
+1728765440,1728765695,IN
 1728765696,1728765951,ID
 1728765952,1728766975,IN
 1728766976,1728767999,TH
 1728768000,1728768255,AU
 1728768256,1728768511,NZ
 1728768512,1728769023,IN
+1728769024,1728770047,HK
 1728770048,1728772095,JP
 1728772096,1728773375,IN
 1728773376,1728773631,ID
 1728773632,1728774143,PH
+1728774144,1728775167,PK
 1728775168,1728776191,JP
 1728776192,1728777215,AU
 1728777216,1728778239,TH
 1728779264,1728779519,IN
-1728779776,1728780287,ID
+1728779520,1728780287,ID
 1728780288,1728781311,KR
 1728781312,1728782335,ID
 1728782336,1728783359,LK
@@ -34975,11 +35887,12 @@
 1728784384,1728785407,PH
 1728785408,1728786431,KR
 1728786432,1728787455,SG
-1728787456,1728788479,NZ
+1728787456,1728788479,AU
 1728788480,1728789503,KR
 1728789504,1728790527,PK
 1728790528,1728791551,PH
 1728791552,1728792575,PK
+1728792576,1728793087,HK
 1728793088,1728793599,ID
 1728793600,1728794623,AU
 1728794624,1728796671,IN
@@ -35004,6 +35917,7 @@
 1728813056,1728814079,IN
 1728814080,1728815103,JP
 1728815104,1728817151,AU
+1728817152,1728818175,CN
 1728818176,1728819199,VN
 1728819200,1728819711,ID
 1728819712,1728819967,NZ
@@ -35013,13 +35927,12 @@
 1728821760,1728822271,ID
 1728822272,1728823295,SG
 1728823296,1728824319,MN
-1728824320,1728825343,JP
 1728825344,1728826367,SG
 1728826368,1728827391,AU
 1728827392,1728828415,JP
 1728828416,1728829439,AU
 1728829440,1728830463,KH
-1728830464,1728830719,SG
+1728830464,1728830719,PK
 1728830720,1728830975,JP
 1728830976,1728831487,ID
 1728831488,1728832511,IN
@@ -35030,11 +35943,10 @@
 1728836608,1728837631,HK
 1728837632,1728838655,KR
 1728838656,1728839679,ID
+1728839680,1728839935,MN
 1728839936,1728840191,IN
 1728840192,1728840447,SG
-1728840448,1728842239,AU
-1728842240,1728842495,NZ
-1728842496,1728842751,AU
+1728840448,1728842751,AU
 1728842752,1728843775,ID
 1728843776,1728844799,JP
 1728844800,1728845311,ID
@@ -35054,11 +35966,13 @@
 1728856064,1728857087,MY
 1728857088,1728858111,CN
 1728858112,1728859135,BD
+1728859136,1728860159,HK
 1728860160,1728860671,ID
 1728860672,1728861183,BD
 1728861184,1728861439,ID
 1728861440,1728862207,AU
 1728862208,1728863231,PH
+1728863232,1728864255,CN
 1728864256,1728865279,AF
 1728865280,1728866303,AU
 1728866304,1728867327,VN
@@ -35076,6 +35990,7 @@
 1728878592,1728879615,MY
 1728879616,1728880127,IN
 1728880128,1728880383,JP
+1728880384,1728880639,AU
 1728880640,1728881663,KH
 1728881664,1728881919,ID
 1728881920,1728882175,AU
@@ -35100,11 +36015,14 @@
 1728900096,1728901119,BD
 1728901120,1728901375,ID
 1728901632,1728902143,ID
-1728902400,1728902655,IN
+1728902144,1728903167,IN
 1728903168,1728905215,KR
+1728905216,1728905471,IN
 1728905472,1728905727,PK
 1728905728,1728906239,IN
+1728906240,1728907263,MY
 1728907264,1728908287,NZ
+1728908288,1728909311,CN
 1728909312,1728912383,JP
 1728912384,1728913407,TH
 1728914432,1728915199,ID
@@ -35116,18 +36034,20 @@
 1728920576,1728921599,JP
 1728921600,1728922623,AF
 1728922624,1728923647,AU
-1728924416,1728924671,MY
+1728923648,1728924159,CN
+1728924160,1728924671,MY
 1728924672,1728925695,VN
 1728925696,1728927743,AU
 1728927744,1728928767,LA
 1728928768,1728929791,JP
 1728929792,1728930815,IN
 1728930816,1728931839,AU
-1728932864,1728933887,IN
+1728932864,1728934911,IN
 1728934912,1728935935,NZ
 1728935936,1728936959,MY
 1728936960,1728937983,CN
 1728937984,1728939007,SG
+1728939008,1728939519,BD
 1728939520,1728939775,PH
 1728939776,1728940031,IN
 1728940032,1728942079,JP
@@ -35143,16 +36063,16 @@
 1728951552,1728951807,ID
 1728951808,1728952063,SG
 1728952064,1728952319,IN
-1728952832,1728953087,NZ
-1728953088,1728953343,AU
+1728952320,1728952831,PH
+1728952832,1728953343,AU
 1728953344,1728954367,HK
-1728954368,1728955391,JP
 1728955392,1728956415,CN
 1728956416,1728957439,ID
 1728958464,1728959487,JP
 1728959488,1728960511,TH
 1728960512,1728961279,AU
 1728961280,1728961535,IN
+1728961536,1728962559,CN
 1728962560,1728963583,BD
 1728963584,1728964607,TH
 1728964608,1728965631,HK
@@ -35160,6 +36080,7 @@
 1728966656,1728967679,IN
 1728967680,1728968703,CN
 1728968704,1728970751,JP
+1728970752,1728971007,IN
 1728971008,1728971263,AU
 1728971264,1728971519,IN
 1728971520,1728971775,NZ
@@ -35168,6 +36089,8 @@
 1728973824,1728974847,JP
 1728974848,1728976383,ID
 1728976384,1728976895,AU
+1728977152,1728977407,AU
+1728977408,1728977919,BD
 1728977920,1728978943,MY
 1728979968,1728980991,MN
 1728980992,1728982015,AU
@@ -35182,15 +36105,19 @@
 1728988192,1728988199,US
 1728988200,1728989183,NZ
 1728989184,1728989695,BD
+1728989696,1728990207,ID
 1728990208,1728990335,MY
 1728990336,1728990463,ID
 1728990464,1728990975,KR
 1728990976,1728991231,SG
+1728991232,1728992255,JP
 1728992256,1728993279,CN
 1728993280,1728994303,PG
 1728994304,1728995327,AU
 1728995328,1728996095,IN
 1728996096,1728996351,SG
+1728996352,1728997375,CN
+1728997376,1728998399,IN
 1728998400,1728998655,ID
 1728998656,1728998911,BD
 1728998912,1728999423,ID
@@ -35216,6 +36143,7 @@
 1729020160,1729020415,BD
 1729020416,1729020671,PH
 1729020672,1729020927,ID
+1729020928,1729021951,IN
 1729021952,1729022975,AU
 1729022976,1729023999,BD
 1729024000,1729025023,IN
@@ -35226,7 +36154,6 @@
 1729027584,1729027839,JP
 1729027840,1729028095,HK
 1729028096,1729029119,SG
-1729029120,1729029375,AU
 1729029376,1729029631,ID
 1729029632,1729029887,AU
 1729029888,1729030143,PK
@@ -35239,7 +36166,6 @@
 1729035264,1729036287,AU
 1729036288,1729037311,JP
 1729037312,1729039359,CN
-1729039360,1729040383,JP
 1729040384,1729041407,CN
 1729041408,1729042687,HK
 1729042688,1729042943,SG
@@ -35251,8 +36177,7 @@
 1729046528,1729047551,BD
 1729047552,1729048575,AU
 1729048576,1729049599,VN
-1729049600,1729050623,IN
-1729051648,1729053695,IN
+1729049600,1729053695,IN
 1729053696,1729054719,JP
 1729054720,1729055231,AU
 1729055232,1729055487,IN
@@ -35290,16 +36215,15 @@
 1729081600,1729082111,AU
 1729082112,1729082367,IN
 1729082368,1729083391,HK
-1729083392,1729083647,JP
-1729083648,1729084415,HK
-1729084416,1729085439,JP
+1729083392,1729085439,JP
 1729085440,1729087487,HK
 1729087488,1729088511,CN
 1729088512,1729090559,AU
 1729090560,1729091583,JP
 1729091584,1729092607,HK
-1729092608,1729094143,BD
-1729094400,1729094655,IN
+1729093632,1729094143,BD
+1729094144,1729094399,ID
+1729094656,1729095679,IN
 1729095680,1729096703,SG
 1729096704,1729097215,AU
 1729097216,1729097727,AF
@@ -35307,6 +36231,7 @@
 1729098752,1729099775,BD
 1729099776,1729100543,IN
 1729100544,1729100799,ID
+1729100800,1729101823,IN
 1729101824,1729102847,VN
 1729102848,1729103871,IN
 1729103872,1729104895,JP
@@ -35314,6 +36239,7 @@
 1729105664,1729105919,VU
 1729105920,1729106943,SG
 1729106944,1729107967,NZ
+1729107968,1729108479,BD
 1729108480,1729108991,HK
 1729108992,1729111039,IN
 1729111040,1729112063,JP
@@ -35382,6 +36308,7 @@
 1729167360,1729168383,IN
 1729168384,1729169407,JP
 1729169408,1729170431,TW
+1729170432,1729171455,HK
 1729171456,1729171967,AU
 1729171968,1729172223,IN
 1729172224,1729172479,MY
@@ -35407,6 +36334,7 @@
 1729190912,1729191935,HK
 1729191936,1729195007,IN
 1729195008,1729195519,MN
+1729195520,1729196031,IN
 1729196032,1729197055,GU
 1729197056,1729198079,HK
 1729198080,1729199103,CN
@@ -35414,6 +36342,7 @@
 1729199616,1729199871,JP
 1729200128,1729201151,IN
 1729201152,1729202175,AU
+1729202176,1729203199,CN
 1729203200,1729205247,SG
 1729205248,1729206271,JP
 1729206272,1729207295,AU
@@ -35431,8 +36360,7 @@
 1729216768,1729217023,AU
 1729217024,1729217535,IN
 1729217536,1729217791,JP
-1729217792,1729218047,SG
-1729218048,1729218175,MY
+1729217792,1729218175,MY
 1729218176,1729218303,SG
 1729218304,1729218431,JP
 1729218432,1729218559,KR
@@ -35447,6 +36375,7 @@
 1729228800,1729229823,TW
 1729229824,1729230847,ID
 1729230848,1729231103,PH
+1729231104,1729231359,TH
 1729231360,1729232895,AU
 1729232896,1729233919,MY
 1729233920,1729234943,VN
@@ -35462,6 +36391,8 @@
 1729247744,1729248255,NZ
 1729248256,1729249279,JP
 1729249280,1729252351,IN
+1729252352,1729253375,ID
+1729253376,1729254399,BD
 1729254400,1729255423,AU
 1729255424,1729257471,MY
 1729257472,1729258495,ID
@@ -35488,7 +36419,9 @@
 1729274880,1729276927,IN
 1729276928,1729277951,BN
 1729277952,1729278975,VN
-1729280000,1729281023,HK
+1729278976,1729279231,BD
+1729279232,1729279487,ID
+1729279488,1729281023,HK
 1729281024,1729281535,AU
 1729281536,1729282047,ID
 1729282048,1729283071,CN
@@ -35505,7 +36438,9 @@
 1729294848,1729295103,IN
 1729295104,1729295359,PK
 1729295360,1729296383,MY
+1729296384,1729297407,IN
 1729297408,1729298431,AU
+1729298432,1729299455,JP
 1729299456,1729300479,NZ
 1729300480,1729300991,SG
 1729300992,1729301503,NZ
@@ -35516,8 +36451,10 @@
 1729304576,1729305599,HK
 1729305600,1729306623,JP
 1729306624,1729307647,PH
+1729307648,1729307903,BD
 1729307904,1729308159,ID
 1729308160,1729308415,HK
+1729308416,1729308671,IN
 1729308672,1729310719,CN
 1729310720,1729311743,JP
 1729311744,1729312767,IN
@@ -35574,14 +36511,18 @@
 1729372160,1729373183,CN
 1729373184,1729374207,JP
 1729374208,1729375231,TW
+1729375232,1729376255,CN
 1729376256,1729376767,AU
 1729376768,1729377023,SG
 1729377024,1729377279,ID
 1729377280,1729378303,BD
+1729378304,1729378559,AU
 1729378560,1729378815,IN
+1729378816,1729379071,KR
 1729379072,1729379327,SG
 1729379328,1729380351,HK
 1729380352,1729381375,IN
+1729381376,1729382399,CN
 1729382400,1729383423,JP
 1729383424,1729384447,PG
 1729384448,1729385471,KH
@@ -35590,10 +36531,8 @@
 1729386752,1729387007,BD
 1729387008,1729387519,ID
 1729387520,1729388543,SG
-1729388544,1729389567,HK
 1729390592,1729391103,IN
 1729391104,1729391615,ID
-1729391616,1729392639,JP
 1729392640,1729393663,CN
 1729393664,1729394687,KR
 1729394688,1729395711,TH
@@ -35626,14 +36565,13 @@
 1729419776,1729420031,IN
 1729420288,1729421311,HK
 1729421312,1729422335,MY
-1729422336,1729423359,HK
 1729423360,1729423871,VU
 1729423872,1729424383,AU
 1729424384,1729425407,HK
-1729425408,1729426431,JP
 1729426432,1729427455,AU
 1729427456,1729428479,CN
 1729428480,1729430527,AU
+1729431552,1729432575,HK
 1729432576,1729433599,PH
 1729433600,1729433855,IN
 1729433856,1729434111,AU
@@ -35680,18 +36618,18 @@
 1729476608,1729477631,IN
 1729477632,1729478655,AU
 1729478912,1729479423,NZ
-1729479424,1729479679,IN
 1729479680,1729480703,TW
 1729480704,1729481727,KR
 1729481728,1729482751,ID
 1729482752,1729483775,CN
 1729483776,1729485823,ID
-1729485824,1729486847,HK
 1729486848,1729488383,ID
 1729488384,1729488895,SB
-1729488896,1729489919,IN
+1729488896,1729490943,IN
 1729490944,1729491967,CN
-1729491968,1729492991,HK
+1729491968,1729492223,US
+1729492224,1729492479,AU
+1729492480,1729492991,US
 1729492992,1729494015,SB
 1729494016,1729495039,MY
 1729495040,1729519615,CN
@@ -35699,6 +36637,7 @@
 1729520640,1729527807,CN
 1729527808,1729528831,SG
 1729528832,1729530879,ID
+1729530880,1729531903,IN
 1729531904,1729532927,AU
 1729532928,1729533951,MY
 1729533952,1729534975,JP
@@ -35717,7 +36656,10 @@
 1729544192,1729545215,IN
 1729545216,1729546239,AU
 1729546240,1729546495,JP
-1729546496,1729547263,HK
+1729546496,1729546751,SG
+1729546752,1729547007,NZ
+1729547008,1729547263,HK
+1729547264,1729548287,ID
 1729548544,1729549311,AU
 1729550336,1729551359,MY
 1729551360,1729552383,KR
@@ -35727,6 +36669,7 @@
 1729554944,1729555455,NZ
 1729555456,1729556479,IN
 1729556480,1729557503,ID
+1729557504,1729558527,NZ
 1729558528,1729559551,ID
 1729559552,1729560575,CN
 1729560576,1729561599,AU
@@ -35737,6 +36680,7 @@
 1729565696,1729566719,ID
 1729566720,1729568255,IN
 1729568256,1729568511,ID
+1729568512,1729568767,BD
 1729568768,1729569791,ID
 1729569792,1729570815,AF
 1729570816,1729571839,AU
@@ -35748,6 +36692,7 @@
 1729576960,1729577983,AU
 1729577984,1729578495,HK
 1729578496,1729578751,AU
+1729578752,1729579007,NZ
 1729579008,1729580031,JP
 1729580032,1729581055,SG
 1729581056,1729583103,KR
@@ -35775,6 +36720,8 @@
 1729601536,1729603583,CN
 1729603584,1729604607,HK
 1729604608,1729604863,AU
+1729604864,1729605119,IN
+1729605120,1729605375,AU
 1729605376,1729605631,ID
 1729605632,1729606655,CN
 1729606656,1729607679,ID
@@ -35786,6 +36733,7 @@
 1729610072,1729610751,HK
 1729610752,1729611775,JP
 1729611776,1729612799,ID
+1729612800,1729613823,BD
 1729613824,1729614847,SG
 1729614848,1729615103,NZ
 1729615104,1729615359,KH
@@ -35805,7 +36753,7 @@
 1729627136,1729628159,SG
 1729628160,1729629183,KR
 1729629184,1729629695,ID
-1729629696,1729629951,NZ
+1729629696,1729629951,AU
 1729629952,1729630207,HK
 1729630208,1729631231,PH
 1729631232,1729632255,IN
@@ -35854,7 +36802,11 @@
 1729674240,1729675263,IN
 1729675264,1729676287,JP
 1729676288,1729677311,AU
-1729677312,1729678335,IN
+1729677312,1729677439,IN
+1729677440,1729677567,NL
+1729677568,1729677823,IN
+1729677824,1729678079,NL
+1729678080,1729678335,IN
 1729678336,1729679359,HK
 1729679360,1729680383,AU
 1729680384,1729681407,ID
@@ -35874,6 +36826,7 @@
 1729696768,1729702911,CN
 1729702912,1729703935,IN
 1729703936,1729704959,CN
+1729704960,1729705215,SG
 1729705216,1729705471,AU
 1729705472,1729705983,ID
 1729705984,1729706751,AU
@@ -35890,8 +36843,9 @@
 1729717248,1729718271,JP
 1729718272,1729719295,HK
 1729719296,1729720319,ID
-1729720320,1729721087,AU
+1729720320,1729721343,AU
 1729721344,1729722367,NZ
+1729722368,1729723391,BD
 1729723392,1729726463,IN
 1729726464,1729727487,PK
 1729727488,1729728511,KI
@@ -35941,17 +36895,22 @@
 1729774592,1729775615,AU
 1729775616,1729776127,IN
 1729776128,1729776639,MY
+1729776640,1729777663,CN
 1729777664,1729779711,PK
 1729779712,1729780735,AU
-1729780736,1729781503,HK
+1729780736,1729780991,HK
+1729780992,1729781247,ID
+1729781248,1729781503,HK
 1729781504,1729781759,TL
 1729781760,1729782783,IN
 1729782784,1729783551,ID
 1729783552,1729783807,NZ
 1729783808,1729785855,IN
 1729785856,1729786879,BD
+1729786880,1729787903,CN
 1729787904,1729789951,HK
 1729789952,1729790975,ID
+1729790976,1729791999,CN
 1729792000,1729793023,BD
 1729793024,1729794047,IN
 1729794048,1729795071,HK
@@ -35998,11 +36957,13 @@
 1729832448,1729832959,AU
 1729832960,1729833983,JP
 1729833984,1729835007,SG
+1729835008,1729836031,IN
 1729836032,1729837055,NZ
 1729837056,1729838079,CN
 1729838080,1729840127,VN
 1729840128,1729841151,JP
 1729841152,1729842175,MY
+1729842176,1729843199,HK
 1729843200,1729844223,JP
 1729844224,1729845247,IN
 1729845248,1729846271,NZ
@@ -36021,6 +36982,7 @@
 1729856512,1729857535,AU
 1729857536,1729858559,JP
 1729858560,1729859583,IN
+1729859584,1729860607,PH
 1729860608,1729861631,KR
 1729861632,1729862655,AU
 1729862656,1729863679,JP
@@ -36058,6 +37020,7 @@
 1729884160,1729885183,CN
 1729885184,1729886207,JP
 1729886208,1729887743,ID
+1729887744,1729887999,JP
 1729888000,1729888255,IN
 1729888256,1729889279,KH
 1729889280,1729891327,CN
@@ -36070,9 +37033,11 @@
 1729898496,1729899519,AU
 1729899520,1729900543,HK
 1729900544,1729901567,AU
+1729901568,1729902079,ID
 1729902080,1729902591,SG
 1729902592,1729903615,ID
 1729903616,1729905663,KR
+1729905664,1729906687,PH
 1729906688,1729906943,AU
 1729906944,1729907199,JP
 1729907200,1729907711,ID
@@ -36111,17 +37076,18 @@
 1729939968,1729940479,PH
 1729940480,1729941503,CN
 1729941504,1729942527,SG
+1729942528,1729943551,CN
 1729943552,1729944063,AU
 1729944064,1729946623,ID
 1729946624,1729949695,JP
 1729949696,1729950207,IN
 1729950208,1729950719,KH
+1729950720,1729951743,IN
 1729951744,1729951999,SG
 1729952000,1729952511,JP
 1729952512,1729952767,NZ
 1729952768,1729953791,IN
 1729954816,1729955839,ID
-1729955840,1729956863,BD
 1729956864,1729957887,HK
 1729957888,1729958911,CN
 1729958912,1729959935,PH
@@ -36187,11 +37153,9 @@
 1730017792,1730019327,PH
 1730019328,1730020351,ID
 1730020352,1730021375,HK
-1730021376,1730022399,JP
 1730022400,1730023423,IN
 1730023424,1730024447,HK
 1730024448,1730025471,CN
-1730025472,1730026495,HK
 1730026496,1730027519,BD
 1730027520,1730028543,SG
 1730028544,1730029567,VN
@@ -36200,16 +37164,17 @@
 1730031616,1730032639,HK
 1730032640,1730033663,JP
 1730033664,1730034687,ID
-1730034688,1730035711,JP
+1730035712,1730036735,IN
 1730036736,1730037759,HK
 1730037760,1730038783,JP
 1730038784,1730039807,HK
 1730039808,1730040831,IN
 1730040832,1730043903,ID
 1730043904,1730044927,CN
-1730044928,1730046975,HK
+1730044928,1730045951,HK
 1730046976,1730047999,KR
 1730048000,1730049023,TL
+1730049024,1730050047,IN
 1730050048,1730050303,AU
 1730050304,1730050559,SG
 1730050560,1730051071,ID
@@ -36225,17 +37190,20 @@
 1730062336,1730062591,AU
 1730062592,1730062847,BD
 1730062848,1730064383,ID
+1730064384,1730065407,IN
 1730065408,1730066431,ID
 1730066432,1730067455,AU
 1730067456,1730068479,BD
 1730068480,1730069503,IN
+1730069504,1730070527,PK
 1730070528,1730071551,CN
 1730071552,1730072575,KR
-1730072576,1730073599,SG
-1730073600,1730073855,HK
+1730072576,1730073343,SG
+1730073344,1730073855,HK
 1730074112,1730074367,AU
 1730074368,1730074623,SG
 1730075648,1730076671,ID
+1730076672,1730077695,IN
 1730077696,1730078719,CN
 1730078720,1730079743,HK
 1730079744,1730080767,CN
@@ -36243,7 +37211,8 @@
 1730081792,1730082815,ID
 1730082816,1730083839,PW
 1730084864,1730085887,CN
-1730085888,1730086911,AU
+1730085888,1730086399,SG
+1730086400,1730086911,AU
 1730086912,1730087935,HK
 1730087936,1730088959,JP
 1730088960,1730091007,HK
@@ -36267,7 +37236,6 @@
 1730112512,1730112767,BD
 1730112768,1730113535,ID
 1730113536,1730114559,AU
-1730114560,1730115583,JP
 1730115584,1730117631,VN
 1730117632,1730118655,KH
 1730118656,1730119679,ID
@@ -36283,7 +37251,13 @@
 1730128896,1730129919,SG
 1730129920,1730130943,BD
 1730130944,1730131967,KR
-1730131968,1730132991,HK
+1730131968,1730132015,HK
+1730132016,1730132223,US
+1730132224,1730132351,HK
+1730132352,1730132399,GB
+1730132400,1730132735,HK
+1730132736,1730132831,RO
+1730132832,1730132991,HK
 1730132992,1730134015,IN
 1730134016,1730135039,JP
 1730135040,1730136063,TW
@@ -36296,6 +37270,7 @@
 1730142208,1730143231,ID
 1730143232,1730144255,SG
 1730144256,1730145279,ID
+1730145280,1730146303,CN
 1730146304,1730147327,HK
 1730147328,1730148351,JP
 1730148352,1730149375,ID
@@ -36400,7 +37375,6 @@
 1730476800,1730477055,IN
 1730477056,1730478079,AU
 1730478080,1730479103,CN
-1730479104,1730480127,HK
 1730480128,1730480639,AU
 1730480640,1730481151,JP
 1730481152,1730483199,CN
@@ -36427,14 +37401,14 @@
 1730503680,1730505727,CN
 1730505728,1730508799,JP
 1730508800,1730509823,AU
-1730509824,1730510847,CN
+1730509824,1730510591,CN
+1730510592,1730510847,HK
 1730510848,1730511871,AU
 1730511872,1730512895,JP
 1730512896,1730521087,CN
 1730521088,1730522111,ID
 1730522112,1730524159,CN
 1730524160,1730525183,IN
-1730525184,1730526207,HK
 1730528256,1730529279,SG
 1730529280,1730529791,IN
 1730529792,1730530303,AU
@@ -36458,7 +37432,6 @@
 1730552832,1730553855,IN
 1730553856,1730555903,CN
 1730555904,1730556415,IN
-1730556928,1730557951,JP
 1730557952,1730558975,CN
 1730558976,1730559999,MY
 1730560000,1730561023,HK
@@ -36472,7 +37445,6 @@
 1730567168,1730569215,CN
 1730569216,1730570239,ID
 1730570240,1730571263,HK
-1730571264,1730572287,IN
 1730572288,1730573311,KH
 1730573312,1730574335,CN
 1730574336,1730575359,AU
@@ -36498,14 +37470,11 @@
 1730592768,1730593791,MY
 1730593792,1730594815,NP
 1730594816,1730596863,IN
-1730596864,1730597887,JP
 1730597888,1730598911,PH
-1730598912,1730599423,AU
 1730599424,1730599935,VU
 1730599936,1730604031,CN
 1730604032,1730605055,NP
 1730605056,1730607103,IN
-1730607104,1730608127,JP
 1730608128,1730609151,CN
 1730609152,1730610687,IN
 1730610688,1730610943,MY
@@ -36540,16 +37509,14 @@
 1730638848,1730639871,IN
 1730639872,1730640383,AU
 1730640384,1730640895,MY
-1730640896,1730641919,JP
 1730641920,1730643967,IN
 1730643968,1730644735,AU
 1730644736,1730644991,IN
 1730644992,1730646015,MY
-1730646016,1730647039,CN
 1730647040,1730649087,HK
 1730649088,1730650111,IN
 1730650112,1730658303,CN
-1730658304,1730660351,JP
+1730658304,1730659327,JP
 1730660352,1730669567,CN
 1730669568,1730670079,IN
 1730670080,1730670591,AU
@@ -36586,10 +37553,8 @@
 1730706432,1730708479,JP
 1730708480,1730713599,TH
 1730713600,1730714623,HK
-1730714624,1730715647,JP
 1730715648,1730716671,HK
 1730716672,1730717183,PH
-1730717184,1730717695,AU
 1730717696,1730718719,IN
 1730718720,1730720767,HK
 1730720768,1730723839,TH
@@ -36617,19 +37582,16 @@
 1730756352,1730756607,CN
 1730756608,1730757631,HK
 1730757632,1730758655,SG
-1730758656,1730759679,JP
-1730759680,1730760703,SG
 1730760704,1730761727,HK
 1730761728,1730762751,TH
 1730762752,1730766847,IN
-1730766848,1730767871,HK
+1730766848,1730767871,CN
 1730767872,1730768127,AU
 1730768128,1730768639,ID
 1730768640,1730768895,BD
-1730768896,1730769919,JP
 1730769920,1730770943,CN
 1730770944,1730771967,ID
-1730771968,1730772991,HK
+1730771968,1730772991,CN
 1730772992,1730774015,SG
 1730774016,1730775039,HK
 1730775040,1730776063,JP
@@ -36645,7 +37607,8 @@
 1730784256,1730785279,HK
 1730785280,1730785535,NL
 1730785536,1730786303,AU
-1730786304,1730788351,HK
+1730786304,1730787583,HK
+1730787584,1730788351,CN
 1730788352,1730790399,ID
 1730790400,1730791423,IN
 1730791424,1730794495,ID
@@ -36660,18 +37623,15 @@
 1730803712,1730804735,HK
 1730804736,1730805759,JP
 1730805760,1730806783,AF
-1730806784,1730807807,JP
 1730807808,1730808831,CN
 1730808832,1730809855,HK
 1730809856,1730810623,IN
 1730810624,1730811903,AU
 1730811904,1730814975,CN
-1730814976,1730815999,HK
 1730816000,1730817023,ID
 1730817024,1730818047,JP
 1730818048,1730818815,AU
 1730818816,1730819071,IN
-1730819072,1730820095,JP
 1730820096,1730821119,VN
 1730821120,1730822143,HK
 1730822144,1730824191,CN
@@ -36687,7 +37647,6 @@
 1730834944,1730835455,IN
 1730835456,1730837503,ID
 1730837504,1730838527,IN
-1730838528,1730839551,TH
 1730839552,1730840575,AU
 1730840576,1730841599,SG
 1730841600,1730842623,AU
@@ -36704,27 +37663,22 @@
 1730854400,1730854655,NZ
 1730854656,1730854911,HK
 1730854912,1730856959,IN
-1730856960,1730857983,JP
 1730857984,1730858239,AU
 1730858240,1730858495,ID
 1730858496,1730859007,IN
 1730859008,1730860031,BN
 1730860032,1730861055,HK
 1730861056,1730862079,MM
-1730862080,1730863103,JP
 1730863104,1730864127,AU
 1730864128,1730865151,TW
 1730865152,1730866175,CN
 1730866176,1730867199,AU
-1730867200,1730868223,JP
-1730868224,1730869247,KR
 1730869248,1730870271,IN
 1730870272,1730871807,ID
 1730871808,1730873343,IN
 1730873344,1730875391,HK
 1730875392,1730876415,CN
 1730876416,1730877439,AU
-1730877440,1730878463,CN
 1730878464,1730879487,HK
 1730879488,1730881023,IN
 1730881024,1730881535,AU
@@ -36748,7 +37702,8 @@
 1730895872,1730898943,CN
 1730898944,1730899967,MO
 1730899968,1730900991,IN
-1730900992,1730901503,AU
+1730900992,1730901247,HK
+1730901248,1730901503,SG
 1730901504,1730901759,DE
 1730901760,1730902015,AU
 1730902016,1730903039,KR
@@ -36807,7 +37762,9 @@
 1730951168,1730952191,CN
 1730952192,1730954239,HK
 1730954240,1730955263,SG
-1730955264,1730957311,BD
+1730955264,1730956031,BD
+1730956032,1730956287,US
+1730956288,1730957311,BD
 1730957312,1730958335,CN
 1730958336,1730959359,JP
 1730959360,1730960383,CN
@@ -36879,7 +37836,8 @@
 1731123200,1731124223,PF
 1731124224,1731125247,AU
 1731125248,1731126271,HK
-1731126272,1731127295,AU
+1731126272,1731127039,AU
+1731127040,1731127295,NZ
 1731127296,1731130367,IN
 1731130368,1731132415,CN
 1731132416,1731133439,SG
@@ -37135,11 +38093,12 @@
 1731426304,1731427327,BD
 1731427328,1731428351,KH
 1731428352,1731428607,IN
-1731428608,1731428863,NZ
 1731428864,1731429119,AU
 1731429120,1731429375,ID
 1731429376,1731431423,IN
-1731431424,1731432447,TW
+1731431424,1731431935,TR
+1731431936,1731432191,TW
+1731432192,1731432447,TR
 1731432448,1731433471,HK
 1731433472,1731435519,IN
 1731435520,1731436031,NZ
@@ -37209,7 +38168,8 @@
 1731509248,1731510271,HK
 1731510272,1731510527,MY
 1731510528,1731510783,AU
-1731510784,1731511295,IN
+1731510784,1731511039,IN
+1731511040,1731511295,US
 1731511296,1731512319,CN
 1731512320,1731513343,KR
 1731513344,1731514367,NZ
@@ -37346,9 +38306,7 @@
 1731660544,1731660799,BN
 1731660800,1731661823,JP
 1731661824,1731662847,AU
-1731662848,1731663871,HK
-1731663872,1731664895,CN
-1731664896,1731665919,HK
+1731662848,1731665919,HK
 1731665920,1731666175,AU
 1731666176,1731666431,ID
 1731666432,1731666687,AU
@@ -37717,8 +38675,8 @@
 1732127744,1732128767,HK
 1732128768,1732129023,SG
 1732129024,1732129279,NZ
-1732129280,1732129535,AU
-1732129536,1732129791,HK
+1732129280,1732129790,AU
+1732129791,1732129791,HK
 1732129792,1732130815,CN
 1732130816,1732134911,IN
 1732134912,1732140031,CN
@@ -37884,7 +38842,9 @@
 1740792832,1740794879,HK
 1740794880,1740795903,KR
 1740795904,1740796415,NZ
-1740796416,1740798207,IN
+1740796416,1740796671,IN
+1740796672,1740796927,AU
+1740796928,1740798207,IN
 1740798208,1740798463,AU
 1740798464,1740798975,IN
 1740798976,1740799999,AU
@@ -37917,7 +38877,6 @@
 1740834816,1740835839,NZ
 1740835840,1740836863,AU
 1740836864,1740837119,IN
-1740837120,1740837375,AU
 1740837376,1740837887,ID
 1740837888,1740838911,MY
 1740838912,1740839935,IN
@@ -37935,7 +38894,7 @@
 1740850176,1740855295,IN
 1740855296,1740856319,ID
 1740856320,1740858367,IN
-1740858368,1740859391,SG
+1740858368,1740859391,US
 1740859392,1740860415,CN
 1740860416,1740861439,HK
 1740861440,1740862463,CN
@@ -37953,7 +38912,8 @@
 1740873728,1740874751,CN
 1740874752,1740876287,ID
 1740876288,1740876799,AU
-1740876800,1740880895,IN
+1740876800,1740880639,IN
+1740880640,1740880895,HK
 1740880896,1740881919,SG
 1740881920,1740882943,CN
 1740882944,1740884991,IN
@@ -37969,7 +38929,7 @@
 1740903424,1740904447,HK
 1740904448,1740904959,NZ
 1740904960,1740907519,IN
-1740907520,1740908543,HK
+1740907520,1740908543,US
 1740908544,1740909055,PK
 1740909056,1740910591,ID
 1740910592,1740911615,CN
@@ -38003,11 +38963,9 @@
 1740938496,1740938751,IN
 1740938752,1740939263,TH
 1740939264,1740940287,PK
-1740940288,1740941311,JP
 1740941312,1740942335,CN
 1740942336,1740943359,TW
-1740943360,1740944383,KR
-1740944384,1740945407,AU
+1740944384,1740945407,US
 1740945408,1740946431,CN
 1740946432,1740947967,IN
 1740947968,1740948223,AU
@@ -38017,7 +38975,8 @@
 1740951552,1740957695,IN
 1740957696,1740958719,BD
 1740958720,1740959743,VN
-1740959744,1740960767,IN
+1740959744,1740960255,NL
+1740960256,1740960767,IN
 1740960768,1740962815,VN
 1740962816,1740964863,SG
 1740964864,1740965887,HK
@@ -38030,14 +38989,448 @@
 1740975104,1740976127,PK
 1740976128,1740976639,BD
 1740976640,1740976895,SG
-1740977152,1740978175,NZ
+1740976896,1740977151,IN
+1740977152,1740977663,NZ
+1740977664,1740977919,GB
+1740977920,1740978175,NZ
 1740978176,1740979199,MY
 1740979200,1740980223,NZ
 1740980224,1740981247,AU
 1740981248,1740982271,HK
+1740982272,1740985343,IN
+1740985344,1740986367,PH
+1740986368,1740986623,AU
+1740986624,1740986879,ID
+1740986880,1740987391,IN
+1740987392,1740988415,ID
+1740988416,1740989439,SG
+1740989440,1740990463,IN
+1740990464,1740991487,KH
+1740991488,1741000703,IN
+1741000704,1741001727,AU
+1741001728,1741002751,HK
+1741002752,1741003775,BD
+1741003776,1741004799,HK
+1741004800,1741005823,AU
+1741005824,1741006847,MV
+1741006848,1741007871,HK
+1741007872,1741008895,TW
+1741008896,1741009919,BT
+1741009920,1741010943,CN
+1741010944,1741011455,IN
+1741011456,1741011967,AU
+1741011968,1741012991,ID
+1741012992,1741014015,HK
+1741014016,1741015039,MM
+1741015040,1741016063,PH
+1741016064,1741017087,BD
+1741017088,1741018111,JP
+1741018112,1741019135,AU
+1741019136,1741020159,HK
+1741020160,1741022207,IN
+1741022208,1741023231,CN
+1741023232,1741025279,AU
+1741025280,1741026303,IN
+1741026304,1741027327,TH
+1741027328,1741028351,BD
+1741028352,1741029375,CN
+1741029376,1741029631,SG
+1741029632,1741029887,HK
+1741029888,1741030399,BD
+1741030400,1741031423,JP
+1741031424,1741031935,NP
+1741031936,1741032447,IN
+1741032448,1741033471,JP
+1741033472,1741033983,MY
+1741033984,1741034495,HK
+1741034496,1741035519,CN
+1741035520,1741036031,AU
+1741036544,1741037567,IN
+1741037568,1741038079,AU
+1741038080,1741038591,IN
+1741038592,1741039615,JP
+1741039616,1741040639,AU
+1741040640,1741042687,HK
+1741042688,1741043199,MY
+1741043200,1741043711,AU
+1741043712,1741044735,HK
+1741044736,1741046783,CN
+1741046784,1741047807,MY
+1741047808,1741048831,CN
+1741048832,1741049855,SG
+1741049856,1741050367,IN
+1741050368,1741050623,HK
+1741050624,1741050879,IN
+1741050880,1741051903,MY
+1741051904,1741052927,PH
+1741052928,1741053183,AU
+1741053184,1741053439,ID
+1741053440,1741055999,IN
+1741056000,1741056511,NZ
+1741056512,1741057023,AU
+1741057024,1741058047,JP
+1741058048,1741058559,AU
+1741058560,1741061119,ID
+1741061120,1741062143,CN
+1741062144,1741062655,IN
+1741062656,1741062911,AU
+1741062912,1741063167,ID
+1741063168,1741065215,BD
+1741065216,1741067263,SG
+1741067264,1741068287,MM
+1741068288,1741069311,TH
+1741069312,1741070335,CN
+1741070336,1741071359,JP
+1741071360,1741072383,IN
+1741072384,1741073407,BD
+1741073408,1741074431,IN
+1741074432,1741075455,TL
+1741075456,1741076479,CN
+1741076480,1741077247,NZ
+1741077248,1741077503,IN
+1741077504,1741079551,HK
+1741079552,1741081599,CN
+1741081600,1741082623,HK
+1741082624,1741084671,JP
+1741084672,1741092863,CN
+1741092864,1741093887,HK
+1741093888,1741094911,BD
+1741094912,1741095423,NZ
+1741095424,1741095935,ID
+1741095936,1741115391,VN
+1741115392,1741115647,AU
+1741115648,1741115903,NZ
+1741115904,1741116415,AU
+1741116416,1741117439,BD
+1741117440,1741119487,IN
+1741119488,1741119743,AU
+1741119744,1741120511,IN
+1741120512,1741122559,HK
+1741122560,1741123583,BD
+1741123584,1741125119,IN
+1741125120,1741125375,ID
+1741125376,1741125631,AU
+1741125632,1741128703,IN
+1741128704,1741129727,JP
+1741129728,1741130751,IN
+1741131776,1741132799,IN
+1741132800,1741133823,HK
+1741133824,1741134847,BD
+1741134848,1741136895,IN
+1741136896,1741137919,CN
+1741137920,1741138431,BD
+1741138432,1741138943,TH
+1741138944,1741145087,IN
+1741145088,1741146111,CN
+1741146112,1741150207,IN
+1741150208,1741151231,MY
+1741151232,1741152255,JP
+1741152256,1741153279,IN
+1741153280,1741154303,CN
+1741154304,1741155327,BD
+1741155328,1741156351,ID
+1741156352,1741157375,IN
+1741157376,1741158399,HK
+1741158400,1741160447,CN
+1741160448,1741161471,TW
+1741161472,1741162239,SG
+1741162240,1741162495,ID
+1741162496,1741164543,AU
+1741164544,1741165567,ID
+1741165568,1741167615,VN
+1741167616,1741169663,CN
+1741169664,1741170687,BD
+1741170688,1741173759,IN
+1741173760,1741174783,CN
+1741174784,1741175807,IN
+1741175808,1741176831,VN
+1741176832,1741178879,CN
+1741178880,1741183999,IN
+1741184000,1741185023,BD
+1741185024,1741186047,JP
+1741186048,1741188095,IN
+1741188096,1741191167,HK
+1741191168,1741192191,VN
+1741192192,1741193215,HK
+1741193216,1741194239,ID
+1741194240,1741195263,MM
+1741195264,1741210623,CN
+1741210624,1741211647,PK
+1741211648,1741212671,SG
+1741213696,1741214719,SG
+1741214720,1741215743,IN
+1741215744,1741216767,SG
+1741216768,1741232127,CN
+1741232128,1741233151,HK
+1741233152,1741243391,CN
+1741243392,1741245439,HK
+1741245440,1741257727,CN
+1741257728,1741258751,IN
+1741258752,1741259775,JP
+1741259776,1741264895,IN
+1741264896,1741303807,CN
+1741303808,1741304831,HK
+1741304832,1741305855,BD
+1741305856,1741329407,CN
+1741329408,1741330431,MH
+1741330432,1741344767,CN
+1741344768,1741345791,AU
+1741345792,1741346815,CN
+1741346816,1741347327,JP
+1741347328,1741347583,PH
+1741347584,1741347839,AU
+1741347840,1741348863,BD
+1741348864,1741349375,PH
+1741349376,1741349631,IN
+1741349632,1741349887,ID
+1741349888,1741350911,CN
+1741350912,1741351935,US
+1741351936,1741366271,CN
+1741366272,1741367295,IN
+1741367296,1741368319,HK
+1741368320,1741369343,PK
+1741369344,1741370367,HK
+1741370368,1741372415,CN
+1741372416,1741376511,IN
+1741376512,1741377535,ID
+1741377536,1741380095,IN
+1741380096,1741380351,SG
+1741380352,1741380607,ID
+1741380608,1741381631,BD
+1741381632,1741390847,CN
+1741390848,1741391871,MM
+1741391872,1741392895,IN
+1741392896,1741393919,CN
+1741393920,1741394943,IN
+1741394944,1741395967,HK
+1741395968,1741396991,SG
+1741396992,1741398015,JP
+1741398016,1741398783,ID
+1741398784,1741399039,AU
+1741399040,1741401087,CN
+1741401088,1741402111,IN
+1741402112,1741403135,BD
+1741403136,1741404159,HK
+1741404160,1741405183,IN
+1741405184,1741405439,NZ
+1741405440,1741405695,ID
+1741405696,1741406207,AU
+1741406208,1741407231,CN
+1741407232,1741408255,AU
+1741408256,1741409279,CN
+1741409280,1741411327,IN
+1741411328,1741413375,CN
+1741413376,1741414399,HK
+1741414400,1741423615,IN
+1741423616,1741425663,MY
+1741425664,1741425919,TH
+1741425920,1741426175,JP
+1741426176,1741426687,AU
+1741426688,1741427711,MM
+1741427712,1741428735,IN
+1741428736,1741429759,CN
+1741429760,1741436927,IN
+1741436928,1741437951,JP
+1741437952,1741438975,PH
+1741438976,1741439999,JP
+1741440000,1741440511,SG
+1741440512,1741440767,IN
+1741440768,1741441023,AF
+1741441024,1741442047,CN
+1741442048,1741443071,HK
+1741443072,1741445119,BD
+1741445120,1741446143,CN
+1741446144,1741447167,SG
+1741447168,1741448191,HK
+1741448192,1741449215,MM
+1741449216,1741450239,AU
+1741450240,1741451263,HK
+1741451264,1741452287,CN
+1741452288,1741452543,IN
+1741452544,1741452799,AU
+1741452800,1741453055,ID
+1741453056,1741455359,IN
+1741455360,1741456383,BD
+1741456384,1741457407,IN
+1741457408,1741462527,CN
+1741462528,1741466623,IN
+1741466624,1741467647,JP
+1741467648,1741469695,HK
+1741469696,1741472767,IN
+1741472768,1741473791,CN
+1741473792,1741474815,BD
+1741474816,1741475839,IN
+1741475840,1741476863,BD
+1741476864,1741477887,AU
+1741477888,1741478655,IN
+1741478656,1741478911,AU
+1741478912,1741479935,NP
+1741479936,1741480447,AU
+1741480448,1741480959,NZ
+1741480960,1741481471,AU
+1741481472,1741481727,JP
+1741481728,1741481983,IN
+1741481984,1741484031,CN
+1741484032,1741485055,AU
+1741485056,1741486079,BD
+1741486080,1741487103,NZ
+1741487104,1741489151,HK
+1741489152,1741491199,CN
+1741491200,1741492223,IN
+1741492224,1741493247,LA
+1741493248,1741494271,HK
+1741494272,1741495295,KH
+1741495296,1741497343,AU
+1741497344,1741497855,PH
+1741497856,1741498111,NZ
+1741498112,1741498367,IN
+1741498368,1741500415,CN
+1741500416,1741501439,JP
+1741501440,1741502463,CN
+1741502464,1741502975,ID
+1741502976,1741503487,BD
+1741503488,1741505535,IN
+1741505536,1741506559,BD
+1741506560,1741507583,JP
+1741507584,1741508607,SG
+1741508608,1741508863,AU
+1741508864,1741509119,SG
+1741509120,1741509375,ID
+1741509376,1741509631,IN
+1741509632,1741511679,JP
+1741511680,1741512703,IN
+1741512704,1741515775,VN
+1741515776,1741516799,CN
+1741516800,1741517823,IN
+1741517824,1741519871,CN
+1741519872,1741521919,IN
+1741521920,1741522943,BD
+1741522944,1741523967,CN
+1741523968,1741528063,IN
+1741528064,1741529087,PH
+1741529088,1741529599,TH
+1741529600,1741529855,CN
+1741529856,1741530111,IN
+1741530112,1741531135,HK
+1741531136,1741532159,JP
+1741532160,1741533183,IN
+1741533184,1741534207,PK
+1741534208,1741535231,BD
+1741535232,1741535487,JP
+1741535488,1741535743,IN
+1741535744,1741536255,SG
+1741536256,1741540351,CN
+1741540352,1741541375,AU
+1741541376,1741542399,MY
+1741542400,1741546495,IN
+1741546496,1741547519,AU
+1741547520,1741548543,BD
+1741548544,1741549567,CN
+1741549568,1741550591,HK
+1741550592,1741551103,IN
+1741551104,1741551615,AU
+1741551616,1741554687,CN
+1741554688,1741557759,IN
+1741557760,1741558783,AU
+1741558784,1741559807,HK
+1741559808,1741560831,SG
+1741560832,1741561087,AU
+1741561088,1741561855,SG
+1741561856,1741562879,NZ
+1741562880,1741563903,HK
+1741563904,1741564927,SG
+1741564928,1741565951,CN
+1741565952,1741572607,IN
+1741572608,1741573119,KR
+1741573120,1741574143,JP
+1741574144,1741575167,PH
+1741575168,1741576191,PK
+1741576192,1741577215,JP
+1741577216,1741578239,HK
+1741578240,1741578751,IN
+1741578752,1741579007,SG
+1741579008,1741581311,IN
+1741581312,1741582335,CN
+1741582336,1741584383,IN
+1741584384,1741586431,HK
+1741586432,1741591551,IN
+1741591552,1741592575,CN
+1741592576,1741593087,MN
+1741593088,1741593599,AU
+1741593600,1741594111,HK
+1741594112,1741594367,MY
+1741594368,1741596671,IN
+1741596672,1741597695,ID
+1741597696,1741597951,IN
+1741597952,1741598207,MM
+1741598208,1741600767,IN
+1741600768,1741601279,BD
+1741601280,1741601535,ID
+1741601536,1741601791,AU
+1741601792,1741602815,HK
+1741602816,1741603839,MN
+1741603840,1741604863,JP
+1741604864,1741605887,PH
+1741605888,1741606911,TH
+1741606912,1741607935,IN
+1741607936,1741609983,VN
+1741609984,1741612031,IN
+1741612032,1741613055,BD
+1741613056,1741614079,HK
+1741614080,1741615103,AU
+1741615104,1741617151,ID
+1741617152,1741618175,IN
+1741618176,1741619199,ID
+1741619200,1741623295,IN
+1741623296,1741623551,NZ
+1741623552,1741623807,IN
+1741623808,1741624063,AU
+1741624064,1741624319,MY
+1741624320,1741625343,JP
+1741625344,1741626367,HK
+1741626368,1741627391,AU
+1741627392,1741629439,VN
+1741629440,1741631487,IN
+1741631488,1741632511,CN
+1741632512,1741636607,IN
+1741636608,1741637631,HK
+1741637632,1741638655,PH
+1741638656,1741639679,NZ
+1741639680,1741640703,NP
+1741640704,1741641727,PK
+1741641728,1741642751,BD
+1741642752,1741643007,AU
+1741643008,1741643263,KR
+1741643264,1741643775,AU
+1741643776,1741644799,ID
+1741644800,1741645311,KR
+1741645312,1741645567,AU
+1741645568,1741645823,IN
+1741645824,1741646847,CN
+1741646848,1741647871,SG
+1741647872,1741648895,KH
+1741648896,1741649919,HK
+1741649920,1741658111,IN
+1741658112,1741658623,BD
+1741658624,1741659135,AU
+1741659136,1741659647,SG
+1741659648,1741659903,PH
+1741659904,1741660159,HK
+1741660160,1741661183,IN
+1741661184,1741662207,CN
+1741662208,1741666303,IN
+1741666304,1741674495,CN
+1741674496,1741675519,JP
+1741675520,1741676543,CN
+1741676544,1741677567,IN
+1741677568,1741679615,CN
+1741679616,1741680639,ID
+1741680640,1741683711,IN
+1741683712,1741684735,TW
 1742734336,1742735359,IN
 1742735360,1742736383,JP
 1742736384,1742737407,PK
+1742737408,1742738431,CN
 1742738432,1742738687,HK
 1742738688,1742738943,AU
 1742738944,1742739199,HK
@@ -38050,7 +39443,6 @@
 1742746112,1742746623,IN
 1742746624,1742747135,AU
 1742747136,1742747391,IN
-1742747392,1742747647,AU
 1742747648,1742748671,HK
 1742748672,1742749695,CN
 1742749696,1742750719,ID
@@ -38069,7 +39461,9 @@
 1742760960,1742761983,IN
 1742761984,1742763007,AU
 1742763008,1742764031,SG
-1742764032,1742765823,AU
+1742764032,1742764287,AU
+1742764288,1742764543,SG
+1742764544,1742765823,AU
 1742765824,1742766079,AF
 1742766080,1742767103,NZ
 1742767104,1742768127,TW
@@ -38131,7 +39525,9 @@
 1742835712,1742836735,JP
 1742836736,1742837759,ID
 1742837760,1742838783,JP
-1742838784,1742841855,AU
+1742838784,1742840831,AU
+1742840832,1742841087,US
+1742841088,1742841855,AU
 1742841856,1742842367,TH
 1742842368,1742843391,ID
 1742843392,1742843647,IN
@@ -38154,7 +39550,6 @@
 1742859264,1742860287,VN
 1742860288,1742860799,AU
 1742860800,1742861055,ID
-1742861056,1742861311,AU
 1742861312,1742862335,NP
 1742862336,1742862847,IN
 1742862848,1742863359,HK
@@ -38228,8 +39623,7 @@
 1742933504,1742933759,ID
 1742933760,1742934015,NZ
 1742934016,1742935039,AF
-1742935040,1742937087,AU
-1742937088,1742938111,NZ
+1742935040,1742938111,AU
 1742938112,1742939135,TW
 1742939136,1742940159,IN
 1742940160,1742941183,JP
@@ -38263,9 +39657,7 @@
 1742978048,1742979071,JP
 1742979072,1742980095,HK
 1742980096,1742981119,CN
-1742981120,1742981375,NZ
-1742981376,1742981631,AU
-1742981632,1742982143,NZ
+1742981120,1742982143,AU
 1742982144,1742983167,CN
 1742983168,1742984191,IN
 1742984192,1742985215,CN
@@ -38313,6 +39705,8 @@
 1743026176,1743027199,BD
 1743027200,1743028223,AU
 1743028224,1743029247,CN
+1743029504,1743029759,AU
+1743029760,1743030271,BD
 1743031296,1743035391,IN
 1743035392,1743036415,PK
 1743036416,1743037439,CN
@@ -38432,6 +39826,7 @@
 1743149056,1743150079,KR
 1743150080,1743151103,JP
 1743151104,1743152127,CN
+1743152128,1743152383,ID
 1743152384,1743153151,IN
 1743153152,1743154175,BD
 1743154176,1743155199,HK
@@ -38443,7 +39838,7 @@
 1743163392,1743166463,IN
 1743166464,1743167487,AU
 1743167488,1743168511,HK
-1743169024,1743169535,IN
+1743168512,1743169535,IN
 1743169536,1743170559,JP
 1743171584,1743172607,AU
 1743172608,1743173631,BD
@@ -38692,6 +40087,8 @@
 1743438848,1743439871,JP
 1743439872,1743440895,BD
 1743440896,1743441919,TW
+1743441920,1743442943,ID
+1743442944,1743443967,IN
 1743443968,1743444991,ID
 1743444992,1743446015,HK
 1743446016,1743448063,TW
@@ -38760,7 +40157,8 @@
 1743553536,1743554559,PK
 1743554560,1743555583,HK
 1743555584,1743557631,JP
-1743557632,1743558655,ID
+1743557632,1743558143,SG
+1743558144,1743558655,ID
 1743558656,1743560703,IN
 1743560704,1743561215,ID
 1743561216,1743561727,AU
@@ -38936,7 +40334,7 @@
 1743795200,1743796223,NZ
 1743796224,1743797247,JP
 1743797248,1743798271,TH
-1743798272,1743800319,HK
+1743798272,1743799295,HK
 1743800320,1743801343,CN
 1743801344,1743802367,IN
 1743802368,1743803391,HK
@@ -38948,6 +40346,7 @@
 1743809536,1743810559,ID
 1743810560,1743811583,KH
 1743811584,1743812607,JP
+1743812608,1743813631,PH
 1743813632,1743814655,CN
 1743814656,1743815679,SG
 1743815680,1743815935,AU
@@ -38997,6 +40396,7 @@
 1743864832,1743865855,TW
 1743865856,1743866879,CN
 1743866880,1743867903,KR
+1743867904,1743868927,IN
 1743868928,1743870975,NZ
 1743870976,1743873023,CN
 1743873024,1743874047,AU
@@ -39025,9 +40425,12 @@
 1743897600,1743899647,AU
 1743899648,1743900671,ID
 1743900672,1743901695,JP
+1743901696,1743902463,AU
+1743902464,1743902719,US
 1743902720,1743903743,AU
 1743903744,1743904767,CN
 1743904768,1743905791,IN
+1743905792,1743906815,HK
 1743906816,1743908863,IN
 1743908864,1743909375,AU
 1743909376,1743910911,IN
@@ -39056,6 +40459,8 @@
 1743931392,1743932415,HK
 1743932416,1743933439,IN
 1743933440,1743934463,AU
+1743934464,1743934975,ID
+1743934976,1743935487,IN
 1743935488,1743936511,SG
 1743936512,1743937535,AU
 1743937536,1743938559,MM
@@ -39067,6 +40472,7 @@
 1743944704,1743945215,ID
 1743945216,1743945727,TO
 1743945728,1743947775,CN
+1743947776,1743948799,IN
 1743948800,1743949823,HK
 1743949824,1743950847,TH
 1743950848,1743951359,HK
@@ -39096,12 +40502,15 @@
 1743976448,1743977471,AU
 1743977472,1743978495,JP
 1743978496,1743979519,HK
-1743980544,1743981567,IN
-1743981568,1743982591,SG
+1743979520,1743981567,IN
+1743981568,1743981823,AU
+1743981824,1743982079,SG
+1743982080,1743982335,HK
+1743982336,1743982591,SG
 1743982592,1743983359,AU
 1743983360,1743983615,IN
 1743983616,1743984639,KR
-1743984640,1743985663,CN
+1743984640,1743985663,HK
 1743985664,1743990783,IN
 1743991808,1743994879,IN
 1743994880,1743995903,AU
@@ -39119,7 +40528,7 @@
 1744006656,1744006911,AU
 1744006912,1744009215,IN
 1744009216,1744010239,JP
-1744011264,1744012287,HK
+1744010240,1744011263,IN
 1744012288,1744013311,IN
 1744013312,1744014335,CN
 1744014336,1744015359,BD
@@ -39136,6 +40545,7 @@
 1744024320,1744024575,AF
 1744024576,1744025599,HK
 1744025600,1744026623,IN
+1744026624,1744027647,SG
 1744027648,1744028671,MY
 1744028672,1744029695,JP
 1744029696,1744030719,KR
@@ -39159,6 +40569,7 @@
 1744049152,1744050175,BD
 1744050176,1744051199,HK
 1744051200,1744052223,PH
+1744052224,1744053247,IN
 1744053248,1744054271,ID
 1744054272,1744055295,KR
 1744055296,1744056319,HK
@@ -39174,6 +40585,7 @@
 1744069632,1744070655,SG
 1744070656,1744071679,JP
 1744071680,1744072703,KR
+1744073728,1744074751,CN
 1744074752,1744076799,IN
 1744076800,1744077823,AU
 1744077824,1744078847,PK
@@ -39211,6 +40623,7 @@
 1744109568,1744110591,IN
 1744110592,1744111615,JP
 1744111616,1744113663,IN
+1744113664,1744114687,ID
 1744114688,1744115455,IN
 1744115456,1744115711,CN
 1744115712,1744116735,MY
@@ -39250,7 +40663,6 @@
 1744150528,1744151551,TO
 1744151552,1744152319,LA
 1744152320,1744152575,TH
-1744152576,1744153599,JP
 1744153600,1744154623,NZ
 1744154880,1744155135,ID
 1744155136,1744155647,BD
@@ -39279,7 +40691,7 @@
 1744184576,1744184831,SG
 1744184832,1744185087,HK
 1744185088,1744185343,JP
-1744186368,1744187903,IN
+1744185344,1744187903,IN
 1744187904,1744188159,TH
 1744188160,1744188415,AU
 1744188416,1744189439,NZ
@@ -39309,7 +40721,9 @@
 1744208384,1744208895,AU
 1744208896,1744209919,CN
 1744209920,1744210943,AU
-1744210944,1744211967,SG
+1744210944,1744211199,JP
+1744211200,1744211455,HK
+1744211456,1744211967,SG
 1744211968,1744212991,KH
 1744212992,1744213503,SG
 1744213504,1744214015,JP
@@ -39324,8 +40738,9 @@
 1744221184,1744222207,NZ
 1744222208,1744222719,ID
 1744222720,1744222975,AU
+1744222976,1744223231,IN
 1744223232,1744224255,TH
-1744225280,1744226303,IN
+1744224256,1744226303,IN
 1744226304,1744226559,SG
 1744226560,1744226595,ID
 1744226596,1744226596,SG
@@ -39336,6 +40751,7 @@
 1744229376,1744230399,IN
 1744230400,1744230655,HK
 1744230656,1744230911,MY
+1744230912,1744231423,TW
 1744231424,1744232447,VN
 1744232448,1744233471,IN
 1744233472,1744234495,KH
@@ -39348,13 +40764,17 @@
 1744238848,1744239615,NZ
 1744239616,1744240639,JP
 1744240640,1744241663,AU
-1744242688,1744247807,ID
+1744241664,1744242687,IN
+1744242688,1744245503,ID
+1744245760,1744247807,ID
 1744247808,1744248831,IN
 1744248832,1744249855,ID
+1744249856,1744250367,HK
 1744250368,1744250879,PH
 1744250880,1744251903,ID
 1744251904,1744252927,BD
 1744252928,1744253951,LK
+1744253952,1744254975,IN
 1744254976,1744255999,NZ
 1744256000,1744257023,TH
 1744257024,1744257535,AU
@@ -39384,6 +40804,8 @@
 1744279552,1744280575,NZ
 1744280576,1744283647,HK
 1744283648,1744286719,CN
+1744286720,1744286975,SG
+1744286976,1744287231,JP
 1744287232,1744287743,ID
 1744287744,1744288767,AU
 1744288768,1744289791,JP
@@ -39430,6 +40852,7 @@
 1744324608,1744325631,IN
 1744325632,1744326655,HK
 1744326656,1744328703,IN
+1744328704,1744329727,HK
 1744329728,1744330751,IN
 1744330752,1744331263,AU
 1744331264,1744331775,SG
@@ -39451,9 +40874,8 @@
 1744349184,1744350207,CN
 1744350208,1744351231,IN
 1744351232,1744352255,NZ
-1744353280,1744354303,HK
-1744354304,1744354559,AU
-1744354560,1744355327,NZ
+1744352256,1744354303,HK
+1744354304,1744355327,AU
 1744355328,1744356351,CN
 1744357376,1744357631,NZ
 1744357632,1744357887,AU
@@ -39461,7 +40883,7 @@
 1744359424,1744360447,IN
 1744360448,1744361471,CN
 1744361472,1744362495,ID
-1744363520,1744365567,CN
+1744362496,1744365567,CN
 1744365568,1744366591,IN
 1744366592,1744367615,BD
 1744367616,1744368639,HK
@@ -39472,7 +40894,7 @@
 1744370688,1744371711,HK
 1744371712,1744372735,BD
 1744372736,1744373759,IN
-1744374784,1744375807,CN
+1744373760,1744375807,CN
 1744375808,1744376831,IN
 1744376832,1744377855,VN
 1744377856,1744378879,IN
@@ -39490,7 +40912,8 @@
 1744386560,1744387071,ID
 1744387072,1744388095,NZ
 1744388096,1744388607,ID
-1744388608,1744390143,AU
+1744388608,1744389631,AU
+1744389632,1744390143,RO
 1744390144,1744391167,HK
 1744391168,1744393215,IN
 1744393216,1744394239,MY
@@ -39498,17 +40921,20 @@
 1744395264,1744396287,MY
 1744396288,1744397311,IN
 1744397312,1744398335,VN
+1744398336,1744399359,CN
 1744399360,1744400383,HK
 1744400384,1744402431,JP
 1744402432,1744403455,IN
 1744403456,1744404479,AU
 1744404480,1744405503,CN
+1744405504,1744406527,IN
 1744406528,1744407551,CN
 1744407552,1744408575,AU
 1744408576,1744409599,CN
 1744409600,1744410623,AU
 1744410624,1744411647,PK
-1744412672,1744413695,SG
+1744411648,1744412671,LA
+1744412672,1744413695,TW
 1744413696,1744417791,CN
 1744417792,1744418815,IN
 1744418816,1744419839,JP
@@ -39519,7 +40945,7 @@
 1744424960,1744425471,MY
 1744425472,1744425727,ID
 1744425728,1744425983,IN
-1744425984,1744427007,JP
+1744425984,1744428031,JP
 1744428032,1744429567,AU
 1744429568,1744429823,IN
 1744429824,1744430079,ID
@@ -39528,6 +40954,7 @@
 1744434176,1744435199,CN
 1744435200,1744436223,IN
 1744436224,1744437247,CN
+1744437248,1744438271,KI
 1744439296,1744439807,AU
 1744439808,1744440319,IN
 1744440320,1744441343,HK
@@ -39536,7 +40963,7 @@
 1744443392,1744444415,VN
 1744444416,1744445439,IN
 1744445440,1744446463,CN
-1744447488,1744447743,IN
+1744446464,1744447743,IN
 1744447744,1744447999,HK
 1744448000,1744448511,BD
 1744448512,1744449535,IN
@@ -39565,6 +40992,7 @@
 1744473344,1744474111,SG
 1744474112,1744481279,IN
 1744481280,1744482303,JP
+1744482304,1744483327,HK
 1744483328,1744484351,CN
 1744484352,1744486399,IN
 1744486400,1744487423,CN
@@ -39596,8 +41024,7 @@
 1744514048,1744514559,ID
 1744514560,1744514815,IN
 1744514816,1744515071,AU
-1744515072,1744516095,IN
-1744517120,1744519167,IN
+1744515072,1744519167,IN
 1744519168,1744520191,AU
 1744520192,1744521215,TH
 1744521216,1744523263,JP
@@ -39616,6 +41043,7 @@
 1744534528,1744536575,CN
 1744536576,1744537087,PW
 1744537088,1744538623,AU
+1744538624,1744539647,IN
 1744539648,1744540671,AU
 1744540672,1744541695,IN
 1744541696,1744542719,ID
@@ -39627,6 +41055,7 @@
 1744547840,1744548863,AF
 1744548864,1744549887,ID
 1744549888,1744551935,IN
+1744551936,1744552959,CN
 1744552960,1744553471,SG
 1744553472,1744553983,HK
 1744553984,1744555007,MY
@@ -39635,11 +41064,12 @@
 1744562176,1744563199,BD
 1744563200,1744564223,HK
 1744564224,1744565247,CN
+1744565248,1744566271,BD
 1744566272,1744567295,IN
 1744567296,1744568319,JP
 1744568320,1744569343,VN
 1744569344,1744570367,IN
-1744570880,1744571391,AU
+1744570368,1744571391,AU
 1744571392,1744571903,ID
 1744571904,1744572415,AU
 1744572416,1744573439,HK
@@ -39648,9 +41078,9 @@
 1744575488,1744576511,CN
 1744577536,1744578559,CN
 1744578560,1744580607,IN
-1744580608,1744580863,PH
 1744580864,1744581119,SG
 1744581120,1744581631,ID
+1744581632,1744582655,IN
 1744582656,1744583679,AU
 1744583680,1744584703,IN
 1744584704,1744585727,CN
@@ -39667,13 +41097,16 @@
 1744594432,1744594943,AU
 1744594944,1744595967,CN
 1744595968,1744596991,IN
-1744596992,1744597123,SG
+1744596992,1744597023,AU
+1744597024,1744597123,SG
 1744597124,1744597124,US
 1744597125,1744597151,SG
 1744597152,1744597183,IN
 1744597184,1744597215,JP
 1744597216,1744598015,SG
+1744598016,1744599039,IN
 1744599040,1744601087,JP
+1744601088,1744602111,TW
 1744602112,1744603135,HK
 1744603136,1744604159,JP
 1744604160,1744607231,IN
@@ -39688,10 +41121,12 @@
 1744616448,1744616959,ID
 1744616960,1744617471,AU
 1744617472,1744618495,IN
+1744618496,1744619519,TW
 1744619520,1744620543,SG
 1744620544,1744622591,CN
 1744622592,1744624639,IN
 1744624640,1744625663,NL
+1744625664,1744626687,BD
 1744626688,1744627711,KR
 1744627712,1744628735,CN
 1744628736,1744629759,IN
@@ -39713,6 +41148,7 @@
 1744643584,1744644095,BD
 1744644096,1744645119,HK
 1744645120,1744646143,BD
+1744646144,1744647167,NZ
 1744647168,1744648191,IN
 1744648192,1744649215,KR
 1744649216,1744650239,CN
@@ -39738,6 +41174,7 @@
 1744665856,1744666111,IN
 1744666112,1744666367,AU
 1744666368,1744666623,PH
+1744666624,1744667647,IN
 1744667648,1744668671,TH
 1744668672,1744669695,NZ
 1744669696,1744670719,HK
@@ -39810,6 +41247,7 @@
 1744744448,1744745471,CN
 1744745472,1744747519,NP
 1744747520,1744748543,CN
+1744748544,1744749055,IN
 1744749056,1744749567,NZ
 1744749568,1744749823,CN
 1744750592,1744752639,IN
@@ -39850,7 +41288,6 @@
 1744786432,1744787455,VN
 1744787456,1744789503,CN
 1744789504,1744792575,IN
-1744792576,1744793599,PK
 1744793600,1744794623,IN
 1744794624,1744795647,KH
 1744795648,1744797183,ID
@@ -39878,7 +41315,7 @@
 1744825344,1744826367,VN
 1744826368,1744827391,ID
 1744827392,1744828415,JP
-1744828416,1744828927,NZ
+1744828416,1744828927,AU
 1744828928,1744829183,SG
 1744829184,1744829439,AU
 1744829440,1744830463,HK
@@ -39892,7 +41329,8 @@
 1747219456,1747220479,CA
 1747220480,1747227647,US
 1747227648,1747228671,CA
-1747228672,1747235839,US
+1747228672,1747230719,US
+1747231744,1747235839,US
 1747235840,1747236863,CA
 1747236864,1747255807,US
 1747255808,1747256063,CN
@@ -39927,7 +41365,26 @@
 1747521792,1747522303,BR
 1747522304,1747525631,US
 1747525632,1747527679,BR
-1747527680,1747779583,US
+1747527680,1747558399,US
+1747558400,1747566591,JP
+1747566592,1747763679,US
+1747763680,1747763711,AU
+1747763712,1747767887,US
+1747767888,1747767903,AU
+1747767904,1747767919,JP
+1747767920,1747767935,AU
+1747767936,1747767951,JP
+1747767952,1747770623,US
+1747770624,1747770655,JP
+1747770656,1747770687,SG
+1747770688,1747770719,JP
+1747770720,1747770751,IE
+1747770752,1747770815,AT
+1747770816,1747770943,US
+1747770944,1747771007,SE
+1747771008,1747771071,AU
+1747771072,1747771135,OM
+1747771136,1747779583,US
 1747779584,1747795967,NL
 1747795968,1747801855,US
 1747801856,1747802111,IE
@@ -40065,7 +41522,9 @@
 1753483520,1753483775,IL
 1753483776,1753484607,US
 1753484608,1753484655,BR
-1753484656,1753486335,US
+1753484656,1753485567,US
+1753485568,1753485823,GH
+1753485824,1753486335,US
 1753486336,1753486591,IN
 1753486592,1753487359,US
 1753487360,1753487615,CH
@@ -40082,7 +41541,13 @@
 1753517568,1753517823,NO
 1753517824,1753522431,US
 1753522432,1753522687,FR
-1753522688,1753735167,US
+1753522688,1753527039,US
+1753527040,1753527295,LT
+1753527296,1753529087,US
+1753529088,1753529343,NZ
+1753529344,1753547007,US
+1753547008,1753547263,DE
+1753547264,1753735167,US
 1753735168,1753743359,IE
 1753743360,1754136575,US
 1754136576,1754169343,CA
@@ -40143,7 +41608,9 @@
 1754258944,1754259199,TN
 1754259200,1754333183,US
 1754333184,1754337279,CA
-1754337280,1754792959,US
+1754337280,1754394367,US
+1754394368,1754394623,CA
+1754394624,1754792959,US
 1754792960,1754793983,CA
 1754793984,1754799103,US
 1754799104,1754800127,CA
@@ -40402,27 +41869,25 @@
 1758413568,1758414335,US
 1758414336,1758414591,LV
 1758414592,1758414847,IN
-1758414848,1758415103,GD
+1758414848,1758415103,US
 1758415104,1758415359,GB
 1758415360,1758415615,FR
 1758415616,1758415871,CY
 1758415872,1758416127,IT
 1758416128,1758416383,US
 1758416384,1758416639,CF
-1758416640,1758416895,IL
+1758416640,1758416895,US
 1758416896,1758417151,VC
 1758417152,1758417407,ID
 1758417408,1758417663,CL
 1758417664,1758417919,HK
 1758417920,1758418175,DE
-1758418176,1758418431,RU
+1758418176,1758418431,US
 1758418432,1758418687,CN
 1758418688,1758418943,BL
 1758418944,1758419199,US
 1758419200,1758419455,CR
-1758419456,1758419711,EG
-1758419712,1758419967,VE
-1758419968,1758420223,US
+1758419456,1758420223,US
 1758420224,1758420479,HU
 1758420480,1758420735,CH
 1758420736,1758420991,MM
@@ -40773,7 +42238,9 @@
 1761288192,1761292287,CA
 1761292288,1761302015,US
 1761302016,1761302271,CA
-1761302272,1761304575,US
+1761302272,1761302527,US
+1761302528,1761302783,CA
+1761302784,1761304575,US
 1761304576,1761308671,CA
 1761308672,1761328639,US
 1761328640,1761328895,AU
@@ -40786,15 +42253,15 @@
 1761489920,1761499135,US
 1761499136,1761501183,CA
 1761501184,1761502207,VG
-1761502208,1761515519,US
+1761502208,1761507615,US
+1761507616,1761507711,GB
+1761507712,1761515519,US
 1761515520,1761517567,CA
 1761517568,1761519615,US
 1761519616,1761521663,PR
 1761521664,1761522687,US
 1761522688,1761523711,CA
-1761523712,1761524735,US
-1761524736,1761525759,CA
-1761525760,1761526783,US
+1761523712,1761526783,US
 1761526784,1761527807,CA
 1761527808,1761544191,US
 1761544192,1761546239,CA
@@ -40871,8 +42338,8 @@
 1763402752,1763406335,MU
 1763406336,1763406847,ZA
 1763406848,1763428351,MU
-1763428352,1763428863,ZA
-1763428864,1763430399,MU
+1763428352,1763429375,ZA
+1763429376,1763430399,MU
 1763430400,1763438591,KE
 1763438592,1763442687,UG
 1763442688,1763446783,RW
@@ -40936,6 +42403,12 @@
 1778384896,1778385151,CN
 1778385152,1778385407,AU
 1778385408,1778393087,CN
+1778393088,1778396159,IN
+1778396160,1778397183,CN
+1778397184,1778398207,ID
+1778398208,1778399231,BD
+1778399232,1778400255,IN
+1778400256,1778401279,BD
 1778401280,1778417663,CN
 1778417664,1778450431,TH
 1778450432,1778515967,TW
@@ -40987,7 +42460,9 @@
 1795568128,1795568639,CA
 1795568640,1795569663,US
 1795569664,1795570175,CA
-1795570176,1795583999,US
+1795570176,1795571087,US
+1795571088,1795571103,CA
+1795571104,1795583999,US
 1795584000,1795588095,SG
 1795588096,1795591167,US
 1795591168,1795592191,NL
@@ -41013,11 +42488,20 @@
 1805171608,1805171615,CA
 1805171616,1805190399,US
 1805190400,1805190655,ES
-1805190656,1805194239,US
+1805190656,1805190911,DE
+1805190912,1805194239,US
 1805194240,1805194495,AU
-1805194496,1805210623,US
+1805194496,1805196287,US
+1805196288,1805196543,DE
+1805196544,1805197823,US
+1805197824,1805198079,DE
+1805198080,1805210623,US
 1805210624,1805210879,EG
-1805210880,1805251583,US
+1805210880,1805217279,US
+1805217280,1805217535,DE
+1805217536,1805221375,US
+1805221376,1805221631,DE
+1805221632,1805251583,US
 1805251584,1805251839,DE
 1805251840,1805252095,GB
 1805252096,1805252351,DE
@@ -41051,11 +42535,18 @@
 1806172416,1806172671,GB
 1806172672,1806172927,DE
 1806172928,1806173183,GB
-1806173184,1806174207,US
+1806173184,1806173695,CN
+1806173696,1806174207,US
 1806174208,1806174463,BR
 1806174464,1806180351,US
 1806180352,1806180607,AU
-1806180608,1806198271,US
+1806180608,1806184447,US
+1806184448,1806184959,AU
+1806184960,1806186239,US
+1806186240,1806186751,GB
+1806186752,1806190079,US
+1806190080,1806190591,JP
+1806190592,1806198271,US
 1806198272,1806198527,JP
 1806198528,1806203391,US
 1806203392,1806203647,AU
@@ -41168,7 +42659,9 @@
 1816001792,1816002559,NL
 1816002560,1816068095,US
 1816068096,1816133631,CA
-1816133632,1822429183,US
+1816133632,1819976622,US
+1819976623,1819976623,RE
+1819976624,1822429183,US
 1822429184,1822433279,CA
 1822433280,1822445567,US
 1822445568,1822451199,CA
@@ -41188,13 +42681,22 @@
 1822553856,1822554111,HK
 1822554112,1822572543,US
 1822572544,1822605311,CA
-1822605312,1822614015,US
-1822614016,1822614271,JP
-1822614272,1822617855,US
-1822617856,1822618367,CA
-1822618368,1822619647,US
-1822619648,1822620415,AU
-1822620416,1822654463,US
+1822605312,1822609407,US
+1822609408,1822609663,SG
+1822609664,1822612991,US
+1822612992,1822613503,HK
+1822613504,1822613759,US
+1822613760,1822614015,SG
+1822614016,1822614527,JP
+1822614528,1822615039,FR
+1822615040,1822615551,DE
+1822615552,1822617343,US
+1822617344,1822618367,CA
+1822618368,1822619391,US
+1822619392,1822620415,AU
+1822620416,1822620927,US
+1822620928,1822621439,DE
+1822621440,1822654463,US
 1822654464,1822662143,CA
 1822662144,1822662399,US
 1822662400,1822670847,CA
@@ -41232,7 +42734,9 @@
 1823469568,1823735807,US
 1823735808,1823866879,CA
 1823866880,1828716543,US
-1828716544,1830813695,FR
+1828716544,1830106367,FR
+1830106368,1830106623,CH
+1830106624,1830813695,FR
 1830813696,1831337983,NL
 1831337984,1831862271,DE
 1831862272,1832124415,PT
@@ -41805,7 +43309,9 @@
 1836646400,1836679167,RS
 1836679168,1836680703,BG
 1836680704,1836681215,MK
-1836681216,1836711935,BG
+1836681216,1836687359,BG
+1836687360,1836689151,MK
+1836689152,1836711935,BG
 1836711936,1836728319,UA
 1836728320,1836744703,RS
 1836744704,1836746495,FR
@@ -41872,9 +43378,7 @@
 1837501020,1837501020,CN
 1837501021,1837501040,BE
 1837501041,1837501041,CN
-1837501042,1837501119,BE
-1837501120,1837501120,CN
-1837501121,1837501584,BE
+1837501042,1837501584,BE
 1837501585,1837501585,CN
 1837501586,1837501588,BE
 1837501589,1837501589,CN
@@ -42079,7 +43583,9 @@
 1841946624,1841954815,UA
 1841954816,1841971199,RU
 1841971200,1841979391,CZ
-1841979392,1841983487,NL
+1841979392,1841982975,NL
+1841982976,1841983103,BE
+1841983104,1841983487,NL
 1841983488,1841985535,IM
 1841985536,1841987583,SI
 1841987584,1841995775,DK
@@ -42207,7 +43713,9 @@
 1843789824,1843806207,SK
 1843806208,1843822591,IR
 1843822592,1843838975,RU
-1843838976,1843846911,DE
+1843838976,1843840767,DE
+1843840768,1843841023,SE
+1843841024,1843846911,DE
 1843846912,1843847167,IR
 1843847168,1843853055,DE
 1843853056,1843853311,IR
@@ -42216,7 +43724,7 @@
 1843871744,1843888127,GB
 1843888128,1843904511,CZ
 1843904512,1843920895,GB
-1843920896,1843922943,KZ
+1843920896,1843922943,IR
 1843922944,1843924991,NL
 1843924992,1843927039,ES
 1843927040,1843929087,PL
@@ -42410,8 +43918,7 @@
 1845029888,1845030143,KZ
 1845030144,1845030911,RU
 1845030912,1845031935,GE
-1845031936,1845034751,RU
-1845034752,1845035007,BY
+1845031936,1845035007,RU
 1845035008,1845100543,GB
 1845100544,1845166079,DE
 1845166080,1845231615,UA
@@ -42442,6 +43949,7 @@
 1847590912,1847721983,AU
 1847721984,1847730175,NP
 1847730176,1847732223,PK
+1847732224,1847734271,CN
 1847734272,1847735295,NZ
 1847735296,1847736319,AU
 1847736320,1847738367,JP
@@ -42459,6 +43967,10 @@
 1847812096,1847853055,KR
 1847853056,1848115199,PK
 1848115200,1848377343,CN
+1848377344,1848378367,BD
+1848378368,1848379391,HK
+1848379392,1848380415,IN
+1848380416,1848381439,CN
 1848381440,1848382463,NZ
 1848382464,1848383487,JP
 1848383488,1848385535,AU
@@ -42499,6 +44011,8 @@
 1850400768,1850408959,JP
 1850408960,1850490879,CN
 1850490880,1850507263,KR
+1850507264,1850508287,BD
+1850508288,1850509311,CN
 1850509312,1850510335,AU
 1850510336,1850511359,KR
 1850511360,1850513407,ID
@@ -42518,6 +44032,8 @@
 1851528192,1851529215,KR
 1851529216,1851531263,PH
 1851531264,1851539455,JP
+1851539456,1851540479,HK
+1851540480,1851541503,CN
 1851541504,1851542527,ID
 1851542528,1851543551,HK
 1851543552,1851547647,JP
@@ -42579,11 +44095,9 @@
 1860736000,1860737023,AU
 1860737024,1860739071,JP
 1860739072,1860743167,PH
-1860743168,1860743333,AU
-1860743334,1860743334,HK
-1860743335,1860743462,AU
-1860743463,1860743464,JP
-1860743465,1860744191,AU
+1860743168,1860743423,HK
+1860743424,1860743679,JP
+1860743680,1860744191,AU
 1860744192,1860745215,IN
 1860745216,1860746239,AU
 1860746240,1860747263,PK
@@ -42648,11 +44162,13 @@
 1868341248,1868345343,ID
 1868345344,1868346367,GU
 1868346368,1868347391,TH
+1868347392,1868348415,HK
 1868348416,1868349439,KR
 1868349440,1868357631,SG
 1868357632,1868361727,HK
 1868361728,1868362751,KH
 1868362752,1868363775,JP
+1868363776,1868365823,CN
 1868365824,1868431359,IN
 1868431360,1868562431,ID
 1868562432,1869611007,JP
@@ -42708,6 +44224,9 @@
 1876785408,1876785439,HK
 1876785440,1876787199,SG
 1876787200,1876885503,CN
+1876885504,1876886527,IN
+1876886528,1876890623,CN
+1876890624,1876893695,IN
 1876893696,1876901887,TH
 1876901888,1876918271,SG
 1876918272,1876934655,LK
@@ -42718,8 +44237,7 @@
 1876950016,1876951039,ID
 1876951040,1877475327,CN
 1877475328,1877688319,JP
-1877688320,1877689343,IN
-1877690368,1877691391,IN
+1877688320,1877691391,IN
 1877691392,1877692415,JP
 1877692416,1877696511,PH
 1877696512,1877704703,CN
@@ -42800,6 +44318,7 @@
 1888266240,1888268287,JP
 1888268288,1888270335,AU
 1888270336,1888271359,SG
+1888271360,1888272383,IN
 1888272384,1888288767,KR
 1888288768,1888354303,AU
 1888354304,1888485375,TH
@@ -42853,6 +44372,7 @@
 1897170944,1897172991,ID
 1897172992,1897175039,PH
 1897175040,1897176063,JP
+1897176064,1897177087,SG
 1897177088,1897185279,PH
 1897185280,1897201663,JP
 1897201664,1897209855,KR
@@ -42866,6 +44386,7 @@
 1897250816,1897259007,HK
 1897259008,1897260031,NZ
 1897260032,1897261055,BD
+1897261056,1897263103,CN
 1897263104,1897265151,TH
 1897265152,1897267199,JP
 1897267200,1897365503,VN
@@ -42878,7 +44399,9 @@
 1897730048,1897730303,AU
 1897730304,1897730559,US
 1897730560,1897730815,AU
-1897730816,1897758719,US
+1897730816,1897735295,US
+1897735296,1897735423,HK
+1897735424,1897758719,US
 1897758720,1897779199,KR
 1897779200,1897781247,AU
 1897781248,1897783295,JP
@@ -42907,6 +44430,7 @@
 1899273216,1899274239,JP
 1899274240,1899282431,CN
 1899282432,1899290623,KR
+1899291648,1899292671,CN
 1899292672,1899294719,AU
 1899294720,1899298815,JP
 1899298816,1899364351,TH
@@ -42952,7 +44476,10 @@
 1908756480,1908760575,KR
 1908760576,1908761599,NZ
 1908761600,1908762623,CN
-1908762624,1908763647,IN
+1908762624,1908762879,IN
+1908762880,1908763135,US
+1908763136,1908763391,AU
+1908763392,1908763647,US
 1908763648,1908764671,ID
 1908764672,1908768767,AU
 1908768768,1908801535,JP
@@ -42994,6 +44521,10 @@
 1914437632,1914503167,CN
 1914503168,1914552319,KR
 1914552320,1914560511,SG
+1914560512,1914564607,IN
+1914564608,1914566655,TW
+1914566656,1914567679,IN
+1914567680,1914568703,MY
 1914568704,1914576895,KR
 1914576896,1914580991,TW
 1914580992,1914585087,KR
@@ -43004,6 +44535,7 @@
 1914601472,1914634239,KR
 1914634240,1914642431,BD
 1914642432,1914650623,KR
+1914650624,1914652671,CN
 1914652672,1914654719,AU
 1914654720,1914658815,JP
 1914658816,1914660863,AU
@@ -43054,8 +44586,10 @@
 1920002048,1920003071,CN
 1920003072,1920008191,HK
 1920008192,1920057343,CN
-1920057344,1920058111,HK
-1920058112,1920072703,CN
+1920057344,1920058367,HK
+1920058368,1920069631,CN
+1920069632,1920071167,HK
+1920071168,1920072703,CN
 1920072704,1920073727,HK
 1920073728,1920466943,CN
 1920466944,1920991231,ID
@@ -43074,7 +44608,8 @@
 1921253376,1921318911,CN
 1921318912,1921384447,MY
 1921384448,1921388543,NZ
-1921392640,1921400831,JP
+1921388544,1921391615,IN
+1921391616,1921400831,JP
 1921400832,1921404927,ID
 1921404928,1921406463,HK
 1921406464,1921406719,GB
@@ -43094,11 +44629,14 @@
 1921855488,1921859583,ID
 1921859584,1921861631,CN
 1921861632,1921863679,SG
+1921863680,1921865727,CN
 1921865728,1921867775,ID
 1921867776,1921871871,AU
 1921871872,1921872895,US
 1921872896,1921873663,NZ
-1921873664,1921875967,US
+1921873664,1921874175,US
+1921874176,1921874687,NZ
+1921874688,1921875967,US
 1921875968,1921892351,CN
 1921892352,1921896447,AU
 1921896448,1921898495,SG
@@ -43107,7 +44645,9 @@
 1921908736,1921943551,JP
 1921943552,1921945599,IN
 1921945600,1921949695,HK
-1921949696,1921953791,AU
+1921949696,1921949951,AU
+1921950464,1921950719,AU
+1921950976,1921951231,AU
 1921953792,1921957887,JP
 1921957888,1921974271,GU
 1921974272,1922039807,IN
@@ -43121,8 +44661,7 @@
 1925640192,1925642239,ID
 1925642240,1925644287,CN
 1925644288,1925660671,KR
-1925660672,1925661439,TW
-1925661440,1925662463,HK
+1925660672,1925662463,HK
 1925662464,1925663743,TW
 1925663744,1925664767,HK
 1925664768,1925677055,ID
@@ -43134,6 +44673,7 @@
 1931354112,1931362303,AU
 1931362304,1931378687,TW
 1931378688,1931427839,JP
+1931427840,1931431935,CN
 1931431936,1931433983,JP
 1931433984,1931436031,AU
 1931436032,1931444223,KR
@@ -43144,6 +44684,10 @@
 1931739136,1932001279,JP
 1932001280,1932132351,KR
 1932132352,1932140543,AU
+1932140544,1932145663,IN
+1932145664,1932146687,BD
+1932146688,1932147711,CN
+1932147712,1932148735,HK
 1932148736,1932152831,PK
 1932152832,1932156927,TW
 1932156928,1932161023,JP
@@ -43184,7 +44728,9 @@
 1934966784,1934974975,ID
 1934974976,1934983167,JP
 1934983168,1934983423,MY
-1934983424,1934984959,AU
+1934983424,1934984447,AU
+1934984448,1934984639,US
+1934984640,1934984959,AU
 1934984960,1934985215,US
 1934985216,1934987263,JP
 1934987264,1934991359,TW
@@ -43242,12 +44788,16 @@
 1940258816,1940275199,AU
 1940275200,1940283391,CN
 1940283392,1940291583,ID
+1940291584,1940295679,IN
 1940295680,1940324351,JP
 1940324352,1940357119,PK
 1940357120,1940389887,JP
 1940389888,1940914175,CN
 1940914176,1941045247,JP
-1941045248,1941049343,HK
+1941045248,1941045759,HK
+1941045760,1941046783,JP
+1941046784,1941048319,HK
+1941048320,1941049343,SG
 1941049344,1941051391,AU
 1941051392,1941052415,KH
 1941052416,1941053439,AU
@@ -43264,6 +44814,7 @@
 1941438464,1941569535,IN
 1941569536,1941618687,PK
 1941618688,1941635071,AU
+1941635072,1941639167,CN
 1941639168,1941643263,NP
 1941643264,1941651455,IN
 1941651456,1941655551,JP
@@ -43280,17 +44831,19 @@
 1946161152,1946163199,AU
 1946163200,1946165247,CN
 1946165248,1946173439,PK
-1946173440,1946173695,PG
+1946173440,1946173567,PG
+1946173568,1946173599,HK
+1946173600,1946173695,PG
 1946173696,1946173951,TW
 1946173952,1946174463,SG
 1946174464,1946174719,TW
 1946174720,1946175487,SG
 1946175488,1946175615,HK
-1946175616,1946175999,SG
+1946175616,1946175743,CN
+1946175744,1946175999,SG
 1946176000,1946176255,JP
 1946176256,1946176511,SG
-1946176512,1946176647,AU
-1946176648,1946176767,PH
+1946176512,1946176767,AU
 1946176768,1946178047,SG
 1946178048,1946178303,HK
 1946178304,1946179583,SG
@@ -43338,8 +44891,10 @@
 1950089216,1950351359,CN
 1950351360,1950482431,JP
 1950482432,1950515199,CN
-1950515200,1950517247,IN
-1950517248,1950518271,US
+1950515200,1950515711,IN
+1950515712,1950516223,US
+1950516224,1950516735,IN
+1950516736,1950518271,US
 1950518272,1950519295,IN
 1950519296,1950520319,US
 1950520320,1950521343,PH
@@ -43358,8 +44913,10 @@
 1950621696,1950629887,KR
 1950629888,1950646271,IN
 1950646272,1950648319,VN
+1950648320,1950650367,CN
 1950650368,1950654463,TH
 1950654464,1950658559,ID
+1950658560,1950660607,CN
 1950660608,1950662655,HK
 1950662656,1950666751,BD
 1950666752,1950668799,NP
@@ -43423,10 +44980,12 @@
 1958830080,1958838271,JP
 1958838272,1958842367,IN
 1958842368,1958844415,NZ
+1958844416,1958845439,CN
 1958845440,1958845951,MY
 1958845952,1958846463,HK
 1958846464,1958847487,IN
-1958848512,1958850559,BD
+1958847488,1958848511,CN
+1958848512,1958848767,BD
 1958850560,1958852607,CN
 1958852608,1958853631,AU
 1958853632,1958854655,ID
@@ -43438,8 +44997,13 @@
 1959100416,1959102463,ID
 1959102464,1959104511,JP
 1959104512,1959106559,AU
+1959108608,1959110655,CN
 1959110656,1959112703,JP
-1959112704,1959114751,HK
+1959112704,1959113215,HK
+1959113216,1959113471,IN
+1959113472,1959113727,HK
+1959113728,1959113983,CN
+1959113984,1959114751,HK
 1959114752,1959115007,IN
 1959115008,1959116287,HK
 1959116288,1959116543,AU
@@ -43472,6 +45036,9 @@
 1960099840,1960121343,AU
 1960121344,1960122367,JP
 1960122368,1960124415,ID
+1960124416,1960125439,PK
+1960125440,1960126463,HK
+1960126464,1960128511,CN
 1960128512,1960132607,ID
 1960132608,1960181759,CN
 1960181760,1960185855,TW
@@ -43483,7 +45050,8 @@
 1960210432,1960210943,TH
 1960210944,1960211455,SG
 1960211456,1960211903,AU
-1960211904,1960212479,SG
+1960211904,1960211967,SG
+1960211968,1960212479,AU
 1960212480,1960212582,IN
 1960212583,1960212583,SG
 1960212584,1960212735,IN
@@ -43505,6 +45073,7 @@
 1962672128,1962803199,CN
 1962803200,1962827775,JP
 1962827776,1962829823,ID
+1962829824,1962831871,CN
 1962831872,1962835967,ID
 1962835968,1962868735,CN
 1962868736,1962885119,AU
@@ -43531,9 +45100,8 @@
 1964138496,1964146687,HK
 1964146688,1964171263,JP
 1964171264,1964173311,BD
-1964173312,1964173776,AU
-1964173777,1964173777,JP
-1964173778,1964173823,AU
+1964173312,1964173567,AU
+1964173568,1964173823,JP
 1964173824,1964174079,HK
 1964174080,1964174335,AU
 1964174336,1964174591,SG
@@ -43559,9 +45127,12 @@
 1966080000,1966342143,CN
 1966342144,1966407679,KR
 1966407680,1966417919,JP
+1966417920,1966418943,PK
+1966418944,1966419967,ID
 1966419968,1966424063,CN
 1966424064,1966440447,KR
 1966440448,1966444543,AU
+1966444544,1966446591,ID
 1966446592,1966447615,MY
 1966447616,1966448639,NZ
 1966448640,1966452735,AU
@@ -43607,7 +45178,9 @@
 1969707008,1969709055,MH
 1969709056,1969713151,TW
 1969713152,1969715199,AU
-1969715200,1969717247,IN
+1969715200,1969716223,SG
+1969716224,1969716735,HK
+1969716736,1969717247,IN
 1969717248,1969721343,CN
 1969721344,1969725439,HK
 1969725440,1969727487,JP
@@ -43619,7 +45192,8 @@
 1969793024,1969795071,CN
 1969795072,1969797119,NZ
 1969797120,1969798143,SG
-1969798144,1969799167,HK
+1969798144,1969798399,CN
+1969798400,1969799167,HK
 1969799168,1969807359,ID
 1969807360,1969809407,AF
 1969809408,1969811455,IN
@@ -43633,8 +45207,8 @@
 1970800640,1970802943,AU
 1970802944,1970803199,SG
 1970803200,1970803711,AU
-1970803712,1970803967,HK
-1970803968,1970804479,AU
+1970803712,1970804223,HK
+1970804224,1970804479,AU
 1970804480,1970804735,SG
 1970804736,1970806783,KH
 1970806784,1970808831,NZ
@@ -43711,6 +45285,11 @@
 1986461696,1986496511,JP
 1986496512,1986498559,BT
 1986498560,1986502655,HK
+1986502656,1986503679,IN
+1986503680,1986507775,CN
+1986507776,1986508799,SG
+1986508800,1986509823,AU
+1986509824,1986510847,JP
 1986510848,1986519039,KR
 1986519040,1986523135,PK
 1986523136,1986523904,HK
@@ -43723,6 +45302,7 @@
 1986760704,1986762751,AU
 1986762752,1986764799,JP
 1986764800,1986768895,KR
+1986768896,1986769919,SG
 1986770944,1986772991,AU
 1986772992,1986789375,MY
 1986789376,1987051519,JP
@@ -43759,7 +45339,11 @@
 1991835648,1991901183,IN
 1991901184,1992097791,CN
 1992097792,1992163327,SG
-1992163328,1992417279,CN
+1992163328,1992364031,CN
+1992364032,1992368127,HK
+1992368128,1992380415,CN
+1992380416,1992384511,HK
+1992384512,1992417279,CN
 1992417280,1992417535,HK
 1992417536,1992818687,CN
 1992818688,1992949759,SG
@@ -43841,7 +45425,9 @@
 1998272432,1998272447,JP
 1998272448,1998272547,SG
 1998272548,1998272551,JP
-1998272552,1998274559,SG
+1998272552,1998274047,SG
+1998274048,1998274303,US
+1998274304,1998274559,SG
 1998274560,1998454783,CN
 1998454784,1998456831,AU
 1998456832,1998458879,JP
@@ -43928,9 +45514,7 @@
 2001829888,2001841247,HK
 2001841248,2001841248,SA
 2001841249,2001846271,HK
-2001846272,2001854943,SG
-2001854944,2001854951,CN
-2001854952,2001855231,SG
+2001846272,2001855231,SG
 2001855232,2001855263,US
 2001855264,2001855743,SG
 2001855744,2001855999,HK
@@ -43950,20 +45534,49 @@
 2001858640,2001858655,US
 2001858656,2001859071,SG
 2001859072,2001859327,HK
-2001859328,2001860031,SG
+2001859328,2001860015,SG
+2001860016,2001860031,US
 2001860032,2001860047,HK
-2001860048,2001860351,SG
+2001860048,2001860143,SG
+2001860144,2001860159,US
+2001860160,2001860263,SG
+2001860264,2001860271,US
+2001860272,2001860351,SG
 2001860352,2001860607,HK
 2001860608,2001860655,SG
-2001860656,2001860671,US
+2001860656,2001860659,US
+2001860660,2001860661,HK
+2001860662,2001860664,US
+2001860665,2001860665,HK
+2001860666,2001860667,US
+2001860668,2001860668,HK
+2001860669,2001860671,US
 2001860672,2001860991,SG
-2001860992,2001861007,US
+2001860992,2001860995,US
+2001860996,2001860997,HK
+2001860998,2001861001,US
+2001861002,2001861003,HK
+2001861004,2001861007,US
 2001861008,2001861263,SG
-2001861264,2001861279,US
+2001861264,2001861265,US
+2001861266,2001861267,HK
+2001861268,2001861268,US
+2001861269,2001861269,HK
+2001861270,2001861271,US
+2001861272,2001861272,HK
+2001861273,2001861273,US
+2001861274,2001861274,HK
+2001861275,2001861279,US
 2001861280,2001862079,SG
-2001862080,2001862124,US
+2001862080,2001862101,US
+2001862102,2001862102,HK
+2001862103,2001862116,US
+2001862117,2001862118,HK
+2001862119,2001862124,US
 2001862125,2001862125,HK
-2001862126,2001862143,US
+2001862126,2001862128,US
+2001862129,2001862131,HK
+2001862132,2001862143,US
 2001862144,2001862655,SG
 2001862656,2001864703,AU
 2001864704,2001870847,JP
@@ -44009,8 +45622,10 @@
 2007035904,2007039999,TW
 2007040000,2007048191,KR
 2007048192,2007064575,AU
+2007064576,2007065599,IN
+2007065600,2007066623,SG
 2007066624,2007070719,JP
-2007072768,2007498751,CN
+2007070720,2007498751,CN
 2007498752,2008023039,JP
 2008023040,2009071615,CN
 2009071616,2011168767,KR
@@ -44120,6 +45735,7 @@
 2021654528,2022178815,CN
 2022178816,2022180863,NZ
 2022180864,2022182911,JP
+2022182912,2022184959,CN
 2022184960,2022187007,KH
 2022187008,2022191103,HK
 2022191104,2022194175,NZ
@@ -44130,6 +45746,7 @@
 2022227968,2022244351,JP
 2022244352,2022277119,CN
 2022277120,2022309887,JP
+2022309888,2022313983,IN
 2022313984,2022318079,NZ
 2022318080,2022319135,AU
 2022319136,2022319151,SG
@@ -44168,7 +45785,15 @@
 2030436352,2030567423,SG
 2030567424,2032926719,CN
 2032926720,2033057791,AU
-2033057792,2033319935,CN
+2033057792,2033074175,CN
+2033074176,2033075199,PK
+2033075200,2033077247,BD
+2033077248,2033078271,CN
+2033078272,2033079295,HK
+2033079296,2033088511,IN
+2033088512,2033089535,AU
+2033089536,2033090559,IN
+2033090560,2033319935,CN
 2033319936,2033321983,IN
 2033321984,2033324031,CN
 2033324032,2033328127,KR
@@ -44178,6 +45803,8 @@
 2033352704,2033356799,ID
 2033356800,2033358847,TW
 2033358848,2033362943,JP
+2033362944,2033363967,HK
+2033363968,2033364991,VN
 2033364992,2033369087,TW
 2033369088,2033377279,AU
 2033377280,2033385471,KR
@@ -44191,6 +45818,8 @@
 2033516544,2033582079,KR
 2033582080,2033614847,PH
 2033614848,2033623039,AU
+2033623040,2033624063,HK
+2033624064,2033625087,MM
 2033625088,2033627135,HK
 2033627136,2033629183,CN
 2033631232,2033647615,KR
@@ -44304,7 +45933,17 @@
 2050091008,2050097151,JP
 2050097152,2050101247,SG
 2050101248,2050113535,JP
-2050113536,2050129663,SG
+2050113536,2050122239,SG
+2050122240,2050122495,JP
+2050122496,2050122751,SG
+2050122752,2050122879,JP
+2050122880,2050126079,SG
+2050126080,2050126207,JP
+2050126208,2050126591,SG
+2050126592,2050126719,JP
+2050126720,2050126783,SG
+2050126784,2050126975,JP
+2050126976,2050129663,SG
 2050129664,2050129727,JP
 2050129728,2050129919,SG
 2050129920,2050162687,IN
@@ -44351,6 +45990,8 @@
 2055217152,2055229439,KR
 2055229440,2055231487,TW
 2055231488,2055233535,AU
+2055233536,2055234559,JP
+2055234560,2055235583,CN
 2055235584,2055237631,HK
 2055237632,2055239679,JP
 2055239680,2055241727,CN
@@ -44407,6 +46048,7 @@
 2059931648,2059933695,IN
 2059933696,2059935743,AU
 2059935744,2059937791,JP
+2059937792,2059939839,CN
 2059939840,2059941887,ID
 2059941888,2059943935,AU
 2059943936,2059960319,CN
@@ -44457,11 +46099,10 @@
 2063118080,2063118335,PH
 2063118336,2063118591,IN
 2063118592,2063119871,JP
-2063119872,2063120383,IN
-2063120384,2063120895,JP
+2063119872,2063120127,IN
+2063120128,2063120895,JP
 2063120896,2063121151,AU
-2063121152,2063121919,JP
-2063121920,2063122431,IN
+2063121152,2063122431,JP
 2063122432,2063138815,SG
 2063138816,2063335423,JP
 2063335424,2063341567,AU
@@ -44477,7 +46118,11 @@
 2063392768,2063400959,IN
 2063400960,2063466495,JP
 2063466496,2063482879,TW
-2063482880,2063499263,MN
+2063482880,2063483135,MN
+2063483136,2063483391,JP
+2063483392,2063486975,MN
+2063486976,2063487231,JP
+2063487232,2063499263,MN
 2063499264,2063532031,KR
 2063532032,2063548415,LK
 2063548416,2063550463,CN
@@ -44615,6 +46260,7 @@
 2079326208,2079457279,TW
 2079457280,2079490047,CN
 2079490048,2079506431,TH
+2079506432,2079508479,CN
 2079508480,2079510527,PH
 2079510528,2079514623,JP
 2079514624,2079516671,HK
@@ -44630,6 +46276,7 @@
 2080178176,2080243711,CN
 2080243712,2080260095,JP
 2080260096,2080268287,KR
+2080268288,2080270335,CN
 2080270336,2080272383,HK
 2080272384,2080276479,AU
 2080276480,2080309247,KR
@@ -44675,6 +46322,7 @@
 2083008000,2083024895,JP
 2083024896,2083053567,CN
 2083053568,2083057663,TH
+2083057664,2083058687,CN
 2083058688,2083059711,IN
 2083059712,2083061759,ID
 2083061760,2083110911,JP
@@ -44697,6 +46345,7 @@
 2084569088,2084732927,CN
 2084732928,2084741119,SG
 2084741120,2084743167,ID
+2084743168,2084745215,IN
 2084745216,2084749311,KR
 2084749312,2084753407,JP
 2084753408,2084757503,KR
@@ -44713,20 +46362,27 @@
 2087452672,2087453695,AU
 2087453696,2087454719,KH
 2087454720,2087456767,CN
+2087456768,2087457791,IN
+2087457792,2087458815,HK
 2087458816,2087460863,FJ
 2087460864,2087462911,JP
 2087462912,2087464959,CN
 2087464960,2087467007,KH
 2087467008,2087471103,JP
 2087471104,2087472127,SG
-2087472128,2087476223,HK
+2087472128,2087472639,HK
+2087472640,2087473151,SG
+2087473152,2087474687,HK
+2087474688,2087475199,JP
+2087475200,2087476223,HK
 2087476224,2087477247,TW
 2087477248,2087478271,AU
 2087478272,2087485439,HK
 2087485440,2087501823,TW
 2087501824,2087518207,JP
 2087518208,2087519231,TH
-2087519232,2087520255,SG
+2087519232,2087519999,SG
+2087520000,2087520255,PH
 2087520256,2087522303,FM
 2087524352,2087526399,TH
 2087526400,2087534591,PK
@@ -44912,7 +46568,9 @@
 2112880640,2113560063,KR
 2113560064,2113560319,SG
 2113560320,2113683455,KR
-2113683456,2113685663,JP
+2113683456,2113684607,JP
+2113684608,2113684671,TW
+2113684672,2113685663,JP
 2113685664,2113685695,SG
 2113685696,2113687295,JP
 2113687296,2113687551,AU
@@ -44937,6 +46595,7 @@
 2113761280,2113765375,VN
 2113765376,2113798143,HK
 2113798144,2113811455,AU
+2113811456,2113812479,IN
 2113812480,2113813503,JP
 2113813504,2113830911,AU
 2113830912,2113863679,CN
@@ -45025,9 +46684,12 @@
 2153385920,2153385983,US
 2153385984,2153387007,GB
 2153387008,2153387263,CH
-2153387264,2153387775,US
+2153387264,2153387519,IS
+2153387520,2153387775,IE
 2153387776,2153388031,CH
-2153388032,2153396991,US
+2153388032,2153388287,ES
+2153388288,2153388543,PL
+2153388544,2153396991,US
 2153396992,2153397247,IL
 2153397248,2153397503,IN
 2153397504,2153397759,SA
@@ -45200,6 +46862,9 @@
 2171011072,2171076607,DE
 2171076608,2171142143,FR
 2171142144,2172256255,US
+2172256256,2172272639,GH
+2172272640,2172289023,RE
+2172289024,2172321791,AO
 2172321792,2172452863,US
 2172452864,2172518399,NL
 2172518400,2172583935,US
@@ -45484,7 +47149,9 @@
 2194735104,2194800639,GB
 2194800640,2194888509,US
 2194888510,2194888510,IE
-2194888511,2195193855,US
+2194888511,2194891198,US
+2194891199,2194891199,BE
+2194891200,2195193855,US
 2195193856,2195324927,NZ
 2195324928,2195455999,US
 2195456000,2195521535,AU
@@ -45612,13 +47279,19 @@
 2204893184,2204894207,AR
 2204894208,2204895231,PA
 2204895232,2204897279,BR
-2204897280,2204898303,HN
+2204897280,2204897447,HN
+2204897448,2204897455,CA
+2204897456,2204898095,HN
+2204898096,2204898111,CR
+2204898112,2204898303,HN
 2204898304,2204899327,PA
 2204899328,2204902399,BR
 2204902400,2204903423,CR
 2204903424,2204904447,AR
 2204904448,2204910591,BR
-2204910592,2204911615,CL
+2204910592,2204910847,AR
+2204910848,2204911487,CL
+2204911488,2204911615,CO
 2204911616,2204913663,BR
 2204913664,2204914687,AR
 2204914688,2204929023,BR
@@ -45630,7 +47303,9 @@
 2204943360,2204946431,BR
 2204946432,2204947455,CL
 2204947456,2204952575,BR
-2204952576,2204953599,HN
+2204952576,2204952767,HN
+2204952768,2204952775,US
+2204952776,2204953599,HN
 2204953600,2204958719,BR
 2204958720,2205089791,US
 2205089792,2205155327,GB
@@ -45901,7 +47576,9 @@
 2231333888,2231335935,BR
 2231335936,2231336959,MX
 2231336960,2231337983,BR
-2231337984,2231339007,HN
+2231337984,2231338695,HN
+2231338696,2231338703,US
+2231338704,2231339007,HN
 2231339008,2231346175,BR
 2231346176,2231347199,PY
 2231347200,2231355391,BR
@@ -46270,7 +47947,7 @@
 2263613440,2263678975,TH
 2263678976,2263744511,JP
 2263744512,2263810047,US
-2263810048,2263875583,RO
+2263810048,2263875583,SA
 2263875584,2264203263,US
 2264203264,2264268799,DE
 2264268800,2264334335,FR
@@ -46298,7 +47975,11 @@
 2266431488,2266497023,CA
 2266497024,2266694655,US
 2266694656,2266694911,SG
-2266694912,2270488575,US
+2266694912,2270482687,US
+2270482688,2270482943,GB
+2270482944,2270483967,US
+2270483968,2270484223,GB
+2270484224,2270488575,US
 2270488576,2270490623,MO
 2270490624,2270494719,IN
 2270494720,2270756863,FR
@@ -46340,7 +48021,9 @@
 2281705984,2282226175,US
 2282226176,2282226243,AU
 2282226244,2282226245,US
-2282226246,2282226431,AU
+2282226246,2282226246,AU
+2282226247,2282226247,US
+2282226248,2282226431,AU
 2282226432,2282234111,US
 2282234112,2282234367,GB
 2282234368,2291204095,US
@@ -46408,6 +48091,25 @@
 2302083072,2302214143,NL
 2302214144,2302279679,US
 2302279680,2302345215,SE
+2302345216,2302346239,IN
+2302346240,2302347263,BD
+2302347264,2302348287,IN
+2302348288,2302349311,ID
+2302349312,2302351359,HK
+2302351360,2302357503,VN
+2302357504,2302358527,BD
+2302358528,2302365695,IN
+2302365696,2302366719,HK
+2302366720,2302367743,IN
+2302367744,2302368767,CN
+2302368768,2302370815,IN
+2302370816,2302371839,HK
+2302371840,2302372863,VN
+2302372864,2302373887,MY
+2302373888,2302374911,TH
+2302374912,2302375935,VN
+2302375936,2302376959,AF
+2302376960,2302377983,ID
 2302410752,2302541823,SE
 2302541824,2302607359,CH
 2302607360,2302625761,SC
@@ -46429,7 +48131,7 @@
 2304638976,2304704511,CA
 2304704512,2304770047,US
 2304770048,2304835583,FI
-2304835584,2304901119,US
+2304835584,2304901119,SG
 2304901120,2304966655,CZ
 2304966656,2305097727,US
 2305097728,2305163263,ES
@@ -46549,7 +48251,9 @@
 2316042240,2316173311,US
 2316173312,2316238847,SE
 2316238848,2316500991,US
-2316500992,2316566527,AU
+2316500992,2316505855,HK
+2316505856,2316506111,AU
+2316506112,2316566527,HK
 2316566528,2316613887,US
 2316613888,2316614143,GB
 2316614144,2316632063,US
@@ -46655,18 +48359,26 @@
 2320433152,2320564223,AU
 2320564224,2320629759,CH
 2320629760,2320695295,CA
-2320695296,2321416191,US
+2320695296,2321223679,US
+2321223680,2321227775,JP
+2321227776,2321416191,US
 2321416192,2321417215,CO
 2321417216,2321419263,BR
 2321419264,2321420287,AR
 2321420288,2321430527,BR
 2321430528,2321431551,CR
 2321431552,2321446911,BR
-2321446912,2321447935,HN
+2321446912,2321447647,HN
+2321447648,2321447679,NL
+2321447680,2321447727,HN
+2321447728,2321447743,NL
+2321447744,2321447935,HN
 2321447936,2321452031,BR
 2321452032,2321453055,MX
 2321453056,2321454079,HN
-2321454080,2321471487,BR
+2321454080,2321467136,BR
+2321467137,2321467137,US
+2321467138,2321471487,BR
 2321471488,2321472511,HN
 2321472512,2321477631,BR
 2321477632,2321478655,TT
@@ -46699,7 +48411,9 @@
 2321743872,2321744895,SV
 2321744896,2321745919,AR
 2321745920,2321753087,BR
-2321753088,2321754111,HN
+2321753088,2321753927,HN
+2321753928,2321753935,NL
+2321753936,2321754111,HN
 2321754112,2321755135,BR
 2321755136,2321756159,UY
 2321756160,2321769471,BR
@@ -46909,7 +48623,7 @@
 2327450624,2327451647,CO
 2327451648,2327452671,BR
 2327452672,2327453695,MX
-2327453696,2327459839,BR
+2327453696,2327460863,BR
 2327460864,2327461887,PY
 2327461888,2327462911,MX
 2327462912,2327468031,BR
@@ -46991,6 +48705,7 @@
 2329617408,2329618431,MX
 2329618432,2329619455,AR
 2329619456,2329622527,BR
+2329622528,2329623551,CL
 2329623552,2329624575,AR
 2329624576,2329626623,BR
 2329626624,2329627647,HN
@@ -47009,8 +48724,10 @@
 2329662464,2329664511,AR
 2329664512,2329666559,BR
 2329666560,2329667583,CL
+2329667584,2329668607,AR
 2329668608,2329671679,BR
 2329671680,2329672703,AR
+2329672704,2329673727,BR
 2329673728,2329739263,US
 2329739264,2329804799,SE
 2329804800,2329870335,DE
@@ -47044,7 +48761,8 @@
 2331836416,2331901951,GB
 2331901952,2331967487,US
 2331967488,2331980799,BR
-2331980800,2331981823,PA
+2331980800,2331981567,PA
+2331981568,2331981823,US
 2331981824,2331982847,BR
 2331982848,2331983871,MX
 2331983872,2331987967,BR
@@ -47082,7 +48800,7 @@
 2335637504,2335768575,US
 2335768576,2335834111,CA
 2335834112,2335899647,SE
-2335899648,2335965183,AU
+2335899648,2335965183,SG
 2335965184,2336161791,US
 2336161792,2336227327,NL
 2336292864,2336358399,US
@@ -47166,14 +48884,20 @@
 2342682624,2342690815,DE
 2342690816,2342700247,US
 2342700248,2342700248,GB
-2342700249,2342705120,US
+2342700249,2342701408,US
+2342701409,2342701409,GB
+2342701410,2342704912,US
+2342704913,2342704913,GB
+2342704914,2342705120,US
 2342705121,2342705121,GB
-2342705122,2342715391,US
+2342705122,2342706194,US
+2342706195,2342706195,GB
+2342706196,2342715391,US
 2342715392,2342780927,AU
 2342780928,2342846463,NO
 2342846464,2342911999,BE
 2342912000,2342977535,GB
-2342977536,2343043071,US
+2342977536,2343043071,SG
 2343043072,2343108607,AU
 2343108608,2343174143,US
 2343174144,2343239679,CN
@@ -47321,7 +49045,10 @@
 2366032896,2366033151,GB
 2366033152,2366111743,DE
 2366111744,2366144511,MT
-2366144512,2366149375,RU
+2366144512,2366148351,RU
+2366148352,2366148479,TR
+2366148480,2366148607,US
+2366148608,2366149375,RU
 2366149376,2366149407,DE
 2366149408,2366149423,PL
 2366149424,2366149439,SK
@@ -47362,14 +49089,27 @@
 2372075520,2372206591,DE
 2372206592,2372214783,UA
 2372214784,2372218879,DE
-2372218880,2372222463,FR
-2372222464,2372222975,CH
-2372224656,2372224671,GB
-2372227072,2372227327,NO
-2372227840,2372228607,KR
-2372231168,2372231295,HU
+2372218880,2372222207,FR
+2372222208,2372222975,CH
+2372222976,2372223487,NL
+2372223488,2372223999,FR
+2372224000,2372224255,IN
+2372224256,2372224511,DE
+2372224512,2372225023,GB
+2372225024,2372225791,US
+2372225792,2372226047,NL
+2372226048,2372226303,JP
+2372226304,2372226559,SG
+2372226560,2372227583,SE
+2372227584,2372228607,KR
+2372228608,2372229631,PL
+2372229632,2372230655,AT
+2372230656,2372231679,CZ
 2372231680,2372232191,GB
-2372233728,2372233983,GB
+2372232192,2372233215,CL
+2372233216,2372233727,NL
+2372233728,2372234239,GB
+2372234240,2372235263,CO
 2372238730,2372238730,US
 2372239360,2372240383,SK
 2372240384,2372240511,NL
@@ -47410,7 +49150,9 @@
 2373025792,2373026047,SG
 2373026048,2373031423,DE
 2373031424,2373031679,US
-2373031680,2373058559,DE
+2373031680,2373036031,DE
+2373036032,2373038079,US
+2373038080,2373058559,DE
 2373058560,2373124095,US
 2373124096,2373189631,FR
 2373189632,2373255167,US
@@ -47579,14 +49321,16 @@
 2382659072,2382676479,US
 2382676480,2382676991,CA
 2382676992,2382677503,US
-2382677504,2382677507,CA
-2382677508,2382677511,BY
-2382677512,2382677987,CA
+2382677504,2382677987,CA
 2382677988,2382677991,US
 2382677992,2382678015,CA
 2382678016,2382678527,US
 2382678528,2382679039,CA
-2382679040,2382680063,US
+2382679040,2382679150,US
+2382679151,2382679151,IO
+2382679152,2382679342,US
+2382679343,2382679343,IO
+2382679344,2382680063,US
 2382680064,2382684159,CA
 2382684160,2382692351,US
 2382692352,2383085567,CA
@@ -47640,6 +49384,7 @@
 2392002304,2392010751,CA
 2392010752,2392011263,US
 2392011264,2392011519,CA
+2392011520,2392011775,US
 2392011776,2392012543,CA
 2392012544,2392014079,US
 2392014080,2392014335,CA
@@ -47683,16 +49428,22 @@
 2399148032,2399149055,DO
 2399149056,2399150079,BR
 2399150080,2399151103,BQ
-2399151104,2399156223,BR
-2399157248,2399162367,BR
-2399162368,2399163391,AR
-2399163392,2399164415,BR
+2399151104,2399158271,BR
+2399158272,2399159295,AR
+2399159296,2399161343,BR
+2399161344,2399163391,AR
+2399163392,2399165439,BR
 2399165440,2399166463,CO
 2399166464,2399167487,VE
+2399167488,2399167743,AR
+2399167744,2399167999,BO
+2399168000,2399168511,CO
 2399168512,2399169535,SV
 2399169536,2399170559,CO
 2399170560,2399182847,BR
+2399182848,2399183871,CR
 2399183872,2399184895,BR
+2399184896,2399185919,AR
 2399185920,2399186943,TT
 2399186944,2399202303,BR
 2399202304,2399203327,HN
@@ -47749,12 +49500,21 @@
 2408140800,2408141823,DO
 2408141824,2408144895,BR
 2408144896,2408145919,CO
-2408145920,2408146943,BR
-2408148992,2408162303,BR
+2408145920,2408147967,BR
+2408147968,2408148991,MX
+2408148992,2408150015,BO
+2408150016,2408157183,BR
+2408157184,2408158207,PE
+2408158208,2408159231,CR
+2408159232,2408162303,BR
 2408162304,2408164351,HN
-2408164352,2408178687,BR
+2408164352,2408169471,BR
+2408169472,2408170495,TT
+2408170496,2408178687,BR
 2408178688,2408179711,HN
-2408179712,2408185855,BR
+2408179712,2408182783,BR
+2408182784,2408183807,AR
+2408183808,2408185855,BR
 2408185856,2409562111,US
 2409562112,2409627647,GB
 2409627648,2409693183,ZA
@@ -47779,13 +49539,54 @@
 2411757568,2411986943,US
 2411986944,2412052479,FR
 2412052480,2412314623,US
-2412381184,2412383231,BR
+2412380160,2412383231,BR
 2412383232,2412384255,CL
 2412384256,2412387327,AR
-2412387328,2412396543,BR
+2412387328,2412388351,BR
+2412388352,2412389375,AR
+2412389376,2412399615,BR
+2412399616,2412400639,MX
+2412400640,2412402687,BR
+2412402688,2412403711,AR
+2412403712,2412404735,BR
+2412404736,2412405759,AR
+2412405760,2412414975,BR
+2412414976,2412415999,AR
+2412416000,2412417023,CL
+2412417024,2412418047,AR
+2412418048,2412419071,BR
+2412419072,2412420095,PA
+2412420096,2412421119,MX
+2412421120,2412422143,CR
+2412422144,2412429311,BR
+2412429312,2412430335,AR
+2412430336,2412431359,HN
+2412431360,2412432383,AR
+2412432384,2412433407,MX
+2412433408,2412434431,PY
+2412434432,2412444671,BR
+2412444672,2412445695,NI
 2412445696,2412576767,US
 2412576768,2412642303,AT
 2412642304,2412773375,US
+2412773376,2412777471,BR
+2412777472,2412778495,HN
+2412778496,2412782591,BR
+2412782592,2412783615,AR
+2412783616,2412784639,BR
+2412784640,2412786687,AR
+2412786688,2412787711,CL
+2412787712,2412788735,GT
+2412788736,2412789759,BR
+2412789760,2412790783,CO
+2412790784,2412807167,BR
+2412807168,2412808191,PE
+2412808192,2412815359,BR
+2412815360,2412816383,DO
+2412816384,2412817407,CR
+2412817408,2412819455,BR
+2412819456,2412820479,GT
+2412820480,2412838911,BR
 2412838912,2412904447,US
 2412904448,2412969983,GB
 2412969984,2413297663,US
@@ -47814,9 +49615,38 @@
 2415656960,2415722495,GB
 2415722496,2415788031,JP
 2415788032,2415853567,US
+2415853568,2415859711,BR
+2415859712,2415860735,CL
+2415860736,2415861759,CR
+2415861760,2415862783,HN
+2415862784,2415863807,AR
+2415863808,2415864831,MX
+2415864832,2415867903,BR
+2415867904,2415868927,MX
+2415868928,2415875071,BR
+2415875072,2415876095,VE
+2415876096,2415880191,BR
+2415880192,2415881215,CL
+2415881216,2415888383,BR
+2415888384,2415889407,AR
+2415889408,2415890431,PY
+2415890432,2415892479,BR
+2415892480,2415893503,AR
+2415893504,2415894527,PA
+2415894528,2415898623,BR
+2415898624,2415899647,CL
+2415899648,2415917055,BR
+2415917056,2415918079,EC
+2415918080,2415919103,BR
 2415919104,2415984639,CN
 2416050176,2416058367,US
-2416058368,2416115711,NL
+2416058368,2416084991,NL
+2416084992,2416085247,AU
+2416085248,2416085503,NL
+2416085504,2416085759,US
+2416085760,2416086015,NL
+2416086016,2416086271,SG
+2416086272,2416115711,NL
 2416115712,2416181247,US
 2416181248,2416246783,FI
 2416246784,2416312319,US
@@ -48135,7 +49965,8 @@
 2449473536,2449477631,DE
 2449477632,2449479679,AL
 2449479680,2449481727,FR
-2449481728,2449485823,DE
+2449481728,2449485567,DE
+2449485568,2449485823,PL
 2449485824,2449487871,IE
 2449487872,2449488383,GB
 2449488384,2449489919,RO
@@ -48146,7 +49977,9 @@
 2449494016,2449496063,UA
 2449496064,2449498111,FR
 2449498112,2449506303,DE
-2449506304,2449534975,RO
+2449506304,2449532639,RO
+2449532640,2449532655,DE
+2449532656,2449534975,RO
 2449534976,2449539071,DE
 2449539072,2449604607,US
 2449604608,2449670143,NO
@@ -48225,7 +50058,6 @@
 2455175168,2455240703,GB
 2455240704,2455244799,US
 2455244800,2455245567,AU
-2455245568,2455245823,SG
 2455245824,2455246847,AU
 2455246848,2455247871,IN
 2455247872,2455248127,AU
@@ -48237,12 +50069,17 @@
 2455263232,2455265279,PH
 2455265280,2455273471,US
 2455273472,2455275519,AU
-2455275520,2455279615,US
+2455275520,2455278079,US
+2455278080,2455278591,NZ
+2455278592,2455279615,US
 2455279616,2455280127,MO
 2455280128,2455280383,MY
 2455280384,2455281663,MO
 2455281664,2455285759,IN
-2455285760,2455371775,US
+2455285760,2455290879,US
+2455290880,2455291903,MY
+2455291904,2455293951,KH
+2455293952,2455371775,US
 2455371776,2455437311,GB
 2455437312,2455830527,US
 2455830528,2455896063,GB
@@ -48344,7 +50181,8 @@
 2461612032,2461613567,IL
 2461613568,2461613823,PS
 2461613824,2461614079,IL
-2461614080,2461630463,TR
+2461614080,2461622271,CH
+2461622272,2461630463,TR
 2461630464,2461646847,NL
 2461646848,2461648895,RU
 2461648896,2461649023,BY
@@ -48709,7 +50547,9 @@
 2500050944,2500067327,KZ
 2500067328,2500132991,US
 2500132992,2500133023,NL
-2500133024,2500141055,US
+2500133024,2500138367,US
+2500138368,2500138399,BE
+2500138400,2500141055,US
 2500141056,2500141311,IE
 2500141312,2500141823,US
 2500141824,2500142847,IE
@@ -48737,7 +50577,9 @@
 2500180736,2500180991,HR
 2500180992,2500188679,US
 2500188680,2500188687,CH
-2500188688,2500196351,US
+2500188688,2500191231,US
+2500191232,2500191487,FR
+2500191488,2500196351,US
 2500196352,2500198399,FI
 2500198400,2500198911,US
 2500198912,2500199167,GB
@@ -48749,7 +50591,9 @@
 2500202880,2500203007,ES
 2500203008,2500209919,US
 2500209920,2500210175,GB
-2500210176,2500212415,US
+2500210176,2500211728,US
+2500211729,2500211730,SI
+2500211731,2500212415,US
 2500212416,2500212423,CH
 2500212424,2500212991,US
 2500212992,2500213247,ES
@@ -48757,13 +50601,17 @@
 2500221456,2500221459,FR
 2500221460,2500225551,US
 2500225552,2500225559,ES
-2500225560,2500230041,US
+2500225560,2500226615,US
+2500226616,2500226623,NL
+2500226624,2500230041,US
 2500230042,2500230042,GB
 2500230043,2500235775,US
 2500235776,2500236031,GB
 2500236032,2500236837,US
 2500236838,2500236838,ES
-2500236839,2500238047,US
+2500236839,2500237791,US
+2500237792,2500237799,IT
+2500237800,2500238047,US
 2500238048,2500238055,FR
 2500238056,2500239615,US
 2500239616,2500239871,FR
@@ -48843,7 +50691,9 @@
 2500567040,2500567295,GB
 2500567296,2500568679,US
 2500568680,2500568683,GB
-2500568684,2500591615,US
+2500568684,2500569687,US
+2500569688,2500569695,BE
+2500569696,2500591615,US
 2500591616,2500595711,GB
 2500595712,2500596223,US
 2500596224,2500596735,CH
@@ -48857,17 +50707,23 @@
 2500644864,2500645119,FR
 2500645120,2500646911,US
 2500646912,2500647935,ES
-2500647936,2500666463,US
+2500647936,2500663295,US
+2500663296,2500664319,ES
+2500664320,2500666463,US
 2500666464,2500666471,LU
 2500666472,2500681759,US
 2500681760,2500681767,PL
-2500681768,2500685823,US
+2500681768,2500682495,US
+2500682496,2500682751,PL
+2500682752,2500685823,US
 2500685824,2500686079,FR
 2500686080,2500687871,US
 2500687872,2500689919,FR
 2500689920,2500694527,US
 2500694528,2500694783,IT
-2500694784,2500719103,US
+2500694784,2500695039,US
+2500695040,2500696063,IT
+2500696064,2500719103,US
 2500719104,2500721151,IE
 2500721152,2500723711,US
 2500723712,2500723799,GB
@@ -48875,19 +50731,23 @@
 2500723808,2500723967,GB
 2500723968,2500728063,US
 2500728064,2500728319,GB
-2500728320,2500743215,US
+2500728320,2500739599,US
+2500739600,2500739607,DE
+2500739608,2500743215,US
 2500743216,2500743223,GB
 2500743224,2500984831,US
-2500984832,2501017599,GB
-2501017600,2501574655,US
+2500984832,2501033983,GB
+2501033984,2501574655,US
 2501574656,2501640191,KZ
 2501640192,2502033407,US
 2502033408,2502037503,LU
 2502037504,2502041599,US
-2502041600,2502043647,ES
-2502043648,2503016447,US
+2502041600,2502045695,ES
+2502045696,2503016447,US
 2503016448,2503147519,IL
-2503147520,2503671807,US
+2503147520,2503344127,US
+2503344128,2503376895,AF
+2503376896,2503671807,US
 2503671808,2503737343,NL
 2503737344,2503868415,US
 2503868416,2503876607,RU
@@ -48916,7 +50776,9 @@
 2504917504,2504917759,IL
 2504917760,2504918642,US
 2504918643,2504918643,IL
-2504918644,2504920831,US
+2504918644,2504919670,US
+2504919671,2504919671,IL
+2504919672,2504920831,US
 2504920832,2504921087,IL
 2504921088,2504923135,US
 2504923136,2504923391,IL
@@ -48930,11 +50792,15 @@
 2504936192,2504936447,IL
 2504936448,2504938495,US
 2504938496,2504938751,IL
-2504938752,2504943615,US
+2504938752,2504941293,US
+2504941294,2504941294,IL
+2504941295,2504943615,US
 2504943616,2504944639,IL
 2504944640,2504945151,US
 2504945152,2504945407,IL
-2504945408,2504945663,US
+2504945408,2504945432,US
+2504945433,2504945433,IL
+2504945434,2504945663,US
 2504945664,2504946175,IL
 2504946176,2504946431,US
 2504946432,2504946687,IL
@@ -48993,7 +50859,9 @@
 2508077056,2508079103,BE
 2508079104,2508081151,DE
 2508081152,2508081407,NL
-2508081408,2508081663,IL
+2508081408,2508081445,IL
+2508081446,2508081446,US
+2508081447,2508081663,IL
 2508081664,2508082431,GB
 2508082432,2508082943,DE
 2508082944,2508083199,GB
@@ -49090,19 +50958,31 @@
 2513070560,2513070591,ES
 2513070592,2513070623,FR
 2513070624,2513070655,ES
-2513070656,2513076471,FR
+2513070656,2513073791,FR
+2513073792,2513073855,IT
+2513073856,2513073951,FR
+2513073952,2513073983,ES
+2513073984,2513076471,FR
 2513076472,2513076479,ES
 2513076480,2513078367,FR
 2513078368,2513078371,GB
 2513078372,2513079250,FR
 2513079251,2513079254,ES
-2513079255,2513081327,FR
+2513079255,2513080031,FR
+2513080032,2513080063,IT
+2513080064,2513081327,FR
 2513081328,2513081343,ES
-2513081344,2513082561,FR
+2513081344,2513081935,FR
+2513081936,2513081939,DE
+2513081940,2513082561,FR
 2513082562,2513082562,GB
-2513082563,2513102899,FR
+2513082563,2513102047,FR
+2513102048,2513102063,ES
+2513102064,2513102899,FR
 2513102900,2513102903,CZ
-2513102904,2513108991,FR
+2513102904,2513103935,FR
+2513103936,2513103967,IE
+2513103968,2513108991,FR
 2513108992,2513502207,DE
 2513502208,2513567743,NO
 2513567744,2513600511,GR
@@ -49325,7 +51205,8 @@
 2532474880,2532475903,NZ
 2532475904,2532476927,KR
 2532476928,2532477951,AU
-2532477952,2532478975,IN
+2532477952,2532478463,IN
+2532478464,2532478975,AE
 2532478976,2532479999,KR
 2532480000,2532481023,IN
 2532481024,2532486143,CN
@@ -49364,7 +51245,9 @@
 2538606044,2538606047,DE
 2538606048,2538606403,FR
 2538606404,2538606407,GB
-2538606408,2538619359,FR
+2538606408,2538613134,FR
+2538613135,2538613135,NL
+2538613136,2538619359,FR
 2538619360,2538619375,ES
 2538619376,2538619431,FR
 2538619432,2538619435,DE
@@ -49433,7 +51316,9 @@
 2538658348,2538658351,DE
 2538658352,2538658623,FR
 2538658624,2538658655,NL
-2538658656,2538664847,FR
+2538658656,2538663299,FR
+2538663300,2538663303,IT
+2538663304,2538664847,FR
 2538664848,2538664863,NL
 2538664864,2538664895,DE
 2538664896,2538668031,FR
@@ -49478,8 +51363,9 @@
 2545811456,2547187711,US
 2547187712,2547318783,GB
 2547318784,2547515391,US
-2547523584,2547535871,GB
-2547535872,2547548159,BG
+2547523584,2547524607,GB
+2547524608,2547525631,IR
+2547525632,2547535871,GB
 2547548160,2547580927,NO
 2548039680,2548563967,GB
 2548563968,2548826111,IR
@@ -49697,7 +51583,9 @@
 2572954368,2572954623,HK
 2572954624,2572954879,AU
 2572954880,2572955135,HK
-2572955136,2572955647,DE
+2572955136,2572955388,DE
+2572955389,2572955389,HK
+2572955390,2572955647,DE
 2572955648,2572959743,BR
 2572959744,2572960255,DE
 2572960256,2572960511,SE
@@ -49727,7 +51615,9 @@
 2574188544,2574254079,NZ
 2574254080,2574286847,SE
 2574286848,2574287103,AU
-2574287104,2574319615,SE
+2574287104,2574311167,SE
+2574311168,2574311423,US
+2574311424,2574319615,SE
 2574319616,2574647295,US
 2574647296,2574778367,CN
 2574778368,2583582207,JP
@@ -49754,7 +51644,8 @@
 2584477696,2584608767,US
 2584608768,2584739839,CH
 2584739840,2584739903,AU
-2584739904,2584740095,ZA
+2584739904,2584739935,DE
+2584739936,2584740095,ZA
 2584740096,2584740351,US
 2584740352,2584740415,AU
 2584740416,2584740479,DE
@@ -49820,7 +51711,8 @@
 2584750144,2584750335,ZA
 2584750336,2584750591,US
 2584750592,2584750655,MY
-2584750656,2584750847,ZA
+2584750656,2584750687,DE
+2584750688,2584750847,ZA
 2584750848,2584751103,US
 2584751104,2584751167,AE
 2584751168,2584751359,ZA
@@ -49845,7 +51737,8 @@
 2584754688,2584754943,ZA
 2584754944,2584755199,US
 2584755200,2584755263,AR
-2584755264,2584755455,ZA
+2584755264,2584755279,DE
+2584755280,2584755455,ZA
 2584755456,2584755711,US
 2584755712,2584755775,AR
 2584755776,2584755967,ZA
@@ -49894,17 +51787,26 @@
 2584763456,2584763647,ZA
 2584763648,2584763903,US
 2584763904,2584763967,HK
-2584763968,2584764159,ZA
-2584764160,2584764415,US
+2584763968,2584763999,DE
+2584764000,2584764159,ZA
+2584764160,2584764415,SG
 2584764416,2584764671,ZA
 2584764672,2584775423,US
 2584775424,2584775679,KE
-2584775680,2585001983,US
+2584775680,2584780287,US
+2584780288,2584780543,ES
+2584780544,2585001983,US
 2585001984,2585067519,CA
-2585067520,2585788415,US
+2585067520,2585330440,US
+2585330441,2585330442,SI
+2585330443,2585330468,US
+2585330469,2585330470,SI
+2585330471,2585788415,US
 2585788416,2585853951,GB
 2585853952,2585985023,JP
-2585985024,2586480639,US
+2585985024,2586378751,US
+2586378752,2586379263,UA
+2586379264,2586480639,US
 2586480640,2586484735,IL
 2586484736,2586486783,GB
 2586486784,2586510335,US
@@ -49932,8 +51834,8 @@
 2586715136,2586716159,US
 2586716160,2586716671,ES
 2586716672,2586717183,US
-2586717184,2586717439,ES
-2586717440,2586733567,US
+2586717184,2586718207,ES
+2586718208,2586733567,US
 2586733568,2586733823,LT
 2586733824,2586734591,US
 2586734592,2586735615,LT
@@ -49949,7 +51851,9 @@
 2586806272,2586807295,ES
 2586807296,2586828799,US
 2586828800,2586829055,CH
-2586829056,2586869759,US
+2586829056,2586829311,US
+2586829312,2586829567,CH
+2586829568,2586869759,US
 2586869760,2586870015,ES
 2586870016,2586870271,US
 2586870272,2586875903,ES
@@ -49964,7 +51868,9 @@
 2586953472,2586953727,ES
 2586953728,2586953983,MX
 2586953984,2586954239,PE
-2586954240,2587017215,US
+2586954240,2586968127,US
+2586968128,2586968319,FR
+2586968320,2587017215,US
 2587017216,2587017471,IE
 2587017472,2587017983,US
 2587017984,2587018495,IE
@@ -49999,12 +51905,14 @@
 2587249419,2587361791,US
 2587361792,2587362047,MD
 2587362048,2587394559,US
-2587394560,2587395071,ES
-2587395072,2587396095,US
+2587394560,2587395327,ES
+2587395328,2587396095,US
 2587396096,2587399167,ES
 2587399168,2587412223,US
 2587412224,2587414527,IT
-2587414528,2587443199,US
+2587414528,2587427839,US
+2587427840,2587428863,GR
+2587428864,2587443199,US
 2587443200,2587447295,CH
 2587447296,2587476760,US
 2587476761,2587476761,LB
@@ -50012,12 +51920,13 @@
 2587479120,2587479120,LB
 2587479121,2587481969,US
 2587481970,2587481970,LB
-2587481971,2587488255,US
-2587488256,2587492351,GB
+2587481971,2587484159,US
+2587484160,2587492351,GB
 2587492352,2587493375,ES
 2587493376,2587494399,US
 2587494400,2587496447,ES
-2587496448,2587508735,US
+2587496448,2587504639,US
+2587504640,2587508735,ES
 2587508736,2587525119,GB
 2587525120,2587542527,US
 2587542528,2587544575,ES
@@ -50028,8 +51937,8 @@
 2587586560,2587592703,US
 2587592704,2587594751,GB
 2587594752,2587623423,US
-2587623424,2587627519,BG
-2587627520,2587639807,US
+2587623424,2587631615,BG
+2587631616,2587639807,US
 2587639808,2587640063,GB
 2587640064,2587926527,US
 2587926528,2587930623,BG
@@ -50083,6 +51992,7 @@
 2588082176,2588147711,RE
 2588147712,2588164095,CI
 2588164096,2588180479,RW
+2588188672,2588196863,ZA
 2588196864,2588213247,NG
 2588213248,2588278783,ZA
 2588278784,2588295167,KE
@@ -50192,6 +52102,7 @@
 2591479552,2591479807,AO
 2591479808,2591481855,PT
 2591481856,2591483903,TZ
+2591483904,2591485951,KE
 2591485952,2591486975,SO
 2591486976,2591487999,ZA
 2591488000,2591489023,GA
@@ -50214,6 +52125,7 @@
 2591612928,2591621119,ZW
 2591621120,2591686655,DZ
 2591686656,2591817727,KE
+2591817728,2591948799,SN
 2591948800,2591981567,MG
 2591981568,2591997951,CM
 2591997952,2592006143,ZA
@@ -50278,6 +52190,7 @@
 2605318144,2606301183,US
 2606301184,2606366719,AO
 2606366720,2606563327,US
+2606563328,2606596095,NG
 2606628864,2607349759,US
 2607349760,2607415295,CH
 2607415296,2609053695,US
@@ -50351,21 +52264,20 @@
 2617140736,2617140991,CA
 2617140992,2617141247,LC
 2617141248,2617141503,SV
-2617141504,2617141759,GT
+2617141504,2617141759,US
 2617141760,2617142015,ZW
 2617142016,2617142271,KR
 2617142272,2617142527,US
 2617142528,2617142783,LU
-2617142784,2617143039,PH
+2617142784,2617143039,US
 2617143040,2617143295,UG
 2617143296,2617143551,US
 2617143552,2617143807,TT
 2617143808,2617144063,US
 2617144064,2617144319,ZA
-2617144320,2617144575,MU
+2617144320,2617144575,US
 2617144576,2617144831,FJ
-2617144832,2617145087,US
-2617145088,2617145343,MX
+2617144832,2617145343,US
 2617145344,2617145599,NI
 2617145600,2617145855,UA
 2617145856,2617146111,US
@@ -50373,8 +52285,7 @@
 2617146368,2617146623,US
 2617146624,2617146879,GY
 2617146880,2617147135,DE
-2617147136,2617147391,AO
-2617147392,2617149439,US
+2617147136,2617149439,US
 2617149440,2617155583,CA
 2617155584,2617163775,US
 2617163776,2617164031,SK
@@ -50496,9 +52407,122 @@
 2623602688,2623668223,CL
 2623668224,2624192511,US
 2624192512,2624258047,CH
-2624258048,2624281087,US
+2624258048,2624269313,US
+2624269314,2624269314,AU
+2624269315,2624269317,US
+2624269318,2624269318,AU
+2624269319,2624269321,US
+2624269322,2624269322,AU
+2624269323,2624269345,US
+2624269346,2624269346,AU
+2624269347,2624269349,US
+2624269350,2624269350,AU
+2624269351,2624269353,US
+2624269354,2624269354,AU
+2624269355,2624269377,US
+2624269378,2624269378,AU
+2624269379,2624269381,US
+2624269382,2624269382,AU
+2624269383,2624269385,US
+2624269386,2624269386,AU
+2624269387,2624279039,US
+2624279040,2624279071,IN
+2624279072,2624279095,US
+2624279096,2624279111,IN
+2624279112,2624281087,US
 2624281088,2624281343,IN
-2624281344,2624716799,US
+2624281344,2624292863,US
+2624292864,2624292883,SG
+2624292884,2624292887,HK
+2624292888,2624292891,SG
+2624292892,2624292895,TW
+2624292896,2624292899,KR
+2624292900,2624292903,VN
+2624292904,2624292907,JP
+2624292908,2624292911,ID
+2624292912,2624292915,MY
+2624292916,2624292919,PH
+2624292920,2624292923,TH
+2624292924,2624293003,SG
+2624293004,2624293007,HK
+2624293008,2624293011,SG
+2624293012,2624293015,TW
+2624293016,2624293019,KR
+2624293020,2624293023,VN
+2624293024,2624293027,JP
+2624293028,2624293031,ID
+2624293032,2624293035,MY
+2624293036,2624293039,PH
+2624293040,2624293043,TH
+2624293044,2624293139,SG
+2624293140,2624293143,HK
+2624293144,2624293147,SG
+2624293148,2624293151,TW
+2624293152,2624293155,KR
+2624293156,2624293159,VN
+2624293160,2624293163,JP
+2624293164,2624293167,ID
+2624293168,2624293171,MY
+2624293172,2624293175,PH
+2624293176,2624293179,TH
+2624293180,2624293375,SG
+2624293376,2624293385,US
+2624293386,2624293386,SG
+2624293387,2624297983,US
+2624297984,2624297999,SG
+2624298000,2624298003,CN
+2624298004,2624298007,HK
+2624298008,2624298011,SG
+2624298012,2624298015,TW
+2624298016,2624298019,KR
+2624298020,2624298023,VN
+2624298024,2624298027,JP
+2624298028,2624298031,ID
+2624298032,2624298035,MY
+2624298036,2624298039,PH
+2624298040,2624298043,TH
+2624298044,2624298119,SG
+2624298120,2624298123,CN
+2624298124,2624298127,HK
+2624298128,2624298131,SG
+2624298132,2624298135,TW
+2624298136,2624298139,KR
+2624298140,2624298143,VN
+2624298144,2624298147,JP
+2624298148,2624298151,ID
+2624298152,2624298155,MY
+2624298156,2624298159,PH
+2624298160,2624298163,TH
+2624298164,2624298255,SG
+2624298256,2624298259,CN
+2624298260,2624298263,HK
+2624298264,2624298267,SG
+2624298268,2624298271,TW
+2624298272,2624298275,KR
+2624298276,2624298279,VN
+2624298280,2624298283,JP
+2624298284,2624298287,ID
+2624298288,2624298291,MY
+2624298292,2624298295,PH
+2624298296,2624298299,TH
+2624298300,2624298495,SG
+2624298496,2624302081,US
+2624302082,2624302082,AU
+2624302083,2624302085,US
+2624302086,2624302086,AU
+2624302087,2624302089,US
+2624302090,2624302090,AU
+2624302091,2624302113,US
+2624302114,2624302114,AU
+2624302115,2624302117,US
+2624302118,2624302118,AU
+2624302119,2624302121,US
+2624302122,2624302122,AU
+2624302123,2624302149,US
+2624302150,2624302150,AU
+2624302151,2624302153,US
+2624302154,2624302154,AU
+2624302155,2624716799,US
 2624716800,2624782335,NL
 2624782336,2624847871,CH
 2624847872,2624913407,NO
@@ -50516,6 +52540,7 @@
 2627141632,2627403775,US
 2627469312,2627731455,TZ
 2627731456,2631925759,EG
+2631925760,2634022911,SC
 2634022912,2634088447,CN
 2634088448,2634350591,JP
 2634416128,2635005951,JP
@@ -50578,7 +52603,9 @@
 2642280448,2642411519,US
 2642411520,2642477055,AU
 2642477056,2642542591,FI
-2642542592,2642935807,US
+2642542592,2642751487,US
+2642751488,2642753535,CA
+2642753536,2642935807,US
 2642935808,2643001343,FR
 2643001344,2643066879,US
 2643066880,2643132415,IT
@@ -50695,7 +52722,9 @@
 2655324800,2655325695,US
 2655325696,2655325823,CA
 2655325824,2655326207,US
-2655326208,2655326463,CA
+2655326208,2655326287,CA
+2655326288,2655326303,US
+2655326304,2655326463,CA
 2655326464,2655373256,US
 2655373257,2655373257,CA
 2655373258,2655715327,US
@@ -50920,7 +52949,9 @@
 2671509504,2671575039,NL
 2671575040,2671711479,US
 2671711480,2671711483,DE
-2671711484,2671718827,US
+2671711484,2671711573,US
+2671711574,2671711574,GB
+2671711575,2671718827,US
 2671718828,2671718831,GB
 2671718832,2671749119,US
 2671749120,2671750143,CA
@@ -50975,9 +53006,15 @@
 2675580064,2675580095,AE
 2675580096,2675589119,US
 2675589120,2675605503,DE
-2675605504,2675606271,US
+2675605504,2675605961,US
+2675605962,2675605962,DE
+2675605963,2675605963,US
+2675605964,2675605964,DE
+2675605965,2675606271,US
 2675606272,2675606527,IT
-2675606528,2675628415,US
+2675606528,2675606975,US
+2675606976,2675607039,IT
+2675607040,2675628415,US
 2675628416,2675628447,GB
 2675628448,2675630095,US
 2675630096,2675630111,GB
@@ -51116,7 +53153,9 @@
 2682008576,2682008831,GB
 2682008832,2682014207,US
 2682014208,2682014719,GB
-2682014720,2682014975,TH
+2682014720,2682014725,TH
+2682014726,2682014727,SG
+2682014728,2682014975,TH
 2682014976,2682015231,US
 2682015232,2682015487,IN
 2682015488,2682107903,US
@@ -51276,9 +53315,12 @@
 2691366912,2691760127,US
 2691825664,2691891199,HU
 2691891200,2692218879,ZA
+2692218880,2692284415,CI
 2692284416,2692546559,ZA
 2692546560,2694316031,US
+2694316032,2694381567,NG
 2694381568,2694447103,US
+2694447104,2694578175,CI
 2694578176,2694840319,TN
 2694840320,2696151039,MA
 2696151040,2696216575,IT
@@ -51287,7 +53329,9 @@
 2696478720,2696871935,JP
 2696937472,2697789439,JP
 2697789440,2697854975,US
-2697854976,2697889791,AU
+2697854976,2697887743,AU
+2697887744,2697887999,ES
+2697888000,2697889791,AU
 2697889792,2697891839,US
 2697891840,2697892095,GB
 2697892096,2697892863,AU
@@ -51321,9 +53365,15 @@
 2700804096,2700935167,JP
 2700935168,2701066239,US
 2701066240,2701131775,BG
-2701131776,2701132543,HN
+2701131776,2701131807,HN
+2701131808,2701131823,CA
+2701131824,2701132543,HN
 2701132544,2701132559,CR
-2701132560,2701139967,HN
+2701132560,2701136047,HN
+2701136048,2701136055,US
+2701136056,2701139135,HN
+2701139136,2701139151,UY
+2701139152,2701139967,HN
 2701139968,2701148159,NI
 2701148160,2701149183,AR
 2701149184,2701150207,HN
@@ -51345,7 +53395,9 @@
 2701393920,2701459455,NO
 2701459456,2701524991,AT
 2701524992,2701656063,US
-2701656064,2701721599,RU
+2701656064,2701688831,RU
+2701688832,2701721087,US
+2701721088,2701721599,RU
 2701721600,2701787135,TR
 2701787136,2701852671,CO
 2701852672,2701918207,US
@@ -51357,9 +53409,9 @@
 2702442496,2702508031,CH
 2702508032,2702573567,US
 2702573568,2702581759,AR
-2702581760,2702585855,VE
-2702585856,2702586111,CW
-2702586112,2702586367,PA
+2702581760,2702583807,VE
+2702583808,2702585855,MX
+2702585856,2702586367,PA
 2702586368,2702587903,CW
 2702587904,2702589951,BR
 2702589952,2702606335,GF
@@ -51441,6 +53493,29 @@
 2708865024,2708930559,JP
 2708930560,2709127167,US
 2709127168,2709192703,KR
+2709192704,2709225471,ZA
+2709225472,2709225727,ES
+2709225728,2709225983,ZA
+2709225984,2709226239,ES
+2709226240,2709242111,ZA
+2709242112,2709242367,US
+2709242368,2709242623,ZA
+2709242624,2709242879,US
+2709242880,2709243135,ZA
+2709243136,2709243391,US
+2709243392,2709243647,ZA
+2709243648,2709243903,US
+2709243904,2709244159,ZA
+2709244160,2709244415,US
+2709244416,2709244671,ZA
+2709244672,2709244927,US
+2709244928,2709245183,ZA
+2709245184,2709245439,US
+2709245440,2709245695,ZA
+2709245696,2709245951,US
+2709245952,2709246207,ZA
+2709246208,2709246463,US
+2709246464,2709258239,ZA
 2709258240,2709389311,US
 2709389312,2709454847,SG
 2709454848,2709716991,US
@@ -51481,7 +53556,11 @@
 2714373128,2714373128,SG
 2714373129,2714386431,US
 2714386432,2714402815,JP
-2714402816,2714697727,US
+2714402816,2714403996,US
+2714403997,2714403997,JP
+2714403998,2714407160,US
+2714407161,2714407161,JP
+2714407162,2714697727,US
 2714697728,2714763263,CN
 2714763264,2715025407,US
 2715025408,2715090943,VE
@@ -51537,7 +53616,9 @@
 2724268288,2724268543,MX
 2724268544,2724303989,US
 2724303990,2724303990,GB
-2724303991,2724790271,US
+2724303991,2724304013,US
+2724304014,2724304014,GB
+2724304015,2724790271,US
 2724790272,2724855807,CN
 2724855808,2724921343,CA
 2724921344,2725249023,US
@@ -51550,19 +53631,54 @@
 2727411712,2727608319,AU
 2727608320,2728132607,US
 2728132608,2728263679,CA
-2728263680,2728263935,US
-2728263936,2728264703,AU
-2728264704,2728266495,US
-2728266496,2728266751,QA
-2728266752,2728273407,US
-2728273408,2728273663,IE
-2728273664,2728282271,US
-2728282272,2728282303,CA
-2728282304,2728286207,US
-2728286208,2728286463,DE
-2728286464,2728289023,US
-2728289024,2728289279,AE
-2728289280,2731543551,US
+2728263680,2728264703,AU
+2728264704,2728265727,JP
+2728265728,2728266751,QA
+2728266752,2728267775,KW
+2728267776,2728268799,RO
+2728268800,2728269823,FR
+2728269824,2728270847,MY
+2728270848,2728271871,OM
+2728271872,2728272895,GB
+2728272896,2728273919,IE
+2728273920,2728274943,KE
+2728274944,2728278015,IN
+2728278016,2728284159,US
+2728284160,2728288255,DE
+2728288256,2728289279,AE
+2728289280,2728290303,PL
+2728290304,2728291327,US
+2728291328,2728291839,NL
+2728291840,2728292351,US
+2728292352,2728293375,DE
+2728293376,2728294399,JP
+2728294400,2728295423,US
+2728295424,2728296447,CA
+2728296448,2728297471,EG
+2728297472,2728298495,DK
+2728298496,2728300543,US
+2728300544,2728301567,CA
+2728301568,2728302591,CH
+2728302592,2728303615,GB
+2728303616,2728304639,AT
+2728304640,2728304895,US
+2728304896,2728305407,SG
+2728305408,2728308735,US
+2728308736,2728309759,HK
+2728309760,2728310783,SE
+2728310784,2728311807,US
+2728311808,2728312831,KR
+2728312832,2728313087,FR
+2728313088,2728313855,US
+2728313856,2728314879,IT
+2728314880,2728315903,DE
+2728315904,2728316927,US
+2728316928,2728317951,BG
+2728317952,2728319999,US
+2728320000,2728321023,NO
+2728321024,2728323071,US
+2728323072,2728324095,BE
+2728324096,2731543551,US
 2731543552,2731544575,CA
 2731544576,2731549695,US
 2731549696,2731550719,CA
@@ -51596,7 +53712,8 @@
 2731717632,2731718655,CA
 2731718656,2731728895,US
 2731728896,2731729919,CA
-2731729920,2731761663,US
+2731729920,2731739135,US
+2731740160,2731761663,US
 2731761664,2731763711,CA
 2731763712,2731765759,US
 2731765760,2731767807,CA
@@ -51679,7 +53796,7 @@
 2732273664,2732275711,CA
 2732275712,2732278783,US
 2732278784,2732279807,CA
-2732279808,2732302335,US
+2732279808,2732301311,US
 2732302336,2732303359,CA
 2732303360,2732306431,US
 2732306432,2732307455,CA
@@ -51720,9 +53837,7 @@
 2732455936,2732457983,CA
 2732457984,2732472319,US
 2732472320,2732474367,CA
-2732474368,2732475391,US
-2732475392,2732476415,CA
-2732476416,2732478463,US
+2732474368,2732478463,US
 2732478464,2732479487,CA
 2732479488,2732480511,AG
 2732480512,2732485631,US
@@ -51738,8 +53853,8 @@
 2732499968,2732500223,US
 2732500224,2732500479,TW
 2732500480,2732515327,US
-2732515328,2732516351,VG
-2732516352,2732523519,US
+2732515328,2732515583,VG
+2732515584,2732523519,US
 2732523520,2732525567,CA
 2732525568,2732534783,US
 2732534784,2732536831,CA
@@ -51863,9 +53978,7 @@
 2734389248,2734389503,CA
 2734389504,2734389535,US
 2734389536,2734390271,CA
-2734390272,2734398463,US
-2734398464,2734399487,PR
-2734399488,2734407679,US
+2734390272,2734407679,US
 2734407680,2734409727,CA
 2734409728,2734435327,US
 2734435328,2734436351,CA
@@ -52011,7 +54124,7 @@
 2738167808,2738168831,AU
 2738168832,2738177023,CN
 2738177024,2738178047,AU
-2738179072,2738182143,IN
+2738178048,2738182143,IN
 2738182144,2738195455,CN
 2738195456,2738196479,BD
 2738196480,2738197503,AU
@@ -52029,8 +54142,7 @@
 2738214912,2738215935,HK
 2738215936,2738216959,CN
 2738216960,2738217983,HK
-2738217984,2738219007,AU
-2738219008,2738220031,NZ
+2738217984,2738220031,AU
 2738220032,2738221055,PK
 2738221056,2738222079,CN
 2738222080,2738223103,MO
@@ -52070,7 +54182,9 @@
 2745548800,2745565183,DE
 2745565184,2745696255,GB
 2745696256,2745761791,CH
-2745761792,2746023935,GB
+2745761792,2745962865,GB
+2745962866,2745962866,FR
+2745962867,2746023935,GB
 2746023936,2746089471,FR
 2746089472,2746155007,NO
 2746155008,2746220543,NL
@@ -52158,8 +54272,8 @@
 2756313088,2756378623,US
 2756378624,2756444159,AU
 2756444160,2756509695,US
-2756509696,2756556799,CL
-2756556800,2756557311,PE
+2756509696,2756556543,CL
+2756556544,2756557311,PE
 2756557312,2756575231,CL
 2756575232,2756640767,SG
 2756640768,2756706303,US
@@ -52192,7 +54306,11 @@
 2759917568,2759983103,FR
 2759983104,2760048639,IT
 2760048640,2760114175,FR
-2760114176,2760179711,IT
+2760114176,2760119967,IT
+2760119968,2760119983,GB
+2760119984,2760120839,IT
+2760120840,2760120843,PT
+2760120844,2760179711,IT
 2760179712,2760245247,DE
 2760245248,2760310783,GB
 2760310784,2760376319,SE
@@ -52284,14 +54402,29 @@
 2773090304,2773221375,US
 2773221376,2773286911,JP
 2773286912,2773745663,US
-2773745664,2773794815,NZ
+2773745664,2773778431,NZ
+2773778432,2773794815,HK
 2773794816,2773798911,IN
-2773798912,2773805055,NZ
+2773798912,2773803007,NZ
+2773803008,2773803263,GB
+2773803264,2773804031,NZ
+2773804032,2773804287,GB
+2773804288,2773804799,NZ
+2773804800,2773805055,GB
 2773805056,2773807103,JP
 2773807104,2773811199,IN
 2773811200,2773876735,US
 2773876736,2773942271,AU
 2773942272,2774138879,US
+2774138880,2774147071,KE
+2774147072,2774155263,ZA
+2774155264,2774163455,MZ
+2774163456,2774171647,CV
+2774171648,2774188031,RE
+2774188032,2774192127,ZA
+2774192128,2774196223,ML
+2774196224,2774200319,ZA
+2774200320,2774204415,NG
 2774204416,2774335487,US
 2774335488,2774401023,JP
 2774401024,2774532095,US
@@ -52367,7 +54500,9 @@
 2781478912,2781544447,HK
 2781544448,2781623807,US
 2781623808,2781624319,CA
-2781624320,2781630463,US
+2781624320,2781628415,US
+2781628416,2781628671,DE
+2781628672,2781630463,US
 2781630464,2781631487,MY
 2781631488,2781675519,US
 2781675520,2781741055,NZ
@@ -52382,7 +54517,9 @@
 2782724096,2782789631,US
 2782789632,2782855167,CH
 2782855168,2782995455,US
-2782995456,2782995967,CA
+2782995456,2782995526,CA
+2782995527,2782995527,US
+2782995528,2782995967,CA
 2782995968,2783002623,US
 2783002624,2783002879,DK
 2783002880,2783003135,US
@@ -52532,9 +54669,13 @@
 2808938496,2809069567,US
 2809069568,2809135103,SA
 2809135104,2809266175,US
-2809266176,2809274367,CA
+2809266176,2809269025,CA
+2809269026,2809269026,US
+2809269027,2809274367,CA
 2809274368,2809274623,US
-2809274624,2809277375,CA
+2809274624,2809276083,CA
+2809276084,2809276087,US
+2809276088,2809277375,CA
 2809277376,2809277407,FR
 2809277408,2809281575,CA
 2809281576,2809281583,US
@@ -52542,15 +54683,23 @@
 2809282653,2809282653,US
 2809282654,2809286975,CA
 2809286976,2809286991,US
-2809286992,2809291732,CA
+2809286992,2809287979,CA
+2809287980,2809287983,US
+2809287984,2809291732,CA
 2809291733,2809291733,US
 2809291734,2809291823,CA
 2809291824,2809291824,US
 2809291825,2809291891,CA
 2809291892,2809291892,US
-2809291893,2809308599,CA
+2809291893,2809297711,CA
+2809297712,2809297712,US
+2809297713,2809302815,CA
+2809302816,2809302831,US
+2809302832,2809308599,CA
 2809308600,2809308607,US
-2809308608,2809321007,CA
+2809308608,2809316607,CA
+2809316608,2809316623,US
+2809316624,2809321007,CA
 2809321008,2809321015,US
 2809321016,2809323519,CA
 2809323520,2809331711,FR
@@ -52603,7 +54752,9 @@
 2815229952,2815295487,ID
 2815295488,2815986943,US
 2815986944,2815987199,GB
-2815987200,2815988863,US
+2815987200,2815988383,US
+2815988384,2815988415,GB
+2815988416,2815988863,US
 2815988864,2815988895,GB
 2815988896,2816159743,US
 2816159744,2816159999,IN
@@ -52634,9 +54785,75 @@
 2818003723,2818003723,US
 2818003724,2818004991,GB
 2818004992,2818113535,US
+2818113536,2818115583,BR
+2818115584,2818116607,PE
+2818116608,2818118655,BR
+2818118656,2818119679,SV
+2818119680,2818121727,BR
+2818121728,2818122751,VE
+2818122752,2818123775,BR
+2818123776,2818124799,CO
+2818124800,2818125823,AR
+2818125824,2818126847,BR
+2818126848,2818127871,AR
+2818127872,2818143231,BR
+2818143232,2818144255,MX
+2818144256,2818162687,BR
+2818162688,2818164735,AR
+2818164736,2818165759,BZ
+2818165760,2818168831,BR
+2818168832,2818169855,AR
+2818169856,2818178047,BR
+2818178048,2818179071,MX
+2818179072,2818180095,BR
+2818180096,2818181119,AR
+2818181120,2818188287,BR
+2818188288,2818189311,PY
+2818189312,2818191359,BR
+2818191360,2818192383,VE
+2818192384,2818193407,CL
+2818193408,2818198527,BR
+2818198528,2818199551,MX
+2818199552,2818206719,BR
+2818206720,2818207743,HN
+2818207744,2818208767,PA
+2818208768,2818209791,AR
+2818209792,2818210815,CO
+2818210816,2818212863,BR
+2818212864,2818213887,CL
+2818213888,2818222079,BR
+2818222080,2818223103,AR
+2818223104,2818225151,BR
+2818225152,2818226175,EC
+2818226176,2818228223,BR
+2818228224,2818229247,CR
+2818229248,2818231295,BR
+2818231296,2818232319,PE
+2818232320,2818233343,AR
+2818233344,2818234367,HN
+2818234368,2818235391,BR
+2818235392,2818236415,GT
+2818236416,2818244607,BR
 2818244608,2818310143,US
 2818310144,2818375679,AR
 2818375680,2818572287,US
+2818572288,2818575359,BR
+2818575360,2818576383,PE
+2818576384,2818586623,BR
+2818586624,2818587647,AR
+2818587648,2818593791,BR
+2818593792,2818594815,SX
+2818594816,2818619391,BR
+2818619392,2818620415,AR
+2818620416,2818623487,BR
+2818623488,2818625535,AR
+2818625536,2818626559,BR
+2818626560,2818627583,HN
+2818627584,2818628607,BR
+2818628608,2818629631,MX
+2818629632,2818634751,BR
+2818634752,2818635775,CO
+2818636800,2818637823,BR
 2818637824,2818670591,AU
 2818670592,2822592397,US
 2822592398,2822592398,IE
@@ -52662,6 +54879,35 @@
 2824357888,2824358143,CA
 2824358144,2824404991,US
 2824404992,2824470527,ZA
+2824471552,2824472575,BR
+2824472576,2824473599,AR
+2824473600,2824474623,CO
+2824474624,2824487935,BR
+2824487936,2824488959,MX
+2824488960,2824489983,AR
+2824489984,2824492031,BR
+2824492032,2824493055,AR
+2824493056,2824494079,BR
+2824494080,2824495103,VE
+2824495104,2824496127,HN
+2824496128,2824497151,BR
+2824498176,2824499199,HN
+2824499200,2824503295,BR
+2824503296,2824504319,AR
+2824504320,2824510463,BR
+2824510464,2824511487,CL
+2824511488,2824512511,AR
+2824512512,2824515583,BR
+2824515584,2824516607,PY
+2824516608,2824520703,BR
+2824520704,2824521727,HN
+2824521728,2824526847,BR
+2824526848,2824527871,CL
+2824527872,2824528895,BR
+2824529920,2824530943,CL
+2824531968,2824532991,BR
+2824534016,2824535039,BR
+2824535040,2824536063,AR
 2824536064,2824798207,US
 2824798208,2824863743,TW
 2824863744,2824929279,AR
@@ -52673,12 +54919,27 @@
 2826108928,2826174463,KR
 2826174464,2826436607,US
 2826436608,2826502143,TH
+2826502144,2826510335,BR
+2826510336,2826512383,AR
+2826512384,2826513407,BR
+2826513408,2826515455,PE
+2826515456,2826516479,BR
+2826517504,2826518527,MX
+2826518528,2826522623,BR
+2826523648,2826524671,SR
+2826524672,2826525695,BR
+2826531840,2826532863,AR
 2826567680,2826633215,US
 2826633216,2826698751,GU
 2826698752,2826829823,US
 2826829824,2826895359,KR
-2826895360,2826960895,US
-2826960896,2827026431,ZA
+2826895360,2826962943,US
+2826962944,2826964991,DE
+2826964992,2826969087,US
+2826969088,2826971135,AU
+2826971136,2826973183,NL
+2826973184,2826975231,AU
+2826975232,2827026431,ZA
 2827026432,2827091967,US
 2827091968,2827157503,AU
 2827157504,2827223039,KR
@@ -52698,7 +54959,9 @@
 2828599808,2828664831,AU
 2828664832,2828730367,KR
 2828730368,2828795903,ZA
-2828795904,2829033471,US
+2828795904,2829029375,US
+2829029376,2829029631,CN
+2829029632,2829033471,US
 2829033472,2829033727,IN
 2829033728,2829041663,US
 2829041664,2829041919,AU
@@ -52777,7 +55040,9 @@
 2835349504,2835480575,ZA
 2835480576,2837446655,US
 2837446656,2837839871,CH
-2837839872,2837905407,US
+2837839872,2837858047,US
+2837858048,2837858055,IN
+2837858056,2837905407,US
 2837905408,2837970943,CH
 2837970944,2838036479,US
 2838036480,2838233087,CH
@@ -52826,11 +55091,13 @@
 2844524544,2844590079,KR
 2844590080,2844862975,US
 2844862976,2844863231,CA
-2844863232,2845704191,US
+2844863232,2845114367,US
+2845114368,2845179903,SG
+2845179904,2845704191,US
 2845704192,2845769727,CU
 2845769728,2845786111,GA
 2845786112,2845802495,NG
-2845818880,2845822975,ZA
+2845802496,2845835263,ZA
 2845835264,2848212991,US
 2848212992,2848215039,GB
 2848215040,2848244735,US
@@ -52860,6 +55127,30 @@
 2851030016,2851031039,ZA
 2851031040,2851032063,CD
 2851032064,2851033087,AO
+2851033088,2851035135,ZA
+2851035136,2851036159,UG
+2851036160,2851037183,LY
+2851037184,2851038207,CF
+2851038208,2851039231,ML
+2851039232,2851040255,MZ
+2851040256,2851041279,AO
+2851041280,2851042303,GQ
+2851042304,2851043327,LY
+2851043328,2851044351,TD
+2851044352,2851045887,ZA
+2851045888,2851046399,SC
+2851046400,2851047423,AO
+2851047424,2851048447,SN
+2851048448,2851049471,MU
+2851049472,2851050495,MZ
+2851050496,2851051519,GA
+2851051520,2851052543,SC
+2851052544,2851053567,CD
+2851053568,2851054591,KE
+2851054592,2851055615,ZA
+2851055616,2851057663,KE
+2851057664,2851060735,ZA
+2851060736,2851062783,NG
 2851078144,2851995647,US
 2852061184,2852062207,ZA
 2852062208,2852063231,CM
@@ -52933,7 +55224,11 @@
 2856058880,2856124415,CH
 2856124416,2856184831,US
 2856184832,2856185855,GB
-2856185856,2856442367,US
+2856185856,2856438783,US
+2856438784,2856439039,BR
+2856439040,2856439295,US
+2856439296,2856439551,BR
+2856439552,2856442367,US
 2856442368,2856442623,PH
 2856442624,2856452095,US
 2856452096,2856517631,BR
@@ -52965,7 +55260,7 @@
 2863267840,2863595519,US
 2863595520,2863661055,CA
 2863661056,2863857663,US
-2863857664,2863923199,SG
+2863857664,2863923199,CN
 2863923200,2864844799,US
 2864844800,2864845055,NL
 2864845056,2864848895,US
@@ -53304,13 +55599,19 @@
 2892146944,2892147199,NL
 2892147200,2892149503,US
 2892149504,2892149759,NL
-2892149760,2892171263,US
+2892149760,2892150271,US
+2892150272,2892150783,CA
+2892150784,2892171263,US
 2892171264,2892172287,CA
 2892172288,2892174335,US
 2892174336,2892177407,CA
 2892177408,2892369919,US
 2892369920,2892374015,CA
-2892374016,2892423167,US
+2892374016,2892420607,US
+2892420608,2892420863,CA
+2892420864,2892421631,US
+2892421632,2892421887,CA
+2892421888,2892423167,US
 2892423168,2892424191,VI
 2892424192,2892425215,CA
 2892425216,2892443647,US
@@ -53330,7 +55631,27 @@
 2892990208,2892990463,CA
 2892990464,2892990975,IT
 2892990976,2892991231,ID
-2892991232,2893676543,US
+2892991232,2892991487,US
+2892991488,2892991999,CN
+2892992000,2892992511,HK
+2892992512,2892993023,IT
+2892993024,2892993535,JP
+2892993536,2892994047,AE
+2892994048,2892994559,US
+2892994560,2892994815,JO
+2892994816,2892995327,GB
+2892995328,2892995839,AU
+2892995840,2892996095,CA
+2892996096,2892996607,US
+2892996608,2892996863,CA
+2892996864,2892997119,AU
+2892997120,2892997375,CA
+2892997376,2892997887,AU
+2892997888,2892998655,GB
+2892998656,2892998911,HK
+2892998912,2892999167,MX
+2892999168,2892999423,MT
+2892999424,2893676543,US
 2893676544,2893807615,CA
 2893807616,2894921727,US
 2894921728,2895118335,GB
@@ -53629,7 +55950,13 @@
 2918477824,2918481919,CA
 2918481920,2918527231,US
 2918527232,2918527487,FR
-2918527488,2918536719,US
+2918527488,2918527743,US
+2918527744,2918527999,DE
+2918528000,2918528255,US
+2918528256,2918528511,NL
+2918528512,2918530559,US
+2918530560,2918530815,HK
+2918530816,2918536719,US
 2918536720,2918536727,CA
 2918536728,2918570239,US
 2918570240,2918570495,JP
@@ -53816,6 +56143,7 @@
 2939002880,2939004927,KR
 2939004928,2939006975,JP
 2939006976,2939007999,KP
+2939008000,2939009023,IN
 2939009024,2939011071,ID
 2939011072,2939027455,KR
 2939027456,2942304255,CN
@@ -53836,6 +56164,7 @@
 2942779392,2942795775,VN
 2942795776,2942959615,JP
 2942959616,2942960639,VN
+2942960640,2942961663,AU
 2942961664,2942965759,ID
 2942965760,2942967807,AU
 2942967808,2942975999,AF
@@ -53855,8 +56184,15 @@
 2943311872,2943312895,HK
 2943312896,2943313919,NZ
 2943313920,2943314943,SG
+2943314944,2943315967,CN
 2943315968,2943318015,ID
 2943318016,2943320063,JP
+2943320064,2943324159,IN
+2943324160,2943332351,CN
+2943332352,2943333375,AU
+2943333376,2943334399,IN
+2943334400,2943335423,CN
+2943335424,2943336447,IN
 2943336448,2943352831,TW
 2943352832,2944401407,KR
 2944401408,2944925695,JP
@@ -53867,6 +56203,8 @@
 2946367488,2946375679,KR
 2946375680,2946383871,ID
 2946383872,2946392063,IN
+2946392064,2946393087,CN
+2946393088,2946394111,HK
 2946394112,2946396159,AU
 2946396160,2946400255,JP
 2946400256,2946416639,NC
@@ -53876,6 +56214,8 @@
 2947547136,2947579903,PH
 2947579904,2947583999,KR
 2947584000,2947586047,TO
+2947586048,2947587071,HK
+2947587072,2947588095,CN
 2947588096,2947590143,ID
 2947590144,2947590655,JP
 2947590656,2947590911,SG
@@ -53889,12 +56229,18 @@
 2947591184,2947591679,SG
 2947591680,2947591695,JP
 2947591696,2947592191,SG
+2947592192,2947593215,CN
+2947593216,2947594239,HK
+2947594240,2947595263,IN
+2947595264,2947596287,CN
 2947596288,2947597311,IN
 2947597312,2947598335,JP
 2947598336,2947602431,AU
 2947602432,2947603455,NZ
 2947603456,2947604479,TH
-2947604480,2947612671,HK
+2947604480,2947609855,HK
+2947609856,2947610111,AF
+2947610112,2947612671,HK
 2947612672,2947678207,JP
 2947678208,2947743743,CN
 2947743744,2947809279,JP
@@ -54223,7 +56569,8 @@
 2956500992,2956503039,NL
 2956503040,2956504063,CY
 2956504064,2956504319,CH
-2956504320,2956504831,NL
+2956504320,2956504575,NL
+2956504576,2956504831,CH
 2956504832,2956505087,RU
 2956505088,2956506111,NL
 2956506112,2956506367,GB
@@ -54284,7 +56631,7 @@
 2956888064,2956890111,BE
 2956890112,2956892159,IR
 2956892160,2956894207,IT
-2956894208,2956898303,NL
+2956894208,2956898303,BE
 2956898304,2956902399,RU
 2956902400,2956904447,NL
 2956904448,2956906495,DK
@@ -54489,7 +56836,7 @@
 2959796224,2959806463,RU
 2959806464,2959810559,SK
 2959810560,2959814655,PL
-2959814656,2959818751,RU
+2959814656,2959818751,UA
 2959818752,2959822847,RO
 2959822848,2959824895,RU
 2959824896,2959826943,UA
@@ -54747,7 +57094,16 @@
 2961057792,2961061887,RU
 2961061888,2961062911,PL
 2961062912,2961063935,UA
-2961063936,2961072127,NL
+2961063936,2961064959,NL
+2961064960,2961065215,HK
+2961065216,2961065471,AU
+2961065472,2961065727,BR
+2961065728,2961066239,HK
+2961066240,2961067519,NL
+2961067520,2961067775,GB
+2961067776,2961069567,NL
+2961069568,2961069823,IN
+2961069824,2961072127,NL
 2961072128,2961088511,UA
 2961088512,2961088767,SE
 2961088768,2961089023,RU
@@ -54803,7 +57159,7 @@
 2967400448,2967404543,RU
 2967404544,2967422975,RO
 2967422976,2967425023,KZ
-2967425024,2967427071,DE
+2967425024,2967427071,IR
 2967427072,2967428095,NL
 2967428096,2967432191,RO
 2967432192,2967432447,GB
@@ -54811,7 +57167,8 @@
 2967432960,2967433215,CH
 2967433216,2967434239,RO
 2967434240,2967435007,GB
-2967435008,2967441407,RO
+2967435008,2967435263,IE
+2967435264,2967441407,RO
 2967441408,2967445503,MD
 2967445504,2967446015,GB
 2967446016,2967446783,RO
@@ -54872,7 +57229,9 @@
 2984247296,2984935423,MX
 2984935424,2984936447,AR
 2984936448,2984937471,BR
-2984937472,2984939519,HN
+2984937472,2984938239,HN
+2984938240,2984938255,US
+2984938256,2984939519,HN
 2984939520,2984951807,BR
 2984951808,2984968191,EC
 2984968192,2985033727,BR
@@ -55132,7 +57491,9 @@
 2988465216,2988465219,ES
 2988465220,2988465559,FR
 2988465560,2988465563,ES
-2988465564,2988466098,FR
+2988465564,2988466059,FR
+2988466060,2988466063,CZ
+2988466064,2988466098,FR
 2988466099,2988466099,BE
 2988466100,2988476415,FR
 2988476416,2988478463,IT
@@ -55309,7 +57670,9 @@
 2988540564,2988540567,CZ
 2988540568,2988541955,FR
 2988541956,2988541959,DE
-2988541960,2988542627,FR
+2988541960,2988542339,FR
+2988542340,2988542340,PT
+2988542341,2988542627,FR
 2988542628,2988542631,NL
 2988542632,2988544671,FR
 2988544672,2988544687,GB
@@ -55336,7 +57699,9 @@
 2988547904,2988548015,FR
 2988548016,2988548019,ES
 2988548020,2988548095,FR
-2988548096,2988550143,ES
+2988548096,2988548338,ES
+2988548339,2988548339,FR
+2988548340,2988550143,ES
 2988550144,2988550359,FR
 2988550360,2988550363,ES
 2988550364,2988550438,FR
@@ -55694,9 +58059,11 @@
 3000317952,3000319999,PL
 3000320000,3000322047,FR
 3000322048,3000322303,PL
-3000322304,3000322559,RU
+3000322304,3000322559,GB
 3000322560,3000322815,DE
-3000322816,3000326143,RU
+3000322816,3000323071,RU
+3000323072,3000323583,DE
+3000323584,3000326143,RU
 3000326144,3000330239,PL
 3000330240,3000332287,UA
 3000332288,3000334335,RU
@@ -55772,7 +58139,9 @@
 3000606720,3000608767,UA
 3000608768,3000610815,KG
 3000610816,3000612863,RU
-3000612864,3000616959,PL
+3000612864,3000613241,PL
+3000613242,3000613242,PT
+3000613243,3000616959,PL
 3000616960,3000621055,UA
 3000621056,3000623103,PL
 3000623104,3000625151,RU
@@ -55864,7 +58233,9 @@
 3002003456,3002011647,PL
 3002011648,3002015743,BA
 3002015744,3002019839,IT
-3002019840,3002023935,NL
+3002019840,3002021271,NL
+3002021272,3002021279,MT
+3002021280,3002023935,NL
 3002023936,3002028031,DE
 3002028032,3002036223,GB
 3002036224,3002040319,BG
@@ -56113,7 +58484,10 @@
 3003154944,3003159039,AR
 3003159040,3003159295,CO
 3003159296,3003160575,AR
-3003160576,3003161599,CL
+3003160576,3003160831,CL
+3003160832,3003161087,PE
+3003161088,3003161343,CO
+3003161344,3003161599,CL
 3003161600,3003162623,UY
 3003162624,3003170815,CR
 3003170816,3003171071,GT
@@ -56158,17 +58532,17 @@
 3005890048,3005890303,CO
 3005890304,3005890559,PA
 3005890560,3005891583,CO
-3005891584,3005893119,PA
+3005891584,3005891839,PA
+3005891840,3005892095,CO
+3005892096,3005893119,PA
 3005893120,3005893631,CO
 3005893632,3005893887,PA
 3005893888,3005894911,CO
 3005894912,3005895167,PA
-3005895168,3005895423,CO
-3005895424,3005896703,PA
-3005896704,3005897727,CO
-3005897728,3005897983,PA
-3005897984,3005898239,CO
-3005898240,3005899007,PA
+3005895168,3005895935,CO
+3005895936,3005896703,PA
+3005896704,3005898495,CO
+3005898496,3005899007,PA
 3005899008,3005900543,CO
 3005900544,3005901055,PA
 3005901056,3005901311,CO
@@ -56176,8 +58550,8 @@
 3005901568,3005901823,CO
 3005901824,3005902591,PA
 3005902592,3005903871,CO
-3005903872,3005904895,PA
-3005904896,3005905407,CO
+3005903872,3005904639,PA
+3005904640,3005905407,CO
 3005905408,3005905663,PA
 3005905664,3005906943,CO
 3005906944,3005911039,PA
@@ -56191,8 +58565,7 @@
 3005913088,3005913343,PA
 3005913344,3005913599,CO
 3005913600,3005913855,PA
-3005913856,3005914879,CO
-3005914880,3005915135,PA
+3005913856,3005915135,CO
 3005915136,3005918207,AR
 3005918208,3005919231,CO
 3005919232,3005923327,AR
@@ -56224,11 +58597,7 @@
 3006279168,3006279423,NI
 3006279424,3006283519,PA
 3006283520,3006283775,NI
-3006283776,3006284543,CR
-3006284544,3006284799,PA
-3006284800,3006285055,CR
-3006285056,3006285311,PA
-3006285312,3006286335,CR
+3006283776,3006286335,CR
 3006286336,3006286847,PA
 3006286848,3006287615,CR
 3006287616,3006287871,PA
@@ -56236,40 +58605,36 @@
 3006288128,3006288383,PA
 3006288384,3006289151,CR
 3006289152,3006289407,PA
-3006289408,3006289919,CR
-3006289920,3006291199,PA
+3006289408,3006290687,CR
+3006290688,3006291199,PA
 3006291200,3006291967,CR
 3006291968,3006296575,PA
 3006296576,3006296831,CR
 3006296832,3006308351,PA
 3006308352,3006308863,CR
 3006308864,3006309631,PA
-3006309632,3006309887,CR
-3006309888,3006310143,PA
-3006310144,3006310655,CR
-3006310656,3006311167,PA
-3006311168,3006311423,CR
-3006311424,3006311679,PA
-3006311680,3006312447,CR
+3006309632,3006310655,CR
+3006310656,3006310911,PA
+3006310912,3006312447,CR
 3006312448,3006312703,PA
 3006312704,3006313471,CR
 3006313472,3006313727,PA
-3006313728,3006314495,CR
-3006314496,3006315263,PA
+3006313728,3006314751,CR
+3006314752,3006315263,PA
 3006315264,3006315775,CR
 3006315776,3006316031,PA
 3006316032,3006316287,CR
 3006316288,3006320895,PA
-3006320896,3006321151,CR
-3006321152,3006321663,PA
+3006320896,3006321407,CR
+3006321408,3006321663,PA
 3006321664,3006322175,CR
 3006322176,3006322431,PA
 3006322432,3006323199,CR
 3006323200,3006323455,PA
 3006323456,3006323711,CR
 3006323712,3006323967,PA
-3006323968,3006324479,CR
-3006324480,3006328831,PA
+3006323968,3006324735,CR
+3006324736,3006328831,PA
 3006328832,3006330623,NI
 3006330624,3006330879,PA
 3006330880,3006331903,CR
@@ -56320,14 +58685,16 @@
 3007078400,3007082495,AR
 3007082496,3007086591,BO
 3007086592,3007090687,PA
-3007090688,3007091711,NL
-3007091712,3007092223,RU
+3007090688,3007091199,NL
+3007091200,3007092223,RU
 3007092224,3007092479,VE
-3007092480,3007092735,FK
+3007092480,3007092735,IR
 3007092736,3007094783,AR
 3007094784,3007096831,CR
 3007096832,3007098879,AR
-3007098880,3007100647,HN
+3007098880,3007099463,HN
+3007099464,3007099471,IN
+3007099472,3007100647,HN
 3007100648,3007100655,MX
 3007100656,3007100887,HN
 3007100888,3007100895,PH
@@ -56380,184 +58747,107 @@
 3007155728,3007155743,DE
 3007155744,3007155967,CL
 3007155968,3007156223,US
-3007156224,3007156239,CL
-3007156240,3007156255,DE
-3007156256,3007156351,CL
+3007156224,3007156351,DE
 3007156352,3007156479,US
 3007156480,3007156495,ES
-3007156496,3007156511,DE
-3007156512,3007156543,CL
+3007156496,3007156543,DE
 3007156544,3007156607,GB
-3007156608,3007156735,DE
-3007156736,3007156751,CL
-3007156752,3007156767,DE
-3007156768,3007156991,CL
+3007156608,3007156991,DE
 3007156992,3007157007,HR
-3007157008,3007157055,CL
+3007157008,3007157055,DE
 3007157056,3007157119,GB
-3007157120,3007157247,DE
-3007157248,3007157263,CL
-3007157264,3007157279,DE
-3007157280,3007157375,CL
+3007157120,3007157375,DE
 3007157376,3007157503,US
 3007157504,3007157519,IE
-3007157520,3007157567,CL
+3007157520,3007157567,DE
 3007157568,3007157631,GB
 3007157632,3007157759,US
-3007157760,3007157775,CL
-3007157776,3007157791,DE
-3007157792,3007158015,CL
+3007157760,3007158015,DE
 3007158016,3007158031,BE
-3007158032,3007158079,CL
+3007158032,3007158079,DE
 3007158080,3007158143,GB
-3007158144,3007158271,DE
-3007158272,3007158287,CL
-3007158288,3007158303,DE
-3007158304,3007158399,CL
+3007158144,3007158399,DE
 3007158400,3007158527,US
 3007158528,3007158543,GB
-3007158544,3007158591,CL
+3007158544,3007158591,DE
 3007158592,3007158655,GB
-3007158656,3007158783,DE
-3007158784,3007158799,CL
-3007158800,3007158815,DE
-3007158816,3007159039,CL
+3007158656,3007159039,DE
 3007159040,3007159055,GB
-3007159056,3007159103,CL
+3007159056,3007159103,DE
 3007159104,3007159167,GB
 3007159168,3007159295,US
-3007159296,3007159311,CL
-3007159312,3007159327,DE
-3007159328,3007159423,CL
+3007159296,3007159423,DE
 3007159424,3007159551,US
 3007159552,3007159567,RU
-3007159568,3007159615,CL
+3007159568,3007159615,DE
 3007159616,3007159679,GB
-3007159680,3007159807,DE
-3007159808,3007159823,CL
-3007159824,3007159839,DE
-3007159840,3007160063,CL
+3007159680,3007160063,DE
 3007160064,3007160079,HR
-3007160080,3007160127,CL
+3007160080,3007160127,DE
 3007160128,3007160191,GB
-3007160192,3007160319,DE
-3007160320,3007160335,CL
-3007160336,3007160351,DE
-3007160352,3007160447,CL
+3007160192,3007160447,DE
 3007160448,3007160575,US
 3007160576,3007160591,IE
 3007160592,3007160607,US
-3007160608,3007160639,CL
+3007160608,3007160639,DE
 3007160640,3007160655,GB
-3007160656,3007160703,CL
+3007160656,3007160703,DE
 3007160704,3007160831,US
-3007160832,3007160847,CL
-3007160848,3007160863,DE
-3007160864,3007161087,CL
+3007160832,3007161087,DE
 3007161088,3007161103,GB
-3007161104,3007161151,CL
+3007161104,3007161151,DE
 3007161152,3007161167,GB
-3007161168,3007161215,CL
-3007161216,3007161343,DE
-3007161344,3007161359,CL
-3007161360,3007161375,DE
-3007161376,3007161471,CL
+3007161168,3007161471,DE
 3007161472,3007161599,US
 3007161600,3007161615,GB
-3007161616,3007161663,CL
+3007161616,3007161663,DE
 3007161664,3007161679,GB
-3007161680,3007161727,CL
-3007161728,3007161855,DE
-3007161856,3007161871,CL
-3007161872,3007161887,DE
-3007161888,3007162111,CL
+3007161680,3007162111,DE
 3007162112,3007162127,ES
-3007162128,3007162175,CL
+3007162128,3007162175,DE
 3007162176,3007162191,GB
-3007162192,3007162239,CL
+3007162192,3007162239,DE
 3007162240,3007162367,US
-3007162368,3007162383,CL
-3007162384,3007162399,DE
-3007162400,3007162495,CL
+3007162368,3007162495,DE
 3007162496,3007162623,US
 3007162624,3007162639,NL
-3007162640,3007162687,CL
+3007162640,3007162687,DE
 3007162688,3007162703,GB
-3007162704,3007162751,CL
-3007162752,3007162879,DE
-3007162880,3007162895,CL
-3007162896,3007162911,DE
-3007162912,3007163135,CL
+3007162704,3007163135,DE
 3007163136,3007163151,GB
-3007163152,3007163199,CL
-3007163200,3007163263,DE
-3007163264,3007163407,CL
-3007163408,3007163423,DE
-3007163424,3007163519,CL
+3007163152,3007163519,DE
 3007163520,3007163647,US
 3007163648,3007163663,ES
-3007163664,3007163711,CL
-3007163712,3007163775,DE
+3007163664,3007163775,DE
 3007163776,3007163903,US
-3007163904,3007163919,CL
-3007163920,3007163935,DE
-3007163936,3007164159,CL
+3007163904,3007164159,DE
 3007164160,3007164175,SK
-3007164176,3007164223,CL
-3007164224,3007164287,DE
-3007164288,3007164431,CL
-3007164432,3007164447,DE
-3007164448,3007164543,CL
+3007164176,3007164543,DE
 3007164544,3007164671,US
 3007164672,3007164687,SE
-3007164688,3007164735,CL
-3007164736,3007164799,DE
-3007164800,3007164943,CL
-3007164944,3007164959,DE
-3007164960,3007165183,CL
+3007164688,3007165183,DE
 3007165184,3007165199,GB
-3007165200,3007165247,CL
-3007165248,3007165311,DE
+3007165200,3007165311,DE
 3007165312,3007165439,US
-3007165440,3007165455,CL
-3007165456,3007165471,DE
-3007165472,3007165567,CL
+3007165440,3007165567,DE
 3007165568,3007165695,US
 3007165696,3007165711,DK
-3007165712,3007165759,CL
-3007165760,3007165823,DE
-3007165824,3007165967,CL
-3007165968,3007165983,DE
-3007165984,3007166207,CL
+3007165712,3007166207,DE
 3007166208,3007166223,TR
-3007166224,3007166271,CL
-3007166272,3007166335,DE
-3007166336,3007166479,CL
-3007166480,3007166495,DE
-3007166496,3007166591,CL
+3007166224,3007166591,DE
 3007166592,3007166719,US
 3007166720,3007166735,GB
-3007166736,3007166751,DE
-3007166752,3007166847,CL
+3007166736,3007166847,DE
 3007166848,3007166975,US
-3007166976,3007166991,CL
-3007166992,3007167007,DE
-3007167008,3007167231,CL
+3007166976,3007167231,DE
 3007167232,3007167247,ES
-3007167248,3007167263,DE
-3007167264,3007167503,CL
-3007167504,3007167519,DE
-3007167520,3007167615,CL
+3007167248,3007167615,DE
 3007167616,3007167743,US
 3007167744,3007167759,AU
-3007167760,3007167775,DE
-3007167776,3007168015,CL
-3007168016,3007168031,DE
-3007168032,3007168127,CL
+3007167760,3007168127,DE
 3007168128,3007168255,US
 3007168256,3007168271,GR
-3007168272,3007168287,DE
-3007168288,3007168383,CL
+3007168272,3007168383,DE
 3007168384,3007168511,US
 3007168512,3007168767,QA
 3007168768,3007169023,CL
@@ -56598,23 +58888,39 @@
 3007174336,3007174399,BR
 3007174400,3007174431,IS
 3007174432,3007174463,IT
-3007174464,3007175679,BR
+3007174464,3007174655,BR
+3007174656,3007174911,US
+3007174912,3007175167,BR
+3007175168,3007175679,US
 3007175680,3007175935,GB
 3007175936,3007175967,NZ
 3007175968,3007175999,BE
 3007176000,3007176319,BR
 3007176320,3007176351,SE
 3007176352,3007176383,FR
-3007176384,3007181183,BR
+3007176384,3007176703,BR
+3007176704,3007177727,IN
+3007177728,3007177983,BR
+3007177984,3007178751,US
+3007178752,3007179007,BR
+3007179008,3007179775,US
+3007179776,3007180031,BR
+3007180032,3007180287,US
+3007180288,3007180543,BR
+3007180544,3007180799,US
+3007180800,3007181183,BR
 3007181184,3007181215,IT
 3007181216,3007181247,IS
-3007181248,3007181567,BR
+3007181248,3007181311,BR
+3007181312,3007181567,US
 3007181568,3007181599,NL
 3007181600,3007181631,AU
 3007181632,3007181823,BR
 3007181824,3007181855,BE
 3007181856,3007181887,NO
-3007181888,3007182591,BR
+3007181888,3007182079,BR
+3007182080,3007182335,US
+3007182336,3007182591,BR
 3007182592,3007182623,SE
 3007182624,3007182655,NL
 3007182656,3007183231,BR
@@ -56649,7 +58955,9 @@
 3007281152,3007281919,PA
 3007281920,3007283199,CR
 3007283200,3007284479,PA
-3007284480,3007285759,CR
+3007284480,3007284991,CR
+3007284992,3007285247,PA
+3007285248,3007285759,CR
 3007285760,3007286271,PA
 3007286272,3007286783,CR
 3007286784,3007287295,PA
@@ -56690,7 +58998,10 @@
 3024879616,3025141759,CN
 3025141760,3025403903,KR
 3025403904,3025600511,CN
-3025600512,3025602047,IN
+3025600512,3025601663,IN
+3025601664,3025601791,HK
+3025601792,3025601919,IN
+3025601920,3025602047,CN
 3025602048,3025602303,HK
 3025602304,3025603071,IN
 3025603072,3025603091,HK
@@ -56699,10 +59010,11 @@
 3025603104,3025603215,HK
 3025603216,3025603327,IN
 3025603328,3025603335,GU
-3025603336,3025603839,IN
+3025603336,3025603583,IN
+3025603584,3025603839,SG
 3025603840,3025604095,HK
-3025604096,3025604607,IN
-3025604608,3025606655,SG
+3025604096,3025604351,IN
+3025604352,3025606655,SG
 3025606656,3025606815,IN
 3025606816,3025606831,SG
 3025606832,3025607167,IN
@@ -56717,8 +59029,10 @@
 3025612800,3025612815,IN
 3025612816,3025612831,SG
 3025612832,3025612895,IN
-3025612896,3025613063,SG
-3025613064,3025616895,IN
+3025612896,3025613067,SG
+3025613068,3025613071,IN
+3025613072,3025613079,SG
+3025613080,3025616895,IN
 3025616896,3025617439,SG
 3025617440,3025617447,IN
 3025617448,3025617455,SG
@@ -56752,8 +59066,8 @@
 3025626112,3025626367,SG
 3025626368,3025629439,IN
 3025629440,3025629951,HK
-3025629952,3025630023,AU
-3025630024,3025630207,IN
+3025629952,3025630031,AU
+3025630032,3025630207,IN
 3025630208,3025630719,AU
 3025630720,3025630975,JP
 3025630976,3025631239,IN
@@ -56762,8 +59076,8 @@
 3025631748,3025631767,HK
 3025631768,3025631999,IN
 3025632000,3025632255,HK
-3025632256,3025632399,SG
-3025632400,3025632511,IN
+3025632256,3025632423,SG
+3025632424,3025632511,IN
 3025632512,3025632767,SG
 3025632768,3025633535,IN
 3025633536,3025633791,HK
@@ -56774,7 +59088,11 @@
 3025637184,3025637375,IN
 3025637376,3025637631,HK
 3025637632,3025637887,MY
-3025637888,3025638279,IN
+3025637888,3025638015,IN
+3025638016,3025638023,HK
+3025638024,3025638031,IN
+3025638032,3025638047,HK
+3025638048,3025638279,IN
 3025638280,3025638287,SG
 3025638288,3025638399,IN
 3025638400,3025638655,SG
@@ -56790,8 +59108,8 @@
 3025639552,3025639679,SG
 3025639680,3025639807,HK
 3025639808,3025639839,IN
-3025639840,3025639871,HK
-3025639872,3025640191,IN
+3025639840,3025639879,HK
+3025639880,3025640191,IN
 3025640192,3025640447,JP
 3025640448,3025640799,MY
 3025640800,3025641727,IN
@@ -56814,7 +59132,8 @@
 3025647968,3025648079,IN
 3025648080,3025648087,SG
 3025648088,3025648091,US
-3025648092,3025649151,IN
+3025648092,3025648095,SG
+3025648096,3025649151,IN
 3025649152,3025649663,HK
 3025649664,3025649919,AE
 3025649920,3025666047,IN
@@ -56836,13 +59155,15 @@
 3025989632,3025993727,KR
 3025993728,3026059263,VN
 3026059264,3026067455,PH
+3026067456,3026068479,IN
 3026068480,3026069503,PH
 3026069504,3026071551,JP
-3026071552,3026073599,HK
+3026071552,3026073599,AU
 3026073600,3026075647,CN
 3026075648,3026083839,AF
 3026083840,3026087935,CN
 3026087936,3026089983,AU
+3026089984,3026092031,CN
 3026092032,3026108415,MO
 3026108416,3026114559,JP
 3026114560,3026115583,SG
@@ -56930,6 +59251,7 @@
 3031582720,3031584767,SG
 3031584768,3031587839,JP
 3031587840,3031592959,ID
+3031592960,3031595007,CN
 3031595008,3031596031,AU
 3031596032,3031597055,KH
 3031597056,3031613439,PK
@@ -56973,7 +59295,9 @@
 3033710592,3033712639,KR
 3033712640,3033714687,SG
 3033714688,3033715711,NZ
+3033715712,3033716735,CN
 3033716736,3033717759,TH
+3033717760,3033718783,BD
 3033718784,3033726975,CN
 3033726976,3033743359,KR
 3033743360,3033745407,IN
@@ -57028,6 +59352,8 @@
 3035199488,3035200511,IN
 3035200512,3035202559,AU
 3035202560,3035205631,JP
+3035205632,3035206655,CN
+3035206656,3035207679,IN
 3035207680,3035209727,ID
 3035209728,3035217919,HK
 3035217920,3035234303,KR
@@ -57036,9 +59362,14 @@
 3035316224,3035324415,CN
 3035324416,3035326463,JP
 3035326464,3035328511,AU
+3035328512,3035329535,CN
+3035329536,3035330559,MM
+3035330560,3035331583,IN
+3035331584,3035332607,JP
 3035332608,3035333631,AU
 3035333632,3035334655,HK
-3035335680,3035337727,JP
+3035334656,3035334911,NL
+3035334912,3035337727,JP
 3035337728,3035338751,ID
 3035338752,3035339775,SG
 3035339776,3035340799,AU
@@ -57061,19 +59392,21 @@
 3039166464,3039231999,PA
 3039232000,3039297535,EC
 3039297536,3039363071,PY
-3039363072,3039379455,BZ
+3039363072,3039379455,US
 3039379456,3039395839,GY
-3039395840,3039411199,BZ
-3039411200,3039412223,US
+3039395840,3039412223,US
 3039412224,3039412735,CL
 3039412736,3039412991,BR
 3039412992,3039413247,US
 3039413248,3039414015,BR
-3039414016,3039414271,CL
-3039414272,3039415039,BR
+3039414016,3039414527,US
+3039414528,3039414783,BR
+3039414784,3039415039,US
 3039415040,3039415295,CL
-3039415296,3039416319,BR
-3039416320,3039416591,CL
+3039415296,3039415551,US
+3039415552,3039415807,BR
+3039415808,3039416575,US
+3039416576,3039416591,CL
 3039416592,3039416607,SG
 3039416608,3039416713,CL
 3039416714,3039416715,US
@@ -57083,8 +59416,12 @@
 3039416740,3039416741,SG
 3039416742,3039416831,CL
 3039416832,3039417599,BR
-3039417600,3039417855,CL
-3039417856,3039419583,BR
+3039417600,3039417855,US
+3039417856,3039418111,BR
+3039418112,3039418623,US
+3039418624,3039418879,BR
+3039418880,3039419135,US
+3039419136,3039419583,BR
 3039419584,3039419647,SG
 3039419648,3039419839,BR
 3039419840,3039419903,SG
@@ -57097,7 +59434,9 @@
 3041132544,3041394687,CO
 3041394688,3041656831,CL
 3041656832,3041787903,BR
-3041787904,3044016127,AR
+3041787904,3041886463,AR
+3041886464,3041886719,US
+3041886720,3044016127,AR
 3044016128,3044147199,EC
 3044147200,3044155391,GT
 3044155392,3044161535,AR
@@ -57112,14 +59451,17 @@
 3044212736,3044245503,HN
 3044245504,3044278271,BO
 3044278272,3044417535,AR
-3044417536,3044425727,PA
+3044417536,3044418047,CY
+3044418048,3044425727,PA
 3044425728,3044446207,AR
 3044446208,3044450303,CO
 3044450304,3044454399,CL
 3044454400,3044482559,AR
 3044482560,3044482687,CO
 3044482688,3044503551,AR
-3044503552,3044507647,US
+3044503552,3044503807,US
+3044503808,3044504319,AR
+3044504320,3044507647,US
 3044507648,3044540415,AR
 3044540416,3045064703,PY
 3045064704,3047161855,CO
@@ -57142,8 +59484,44 @@
 3048210432,3048275967,PE
 3048275968,3048292351,AR
 3048292352,3048292607,BZ
-3048292608,3048293375,HN
-3048293376,3048308735,BZ
+3048292608,3048292799,HN
+3048292800,3048292807,ES
+3048292808,3048293375,HN
+3048293376,3048293599,BZ
+3048293600,3048293615,ES
+3048293616,3048295343,BZ
+3048295344,3048295351,CA
+3048295352,3048297407,BZ
+3048297408,3048297423,CA
+3048297424,3048298799,BZ
+3048298800,3048298807,US
+3048298808,3048299487,BZ
+3048299488,3048299503,BR
+3048299504,3048301935,BZ
+3048301936,3048301951,CA
+3048301952,3048302295,BZ
+3048302296,3048302303,CA
+3048302304,3048303303,BZ
+3048303304,3048303311,NL
+3048303312,3048304031,BZ
+3048304032,3048304047,NL
+3048304048,3048304919,BZ
+3048304920,3048304927,CR
+3048304928,3048305063,BZ
+3048305064,3048305071,CR
+3048305072,3048305471,BZ
+3048305472,3048305487,US
+3048305488,3048305983,BZ
+3048305984,3048305991,US
+3048305992,3048307607,BZ
+3048307608,3048307615,CA
+3048307616,3048307967,BZ
+3048307968,3048307983,CA
+3048307984,3048308103,BZ
+3048308104,3048308111,CA
+3048308112,3048308295,BZ
+3048308296,3048308303,CR
+3048308304,3048308735,BZ
 3048308736,3048325119,BO
 3048325120,3048331263,AR
 3048331264,3048332287,GY
@@ -57169,7 +59547,9 @@
 3049259008,3049283583,AR
 3049283584,3049291775,BZ
 3049291776,3049324543,CO
-3049324544,3049521151,CR
+3049324544,3049362175,CR
+3049362176,3049362431,NI
+3049362432,3049521151,CR
 3049521152,3049586687,EC
 3049586688,3049635839,PA
 3049635840,3049652223,AR
@@ -57238,7 +59618,8 @@
 3050708496,3050708735,BR
 3050708736,3050708991,US
 3050708992,3050709007,AT
-3050709008,3050709247,BR
+3050709008,3050709119,BR
+3050709120,3050709247,US
 3050709248,3050709375,DE
 3050709376,3050709503,BR
 3050709504,3050709519,TH
@@ -57248,8 +59629,8 @@
 3050710032,3050710271,BR
 3050710272,3050710527,US
 3050710528,3050710543,FR
-3050710544,3050710783,BR
-3050710784,3050711039,US
+3050710544,3050710655,BR
+3050710656,3050711039,US
 3050711040,3050711055,AU
 3050711056,3050711295,BR
 3050711296,3050711551,US
@@ -57257,8 +59638,8 @@
 3050711568,3050711807,BR
 3050711808,3050712063,US
 3050712064,3050712079,FR
-3050712080,3050712319,BR
-3050712320,3050712575,US
+3050712080,3050712127,BR
+3050712128,3050712575,US
 3050712576,3050712591,PL
 3050712592,3050712831,BR
 3050712832,3050713087,US
@@ -57271,12 +59652,19 @@
 3050714368,3050714623,GB
 3050714624,3050714879,BR
 3050714880,3050715135,ES
-3050715136,3050766335,US
+3050715136,3050753023,US
+3050753024,3050753279,BR
+3050753280,3050753535,PE
+3050753536,3050755071,US
+3050755072,3050755327,CO
+3050755328,3050755583,CL
+3050755584,3050766335,US
 3050766336,3050766351,NO
 3050766352,3050766591,BR
 3050766592,3050766847,US
 3050766848,3050766863,KR
-3050766864,3050767359,BR
+3050766864,3050767103,BR
+3050767104,3050767359,AR
 3050767360,3050767375,AT
 3050767376,3050767615,BR
 3050767616,3050767871,US
@@ -57284,8 +59672,8 @@
 3050767888,3050768127,BR
 3050768128,3050768383,US
 3050768384,3050768399,AT
-3050768400,3050768639,BR
-3050768640,3050768895,US
+3050768400,3050768511,BR
+3050768512,3050768895,US
 3050768896,3050768911,CZ
 3050768912,3050769151,BR
 3050769152,3050769407,US
@@ -57374,7 +59762,8 @@
 3050801008,3050801023,EC
 3050801024,3050801151,US
 3050801152,3050801167,EG
-3050801168,3050801183,GQ
+3050801168,3050801175,GQ
+3050801176,3050801183,NZ
 3050801184,3050801199,GF
 3050801200,3050801215,PF
 3050801216,3050801231,GE
@@ -57393,7 +59782,8 @@
 3050801536,3050801663,US
 3050801664,3050801679,MT
 3050801680,3050801695,MQ
-3050801696,3050801711,MU
+3050801696,3050801703,MU
+3050801704,3050801711,CL
 3050801712,3050801727,MX
 3050801728,3050801743,MC
 3050801744,3050801759,ME
@@ -57406,7 +59796,8 @@
 3050802224,3050802239,PH
 3050802240,3050802255,PR
 3050802256,3050802271,QA
-3050802272,3050802287,LC
+3050802272,3050802279,LC
+3050802280,3050802287,IN
 3050802288,3050802303,RS
 3050802304,3050802431,US
 3050802432,3050802447,SC
@@ -57414,7 +59805,8 @@
 3050802464,3050802479,KR
 3050802480,3050802495,LK
 3050802496,3050802511,TW
-3050802512,3050802527,TT
+3050802512,3050802519,TT
+3050802520,3050802527,CR
 3050802528,3050802543,UY
 3050802544,3050802559,VE
 3050802560,3050802687,US
@@ -57439,18 +59831,20 @@
 3051356160,3051372543,CR
 3051372544,3051372799,PA
 3051372800,3051373055,CR
-3051373056,3051373311,PA
-3051373312,3051374335,CR
-3051374336,3051374591,PA
+3051373056,3051374591,PA
 3051374592,3051374847,CR
-3051374848,3051375615,PA
-3051375616,3051376895,CR
+3051374848,3051375871,PA
+3051375872,3051376895,CR
 3051376896,3051377151,PA
 3051377152,3051379455,CR
 3051379456,3051379711,PA
 3051379712,3051380735,CR
 3051380736,3051388927,AR
-3051388928,3051395071,US
+3051388928,3051389695,US
+3051389696,3051389951,NL
+3051389952,3051390719,US
+3051390720,3051390975,NL
+3051390976,3051395071,US
 3051395072,3051395583,NL
 3051395584,3051397119,PA
 3051397120,3051398143,CO
@@ -57512,6 +59906,7 @@
 3054501888,3054534655,HK
 3054534656,3054537727,PH
 3054537728,3054538751,SG
+3054538752,3054540799,CN
 3054540800,3054541823,NZ
 3054541824,3054542847,BD
 3054542848,3054551039,ID
@@ -57550,6 +59945,7 @@
 3056664576,3056734207,CN
 3056734208,3056746495,KR
 3056746496,3056747519,NP
+3056747520,3056748543,IN
 3056748544,3056749567,WS
 3056749568,3056750591,SG
 3056750592,3056754687,TH
@@ -57571,12 +59967,15 @@
 3057041408,3057049599,MY
 3057049600,3057050623,AU
 3057050624,3057051647,SG
-3057051648,3057052415,AU
+3057051648,3057052159,AU
+3057052160,3057052415,US
 3057052416,3057052671,ES
 3057052672,3057052927,IL
 3057052928,3057053183,GB
-3057053184,3057053695,AU
+3057053184,3057053439,US
+3057053440,3057053695,SG
 3057053696,3057054719,JP
+3057054720,3057055743,CN
 3057055744,3057057791,JP
 3057057792,3057123327,SG
 3057123328,3057451007,IN
@@ -57602,6 +60001,13 @@
 3063971840,3063988223,AU
 3063988224,3064004607,JP
 3064004608,3064012799,LK
+3064012800,3064013823,AU
+3064013824,3064015871,HK
+3064015872,3064016895,AU
+3064016896,3064017919,SG
+3064017920,3064018943,IN
+3064018944,3064019967,NZ
+3064019968,3064020991,HK
 3064020992,3064023039,JP
 3064023040,3064024063,SG
 3064024064,3064025087,JP
@@ -57614,7 +60020,10 @@
 3064725504,3064791039,KR
 3064791040,3064807423,TW
 3064807424,3064808447,IN
-3064808448,3064809471,TW
+3064808448,3064808703,VG
+3064808704,3064808959,JP
+3064808960,3064809215,VN
+3064809216,3064809471,VG
 3064809472,3064810495,MY
 3064810496,3064811519,HK
 3064811520,3064823807,KR
@@ -57637,6 +60046,7 @@
 3068986368,3068987391,AU
 3068987392,3068990463,IN
 3068990464,3068991487,VN
+3068991488,3068993535,CN
 3068993536,3069018111,KR
 3069018112,3069034495,IN
 3069034496,3069050879,KR
@@ -57666,8 +60076,10 @@
 3074949120,3075342335,JP
 3075342336,3075375103,MY
 3075375104,3075383295,KR
+3075383296,3075385343,CN
 3075385344,3075386367,MY
 3075386368,3075387391,AU
+3075387392,3075388415,HK
 3075388416,3075389439,CN
 3075389440,3075390463,IN
 3075390464,3075391487,JP
@@ -57679,6 +60091,7 @@
 3075577856,3075579903,ID
 3075579904,3075581951,MY
 3075581952,3075582975,MN
+3075582976,3075583999,CN
 3075584000,3075585023,JP
 3075585024,3075586047,CN
 3075586048,3075588095,KH
@@ -57715,7 +60128,8 @@
 3081846784,3081847807,TW
 3081847808,3081848831,KR
 3081848832,3081850879,SG
-3081850880,3081851903,HK
+3081850880,3081851391,HK
+3081851392,3081851903,SG
 3081851904,3081852927,JP
 3081852928,3081854975,HK
 3081854976,3081859071,MN
@@ -57879,7 +60293,9 @@
 3093233664,3093237759,PR
 3093237760,3093282815,US
 3093282816,3093299199,CA
-3093299200,3093908991,US
+3093299200,3093907199,US
+3093907200,3093907455,CA
+3093907456,3093908991,US
 3093908992,3093909247,PR
 3093909248,3093909528,US
 3093909529,3093909529,AT
@@ -57982,6 +60398,7 @@
 3103859712,3103859967,RO
 3103859968,3103860223,PL
 3103860224,3103860479,FR
+3103860480,3103860735,UA
 3103860736,3103860991,BG
 3103860992,3103861247,RU
 3103861248,3103861503,PL
@@ -57993,6 +60410,18 @@
 3103862784,3103863039,DE
 3103863040,3103863295,RU
 3103863296,3103863807,UA
+3103863808,3103864063,RU
+3103864064,3103864319,GB
+3103864320,3103864575,DE
+3103864576,3103864831,NO
+3103864832,3103865087,BG
+3103865088,3103865343,DK
+3103865344,3103865599,DE
+3103865600,3103865855,BG
+3103865856,3103866367,DE
+3103866368,3103866879,UA
+3103866880,3103867135,RU
+3103867136,3103867391,NO
 3103916032,3103917055,CH
 3103917056,3103918079,IT
 3103918080,3103919103,DE
@@ -58053,7 +60482,8 @@
 3103970304,3103971327,UA
 3103971328,3103973375,GB
 3103973376,3103974399,KZ
-3103974400,3103974911,SE
+3103974400,3103974655,LT
+3103974656,3103974911,SE
 3103974912,3103974919,LT
 3103974920,3103974943,SE
 3103974944,3103975071,LT
@@ -58558,7 +60988,9 @@
 3104513024,3104514047,UA
 3104514048,3104515071,RU
 3104515072,3104516095,GB
-3104516096,3104517119,CY
+3104516096,3104516351,CY
+3104516352,3104516607,LU
+3104516608,3104517119,CY
 3104517120,3104518143,IL
 3104518144,3104519167,RU
 3104519168,3104520191,IT
@@ -58578,6 +61010,7 @@
 3104533504,3104534527,PL
 3104534528,3104535551,SE
 3104535552,3104536575,ES
+3104536576,3104537599,SA
 3104537600,3104538623,US
 3104538624,3104539647,PL
 3104539648,3104540671,RU
@@ -59401,7 +61834,9 @@
 3105400832,3105401855,DK
 3105401856,3105402879,NL
 3105402880,3105404927,RU
-3105404928,3105405951,FR
+3105404928,3105404928,FR
+3105404929,3105404929,RE
+3105404930,3105405951,FR
 3105405952,3105406975,NO
 3105406976,3105407999,FR
 3105408000,3105410047,PL
@@ -59531,7 +61966,9 @@
 3105531904,3105532927,RU
 3105532928,3105533951,RS
 3105533952,3105534975,BA
-3105534976,3105535999,NO
+3105534976,3105535794,NO
+3105535795,3105535795,RU
+3105535796,3105535999,NO
 3105536000,3105537023,AZ
 3105537024,3105538047,AT
 3105538048,3105539071,RU
@@ -60056,7 +62493,8 @@
 3106044928,3106045951,GB
 3106045952,3106046975,TR
 3106046976,3106047999,DK
-3106048000,3106049023,IT
+3106048000,3106048255,NL
+3106048256,3106049023,IT
 3106049024,3106050047,FR
 3106050048,3106051071,NL
 3106051072,3106052095,LI
@@ -60268,7 +62706,22 @@
 3106263040,3106264063,PT
 3106264064,3106265087,ES
 3106265088,3106266111,GB
-3106266112,3106267135,FR
+3106266112,3106266367,FR
+3106266368,3106266399,HK
+3106266400,3106266431,SG
+3106266432,3106266463,JP
+3106266464,3106266527,US
+3106266528,3106266543,FR
+3106266544,3106266559,HK
+3106266560,3106266591,FR
+3106266592,3106266607,US
+3106266608,3106266623,FR
+3106266624,3106266879,US
+3106266880,3106266927,FR
+3106266928,3106266943,AU
+3106266944,3106266975,FR
+3106266976,3106267007,US
+3106267008,3106267135,JP
 3106267136,3106269183,ES
 3106269184,3106270207,IS
 3106270208,3106271231,GB
@@ -60467,7 +62920,7 @@
 3106466560,3106466815,RO
 3106466816,3106467839,EE
 3106467840,3106468863,IR
-3106469888,3106470911,DE
+3106468864,3106470911,DE
 3106470912,3106471935,NL
 3106471936,3106472959,IR
 3106472960,3106473983,FR
@@ -60606,7 +63059,9 @@
 3106599936,3106601983,CH
 3106601984,3106603007,DE
 3106603008,3106604031,BE
-3106604032,3106604543,DE
+3106604032,3106604434,DE
+3106604435,3106604435,RU
+3106604436,3106604543,DE
 3106604544,3106604799,RU
 3106604800,3106605055,DE
 3106605056,3106606079,RU
@@ -60762,7 +63217,7 @@
 3106758656,3106759679,GB
 3106759680,3106760703,RU
 3106760704,3106761727,IE
-3106762752,3106763775,DE
+3106761728,3106763775,DE
 3106763776,3106764799,NL
 3106764800,3106765823,SE
 3106765824,3106766847,CZ
@@ -61005,7 +63460,15 @@
 3107013632,3107014655,DE
 3107014656,3107015679,GB
 3107015680,3107016703,DE
-3107016704,3107017727,NL
+3107016704,3107016959,NL
+3107016960,3107017087,GB
+3107017088,3107017107,NL
+3107017108,3107017108,GB
+3107017109,3107017127,NL
+3107017128,3107017128,GB
+3107017129,3107017151,NL
+3107017152,3107017215,GB
+3107017216,3107017727,NL
 3107017728,3107018751,IR
 3107018752,3107019775,BG
 3107019776,3107020799,GB
@@ -61085,7 +63548,8 @@
 3107099648,3107099903,UA
 3107099904,3107100159,CZ
 3107100160,3107100415,RU
-3107100416,3107101695,CZ
+3107100416,3107100671,SK
+3107100672,3107101695,CZ
 3107101696,3107102719,RU
 3107102720,3107103743,GB
 3107103744,3107104767,PL
@@ -61144,7 +63608,11 @@
 3107161088,3107162111,GR
 3107162112,3107163135,IT
 3107163136,3107164159,RU
-3107164160,3107165183,FR
+3107164160,3107164213,FR
+3107164214,3107164214,SE
+3107164215,3107164777,FR
+3107164778,3107164778,SE
+3107164779,3107165183,FR
 3107165184,3107166207,NL
 3107166208,3107167231,AE
 3107167232,3107168255,RU
@@ -61186,6 +63654,7 @@
 3107205120,3107206143,BG
 3107206144,3107207167,NL
 3107207168,3107207423,AT
+3107207424,3107208191,RU
 3107208192,3107209215,NL
 3107209216,3107210239,IT
 3107210240,3107213311,RU
@@ -61465,7 +63934,8 @@
 3107496192,3107496255,DE
 3107496256,3107496287,BS
 3107496288,3107496319,VG
-3107496320,3107496447,NL
+3107496320,3107496431,NL
+3107496432,3107496447,UA
 3107496448,3107496463,CL
 3107496464,3107496479,ES
 3107496480,3107496495,RO
@@ -61621,7 +64091,10 @@
 3107639296,3107640319,ES
 3107640320,3107641343,DK
 3107641344,3107643391,RU
-3107643392,3107644415,IT
+3107643392,3107643647,GB
+3107643648,3107643903,IT
+3107643904,3107643904,GB
+3107643905,3107644415,IT
 3107644416,3107645439,FR
 3107645440,3107646463,IE
 3107646464,3107647487,NL
@@ -61933,6 +64406,7 @@
 3107972096,3107973119,IT
 3107973120,3107974143,SA
 3107974144,3107975167,IR
+3107975168,3107976191,DE
 3107976192,3107977215,NL
 3107977216,3107978239,AT
 3107978240,3107979263,NL
@@ -61973,7 +64447,8 @@
 3108013056,3108014079,HR
 3108014080,3108015103,NL
 3108015104,3108015359,GB
-3108015360,3108016127,IE
+3108015360,3108015615,NL
+3108015616,3108016127,IE
 3108016128,3108017151,DE
 3108017152,3108018175,FR
 3108018176,3108019199,AT
@@ -62005,6 +64480,7 @@
 3108047872,3108050943,RU
 3108050944,3108051967,GB
 3108051968,3108052991,FR
+3108052992,3108054015,GB
 3108054016,3108055039,LV
 3108055040,3108056063,GB
 3108056064,3108057087,IT
@@ -62269,7 +64745,9 @@
 3108333568,3108334591,SK
 3108334592,3108335615,IR
 3108335616,3108336639,NL
-3108336640,3108337663,GB
+3108336640,3108337151,GB
+3108337152,3108337407,ES
+3108337408,3108337663,GB
 3108337664,3108338687,IR
 3108338688,3108339711,RU
 3108339712,3108340735,NL
@@ -62606,7 +65084,7 @@
 3108716544,3108717567,RU
 3108717568,3108718591,FR
 3108718592,3108719615,DE
-3108719616,3108720639,IT
+3108719616,3108720639,NL
 3108720640,3108721663,GI
 3108721664,3108723711,RU
 3108723712,3108724735,GB
@@ -62646,7 +65124,9 @@
 3108758528,3108759551,DE
 3108759552,3108760575,CZ
 3108760576,3108761599,LV
-3108761600,3108762623,GB
+3108761600,3108761791,GB
+3108761792,3108761855,AT
+3108761856,3108762623,GB
 3108762624,3108763647,NL
 3108763648,3108764671,RU
 3108764672,3108765695,NL
@@ -62962,7 +65442,9 @@
 3109081088,3109082111,SE
 3109082112,3109083135,PL
 3109083136,3109084159,SE
-3109084160,3109085183,GB
+3109084160,3109084170,GB
+3109084171,3109084171,NL
+3109084172,3109085183,GB
 3109085184,3109086207,AL
 3109086208,3109087231,RU
 3109087232,3109088255,NL
@@ -63340,7 +65822,9 @@
 3109465088,3109466111,DE
 3109466112,3109467135,FR
 3109467136,3109468159,IR
-3109468160,3109468351,GB
+3109468160,3109468322,GB
+3109468323,3109468323,ES
+3109468324,3109468351,GB
 3109468352,3109468415,ES
 3109468416,3109468671,GB
 3109468672,3109468799,ES
@@ -63503,7 +65987,10 @@
 3109640192,3109641215,IQ
 3109641216,3109642239,NO
 3109642240,3109643263,US
-3109643264,3109644287,UA
+3109643264,3109643391,DE
+3109643392,3109643519,UA
+3109643520,3109643775,RU
+3109643776,3109644287,UA
 3109644288,3109646335,RU
 3109646336,3109647359,IR
 3109647360,3109648383,CZ
@@ -63530,10 +66017,10 @@
 3109669888,3109670911,GB
 3109670912,3109671935,DE
 3109671936,3109672959,HR
-3109672960,3109673215,GB
+3109672960,3109673215,US
 3109673216,3109673471,NL
 3109673472,3109673727,SG
-3109673728,3109673983,GB
+3109673728,3109673983,HK
 3109673984,3109675007,FR
 3109675008,3109677055,DE
 3109677056,3109678079,BE
@@ -63772,7 +66259,22 @@
 3109921792,3109922815,IR
 3109922816,3109924863,GB
 3109924864,3109925887,IT
-3109925888,3109926911,GB
+3109925888,3109925967,GB
+3109925968,3109925975,DE
+3109925976,3109926015,GB
+3109926016,3109926031,DE
+3109926032,3109926143,GB
+3109926144,3109926159,FR
+3109926160,3109926175,GB
+3109926176,3109926183,ES
+3109926184,3109926207,GB
+3109926208,3109926215,ES
+3109926216,3109926279,GB
+3109926280,3109926287,DE
+3109926288,3109926335,ES
+3109926336,3109926399,GB
+3109926400,3109926655,ES
+3109926656,3109926911,IT
 3109926912,3109927935,UA
 3109927936,3109928959,DE
 3109928960,3109929983,DK
@@ -63864,7 +66366,11 @@
 3109989376,3109990399,RU
 3109990400,3109991423,GB
 3109991424,3109992447,NL
-3109992448,3109995519,GB
+3109992448,3109993471,GB
+3109993472,3109993727,NL
+3109993728,3109993983,FR
+3109993984,3109994239,HU
+3109994240,3109995519,GB
 3109995520,3109996543,NL
 3109996544,3109997567,IE
 3109997568,3109998591,GB
@@ -64031,7 +66537,9 @@
 3110170624,3110171647,KZ
 3110171648,3110172671,IR
 3110172672,3110173695,IT
-3110173696,3110174719,IL
+3110173696,3110173951,IL
+3110173952,3110174207,PS
+3110174208,3110174719,IL
 3110174720,3110175743,SE
 3110175744,3110176767,PS
 3110176768,3110177791,CH
@@ -64143,6 +66651,7 @@
 3110280192,3110281215,RU
 3110281216,3110282239,LB
 3110282240,3110283263,SE
+3110283264,3110284287,FR
 3110284288,3110285311,PS
 3110285312,3110286335,BE
 3110286336,3110288383,DE
@@ -64163,13 +66672,20 @@
 3110303744,3110304767,DK
 3110304768,3110305791,KZ
 3110305792,3110306815,NL
-3110306816,3110307071,NZ
-3110307072,3110307839,BY
+3110306816,3110307327,NZ
+3110307328,3110307452,GB
+3110307453,3110307453,NL
+3110307454,3110307583,GB
+3110307584,3110307683,BY
+3110307684,3110307684,BR
+3110307685,3110307839,BY
 3110307840,3110308863,IE
 3110308864,3110309887,RS
 3110309888,3110310911,DE
 3110310912,3110311935,FR
-3110311936,3110315007,RU
+3110311936,3110312959,RU
+3110312960,3110313983,UA
+3110313984,3110315007,RU
 3110315008,3110316031,GB
 3110316032,3110317055,RU
 3110317056,3110318079,PL
@@ -64240,9 +66756,14 @@
 3110389760,3110390783,LB
 3110390784,3110391807,NO
 3110391808,3110392831,AE
-3110392832,3110393855,GB
+3110392832,3110393087,GB
+3110393088,3110393343,IE
+3110393344,3110393599,GB
+3110393600,3110393855,IE
 3110393856,3110394879,LB
-3110394880,3110395903,DE
+3110394880,3110395647,DE
+3110395648,3110395648,SA
+3110395649,3110395903,DE
 3110395904,3110396927,KZ
 3110396928,3110397951,PL
 3110397952,3110398975,NL
@@ -64267,13 +66788,17 @@
 3110418432,3110419455,SE
 3110419456,3110420479,NL
 3110420480,3110421503,FR
-3110421504,3110422527,RU
+3110421504,3110422015,RU
+3110422016,3110422271,US
+3110422272,3110422527,RU
 3110422528,3110423551,PL
 3110423552,3110425599,GB
 3110425600,3110426623,IE
 3110426624,3110427647,DK
 3110427648,3110428671,DE
-3110428672,3110429695,NL
+3110428672,3110428927,NL
+3110428928,3110429183,US
+3110429184,3110429695,NL
 3110429696,3110430719,DE
 3110430720,3110431743,RO
 3110431744,3110432767,NL
@@ -64336,7 +66861,9 @@
 3110495232,3110496255,SE
 3110496256,3110497279,DE
 3110497280,3110498303,NO
-3110498304,3110501375,RU
+3110498304,3110499839,RU
+3110499840,3110500351,KZ
+3110500352,3110501375,RU
 3110501376,3110502399,RS
 3110502400,3110503423,RU
 3110503424,3110504447,GB
@@ -64454,7 +66981,7 @@
 3110629376,3110630399,UA
 3110630400,3110631423,IT
 3110631424,3110632447,GB
-3110632448,3110633471,BG
+3110632448,3110633471,IT
 3110633472,3110636543,NL
 3110636544,3110637567,DE
 3110637568,3110638591,GR
@@ -64504,16 +67031,16 @@
 3110686720,3110687743,BE
 3110687744,3110688767,RO
 3110688768,3110689791,RU
-3110689792,3110690815,BG
+3110689792,3110690815,IT
 3110690816,3110691839,GB
 3110691840,3110692863,RU
-3110692864,3110693887,HU
+3110692864,3110693887,IT
 3110693888,3110694911,UA
 3110694912,3110695935,DE
 3110695936,3110696959,RU
 3110696960,3110697983,IR
 3110697984,3110699007,GB
-3110699008,3110700031,HU
+3110699008,3110700031,IT
 3110700032,3110701055,CH
 3110701056,3110702079,FR
 3110702080,3110703103,PL
@@ -64533,13 +67060,16 @@
 3110716416,3110717439,AZ
 3110717440,3110718463,BE
 3110718464,3110719487,NL
-3110719488,3110720511,IT
-3110720512,3110721535,CZ
-3110721536,3110723583,NL
+3110719488,3110721535,IT
+3110721536,3110723087,NL
+3110723088,3110723103,DE
+3110723104,3110723583,NL
 3110723584,3110724607,RU
 3110724608,3110725631,TJ
 3110725632,3110726655,ES
-3110726656,3110727679,IR
+3110726656,3110726911,IR
+3110726912,3110726943,AE
+3110726944,3110727679,IR
 3110727680,3110728703,IT
 3110728704,3110729727,SE
 3110729728,3110730751,NL
@@ -64577,7 +67107,6 @@
 3110763008,3110763263,RO
 3110763264,3110763519,NL
 3110763520,3110764543,AD
-3110764544,3110765567,RU
 3110765568,3110766591,PL
 3110766592,3110767615,IR
 3110767616,3110768639,RS
@@ -64600,7 +67129,8 @@
 3110785024,3110786047,TR
 3110786048,3110787071,AT
 3110787072,3110788095,FR
-3110788096,3110790143,NL
+3110788096,3110789119,ES
+3110789120,3110790143,NL
 3110790144,3110791167,IR
 3110791168,3110792191,DE
 3110792192,3110793215,BE
@@ -64632,8 +67162,7 @@
 3110822912,3110823935,NL
 3110823936,3110825983,ES
 3110825984,3110829055,NL
-3110829056,3110830079,UA
-3110830080,3110831103,RU
+3110829056,3110831103,RU
 3110831104,3110832127,TR
 3110832128,3110833151,RU
 3110833152,3110834175,PL
@@ -64755,7 +67284,7 @@
 3110963200,3110965247,GB
 3110965248,3110966271,NL
 3110966272,3110967295,IL
-3110967296,3110968319,GB
+3110967296,3110968319,PT
 3110968320,3110969343,DE
 3110969344,3110970367,NL
 3110970368,3110971391,CH
@@ -64893,7 +67422,9 @@
 3111114752,3111115775,RU
 3111115776,3111116799,DE
 3111116800,3111117823,GB
-3111117824,3111118847,ES
+3111117824,3111117824,ES
+3111117825,3111118079,FR
+3111118080,3111118847,ES
 3111118848,3111119871,TR
 3111119872,3111120895,FR
 3111120896,3111121919,SE
@@ -64955,7 +67486,7 @@
 3111182336,3111183359,RU
 3111183360,3111184383,FR
 3111184384,3111185407,IQ
-3111185408,3111186431,UA
+3111185408,3111186431,RU
 3111186432,3111189503,GB
 3111189504,3111190527,DE
 3111190528,3111191551,GB
@@ -65067,7 +67598,9 @@
 3111308288,3111309311,GB
 3111309312,3111310335,CH
 3111310336,3111313407,DE
-3111313408,3111314431,AT
+3111313408,3111313663,GB
+3111313664,3111313919,NL
+3111313920,3111314431,AT
 3111314432,3111315455,GB
 3111315456,3111316479,IT
 3111316480,3111317503,NL
@@ -65105,8 +67638,8 @@
 3111349248,3111350271,GB
 3111350272,3111351295,PL
 3111351296,3111353343,GB
-3111353344,3111354111,DE
-3111354112,3111355391,GB
+3111353344,3111353855,DE
+3111353856,3111355391,GB
 3111355392,3111356415,IT
 3111356416,3111357439,GE
 3111357440,3111358463,RU
@@ -65133,7 +67666,7 @@
 3111383040,3111383295,FI
 3111383296,3111383551,FR
 3111383552,3111383807,CH
-3111383808,3111384063,FI
+3111383808,3111384063,NL
 3111384064,3111387135,NO
 3111387136,3111388159,IT
 3111388160,3111389183,NO
@@ -65187,7 +67720,7 @@
 3111444480,3111445503,SA
 3111445504,3111446527,RU
 3111446528,3111447551,DE
-3111447552,3111447791,GB
+3111447552,3111447791,NL
 3111447792,3111447807,AT
 3111447808,3111448575,GB
 3111448576,3111449599,NO
@@ -65196,14 +67729,15 @@
 3111452672,3111453695,MY
 3111453696,3111454719,NL
 3111454720,3111455743,IQ
-3111455744,3111456767,CH
+3111455744,3111456255,CH
+3111456256,3111456767,DE
 3111456768,3111457791,FR
 3111457792,3111458303,GB
 3111458304,3111458815,FR
 3111458816,3111459839,NL
 3111459840,3111460863,RU
 3111460864,3111461887,GR
-3111461888,3111462911,ES
+3111461888,3111462911,FR
 3111462912,3111463935,AT
 3111463936,3111464959,ES
 3111464960,3111465983,IR
@@ -65211,7 +67745,9 @@
 3111467008,3111469055,FR
 3111469056,3111470079,EE
 3111470080,3111471103,AE
-3111471104,3111473151,NL
+3111471104,3111471359,NL
+3111471360,3111471615,RO
+3111471616,3111473151,NL
 3111473152,3111474175,BG
 3111474176,3111475199,PL
 3111475200,3111476223,NL
@@ -65227,7 +67763,8 @@
 3111485440,3111486463,SA
 3111486464,3111487487,CY
 3111487488,3111488511,IR
-3111488512,3111490559,RU
+3111488512,3111489535,UA
+3111489536,3111490559,RU
 3111490560,3111491583,KG
 3111491584,3111493631,RU
 3111493632,3111494655,DE
@@ -65363,7 +67900,985 @@
 3111638016,3111639039,UA
 3111639040,3111640063,CZ
 3111640064,3111641087,NL
-3111641088,3111642111,IT
+3111641088,3111643135,IT
+3111643136,3111644159,GB
+3111644160,3111645183,ES
+3111645184,3111646207,IR
+3111646208,3111647231,IT
+3111647232,3111648255,ES
+3111648256,3111650559,GB
+3111650560,3111650815,NL
+3111650816,3111651071,SE
+3111651072,3111651327,GB
+3111651328,3111652351,RO
+3111652352,3111653375,GB
+3111653376,3111654399,RO
+3111654400,3111654911,GB
+3111654912,3111655423,FR
+3111655424,3111656447,NO
+3111656448,3111657471,LB
+3111657472,3111658495,GB
+3111658496,3111659519,AL
+3111659520,3111660543,IT
+3111660544,3111661567,ES
+3111661568,3111662591,FI
+3111662592,3111663615,GB
+3111663616,3111664639,RU
+3111664640,3111665663,DE
+3111665664,3111666687,PL
+3111666688,3111667711,CZ
+3111667712,3111668735,GB
+3111668736,3111669759,KZ
+3111669760,3111670783,IT
+3111670784,3111671807,ES
+3111671808,3111672831,RU
+3111672832,3111673855,MK
+3111673856,3111674879,GI
+3111674880,3111675903,NO
+3111675904,3111676927,ES
+3111676928,3111677951,AE
+3111677952,3111678975,ES
+3111678976,3111679999,GB
+3111680000,3111681023,IR
+3111681024,3111682047,IL
+3111682048,3111683071,GB
+3111683072,3111684095,UA
+3111684096,3111685119,IR
+3111685120,3111686143,CH
+3111686144,3111687167,RO
+3111687168,3111688191,DE
+3111688192,3111689215,GB
+3111689216,3111690239,DE
+3111690240,3111691263,IR
+3111691264,3111692287,BE
+3111692288,3111693311,IR
+3111693312,3111694335,GB
+3111694336,3111695359,FR
+3111695360,3111696383,RU
+3111696384,3111697407,CY
+3111697408,3111698431,RU
+3111698432,3111701503,IR
+3111701504,3111702527,GB
+3111702528,3111713791,IR
+3111713792,3111714815,RU
+3111714816,3111715839,TJ
+3111715840,3111716863,GB
+3111716864,3111717887,NL
+3111717888,3111718911,AD
+3111718912,3111719935,GB
+3111719936,3111720959,CY
+3111720960,3111721983,GB
+3111721984,3111723007,SE
+3111723008,3111725055,IT
+3111725056,3111726079,AT
+3111726080,3111727103,SE
+3111727104,3111728127,HR
+3111728128,3111729151,AT
+3111729152,3111730175,IR
+3111730176,3111731199,DK
+3111731200,3111732223,SK
+3111732224,3111733247,DE
+3111733248,3111734271,RU
+3111734272,3111735295,GB
+3111735296,3111736319,KZ
+3111736320,3111737343,RU
+3111737344,3111738367,GB
+3111738368,3111739391,NL
+3111739392,3111740415,DE
+3111740416,3111741439,IT
+3111741440,3111743487,UA
+3111743488,3111744511,NL
+3111744512,3111745535,UA
+3111745536,3111746559,MD
+3111746560,3111747583,TR
+3111747584,3111748607,IR
+3111748608,3111749631,GB
+3111749632,3111750655,DE
+3111750656,3111751679,FR
+3111751680,3111752703,GB
+3111752704,3111753727,IT
+3111753728,3111754751,BG
+3111754752,3111755775,IT
+3111755776,3111756799,NO
+3111756800,3111757823,NL
+3111757824,3111758335,NZ
+3111758336,3111758591,NL
+3111758592,3111758847,HR
+3111758848,3111759871,DK
+3111759872,3111760895,IS
+3111760896,3111761919,NL
+3111761920,3111762943,SY
+3111762944,3111763967,NL
+3111763968,3111766015,DE
+3111766016,3111767039,HR
+3111767040,3111768063,SE
+3111768064,3111769087,IT
+3111769088,3111770111,DE
+3111770112,3111771135,FI
+3111771136,3111772159,GB
+3111772160,3111773183,NL
+3111773184,3111774207,IQ
+3111774208,3111775231,ES
+3111775232,3111776255,AM
+3111776256,3111778303,RU
+3111778304,3111779327,GB
+3111779328,3111780351,SA
+3111780352,3111781375,GB
+3111781376,3111782399,DE
+3111782400,3111783423,IL
+3111783424,3111784447,TR
+3111784448,3111785471,GB
+3111785472,3111786495,NL
+3111786496,3111787519,IT
+3111787520,3111788543,RU
+3111788544,3111789567,KZ
+3111789568,3111790591,GB
+3111790592,3111791615,CZ
+3111791616,3111792639,IT
+3111792640,3111793663,CH
+3111793664,3111794687,SK
+3111794688,3111795711,GB
+3111795712,3111796735,PL
+3111796736,3111798783,GB
+3111798784,3111799807,SE
+3111799808,3111800831,CH
+3111800832,3111801855,IR
+3111801856,3111802879,DE
+3111802880,3111803903,PL
+3111803904,3111804927,LB
+3111804928,3111805951,PL
+3111805952,3111806975,FR
+3111806976,3111807999,PL
+3111808000,3111809023,FI
+3111809024,3111810047,NO
+3111810048,3111811071,NL
+3111811072,3111812095,SA
+3111812096,3111814143,GB
+3111814144,3111815167,IE
+3111815168,3111816191,PL
+3111816192,3111816447,LT
+3111816448,3111816703,GB
+3111816704,3111816959,LT
+3111816960,3111817215,GB
+3111817216,3111819263,PL
+3111819264,3111821311,NL
+3111821312,3111822335,FR
+3111822336,3111824383,NL
+3111824384,3111825407,PL
+3111825408,3111826431,RU
+3111826432,3111827455,DE
+3111827456,3111828479,ES
+3111828480,3111829503,DK
+3111829504,3111830527,NL
+3111830528,3111831551,NO
+3111831552,3111832575,TR
+3111832576,3111835647,GB
+3111835648,3111836671,CZ
+3111836672,3111837695,RO
+3111837696,3111838719,IT
+3111838720,3111839743,AL
+3111839744,3111840767,GB
+3111840768,3111841791,CH
+3111841792,3111842815,DE
+3111842816,3111843839,CH
+3111843840,3111844863,BE
+3111844864,3111845887,IQ
+3111845888,3111846911,TR
+3111846912,3111847935,GB
+3111847936,3111848959,IT
+3111848960,3111849983,RU
+3111849984,3111851007,KZ
+3111851008,3111852031,SA
+3111852032,3111853055,FR
+3111853056,3111854079,GP
+3111854080,3111855103,NO
+3111855104,3111856127,IT
+3111856128,3111857151,KZ
+3111857152,3111858175,UA
+3111858176,3111859199,PL
+3111859200,3111860223,EE
+3111860224,3111861247,ES
+3111861248,3111862271,NL
+3111862272,3111864319,IR
+3111864320,3111865343,FR
+3111865344,3111866367,RU
+3111866368,3111867391,GB
+3111867392,3111868415,FR
+3111868416,3111869439,DE
+3111869440,3111870463,NO
+3111870464,3111871487,GB
+3111871488,3111873535,TR
+3111873536,3111874559,AT
+3111874560,3111875583,GB
+3111875584,3111876607,FI
+3111876608,3111877631,ES
+3111877632,3111878655,PL
+3111878656,3111879679,CZ
+3111879680,3111880703,FI
+3111880704,3111881727,ES
+3111881728,3111882751,RO
+3111882752,3111886847,GB
+3111886848,3111887871,PL
+3111887872,3111888895,RU
+3111888896,3111889919,IE
+3111889920,3111890943,RU
+3111890944,3111891967,AT
+3111891968,3111892991,FR
+3111892992,3111894015,BY
+3111894016,3111895039,BG
+3111895040,3111896063,RU
+3111896064,3111897087,IS
+3111897088,3111899135,ES
+3111899136,3111900159,IR
+3111900160,3111901183,IT
+3111901184,3111902207,LU
+3111902208,3111903231,RO
+3111903232,3111904255,DE
+3111904256,3111905279,SE
+3111905280,3111906303,IT
+3111906304,3111908351,GB
+3111908352,3111909375,RO
+3111909376,3111912447,GB
+3111912448,3111913471,ES
+3111913472,3111914495,UA
+3111914496,3111915519,RU
+3111915520,3111916543,DE
+3111916544,3111919615,ES
+3111919616,3111920639,RO
+3111920640,3111921663,ES
+3111921664,3111922687,RU
+3111922688,3111923711,IT
+3111923712,3111924735,DE
+3111924736,3111925759,NO
+3111925760,3111927807,GB
+3111927808,3111930879,DE
+3111930880,3111931903,NO
+3111931904,3111932927,CZ
+3111932928,3111933951,TR
+3111933952,3111935999,FI
+3111936000,3111937023,NO
+3111937024,3111940095,ES
+3111940096,3111941119,IR
+3111941120,3111942143,PL
+3111942144,3111943167,DE
+3111943168,3111944191,PT
+3111944192,3111945215,PL
+3111945216,3111946239,CH
+3111946240,3111948287,ES
+3111948288,3111949311,AT
+3111949312,3111950335,IQ
+3111950336,3111951359,RU
+3111951360,3111952383,IR
+3111952384,3111953407,GB
+3111953408,3111954431,RU
+3111954432,3111955455,UA
+3111955456,3111956479,IR
+3111956480,3111957503,RU
+3111957504,3111958527,IT
+3111958528,3111959551,PL
+3111959552,3111960575,RU
+3111960576,3111962623,DE
+3111962624,3111963647,NL
+3111963648,3111964671,IE
+3111964672,3111965695,RU
+3111965696,3111966719,LB
+3111966720,3111967743,FR
+3111967744,3111968767,DE
+3111968768,3111969791,FR
+3111969792,3111970815,RU
+3111970816,3111971839,DE
+3111971840,3111972863,FR
+3111972864,3111973887,CH
+3111973888,3111974911,LB
+3111974912,3111975935,RO
+3111975936,3111976959,IT
+3111976960,3111977983,DE
+3111977984,3111979007,PL
+3111979008,3111980031,NL
+3111980032,3111981055,IL
+3111981056,3111982079,RU
+3111982080,3111983103,IR
+3111983104,3111984127,SA
+3111984128,3111985151,FI
+3111985152,3111986175,TR
+3111986176,3111987199,RU
+3111987200,3111988223,NL
+3111988224,3111989247,KZ
+3111989248,3111990271,RU
+3111990272,3111991295,FR
+3111991296,3111992319,RU
+3111992320,3111993343,RS
+3111993344,3111994367,GB
+3111994368,3111995391,IT
+3111995392,3111996415,RU
+3111996416,3111997439,ES
+3111997440,3111998463,DK
+3111998464,3111999487,ES
+3111999488,3112000511,KZ
+3112000512,3112001535,DE
+3112001536,3112002559,DK
+3112002560,3112003583,RU
+3112003584,3112004607,GB
+3112004608,3112005631,RO
+3112005632,3112006655,RU
+3112006656,3112007679,NL
+3112007680,3112008703,BA
+3112008704,3112009727,PL
+3112009728,3112010751,CZ
+3112010752,3112011775,PL
+3112011776,3112012799,RU
+3112012800,3112013823,GB
+3112013824,3112014847,IT
+3112014848,3112017919,LB
+3112017920,3112018943,NO
+3112018944,3112019967,CH
+3112019968,3112020991,NO
+3112020992,3112022015,DE
+3112022016,3112023039,RS
+3112023040,3112024063,LU
+3112024064,3112025087,US
+3112025088,3112026111,GB
+3112026112,3112027135,RU
+3112027136,3112028159,CH
+3112028160,3112029183,RU
+3112029184,3112030207,DE
+3112030208,3112031231,AT
+3112031232,3112032255,CH
+3112032256,3112033279,RU
+3112033280,3112034303,DK
+3112034304,3112034305,DE
+3112034306,3112034306,GB
+3112034307,3112034307,PL
+3112034308,3112034308,FR
+3112034309,3112034309,NL
+3112034310,3112034310,AT
+3112034311,3112034311,IT
+3112034312,3112034312,CH
+3112034313,3112034313,CZ
+3112034314,3112034314,DK
+3112034315,3112035327,DE
+3112035328,3112036351,RU
+3112036352,3112038399,NL
+3112038400,3112039423,IS
+3112039424,3112047615,IR
+3112047616,3112048639,AT
+3112048640,3112049663,GB
+3112049664,3112050687,DE
+3112050688,3112051711,AE
+3112051712,3112052735,NO
+3112052736,3112053759,IR
+3112053760,3112054783,LB
+3112054784,3112055807,BE
+3112055808,3112056831,DK
+3112056832,3112057855,NL
+3112057856,3112058879,IS
+3112058880,3112059903,NL
+3112059904,3112062975,RO
+3112062976,3112063999,ES
+3112064000,3112065023,RU
+3112065024,3112066047,PT
+3112066048,3112067071,RU
+3112067072,3112068095,ES
+3112068096,3112069119,DE
+3112069120,3112070143,ES
+3112070144,3112071167,DK
+3112071168,3112072191,UA
+3112072192,3112073215,RO
+3112073216,3112074239,NL
+3112074240,3112075263,IR
+3112075264,3112076287,RU
+3112076288,3112077311,IR
+3112077312,3112078335,GB
+3112078336,3112079359,IT
+3112079360,3112080383,IR
+3112080384,3112081407,GB
+3112081408,3112082431,DK
+3112082432,3112083455,IR
+3112083456,3112085503,GB
+3112085504,3112086527,DE
+3112086528,3112087551,GB
+3112087552,3112088575,TR
+3112088576,3112089599,RU
+3112089600,3112090623,NO
+3112090624,3112091647,PL
+3112091648,3112092671,RU
+3112092672,3112093695,SK
+3112093696,3112094719,IR
+3112094720,3112095743,IT
+3112095744,3112096767,AT
+3112096768,3112097791,DE
+3112097792,3112098815,TR
+3112098816,3112099839,CH
+3112099840,3112100863,GB
+3112100864,3112102911,FR
+3112102912,3112103935,GB
+3112103936,3112104959,DE
+3112104960,3112105983,FR
+3112105984,3112107007,GB
+3112107008,3112108031,UA
+3112108032,3112109055,LT
+3112109056,3112110079,FR
+3112110080,3112111103,IL
+3112111104,3112112127,NL
+3112112128,3112113151,GB
+3112113152,3112114175,PL
+3112114176,3112115199,RU
+3112115200,3112116223,DE
+3112116224,3112118271,IT
+3112118272,3112119295,NO
+3112119296,3112120319,GB
+3112120320,3112121343,DK
+3112121344,3112122367,ES
+3112122368,3112123391,GB
+3112123392,3112124415,FI
+3112124416,3112125439,AM
+3112125440,3112126463,GB
+3112126464,3112127487,FI
+3112127488,3112128511,GB
+3112128512,3112129535,FR
+3112129536,3112130559,FI
+3112130560,3112131583,DK
+3112131584,3112132607,GB
+3112132608,3112133631,DK
+3112133632,3112134655,NO
+3112134656,3112136703,NL
+3112136704,3112137727,CH
+3112137728,3112138751,ES
+3112138752,3112139775,PL
+3112139776,3112140799,LB
+3112140800,3112141823,ES
+3112141824,3112142847,IT
+3112142848,3112143871,NL
+3112143872,3112144895,GB
+3112144896,3112145919,ES
+3112145920,3112146943,RU
+3112146944,3112148991,GB
+3112148992,3112150015,PT
+3112150016,3112151039,RU
+3112151040,3112152063,NO
+3112152064,3112153087,CH
+3112153088,3112154111,IR
+3112154112,3112155135,LB
+3112155136,3112156159,NL
+3112156160,3112157183,LB
+3112157184,3112158207,GB
+3112158208,3112159231,IT
+3112159232,3112160255,NL
+3112160256,3112161279,CH
+3112161280,3112162303,DE
+3112162304,3112163327,IT
+3112163328,3112164351,RS
+3112164352,3112165375,IT
+3112165376,3112166399,RU
+3112166400,3112167423,SE
+3112167424,3112168447,IR
+3112168448,3112169471,IT
+3112169472,3112170495,FR
+3112170496,3112171519,UA
+3112171520,3112172543,GB
+3112172544,3112173567,NO
+3112173568,3112174591,SE
+3112174592,3112175615,RU
+3112175616,3112176639,UA
+3112176640,3112177663,ES
+3112177664,3112178687,FI
+3112178688,3112179711,PL
+3112179712,3112180735,AE
+3112180736,3112181759,IT
+3112181760,3112182783,NL
+3112182784,3112183807,IQ
+3112183808,3112184831,CH
+3112184832,3112185855,DE
+3112185856,3112186879,IR
+3112186880,3112187903,ES
+3112187904,3112188927,GB
+3112188928,3112189951,ES
+3112189952,3112190975,NL
+3112190976,3112191999,DE
+3112192000,3112193023,DK
+3112193024,3112194047,IT
+3112194048,3112195071,IR
+3112195072,3112196095,RU
+3112196096,3112197119,NL
+3112197120,3112198143,UA
+3112198144,3112199167,RO
+3112199168,3112200191,DK
+3112200192,3112201215,RU
+3112201216,3112202239,DE
+3112202240,3112203263,TR
+3112203264,3112205311,DE
+3112205312,3112206335,LB
+3112206336,3112207359,ES
+3112207360,3112208383,GB
+3112208384,3112209407,IR
+3112209408,3112210431,FR
+3112210432,3112211455,NO
+3112211456,3112212479,IT
+3112212480,3112213503,IR
+3112213504,3112214527,PL
+3112214528,3112215551,FI
+3112215552,3112216575,IR
+3112216576,3112217599,ES
+3112217600,3112218623,CH
+3112218624,3112219647,GB
+3112219648,3112220671,SY
+3112220672,3112221695,NL
+3112221696,3112222719,DE
+3112222720,3112223743,ES
+3112223744,3112224767,RU
+3112224768,3112225791,BY
+3112225792,3112227839,GB
+3112227840,3112228863,RU
+3112228864,3112229887,DE
+3112229888,3112231935,GB
+3112231936,3112232959,HU
+3112232960,3112233983,UA
+3112233984,3112235007,FR
+3112235008,3112236031,RO
+3112236032,3112237055,AT
+3112237056,3112238079,SI
+3112238080,3112239103,FI
+3112239104,3112240127,AZ
+3112240128,3112241151,IQ
+3112241152,3112242175,GB
+3112242176,3112243199,HR
+3112243200,3112244223,TR
+3112244224,3112245247,GB
+3112245248,3112246271,NO
+3112246272,3112247295,ES
+3112247296,3112248319,PL
+3112248320,3112249343,RO
+3112249344,3112250367,ES
+3112250368,3112251391,FR
+3112251392,3112252415,KZ
+3112252416,3112253439,CH
+3112253440,3112254463,RU
+3112254464,3112255487,DK
+3112255488,3112256511,NO
+3112256512,3112257535,NL
+3112257536,3112258559,GB
+3112258560,3112259583,PL
+3112259584,3112260607,IR
+3112260608,3112261631,DE
+3112261632,3112262655,IT
+3112262656,3112263679,AZ
+3112263680,3112265727,RU
+3112265728,3112266751,ES
+3112266752,3112267775,IR
+3112267776,3112268799,PL
+3112268800,3112269823,IR
+3112269824,3112270847,RS
+3112270848,3112271871,IR
+3112271872,3112272895,UA
+3112272896,3112273919,IE
+3112273920,3112274943,CZ
+3112274944,3112275967,IR
+3112275968,3112276991,RU
+3112276992,3112278015,LV
+3112278016,3112279039,FI
+3112279040,3112280063,NO
+3112280064,3112281087,GB
+3112281088,3112282111,FR
+3112282112,3112283135,IR
+3112283136,3112284159,AT
+3112284160,3112285183,GB
+3112285184,3112286207,DE
+3112286208,3112288255,IR
+3112288256,3112289279,KZ
+3112289280,3112291327,IR
+3112291328,3112292351,RU
+3112292352,3112293375,GB
+3112293376,3112295423,IR
+3112295424,3112297471,GB
+3112297472,3112301567,IR
+3112301568,3112302591,DE
+3112302592,3112303615,ES
+3112303616,3112304639,DE
+3112304640,3112305663,SE
+3112305664,3112306687,LT
+3112306688,3112307711,DE
+3112307712,3112308735,IS
+3112308736,3112309759,HR
+3112309760,3112310783,DE
+3112310784,3112312831,ES
+3112312832,3112313855,DE
+3112313856,3112315903,GB
+3112315904,3112316927,PL
+3112316928,3112317951,IQ
+3112317952,3112318975,UA
+3112318976,3112319999,RU
+3112320000,3112321023,IQ
+3112321024,3112322047,FI
+3112322048,3112323071,NO
+3112323072,3112324095,NL
+3112324096,3112325119,IR
+3112325120,3112326143,RU
+3112326144,3112327167,IL
+3112327168,3112328191,RU
+3112328192,3112329215,GB
+3112329216,3112330239,DK
+3112330240,3112331263,GB
+3112331264,3112332287,RU
+3112332288,3112333311,PL
+3112333312,3112334335,RU
+3112334336,3112335359,FR
+3112335360,3112336383,UA
+3112336384,3112337407,RS
+3112337408,3112338431,BE
+3112338432,3112339455,MK
+3112339456,3112340479,LB
+3112340480,3112341503,CH
+3112341504,3112342527,ES
+3112342528,3112343551,BE
+3112343552,3112344575,ES
+3112344576,3112345599,GB
+3112345600,3112346623,DK
+3112346624,3112347647,SE
+3112347648,3112349695,NL
+3112349696,3112350719,HU
+3112350720,3112351743,PL
+3112351744,3112352767,DE
+3112352768,3112353791,DK
+3112353792,3112354815,DE
+3112354816,3112355839,GB
+3112355840,3112356863,ES
+3112356864,3112357887,DE
+3112357888,3112358911,PL
+3112358912,3112359935,RU
+3112359936,3112360959,ES
+3112360960,3112361983,SK
+3112361984,3112364031,NL
+3112364032,3112365055,RU
+3112365056,3112366079,US
+3112366080,3112367103,NL
+3112367104,3112368127,NO
+3112368128,3112369151,RU
+3112369152,3112370175,AT
+3112370176,3112371199,LU
+3112371200,3112372223,CH
+3112372224,3112373247,GB
+3112373248,3112374271,ES
+3112374272,3112375295,IT
+3112375296,3112376319,SE
+3112376320,3112377343,NL
+3112377344,3112378367,IR
+3112378368,3112379391,PL
+3112379392,3112380415,LB
+3112380416,3112382463,FR
+3112382464,3112383487,TR
+3112383488,3112384511,ES
+3112384512,3112385535,AE
+3112385536,3112386559,CZ
+3112386560,3112387583,NL
+3112387584,3112388607,EE
+3112388608,3112389631,DE
+3112389632,3112390655,SA
+3112390656,3112391679,FR
+3112391680,3112394751,IR
+3112394752,3112395775,SA
+3112395776,3112396799,IR
+3112396800,3112397823,RU
+3112397824,3112400895,IR
+3112400896,3112401919,DE
+3112401920,3112403967,IR
+3112403968,3112404991,ES
+3112404992,3112407039,IR
+3112407040,3112408063,AE
+3112408064,3112411135,IR
+3112411136,3112412159,IT
+3112412160,3112414207,IR
+3112414208,3112415231,RU
+3112415232,3112416255,AE
+3112416256,3112417279,RU
+3112417280,3112418303,ES
+3112418304,3112419327,IQ
+3112419328,3112420351,FR
+3112420352,3112421375,DE
+3112421376,3112423423,GB
+3112423424,3112424447,TR
+3112424448,3112425471,IT
+3112425472,3112426495,FI
+3112426496,3112427519,FR
+3112427520,3112428543,PL
+3112428544,3112430591,GB
+3112430592,3112431615,DE
+3112431616,3112432639,PL
+3112432640,3112433663,CZ
+3112433664,3112435711,IT
+3112435712,3112436735,UA
+3112436736,3112437759,BG
+3112437760,3112439807,GB
+3112439808,3112440831,CH
+3112440832,3112441855,RU
+3112441856,3112442879,DE
+3112442880,3112443903,RU
+3112443904,3112444927,DE
+3112444928,3112446975,GB
+3112446976,3112447999,DE
+3112448000,3112449023,LT
+3112449024,3112450047,PL
+3112450048,3112451071,IT
+3112451072,3112452095,LU
+3112452096,3112453119,FR
+3112453120,3112454143,IT
+3112454144,3112455167,FR
+3112455168,3112456191,GB
+3112456192,3112457215,IR
+3112457216,3112458239,GB
+3112458240,3112459263,ES
+3112459264,3112460287,AL
+3112460288,3112461311,AT
+3112461312,3112462335,FR
+3112462336,3112463359,FI
+3112463360,3112464383,RO
+3112464384,3112465407,CZ
+3112465408,3112466431,FR
+3112466432,3112468479,TR
+3112468480,3112469503,CH
+3112469504,3112470527,AE
+3112470528,3112472575,ES
+3112472576,3112473599,RS
+3112473600,3112474623,LB
+3112474624,3112475647,GB
+3112475648,3112476671,IL
+3112476672,3112477695,ME
+3112477696,3112479743,AE
+3112479744,3112480767,RO
+3112480768,3112481791,AE
+3112481792,3112482815,NL
+3112482816,3112485887,AE
+3112485888,3112486911,RU
+3112486912,3112487935,AE
+3112487936,3112488959,KW
+3112488960,3112489983,DE
+3112489984,3112491007,IR
+3112491008,3112492031,SE
+3112492032,3112494079,DE
+3112494080,3112495103,IT
+3112495104,3112496127,RS
+3112496128,3112497151,NL
+3112497152,3112498175,RU
+3112498176,3112499199,GB
+3112499200,3112500223,PS
+3112500224,3112501247,NL
+3112501248,3112502271,RU
+3112502272,3112503295,ES
+3112503296,3112505343,DE
+3112505344,3112506367,EG
+3112506368,3112507391,BG
+3112507392,3112508415,DE
+3112508416,3112509439,CH
+3112509440,3112511487,NL
+3112511488,3112512511,RU
+3112512512,3112514559,CH
+3112514560,3112515583,FR
+3112515584,3112516607,CZ
+3112516608,3112517631,SK
+3112517632,3112518655,RO
+3112518656,3112519679,SE
+3112519680,3112520703,NL
+3112520704,3112521727,PT
+3112521728,3112522751,FR
+3112522752,3112523775,SA
+3112523776,3112524799,PL
+3112524800,3112525823,IT
+3112525824,3112526847,ES
+3112526848,3112527871,CZ
+3112527872,3112528895,DE
+3112528896,3112529919,NL
+3112529920,3112530943,DE
+3112530944,3112531967,FR
+3112531968,3112532991,ES
+3112532992,3112534015,KW
+3112534016,3112535039,FR
+3112535040,3112536063,HR
+3112536064,3112537087,CZ
+3112537088,3112538111,NO
+3112538112,3112539135,CZ
+3112539136,3112540159,NL
+3112540160,3112541183,IR
+3112541184,3112542207,GB
+3112542208,3112543231,PL
+3112543232,3112544255,IR
+3112544256,3112545279,GB
+3112545280,3112546303,DE
+3112546304,3112547327,GB
+3112547328,3112548351,SA
+3112548352,3112549375,SI
+3112549376,3112550399,CZ
+3112550400,3112551423,GB
+3112551424,3112552447,CZ
+3112552448,3112553471,ES
+3112553472,3112554495,SE
+3112554496,3112555519,CH
+3112555520,3112556543,IR
+3112556544,3112557567,IT
+3112557568,3112558591,GB
+3112558592,3112559615,IQ
+3112559616,3112560639,RU
+3112560640,3112561663,FR
+3112561664,3112562687,DE
+3112562688,3112563711,CZ
+3112563712,3112564735,AE
+3112564736,3112565759,GB
+3112565760,3112566783,US
+3112566784,3112567807,CZ
+3112567808,3112568831,DE
+3112568832,3112569855,IT
+3112569856,3112571903,SE
+3112571904,3112572927,DE
+3112572928,3112573951,BE
+3112573952,3112574975,DK
+3112574976,3112577023,RU
+3112577024,3112578047,ES
+3112578048,3112579071,DE
+3112579072,3112580095,GB
+3112580096,3112581119,IT
+3112581120,3112582143,NL
+3112582144,3112583167,CZ
+3112583168,3112584191,NL
+3112584192,3112585215,IT
+3112585216,3112586239,RU
+3112586240,3112587263,LU
+3112587264,3112588287,HU
+3112588288,3112589311,DE
+3112589312,3112590335,FI
+3112590336,3112591359,SE
+3112591360,3112592383,IR
+3112592384,3112593407,FI
+3112593408,3112594431,GB
+3112594432,3112595455,DE
+3112595456,3112596479,GR
+3112596480,3112597503,CY
+3112597504,3112598527,RU
+3112598528,3112599551,NO
+3112599552,3112600575,DE
+3112600576,3112601599,SY
+3112601600,3112602623,ES
+3112602624,3112603647,IT
+3112603648,3112604671,IE
+3112604672,3112605695,RU
+3112605696,3112606719,IT
+3112606720,3112607743,FR
+3112607744,3112608767,CZ
+3112608768,3112609791,CH
+3112609792,3112610815,TJ
+3112610816,3112611839,GE
+3112611840,3112612863,LB
+3112612864,3112613887,GB
+3112613888,3112614911,TR
+3112614912,3112615935,SK
+3112615936,3112616959,BG
+3112616960,3112617983,GB
+3112617984,3112620031,RU
+3112620032,3112621055,NL
+3112621056,3112622079,SK
+3112622080,3112623103,NL
+3112623104,3112624127,DE
+3112624128,3112625151,GB
+3112625152,3112626175,BG
+3112626176,3112627199,RU
+3112627200,3112628223,KZ
+3112628224,3112629247,DE
+3112629248,3112630271,NO
+3112630272,3112631295,NL
+3112631296,3112632319,DK
+3112632320,3112633343,PL
+3112633344,3112634367,CZ
+3112634368,3112635391,DE
+3112635392,3112636415,BE
+3112636416,3112637439,AT
+3112637440,3112638463,CZ
+3112638464,3112639487,DE
+3112639488,3112640511,IR
+3112640512,3112641535,DE
+3112641536,3112642559,GB
+3112642560,3112644607,TR
+3112644608,3112645631,SY
+3112645632,3112646655,DE
+3112646656,3112647679,GB
+3112647680,3112648703,DK
+3112648704,3112649727,RO
+3112649728,3112650751,IQ
+3112650752,3112652799,IR
+3112652800,3112653823,RU
+3112653824,3112654847,IR
+3112654848,3112655871,PL
+3112655872,3112656895,IT
+3112656896,3112657919,CY
+3112657920,3112658943,IT
+3112658944,3112659967,GB
+3112659968,3112660991,TR
+3112660992,3112662015,IT
+3112662016,3112663039,ES
+3112663040,3112664063,PL
+3112664064,3112665087,FR
+3112665088,3112666111,GB
+3112666112,3112667135,CZ
+3112667136,3112668159,CH
+3112668160,3112669183,BE
+3112669184,3112670207,CZ
+3112670208,3112671231,RU
+3112671232,3112672255,US
+3112672256,3112673279,DE
+3112673280,3112674303,FR
+3112674304,3112676351,GB
+3112676352,3112677375,RU
+3112677376,3112678399,FR
+3112678400,3112679423,RU
+3112679424,3112680447,BG
+3112680448,3112681471,IQ
+3112681472,3112682495,PL
+3112682496,3112683519,CZ
+3112683520,3112684543,JO
+3112684544,3112685567,ES
+3112685568,3112686591,GB
+3112687616,3112688639,FR
+3112688640,3112689663,TR
+3112689664,3112690687,PL
+3112690688,3112691711,IR
+3112691712,3112692735,RU
+3112692736,3112693759,FR
+3112693760,3112694783,NL
+3112694784,3112695807,GB
+3112695808,3112696831,LU
+3112696832,3112697855,US
+3112697856,3112699903,NL
+3112699904,3112700927,RO
+3112700928,3112701951,KZ
+3112701952,3112702975,MD
+3112702976,3112703231,SE
+3112703232,3112703487,FI
+3112703488,3112703743,DK
+3112703744,3112703999,NO
+3112704000,3112705023,DE
+3112705024,3112706047,ES
+3112706048,3112707071,RU
+3112707072,3112708095,FI
+3112708096,3112709119,FR
+3112709120,3112710143,IL
+3112710144,3112711167,NO
+3112711168,3112712191,PT
+3112712192,3112713215,TR
+3112713216,3112714239,AT
+3112714240,3112715263,NL
+3112715264,3112717311,GB
+3112717312,3112718335,RU
+3112718336,3112719359,AT
+3112719360,3112720383,TR
+3112720384,3112721407,ES
+3112721408,3112722431,PL
+3112722432,3112723455,BG
+3112723456,3112724479,IR
+3112724480,3112725503,GB
+3112725504,3112726527,CZ
+3112726528,3112727551,DE
+3112727552,3112728575,DK
+3112728576,3112729599,CH
+3112729600,3112730623,IT
+3112730624,3112731647,NO
+3112731648,3112732671,PL
+3112732672,3112733695,IT
 3113710318,3113710318,CA
 3120562176,3120594943,CO
 3120594944,3120599039,AR
@@ -65384,8 +68899,8 @@
 3120691200,3120693247,CO
 3120693248,3120726015,BO
 3120726016,3120734207,HN
-3120734208,3120735999,RU
-3120736000,3120736255,BZ
+3120734208,3120735743,RU
+3120735744,3120736255,BZ
 3120736256,3120736511,EC
 3120736512,3120738303,BZ
 3120738304,3120742399,CW
@@ -65503,14 +69018,20 @@
 3126857856,3126857983,US
 3126857984,3126858495,AR
 3126858496,3126858623,US
-3126858624,3126861311,AR
+3126858624,3126860415,AR
+3126860416,3126860543,US
+3126860544,3126860671,AR
+3126860672,3126860799,US
+3126860800,3126861311,AR
 3126861312,3126861439,US
 3126861440,3126862591,AR
 3126862592,3126862719,US
 3126862720,3126863999,AR
 3126864000,3126864127,US
 3126864128,3126870015,AR
-3126870016,3126874111,VE
+3126870016,3126873343,VE
+3126873344,3126873599,PA
+3126873600,3126874111,VE
 3126874112,3126878207,CR
 3126878208,3126882303,PA
 3126882304,3126886399,US
@@ -65534,7 +69055,8 @@
 3130284032,3130286079,DO
 3130286080,3130290175,PA
 3130290176,3130302463,AR
-3130302464,3130312703,PA
+3130302464,3130302975,CY
+3130302976,3130312703,PA
 3130312704,3130314751,AR
 3130314752,3130315775,CL
 3130315776,3130316799,CR
@@ -65577,14 +69099,18 @@
 3132948480,3133014015,AR
 3133014016,3133046783,HT
 3133046784,3133067263,AR
-3133067264,3133073407,PA
+3133067264,3133071359,PA
+3133071360,3133071871,CY
+3133071872,3133073407,PA
 3133073408,3133073663,CW
 3133073664,3133073919,AW
 3133073920,3133074431,CW
 3133074432,3133075455,CL
 3133075456,3133079551,CW
 3133079552,3133145087,AR
-3133145088,3134289919,BR
+3133145088,3133311999,BR
+3133312000,3133313023,MX
+3133313024,3134289919,BR
 3134291968,3136961535,BR
 3136962560,3136985087,BR
 3136985088,3136986111,AR
@@ -65610,7 +69136,9 @@
 3154313216,3154378751,TR
 3154378752,3154444287,GR
 3154444288,3154509823,BE
-3154509824,3154575359,HU
+3154509824,3154571519,HU
+3154571520,3154571775,BG
+3154571776,3154575359,HU
 3154575360,3154640895,FR
 3154640896,3155165183,IT
 3155165184,3155427327,RU
@@ -65633,14 +69161,14 @@
 3156928512,3156930559,LU
 3156930560,3156933631,US
 3156933632,3156933887,SG
-3156933888,3156934143,CN
+3156933888,3156933909,CN
+3156933910,3156933910,SG
+3156933911,3156934143,CN
 3156934144,3156934655,SG
 3156934656,3157000191,RU
 3157000192,3157008383,MK
 3157008384,3157016575,RU
-3157016576,3157024255,BE
-3157024256,3157024511,FR
-3157024512,3157024767,BE
+3157016576,3157024767,BE
 3157024768,3157032959,RU
 3157032960,3157065727,HU
 3157065728,3157131263,AT
@@ -65917,12 +69445,21 @@
 3161571328,3161587711,UZ
 3161587712,3161604095,RU
 3161604096,3161612287,PL
-3161613056,3161613311,BR
-3161616128,3161616383,ES
+3161612288,3161613311,BR
+3161613312,3161614335,IT
+3161614336,3161614591,US
+3161614848,3161615103,US
+3161615360,3161616383,ES
 3161616384,3161618431,GB
 3161618432,3161620479,IQ
 3161620480,3161636863,DK
-3161636864,3161653247,RU
+3161636864,3161641215,RU
+3161641216,3161641983,UA
+3161641984,3161642239,RU
+3161642240,3161645055,UA
+3161645056,3161651975,RU
+3161651976,3161651976,SE
+3161651977,3161653247,RU
 3161653248,3161669631,LU
 3161669632,3161670143,FR
 3161670144,3161670399,RE
@@ -66043,7 +69580,9 @@
 3162570752,3162603519,HR
 3162603520,3162636287,GE
 3162636288,3162669055,FR
-3162669056,3162681343,RU
+3162669056,3162676223,RU
+3162676224,3162677247,KZ
+3162677248,3162681343,RU
 3162681344,3162682367,UA
 3162682368,3162682879,MD
 3162682880,3162683135,IE
@@ -66175,7 +69714,9 @@
 3164967232,3164967239,ES
 3164967240,3164967303,FR
 3164967304,3164967307,DE
-3164967308,3164968319,FR
+3164967308,3164968223,FR
+3164968224,3164968255,GB
+3164968256,3164968319,FR
 3164968320,3164968447,GB
 3164968448,3164968455,FR
 3164968456,3164968459,NL
@@ -66210,8 +69751,12 @@
 3164976160,3164976295,FR
 3164976296,3164976303,IT
 3164976304,3164995583,FR
-3164995584,3165057023,NL
-3165057024,3165061119,SG
+3164995584,3165032447,NL
+3165032448,3165036543,GB
+3165036544,3165040639,NL
+3165040640,3165044735,SG
+3165044736,3165048831,NL
+3165048832,3165061119,SG
 3165061120,3165126655,SK
 3165126656,3165192191,RU
 3165192192,3165257727,GE
@@ -66280,7 +69825,9 @@
 3166699520,3166961663,DE
 3166961664,3167223807,SI
 3167223808,3167748095,NL
-3167748096,3167758335,RO
+3167748096,3167753215,RO
+3167753216,3167754239,ES
+3167754240,3167758335,RO
 3167758336,3167758463,NL
 3167758464,3167760383,RO
 3167760384,3167762431,GB
@@ -66325,7 +69872,7 @@
 3167899648,3167902719,RO
 3167902720,3167902975,BE
 3167902976,3167903231,NL
-3167903232,3167903743,RO
+3167903232,3167903743,DE
 3167903744,3167932415,IR
 3167932416,3167933439,CH
 3167933440,3167933695,RO
@@ -66395,7 +69942,8 @@
 3168089088,3168090111,MD
 3168090112,3168092159,ES
 3168092160,3168096255,IR
-3168096256,3168100351,MD
+3168096256,3168097279,ES
+3168097280,3168100351,MD
 3168100352,3168108543,IR
 3168108544,3168110335,RO
 3168110336,3168110591,GB
@@ -66462,7 +70010,10 @@
 3168192000,3168192255,GB
 3168192256,3168192511,RO
 3168192512,3168194559,MD
-3168194560,3168199679,RO
+3168194560,3168196607,RO
+3168196608,3168198655,IR
+3168198656,3168199167,ES
+3168199168,3168199679,RO
 3168199680,3168200703,MD
 3168200704,3168202751,IR
 3168202752,3168203775,ES
@@ -66550,13 +70101,18 @@
 3169905664,3169906687,ES
 3169906688,3169913855,RO
 3169913856,3169914111,GB
-3169914112,3169921023,RO
+3169914112,3169920767,RO
+3169920768,3169921023,BZ
 3169921024,3169923071,GB
 3169923072,3169927423,RO
 3169927424,3169927679,NL
-3169927680,3169935359,RO
+3169927680,3169928191,RO
+3169928192,3169928447,SE
+3169928448,3169935359,RO
 3169935360,3169937407,ES
-3169937408,3169951743,RO
+3169937408,3169946623,RO
+3169946624,3169947135,IT
+3169947136,3169951743,RO
 3169951744,3169955839,SE
 3169955840,3169960191,RO
 3169960192,3169960447,NL
@@ -66629,8 +70185,8 @@
 3187824640,3187826687,CL
 3187826688,3187834879,AR
 3187834880,3187843071,CW
-3187843072,3187845119,AW
-3187845120,3187849215,CW
+3187843072,3187846143,AW
+3187846144,3187849215,CW
 3187849216,3187849471,CO
 3187849472,3187851263,CW
 3187851264,3187855359,PY
@@ -66648,7 +70204,9 @@
 3187933342,3187933342,HN
 3187933343,3187935519,GT
 3187935520,3187935527,HN
-3187935528,3187935607,GT
+3187935528,3187935543,GT
+3187935544,3187935551,HN
+3187935552,3187935607,GT
 3187935608,3187935615,HN
 3187935616,3187936047,GT
 3187936048,3187936063,HN
@@ -66666,7 +70224,11 @@
 3187940964,3187940967,HN
 3187940968,3187941207,GT
 3187941208,3187941215,HN
-3187941216,3187943055,GT
+3187941216,3187941647,GT
+3187941648,3187941655,HN
+3187941656,3187942563,GT
+3187942564,3187942567,HN
+3187942568,3187943055,GT
 3187943056,3187943063,HN
 3187943064,3187943127,GT
 3187943128,3187943135,HN
@@ -66682,13 +70244,17 @@
 3187944774,3187944774,HN
 3187944775,3187944831,GT
 3187944832,3187944835,HN
-3187944836,3187945971,GT
+3187944836,3187945343,GT
+3187945344,3187945471,HN
+3187945472,3187945971,GT
 3187945972,3187945975,HN
 3187945976,3187946111,GT
 3187946112,3187946239,HN
 3187946240,3187946495,GT
 3187946496,3187946751,HN
-3187946752,3187947983,GT
+3187946752,3187946887,GT
+3187946888,3187946895,HN
+3187946896,3187947983,GT
 3187947984,3187947987,HN
 3187947988,3187948031,GT
 3187948032,3187948287,HN
@@ -66696,7 +70262,9 @@
 3187948480,3187948543,HN
 3187948544,3187948799,GT
 3187948800,3187948927,HN
-3187948928,3187949567,GT
+3187948928,3187949311,GT
+3187949312,3187949439,HN
+3187949440,3187949567,GT
 3187949568,3187950126,BQ
 3187950127,3187950127,CW
 3187950128,3187953663,BQ
@@ -66727,7 +70295,9 @@
 3188125696,3188137175,AR
 3188137176,3188137183,DE
 3188137184,3188146175,AR
-3188146176,3188170751,CO
+3188146176,3188152171,CO
+3188152172,3188152175,PE
+3188152176,3188170751,CO
 3188170752,3188174847,CR
 3188174848,3188178943,BR
 3188178944,3188187135,CR
@@ -66753,7 +70323,8 @@
 3188269568,3188269823,MX
 3188269824,3188270079,VE
 3188270080,3188270335,MX
-3188270336,3188270847,VE
+3188270336,3188270719,VE
+3188270720,3188270847,MX
 3188270848,3188271103,BR
 3188271104,3188273151,MX
 3188273152,3188275199,PA
@@ -66773,7 +70344,9 @@
 3188473856,3188482047,PE
 3188482048,3188490239,AR
 3188490240,3188498431,CO
-3188498432,3188512127,AR
+3188498432,3188511103,AR
+3188511104,3188511231,US
+3188511232,3188512127,AR
 3188512128,3188512255,US
 3188512256,3188513407,AR
 3188513408,3188513535,US
@@ -66788,7 +70361,8 @@
 3188518400,3188523007,AR
 3188523008,3188539391,CO
 3188539392,3188543487,CL
-3188543488,3188545535,PA
+3188543488,3188543999,CY
+3188544000,3188545535,PA
 3188545536,3188547583,AR
 3188547584,3188551679,CO
 3188551680,3188552703,AR
@@ -66879,15 +70453,15 @@
 3191647936,3191648255,CO
 3191648256,3191649791,US
 3191649792,3191650303,CO
-3191650304,3191650815,US
-3191650816,3191651071,CO
-3191651072,3191651839,US
-3191651840,3191670015,CO
+3191650304,3191652095,US
+3191652096,3191668991,CO
+3191668992,3191669247,PY
+3191669248,3191670015,CO
 3191670016,3191670271,AR
 3191670272,3191670783,CO
 3191670784,3191672831,CL
-3191672832,3191673855,CO
-3191673856,3191676927,CL
+3191672832,3191673343,CO
+3191673344,3191676927,CL
 3191676928,3191677951,US
 3191677952,3191678207,AR
 3191678208,3191678719,US
@@ -66909,9 +70483,7 @@
 3191696128,3191696383,CO
 3191696384,3191701503,US
 3191701504,3191702527,CL
-3191702528,3191703039,US
-3191703040,3191703551,CO
-3191703552,3191704575,US
+3191702528,3191704575,US
 3191704576,3191704831,CO
 3191704832,3191705343,US
 3191705344,3191705599,CO
@@ -66922,18 +70494,24 @@
 3191722496,3191725055,CL
 3191725056,3191725311,AR
 3191725312,3191725567,CL
-3191725568,3191726079,CO
+3191725568,3191725823,CO
+3191725824,3191726079,CL
 3191726080,3191726335,AR
 3191726336,3191726591,CL
 3191726592,3191726847,AR
 3191726848,3191727103,CL
 3191727104,3191727359,AR
-3191727360,3191729919,CO
+3191727360,3191727871,CO
+3191727872,3191728127,CL
+3191728128,3191729407,CO
+3191729408,3191729663,CL
+3191729664,3191729919,CO
 3191729920,3191730431,CL
 3191730432,3191730687,AR
 3191730688,3191730943,CL
 3191730944,3191731199,AR
-3191731200,3191731711,CO
+3191731200,3191731455,CL
+3191731456,3191731711,CO
 3191731712,3191731967,AR
 3191731968,3191732223,CO
 3191732224,3191732479,CL
@@ -66956,11 +70534,15 @@
 3193438208,3193569279,CW
 3193569280,3193573087,CO
 3193573088,3193573095,US
-3193573096,3193579263,CO
+3193573096,3193575311,CO
+3193575312,3193575327,PE
+3193575328,3193579263,CO
 3193579264,3193579519,EC
 3193579520,3193582591,CO
 3193582592,3193583103,EC
-3193583104,3193592319,CO
+3193583104,3193589503,CO
+3193589504,3193589759,EC
+3193589760,3193592319,CO
 3193592320,3193592575,EC
 3193592576,3193595391,CO
 3193595392,3193595647,EC
@@ -66976,9 +70558,11 @@
 3193617152,3193617407,EC
 3193617408,3193621759,CO
 3193621760,3193622015,EC
-3193622016,3193622527,CO
-3193622528,3193623551,EC
-3193623552,3193625599,CO
+3193622016,3193622271,CO
+3193622272,3193623551,EC
+3193623552,3193624063,CO
+3193624064,3193624575,EC
+3193624576,3193625599,CO
 3193625600,3193625855,EC
 3193625856,3193626111,CO
 3193626112,3193626623,US
@@ -66995,56 +70579,46 @@
 3193724928,3193729023,AR
 3193729024,3193733119,CU
 3193733120,3193735167,AR
-3193735168,3193735679,US
-3193735680,3193736191,AR
-3193736192,3193736447,US
-3193736448,3193736703,AR
-3193736704,3193736959,US
+3193735168,3193735935,US
+3193735936,3193736191,AR
+3193736192,3193736959,US
 3193736960,3193737215,AR
 3193737216,3193739007,US
 3193739008,3193739263,AR
-3193739264,3193740799,US
-3193740800,3193741311,AR
-3193741312,3193742335,US
+3193739264,3193742335,US
 3193742336,3193742591,AR
 3193742592,3193742847,US
 3193742848,3193743231,AR
 3193743232,3193743359,US
 3193743360,3193743743,AR
-3193743744,3193743871,US
-3193743872,3193743999,AR
-3193744000,3193744127,US
+3193743744,3193744127,US
 3193744128,3193744639,AR
-3193744640,3193744895,US
-3193744896,3193745151,AR
-3193745152,3193745407,US
+3193744640,3193745407,US
 3193745408,3193746431,AR
 3193746432,3193746687,US
 3193746688,3193746751,AR
 3193746752,3193746815,US
 3193746816,3193746879,AR
-3193746880,3193747455,US
-3193747456,3193747583,AR
-3193747584,3193748479,US
+3193746880,3193748479,US
 3193748480,3193748863,AR
 3193748864,3193750271,US
 3193750272,3193750527,AR
 3193750528,3193750783,US
 3193750784,3193751039,AR
-3193751040,3193751295,US
-3193751296,3193751807,AR
+3193751040,3193751551,US
+3193751552,3193751807,AR
 3193751808,3193752959,US
 3193752960,3193753087,AR
 3193753088,3193753343,US
 3193753344,3193753471,AR
 3193753472,3193753599,US
-3193753600,3193754239,AR
-3193754240,3193754367,US
+3193753600,3193754111,AR
+3193754112,3193754367,US
 3193754368,3193754623,AR
 3193754624,3193754751,US
-3193754752,3193755135,AR
-3193755136,3193755263,US
-3193755264,3193755647,AR
+3193754752,3193755007,AR
+3193755008,3193755519,US
+3193755520,3193755647,AR
 3193755648,3193755775,US
 3193755776,3193756415,AR
 3193756416,3193756543,US
@@ -67061,7 +70635,9 @@
 3193778176,3193782271,AR
 3193782272,3193798655,TT
 3193798656,3193806847,CO
-3193806848,3193810943,CR
+3193806848,3193808895,CR
+3193808896,3193809663,US
+3193809664,3193810943,CR
 3193810944,3193815039,PY
 3193815040,3193823231,AR
 3193823232,3193827327,CL
@@ -67090,7 +70666,11 @@
 3194077184,3194085375,CO
 3194085376,3194093567,VE
 3194093568,3194126335,SR
-3194126336,3194127103,GT
+3194126336,3194126591,GT
+3194126592,3194126847,NL
+3194126848,3194126911,GT
+3194126912,3194126975,PE
+3194126976,3194127103,GT
 3194127104,3194127359,BR
 3194127360,3194128383,PE
 3194128384,3194129407,NI
@@ -67135,7 +70715,9 @@
 3194428416,3194437631,VE
 3194437632,3194441727,BO
 3194441728,3194445823,AR
-3194445824,3194454015,CO
+3194445824,3194449175,CO
+3194449176,3194449183,PE
+3194449184,3194454015,CO
 3194454016,3194458111,AR
 3194458112,3194462207,CL
 3194462208,3194466303,BR
@@ -67233,8 +70815,9 @@
 3194806272,3194814463,AR
 3194814464,3194818559,PA
 3194818560,3194830847,AR
-3194830848,3194831871,BR
-3194831872,3194839039,PA
+3194830848,3194836991,BR
+3194836992,3194838015,PA
+3194838016,3194839039,MX
 3194839040,3194863615,CO
 3194863616,3194871807,HN
 3194871808,3194879999,BO
@@ -67250,7 +70833,11 @@
 3194953216,3194953343,NI
 3194953344,3194953727,GT
 3194953728,3194959871,AR
-3194959872,3194961919,US
+3194959872,3194960383,US
+3194960384,3194960895,AR
+3194960896,3194961151,US
+3194961152,3194961407,AR
+3194961408,3194961919,US
 3194961920,3194970111,EC
 3194970112,3194974207,PA
 3194974208,3194976255,AR
@@ -67312,7 +70899,9 @@
 3195139072,3195140095,CL
 3195140096,3195142143,CR
 3195142144,3195142399,MX
-3195142400,3195150335,PA
+3195142400,3195142655,PA
+3195142656,3195142911,VE
+3195142912,3195150335,PA
 3195150336,3195158527,CL
 3195158528,3195199487,AR
 3195199488,3195201535,PY
@@ -67320,7 +70909,9 @@
 3195203584,3195205631,VE
 3195205632,3195206655,PE
 3195206656,3195207679,CL
-3195207680,3195211775,GT
+3195207680,3195209687,GT
+3195209688,3195209695,PR
+3195209696,3195211775,GT
 3195211776,3195214988,BZ
 3195214989,3195214989,RU
 3195214990,3195215871,BZ
@@ -67388,18 +70979,33 @@
 3195768832,3195772927,AR
 3195772928,3195781119,VE
 3195781120,3195785215,PA
-3195785216,3195786991,HN
+3195785216,3195786191,HN
+3195786192,3195786199,US
+3195786200,3195786527,HN
+3195786528,3195786543,US
+3195786544,3195786991,HN
 3195786992,3195787007,CA
-3195787008,3195789311,HN
+3195787008,3195787127,HN
+3195787128,3195787135,DE
+3195787136,3195787215,HN
+3195787216,3195787231,US
+3195787232,3195787607,HN
+3195787608,3195787615,DE
+3195787616,3195788159,HN
+3195788160,3195788167,CA
+3195788168,3195789311,HN
 3195789312,3195793407,PA
 3195793408,3195801599,AR
 3195801600,3195803647,HN
 3195803648,3195804671,CL
 3195804672,3195805695,VE
 3195805696,3195807743,NI
-3195807744,3195808639,BZ
+3195807744,3195808383,BZ
+3195808384,3195808511,US
+3195808512,3195808639,BZ
 3195808640,3195808767,CO
-3195808768,3195809151,BZ
+3195808768,3195808895,US
+3195808896,3195809151,BZ
 3195809152,3195809279,US
 3195809280,3195809791,BZ
 3195809792,3195811839,PE
@@ -67424,7 +71030,9 @@
 3196190720,3196207103,HN
 3196207104,3196223487,CO
 3196223488,3196305407,EC
-3196305408,3196321791,CO
+3196305408,3196316183,CO
+3196316184,3196316191,CW
+3196316192,3196321791,CO
 3196321792,3196583935,UY
 3196583936,3196690687,AR
 3196690688,3196690943,UY
@@ -67471,7 +71079,9 @@
 3199565824,3199582207,NI
 3199582208,3199598591,HN
 3199598592,3199631359,CO
-3199631360,3199729663,AR
+3199631360,3199719167,AR
+3199719168,3199719423,DE
+3199719424,3199729663,AR
 3199729664,3199762431,NI
 3199762432,3199778815,CO
 3199778816,3199779839,AR
@@ -67481,9 +71091,8 @@
 3199782912,3199784959,AR
 3199784960,3199785983,EC
 3199785984,3199795199,AR
-3199795200,3199815679,CW
-3199815680,3199817727,SX
-3199817728,3199819775,CW
+3199795200,3199811583,CW
+3199811584,3199819775,SX
 3199819776,3199820799,CR
 3199820800,3199822847,AR
 3199822848,3199827967,HN
@@ -67522,7 +71131,8 @@
 3201562624,3201563647,CL
 3201563648,3201564287,PA
 3201564288,3201564415,GB
-3201564416,3201564671,PA
+3201564416,3201564543,PA
+3201564544,3201564671,GB
 3201564672,3201630207,NI
 3201630208,3201695743,TT
 3201695744,3201761279,EC
@@ -67533,24 +71143,16 @@
 3201859584,3201863679,CO
 3201863680,3201865727,CL
 3201865728,3201867775,CO
-3201867776,3201869823,PE
-3201869824,3201869855,AR
-3201869856,3201869871,PE
-3201869872,3201869919,AR
-3201869920,3201869935,PE
-3201869936,3201871743,AR
-3201871744,3201871807,PE
-3201871808,3201871811,AR
-3201871812,3201871815,PE
-3201871816,3201871871,AR
-3201871872,3201875967,PE
+3201867776,3201875967,PE
 3201875968,3201880063,CO
 3201880064,3201884159,EC
 3201884160,3201894399,VE
 3201894400,3201925119,AR
 3201925120,3201957887,CL
 3201957888,3202088959,PA
-3202088960,3202220031,AR
+3202088960,3202127999,AR
+3202128000,3202128015,CW
+3202128016,3202220031,AR
 3202220032,3202280447,PE
 3202280448,3202280575,SE
 3202280576,3202351103,PE
@@ -67580,14 +71182,16 @@
 3203545088,3203545599,GT
 3203545600,3203547135,CO
 3203547136,3203549183,PA
-3203549184,3203556863,CO
+3203549184,3203553279,CO
+3203553280,3203553535,CR
+3203553536,3203556863,CO
 3203556864,3203557119,DO
 3203557120,3203561471,CO
 3203561472,3203562495,SV
 3203562496,3203563775,CO
-3203563776,3203564287,PA
-3203564288,3203564799,CO
-3203564800,3203565055,DO
+3203563776,3203564031,PA
+3203564032,3203564543,CO
+3203564544,3203565055,DO
 3203565056,3203566591,CO
 3203566592,3203566847,PA
 3203566848,3203568639,CO
@@ -67602,7 +71206,7 @@
 3209691136,3210084351,AR
 3210084352,3210215423,BR
 3210215424,3210739711,CO
-3210739712,3210739967,CL
+3210739712,3210739967,US
 3210739968,3210740223,MX
 3210740224,3210740479,AR
 3210740480,3210740735,US
@@ -67627,12 +71231,14 @@
 3210743296,3210743551,US
 3210743552,3210743567,TH
 3210743568,3210743583,US
-3210743584,3210744063,CL
+3210743584,3210743807,CL
+3210743808,3210744063,US
 3210744064,3210744079,TR
-3210744080,3210744319,CL
-3210744320,3210744575,US
+3210744080,3210744191,CL
+3210744192,3210744575,US
 3210744576,3210744591,BE
-3210744592,3210744831,BR
+3210744592,3210744703,BR
+3210744704,3210744831,US
 3210744832,3210744863,NZ
 3210744864,3210744895,IS
 3210744896,3210745087,CL
@@ -67644,18 +71250,18 @@
 3210745856,3210745871,IT
 3210745872,3210746367,BR
 3210746368,3210746383,SE
-3210746384,3210746623,CL
+3210746384,3210746623,BR
 3210746624,3210746879,US
 3210746880,3210746895,CH
 3210746896,3210747135,CL
 3210747136,3210747903,US
 3210747904,3210748159,BR
 3210748160,3210748175,JP
-3210748176,3210748415,BR
-3210748416,3210748927,US
+3210748176,3210748287,BR
+3210748288,3210748927,US
 3210748928,3210749439,CL
 3210749440,3210752255,US
-3210752256,3210752511,CL
+3210752256,3210752511,SG
 3210752512,3210755839,US
 3210755840,3210755855,MY
 3210755856,3210755871,US
@@ -67674,7 +71280,8 @@
 3210765056,3210765071,SE
 3210765072,3210765311,BR
 3210765312,3210765567,CL
-3210765568,3210766079,US
+3210765568,3210765823,US
+3210765824,3210766079,ES
 3210766080,3210766335,CL
 3210766336,3210766591,US
 3210766592,3210766847,CL
@@ -67683,22 +71290,18 @@
 3210767360,3210768127,US
 3210768128,3210768383,MY
 3210768384,3210768639,NL
-3210768640,3210769151,CL
+3210768640,3210769151,US
 3210769152,3210769407,NL
-3210769408,3210769663,CL
-3210769664,3210770431,US
-3210770432,3210770687,CL
-3210770688,3210770943,US
-3210770944,3210771199,CL
+3210769408,3210771199,US
 3210771200,3210771215,TH
-3210771216,3210771711,CL
-3210771712,3210772479,US
-3210772480,3210772991,CL
-3210772992,3210773247,US
+3210771216,3210771455,CL
+3210771456,3210772479,US
+3210772480,3210772735,CL
+3210772736,3210773247,US
 3210773248,3210773503,BR
 3210773504,3210773519,PL
-3210773520,3210774015,CL
-3210774016,3210774271,US
+3210773520,3210773759,BR
+3210773760,3210774271,US
 3210774272,3210774287,NO
 3210774288,3210774783,BR
 3210774784,3210774799,IT
@@ -67712,42 +71315,35 @@
 3210776576,3210776831,CL
 3210776832,3210777087,US
 3210777088,3210777599,CL
-3210777600,3210777855,US
-3210777856,3210778367,CL
-3210778368,3210778623,US
-3210778624,3210779135,CL
-3210779136,3210779391,US
-3210779392,3210779647,CL
-3210779648,3210780927,US
-3210780928,3210781183,CL
-3210781184,3210781439,US
-3210781440,3210782719,CL
+3210777600,3210781951,US
+3210781952,3210782719,CL
 3210782720,3210782975,US
 3210782976,3210782991,TR
-3210782992,3210783487,CL
+3210782992,3210783231,CL
+3210783232,3210783487,US
 3210783488,3210783503,JP
-3210783504,3210783999,CL
+3210783504,3210783743,CL
+3210783744,3210783999,US
 3210784000,3210784015,JP
-3210784016,3210784511,CL
+3210784016,3210784255,CL
+3210784256,3210784511,US
 3210784512,3210784527,BE
-3210784528,3210785279,CL
-3210785280,3210785535,US
-3210785536,3210785791,CL
+3210784528,3210785023,CL
+3210785024,3210785791,US
 3210785792,3210786047,BR
 3210786048,3210786063,AU
 3210786064,3210786303,CL
 3210786304,3210786559,US
 3210786560,3210786575,GR
-3210786576,3210787071,CL
+3210786576,3210786583,SG
+3210786584,3210787071,CL
 3210787072,3210787839,US
-3210787840,3210788351,CL
-3210788352,3210788607,US
+3210787840,3210788095,CL
+3210788096,3210788607,US
 3210788608,3210789119,CL
-3210789120,3210789375,US
-3210789376,3210790143,CL
-3210790144,3210790399,US
-3210790400,3210790655,CL
-3210790656,3210791423,US
+3210789120,3210789631,US
+3210789632,3210789887,CL
+3210789888,3210791423,US
 3210791424,3210791679,CL
 3210791680,3210791935,US
 3210791936,3210792447,CL
@@ -67756,11 +71352,13 @@
 3210793472,3210793727,US
 3210793728,3210793983,CL
 3210793984,3210794751,US
-3210794752,3210796287,CL
+3210794752,3210795007,CL
+3210795008,3210796031,US
+3210796032,3210796287,CL
 3210796288,3210797055,US
 3210797056,3210797311,CL
-3210797312,3210798079,US
-3210798080,3210798847,CL
+3210797312,3210798591,US
+3210798592,3210798847,CL
 3210798848,3210799103,ES
 3210799104,3210799359,US
 3210799360,3210799615,CL
@@ -67797,7 +71395,9 @@
 3210831872,3210832895,DO
 3210832896,3210835967,AR
 3210835968,3210838015,PY
-3210838016,3210870783,AR
+3210838016,3210868735,AR
+3210868736,3210869759,US
+3210869760,3210870783,AR
 3210870784,3210903551,CO
 3210903552,3210919935,PE
 3210919936,3210920959,GT
@@ -67818,8 +71418,7 @@
 3211072512,3211073023,NL
 3211073024,3211073279,GB
 3211073280,3211073535,FR
-3211073536,3211073791,US
-3211073792,3211074047,LT
+3211073536,3211074047,US
 3211074048,3211074303,NL
 3211074304,3211074559,ES
 3211074560,3211074815,NL
@@ -67844,8 +71443,8 @@
 3211083776,3211083791,RU
 3211083792,3211083839,CL
 3211083840,3211083855,GB
-3211083856,3211083871,DE
-3211083872,3211084031,CL
+3211083856,3211083903,DE
+3211083904,3211084031,CL
 3211084032,3211084287,DE
 3211084288,3211084303,NL
 3211084304,3211084351,DE
@@ -67879,10 +71478,7 @@
 3211086336,3211086351,FR
 3211086352,3211086367,DE
 3211086368,3211086463,CL
-3211086464,3211086591,DE
-3211086592,3211086607,CL
-3211086608,3211086623,DE
-3211086624,3211086847,CL
+3211086464,3211086847,DE
 3211086848,3211086863,PL
 3211086864,3211086879,DE
 3211086880,3211087119,CL
@@ -67891,22 +71487,15 @@
 3211087360,3211087375,GB
 3211087376,3211087871,DE
 3211087872,3211087887,ES
-3211087888,3211087903,DE
-3211087904,3211087999,CL
+3211087888,3211087999,DE
 3211088000,3211088127,US
-3211088128,3211088143,CL
-3211088144,3211088159,DE
-3211088160,3211088383,CL
+3211088128,3211088383,DE
 3211088384,3211088399,BE
-3211088400,3211088415,DE
-3211088416,3211088655,CL
-3211088656,3211088671,DE
-3211088672,3211088895,CL
+3211088400,3211088895,DE
 3211088896,3211088911,DK
 3211088912,3211089407,DE
 3211089408,3211089423,GB
-3211089424,3211089439,DE
-3211089440,3211089535,CL
+3211089424,3211089535,DE
 3211089536,3211089663,US
 3211089664,3211089919,DE
 3211089920,3211089935,GB
@@ -67916,76 +71505,44 @@
 3211090944,3211090959,TR
 3211090960,3211091071,DE
 3211091072,3211091199,US
-3211091200,3211091215,CL
-3211091216,3211091231,DE
-3211091232,3211091455,CL
+3211091200,3211091455,DE
 3211091456,3211091471,FI
-3211091472,3211091487,DE
-3211091488,3211091727,CL
-3211091728,3211091743,DE
-3211091744,3211091967,CL
+3211091472,3211091967,DE
 3211091968,3211091983,RU
-3211091984,3211091999,DE
-3211092000,3211092239,CL
-3211092240,3211092255,DE
-3211092256,3211092479,CL
+3211091984,3211092479,DE
 3211092480,3211092495,BE
-3211092496,3211092511,DE
-3211092512,3211092607,CL
+3211092496,3211092607,DE
 3211092608,3211092735,US
-3211092736,3211092751,CL
-3211092752,3211092767,DE
-3211092768,3211092991,CL
+3211092736,3211092991,DE
 3211092992,3211093007,SK
-3211093008,3211093023,DE
-3211093024,3211093263,CL
-3211093264,3211093279,DE
-3211093280,3211093503,CL
+3211093008,3211093503,DE
 3211093504,3211093519,HR
-3211093520,3211093535,DE
-3211093536,3211093775,CL
-3211093776,3211093791,DE
-3211093792,3211094015,CL
+3211093520,3211094015,DE
 3211094016,3211094031,CZ
-3211094032,3211094047,DE
-3211094048,3211094143,CL
+3211094032,3211094143,DE
 3211094144,3211094271,US
-3211094272,3211094287,CL
-3211094288,3211094303,DE
-3211094304,3211094527,CL
+3211094272,3211094527,DE
 3211094528,3211094543,HR
 3211094544,3211095039,DE
 3211095040,3211095055,ES
-3211095056,3211095071,DE
-3211095072,3211095311,CL
-3211095312,3211095327,DE
-3211095328,3211095551,CL
+3211095056,3211095551,DE
 3211095552,3211095567,GB
-3211095568,3211095583,DE
-3211095584,3211095679,CL
+3211095568,3211095679,DE
 3211095680,3211095807,US
 3211095808,3211096063,DE
 3211096064,3211096079,GB
-3211096080,3211096095,DE
-3211096096,3211096335,CL
-3211096336,3211096351,DE
-3211096352,3211096575,CL
-3211096576,3211096831,DE
-3211096832,3211096847,CL
-3211096848,3211096863,DE
-3211096864,3211097087,CL
-3211097088,3211097103,DE
+3211096080,3211097103,DE
 3211097104,3211097151,GB
 3211097152,3211097215,CL
 3211097216,3211097343,GB
 3211097344,3211097359,CL
 3211097360,3211097375,DE
 3211097376,3211097599,CL
-3211097600,3211097855,RU
+3211097600,3211097855,US
 3211097856,3211097871,CL
 3211097872,3211097887,DE
 3211097888,3211098111,CL
-3211098112,3211098367,RU
+3211098112,3211098367,US
 3211098368,3211098383,CL
 3211098384,3211098399,DE
 3211098400,3211098623,CL
@@ -68013,7 +71570,12 @@
 3211114240,3211114495,CL
 3211114496,3211116031,US
 3211116032,3211116287,RU
-3211116288,3211129087,US
+3211116288,3211118079,US
+3211118080,3211118335,VE
+3211118336,3211118591,EC
+3211118592,3211118847,BO
+3211118848,3211119103,UY
+3211119104,3211129087,US
 3211129088,3211129343,CL
 3211129344,3211129599,SG
 3211129600,3211129855,NL
@@ -68027,7 +71589,11 @@
 3211145216,3211147263,NI
 3211147264,3211148287,CR
 3211148288,3211165695,CO
-3211165696,3211182079,HN
+3211165696,3211165951,HN
+3211165952,3211165983,UY
+3211165984,3211172047,HN
+3211172048,3211172063,NL
+3211172064,3211182079,HN
 3211182080,3211194367,CO
 3211194368,3211195391,DO
 3211195392,3211214847,AR
@@ -68135,7 +71701,9 @@
 3220163584,3220164607,BR
 3220164608,3220168703,IE
 3220168704,3220172799,US
-3220172800,3221225471,BR
+3220172800,3221196100,BR
+3221196101,3221196101,US
+3221196102,3221225471,BR
 3221225480,3221225727,US
 3221226240,3221226495,US
 3221226496,3221227519,KY
@@ -68148,7 +71716,9 @@
 3221258240,3221291007,CA
 3221291008,3221334269,US
 3221334270,3221334270,DZ
-3221334271,3221469175,US
+3221334271,3221415935,US
+3221415936,3221416191,RU
+3221416192,3221469175,US
 3221469176,3221469183,CA
 3221469184,3221560319,US
 3221560320,3221561087,GB
@@ -68251,7 +71821,21 @@
 3222075136,3222075391,NL
 3222075392,3222274559,US
 3222274560,3222274815,AU
-3222274816,3222305535,US
+3222274816,3222275071,US
+3222275072,3222275583,JP
+3222275584,3222277631,US
+3222277632,3222278143,IT
+3222278144,3222279679,US
+3222279680,3222280191,PL
+3222280192,3222281215,US
+3222281216,3222281727,GB
+3222281728,3222284543,US
+3222284544,3222285055,BR
+3222285056,3222287359,US
+3222287360,3222287871,NL
+3222287872,3222288383,US
+3222288384,3222288895,JP
+3222288896,3222305535,US
 3222305536,3222309119,SE
 3222309120,3222309375,DE
 3222309376,3222313727,SE
@@ -68283,9 +71867,10 @@
 3222941696,3222952703,US
 3222952704,3222952959,AU
 3222952960,3222953215,US
-3222953216,3222953727,AU
+3222953216,3222953471,JP
+3222953472,3222953727,AU
 3222953728,3222953983,US
-3222953984,3222954239,AU
+3222953984,3222954239,JP
 3222954240,3222956287,US
 3222956288,3222957567,FI
 3222957824,3222962431,FI
@@ -68304,8 +71889,7 @@
 3222989312,3222989567,NL
 3222989568,3222989823,CA
 3222989824,3222990079,PT
-3222990080,3222990335,NL
-3222990336,3222990591,AT
+3222990080,3222990591,AT
 3222990592,3222990847,PT
 3222990848,3223091199,US
 3223091200,3223092223,AU
@@ -68377,7 +71961,9 @@
 3223390720,3223390975,MU
 3223390976,3223391999,US
 3223392000,3223392511,NL
-3223392512,3223397375,US
+3223392512,3223395839,US
+3223395840,3223396095,DE
+3223396096,3223397375,US
 3223397376,3223397631,NL
 3223397632,3223410431,US
 3223410432,3223416831,CH
@@ -68434,7 +72020,9 @@
 3223504896,3223508991,US
 3223508992,3223513087,CA
 3223513088,3223519231,US
-3223519232,3223524351,DE
+3223519232,3223523599,DE
+3223523600,3223523600,CH
+3223523601,3223524351,DE
 3223524352,3223534335,US
 3223534336,3223534591,AU
 3223534592,3223535359,US
@@ -68551,7 +72139,8 @@
 3223868416,3223869439,BM
 3223869440,3223869695,NO
 3223869696,3223869951,DK
-3223869952,3223871487,US
+3223869952,3223871231,US
+3223871232,3223871487,FI
 3223871488,3223873535,CA
 3223873536,3223881727,US
 3223881728,3223882751,CA
@@ -68584,7 +72173,7 @@
 3223964160,3223964415,US
 3223964416,3223964671,AU
 3223964672,3223965183,US
-3223965184,3223965439,AU
+3223965184,3223965439,ID
 3223965440,3223966207,US
 3223966208,3223966463,NL
 3223966464,3223967743,US
@@ -68632,7 +72221,7 @@
 3224030464,3224030719,US
 3224030720,3224030975,CA
 3224030976,3224038655,US
-3224038656,3224038911,AU
+3224038656,3224038911,JP
 3224038912,3224084991,US
 3224084992,3224087551,SE
 3224087552,3224088063,US
@@ -68777,7 +72366,8 @@
 3224799744,3224799999,US
 3224800000,3224800255,NL
 3224800256,3224800511,US
-3224800512,3224816639,FR
+3224800512,3224812031,FR
+3224812544,3224816639,FR
 3224816640,3224816895,IL
 3224816896,3224820735,FR
 3224820736,3224820991,PL
@@ -68843,7 +72433,8 @@
 3224884480,3224885247,US
 3224885248,3224885503,CA
 3224885504,3224886015,US
-3224886016,3224886527,AU
+3224886016,3224886271,AU
+3224886272,3224886527,JP
 3224886528,3224887295,US
 3224887296,3224887551,CA
 3224887552,3224889343,US
@@ -69103,7 +72694,9 @@
 3225785600,3225788159,CA
 3225788160,3225807359,US
 3225807360,3225807615,DE
-3225807616,3225812991,US
+3225807616,3225811711,US
+3225811712,3225811967,GB
+3225811968,3225812991,US
 3225812992,3225843711,FR
 3225843712,3225847039,US
 3225847040,3225847551,NL
@@ -69207,9 +72800,10 @@
 3226012672,3226012927,AU
 3226012928,3226014463,US
 3226014464,3226014975,NL
-3226014976,3226015487,AU
+3226014976,3226015231,NZ
+3226015232,3226015487,AU
 3226015488,3226015743,US
-3226015744,3226016255,AU
+3226015744,3226016255,ID
 3226016256,3226018303,US
 3226018304,3226018559,DE
 3226018560,3226021119,CH
@@ -69446,7 +73040,7 @@
 3226732032,3226732799,US
 3226733056,3226733567,US
 3226733568,3226733823,MX
-3226733824,3226734079,NL
+3226733824,3226734079,PT
 3226734080,3226734335,US
 3226734336,3226734591,NL
 3226734592,3226735615,US
@@ -69498,7 +73092,7 @@
 3226792960,3226793215,ZA
 3226793216,3226793983,DE
 3226793984,3226795263,US
-3226795264,3226795519,AU
+3226795264,3226795519,NZ
 3226795520,3226800127,US
 3226800128,3226800639,DE
 3226800640,3226811391,US
@@ -69555,7 +73149,7 @@
 3227013120,3227013375,AU
 3227013376,3227013887,US
 3227013888,3227014399,NL
-3227014400,3227014655,AU
+3227014400,3227014655,NZ
 3227014656,3227014911,NL
 3227014912,3227017471,US
 3227017472,3227017983,NL
@@ -69681,7 +73275,7 @@
 3227405568,3227414271,US
 3227414272,3227416063,GB
 3227416064,3227417087,US
-3227417088,3227417343,AU
+3227417088,3227417343,BN
 3227417344,3227418111,US
 3227418112,3227418367,CA
 3227418368,3227425791,US
@@ -69721,7 +73315,9 @@
 3227449088,3227450111,US
 3227450112,3227450367,CA
 3227450368,3227451455,US
-3227451456,3227452375,CA
+3227451456,3227451831,CA
+3227451832,3227451835,US
+3227451836,3227452375,CA
 3227452376,3227452382,US
 3227452383,3227452735,CA
 3227452736,3227452767,US
@@ -69913,19 +73509,19 @@
 3227846912,3227847423,US
 3227847424,3227847679,NL
 3227847680,3227848703,US
-3227848704,3227848959,AU
+3227848704,3227848959,NZ
 3227848960,3227851775,US
 3227851776,3227852031,NL
 3227852032,3227853311,US
 3227853312,3227853567,GB
 3227853568,3227856383,US
 3227856896,3227860991,US
-3227863552,3227863807,US
+3227863296,3227863807,US
 3227863808,3227864063,NL
 3227864064,3227865343,US
 3227865344,3227867647,NL
 3227867648,3227867903,BR
-3227867904,3227868159,AU
+3227867904,3227868159,TH
 3227868160,3227872767,US
 3227872768,3227873023,GB
 3227873024,3227874047,NL
@@ -69937,7 +73533,9 @@
 3227879680,3227879935,NL
 3227879936,3227880959,US
 3227880960,3227881215,MU
-3227881216,3227885823,US
+3227881216,3227883319,US
+3227883320,3227883320,CA
+3227883321,3227885823,US
 3227885824,3227887871,ES
 3227887872,3227888127,PR
 3227888128,3227888383,NL
@@ -70007,7 +73605,8 @@
 3227982848,3227985919,GB
 3227985920,3227986175,DE
 3227986176,3227986431,US
-3227986432,3227986943,AU
+3227986432,3227986687,AU
+3227986688,3227986943,JP
 3227986944,3227987455,US
 3227987456,3227987711,AU
 3227987712,3227997439,US
@@ -70062,14 +73661,15 @@
 3228084480,3228085247,US
 3228085248,3228085503,AU
 3228085504,3228100607,US
-3228100608,3228101119,AU
+3228100608,3228101119,JP
 3228101120,3228102143,US
 3228102144,3228102399,NL
 3228102400,3228103423,US
 3228103424,3228103679,CA
 3228103680,3228103935,US
 3228103936,3228104191,FR
-3228104192,3228104703,AU
+3228104192,3228104447,JP
+3228104448,3228104703,AU
 3228104704,3228104959,NL
 3228104960,3228105471,US
 3228105472,3228105727,NL
@@ -70173,7 +73773,7 @@
 3228348160,3228353279,US
 3228353280,3228358399,SE
 3228358400,3228362239,US
-3228362240,3228362495,AU
+3228362240,3228362495,TH
 3228362496,3228363263,US
 3228363264,3228363519,CH
 3228363520,3228364287,US
@@ -70182,7 +73782,8 @@
 3228368896,3228371455,DE
 3228371968,3228372735,DE
 3228372992,3228373247,DE
-3228373504,3228380415,DE
+3228373504,3228379135,DE
+3228379648,3228380415,DE
 3228380416,3228380671,US
 3228380672,3228380927,DE
 3228381184,3228387839,DE
@@ -70205,7 +73806,8 @@
 3228405760,3228406015,FR
 3228406016,3228406271,US
 3228406272,3228406527,IN
-3228406528,3228407039,FR
+3228406528,3228406783,BR
+3228406784,3228407039,FR
 3228407296,3228420095,DE
 3228420608,3228420863,DE
 3228421120,3228424447,DE
@@ -70242,7 +73844,7 @@
 3228522496,3228522751,NL
 3228522752,3228525823,US
 3228525824,3228526079,NL
-3228526080,3228526335,AU
+3228526080,3228526335,NZ
 3228526336,3228526847,NL
 3228526848,3228527103,AU
 3228527104,3228531711,US
@@ -70411,7 +74013,7 @@
 3229382144,3229390847,US
 3229390848,3229391103,AU
 3229391104,3229391359,US
-3229391360,3229391615,AU
+3229391360,3229391615,CN
 3229391616,3229391871,NL
 3229391872,3229395455,US
 3229395456,3229408255,RU
@@ -70454,7 +74056,8 @@
 3229830912,3229831167,NL
 3229831168,3229833471,US
 3229833472,3229833727,NL
-3229833728,3229834495,AU
+3229833728,3229834239,IN
+3229834240,3229834495,AU
 3229834496,3229834751,US
 3229834752,3229835007,CA
 3229835008,3229835263,US
@@ -70481,11 +74084,11 @@
 3229878784,3229879039,IT
 3229879040,3229879295,NO
 3229879296,3229880063,US
-3229880064,3229880319,AU
+3229880064,3229880319,KR
 3229880320,3229881087,US
 3229881088,3229881343,CA
 3229881344,3229884159,US
-3229884160,3229884415,AU
+3229884160,3229884415,JP
 3229884416,3229884927,US
 3229884928,3229885183,NL
 3229885184,3229885439,BR
@@ -70541,7 +74144,8 @@
 3229956864,3229958143,US
 3229958144,3229958399,NL
 3229958400,3229958655,US
-3229958656,3229959167,AU
+3229958656,3229958911,AU
+3229958912,3229959167,SG
 3229959168,3229962079,US
 3229962080,3229962111,CA
 3229962112,3229968127,US
@@ -70586,7 +74190,9 @@
 3230096384,3230096639,JP
 3230096640,3230096895,US
 3230096896,3230097151,JP
-3230097408,3230100735,JP
+3230097408,3230097663,JP
+3230098688,3230098943,JP
+3230099200,3230100735,JP
 3230100736,3230100991,US
 3230100992,3230101503,PR
 3230101504,3230104319,US
@@ -70615,7 +74221,7 @@
 3230126848,3230128895,US
 3230128896,3230129151,NL
 3230129152,3230129663,US
-3230129664,3230129919,AU
+3230129664,3230129919,JP
 3230129920,3230130431,US
 3230130432,3230130687,NL
 3230130688,3230131711,US
@@ -70649,7 +74255,7 @@
 3230152192,3230152447,FR
 3230152448,3230153215,BF
 3230153216,3230153471,FR
-3230153472,3230153727,AU
+3230153472,3230153727,PF
 3230153728,3230153983,US
 3230153984,3230154239,NL
 3230154240,3230156543,US
@@ -70792,7 +74398,7 @@
 3230825472,3230826239,ES
 3230826240,3230827519,US
 3230827520,3230827775,NL
-3230827776,3230828031,AU
+3230827776,3230828031,NZ
 3230828032,3230828543,HU
 3230828544,3230829055,GB
 3230829568,3230830079,RU
@@ -70823,7 +74429,7 @@
 3230845184,3230845951,US
 3230845952,3230846207,CZ
 3230846208,3230849535,US
-3230849536,3230850047,AU
+3230849536,3230850047,NZ
 3230850048,3230851839,US
 3230851840,3230852351,NL
 3230852352,3230852607,BR
@@ -70965,7 +74571,7 @@
 3231028736,3231042047,US
 3231042048,3231042303,GU
 3231042304,3231043839,US
-3231043840,3231044095,AU
+3231043840,3231044095,JP
 3231044096,3231047935,US
 3231047936,3231048191,GB
 3231048192,3231048447,US
@@ -71194,7 +74800,7 @@
 3231308288,3231308799,US
 3231308800,3231309055,CA
 3231310848,3231316735,US
-3231316736,3231316991,AU
+3231316736,3231316991,NZ
 3231316992,3231318783,US
 3231319040,3231321343,US
 3231321344,3231321599,CA
@@ -71218,7 +74824,8 @@
 3231478016,3231482879,US
 3231482880,3231483135,BE
 3231483136,3231484927,US
-3231484928,3231487999,JP
+3231484928,3231485439,JP
+3231485696,3231487999,JP
 3231488512,3231488767,JP
 3231489280,3231489535,US
 3231489536,3231489791,JP
@@ -71226,7 +74833,7 @@
 3231490048,3231490559,US
 3231490560,3231490815,NL
 3231490816,3231491327,US
-3231491328,3231491583,AU
+3231491328,3231491583,NZ
 3231491584,3231491839,US
 3231491840,3231492095,GB
 3231492096,3231493631,US
@@ -71443,7 +75050,7 @@
 3231793664,3231800319,US
 3231800320,3231801343,CN
 3231801344,3231809535,CA
-3231809536,3231810047,AU
+3231809536,3231810047,NZ
 3231810048,3231842303,US
 3231842304,3231843327,RU
 3231843328,3231844351,NO
@@ -71687,7 +75294,7 @@
 3233548800,3233549055,NL
 3233549056,3233549311,BR
 3233549312,3233557247,US
-3233557248,3233557503,AU
+3233557248,3233557503,NZ
 3233557504,3233561855,EC
 3233561856,3233562367,US
 3233562368,3233562879,GB
@@ -71695,7 +75302,7 @@
 3233563136,3233563903,US
 3233563904,3233564159,NL
 3233564160,3233564415,US
-3233564416,3233564671,AU
+3233564416,3233564671,NZ
 3233564672,3233564927,US
 3233564928,3233566719,JP
 3233567744,3233567999,US
@@ -71741,7 +75348,8 @@
 3233590016,3233590271,TW
 3233590272,3233590527,TH
 3233590528,3233590783,PR
-3233590784,3233591295,AU
+3233590784,3233591039,PH
+3233591040,3233591295,ID
 3233591296,3233593599,US
 3233593600,3233593855,NZ
 3233593856,3233594111,AU
@@ -71753,7 +75361,7 @@
 3233596928,3233605887,US
 3233605888,3233607167,PL
 3233607168,3233607935,US
-3233607936,3233608191,AU
+3233607936,3233608191,NZ
 3233608192,3233609727,HU
 3233609984,3233612031,US
 3233612032,3233612287,NL
@@ -71764,7 +75372,7 @@
 3233615616,3233617407,US
 3233617408,3233617663,CA
 3233617664,3233617919,NL
-3233617920,3233618175,AU
+3233617920,3233618175,JP
 3233618176,3233620479,US
 3233620480,3233620735,AU
 3233620736,3233620991,US
@@ -71813,7 +75421,7 @@
 3233664256,3233665023,US
 3233665024,3233666047,AU
 3233666048,3233668863,US
-3233668864,3233669119,AU
+3233668864,3233669119,PH
 3233669120,3233670399,US
 3233670400,3233670655,AU
 3233671680,3233676031,US
@@ -71943,7 +75551,7 @@
 3234008832,3234013695,US
 3234013696,3234013951,AU
 3234013952,3234014975,US
-3234014976,3234015487,AU
+3234014976,3234015487,KR
 3234015488,3234015743,US
 3234015744,3234015999,IE
 3234016000,3234016255,GB
@@ -71981,7 +75589,7 @@
 3234055680,3234056959,US
 3234056960,3234057215,CA
 3234057216,3234061055,US
-3234061056,3234061311,AU
+3234061056,3234061311,NZ
 3234061312,3234064639,US
 3234064640,3234064895,AU
 3234064896,3234065407,US
@@ -72051,7 +75659,7 @@
 3234320384,3234338815,US
 3234338816,3234339071,CN
 3234339072,3234339327,MT
-3234339328,3234339583,LB
+3234339328,3234339583,DE
 3234339584,3234339839,PA
 3234339840,3234340095,US
 3234340096,3234340351,IN
@@ -72071,7 +75679,7 @@
 3234557440,3234564607,US
 3234564608,3234566911,KR
 3234566912,3234568703,US
-3234568704,3234568959,AU
+3234568704,3234568959,NZ
 3234568960,3234569215,US
 3234569216,3234569727,AU
 3234569728,3234569983,CL
@@ -72100,7 +75708,7 @@
 3234589696,3234590463,US
 3234590464,3234590719,CA
 3234590720,3234592511,US
-3234592512,3234592767,AU
+3234592512,3234592767,TH
 3234592768,3234726143,US
 3234726144,3234726399,CA
 3234726400,3234726911,US
@@ -72163,7 +75771,7 @@
 3234826752,3234827007,CA
 3234827008,3234827519,US
 3234827520,3234828031,NL
-3234828032,3234828287,AU
+3234828032,3234828287,NZ
 3234828288,3234828799,US
 3234828800,3234829055,CL
 3234829056,3234830079,US
@@ -72184,7 +75792,7 @@
 3234842368,3234842623,US
 3234842624,3234844415,BR
 3234844416,3234853375,US
-3234853376,3234853631,AU
+3234853376,3234853631,TH
 3234853632,3234853887,US
 3234853888,3234854143,EC
 3234854144,3234854911,US
@@ -72304,7 +75912,13 @@
 3235970560,3235970815,CA
 3235970816,3235971071,US
 3235971072,3235971327,CA
-3235971328,3236044799,US
+3235971328,3235996671,US
+3235996672,3235996927,CA
+3235996928,3235997695,US
+3235997696,3235997951,CA
+3235997952,3235998719,US
+3235998720,3235999231,CA
+3235999232,3236044799,US
 3236044800,3236052991,CA
 3236052992,3236069375,US
 3236069376,3236102143,CA
@@ -72322,12 +75936,28 @@
 3236163520,3236163583,IE
 3236163584,3236167935,US
 3236167936,3236175871,CA
-3236175872,3236191487,US
-3236191744,3236200447,US
+3236175872,3236200447,US
 3236200448,3236233215,MY
 3236233216,3236239359,US
 3236239360,3236241407,CA
-3236241408,3236291071,US
+3236241408,3236267519,US
+3236267520,3236268031,DE
+3236268032,3236268543,ES
+3236268544,3236272639,US
+3236272640,3236272895,HK
+3236272896,3236273919,US
+3236273920,3236274175,DE
+3236274176,3236275199,US
+3236275200,3236275711,FR
+3236275712,3236276223,AU
+3236276224,3236277759,US
+3236277760,3236278783,IN
+3236278784,3236281855,US
+3236281856,3236282367,SG
+3236282368,3236287487,US
+3236287488,3236287743,EC
+3236287744,3236287999,CO
+3236288000,3236291071,US
 3236291072,3236291327,GB
 3236291328,3236302847,US
 3236306944,3236312063,US
@@ -72335,10 +75965,12 @@
 3236312320,3236312575,GH
 3236312576,3236312831,GR
 3236312832,3236313087,QA
-3236313088,3236365567,US
+3236313088,3236314367,US
+3236314368,3236314623,GB
+3236314624,3236365567,US
 3236365568,3236365823,CA
 3236365824,3236368127,US
-3236368128,3236368383,AU
+3236368128,3236368383,NZ
 3236368384,3236372991,US
 3236372992,3236373247,AU
 3236373248,3236373503,US
@@ -72462,7 +76094,13 @@
 3236825856,3236827135,CA
 3236827136,3236958207,US
 3236958208,3236962303,AU
-3236962304,3237038079,US
+3236962304,3236995623,US
+3236995624,3236995631,NL
+3236995632,3237003263,US
+3237003264,3237003519,GB
+3237003520,3237016831,US
+3237016832,3237017087,GB
+3237017088,3237038079,US
 3237038080,3237038335,CA
 3237038336,3237043967,US
 3237043968,3237044223,CH
@@ -72497,7 +76135,7 @@
 3237291264,3237294847,US
 3237294848,3237295103,CA
 3237295104,3237296639,US
-3237296640,3237297151,AU
+3237296640,3237297151,SG
 3237297152,3237297407,CL
 3237297408,3237300479,US
 3237302528,3237305087,US
@@ -72567,7 +76205,9 @@
 3237615616,3237616895,CA
 3237616896,3237647103,US
 3237647104,3237647359,AU
-3237647360,3237655039,US
+3237647360,3237653503,US
+3237653504,3237653759,IN
+3237653760,3237655039,US
 3237655040,3237655551,IN
 3237655552,3237675007,US
 3237675008,3237675263,CA
@@ -72644,11 +76284,14 @@
 3237960192,3237960447,SR
 3237960448,3237960703,BZ
 3237960704,3237960959,BO
-3237960960,3237961215,DM
+3237960960,3237961215,DE
 3237961216,3237961471,SV
 3237961472,3237961727,HT
-3237961728,3238002687,US
-3238002688,3238010879,NL
+3237961728,3237964799,US
+3237964800,3237965055,DE
+3237965056,3238002687,US
+3238002688,3238008831,NL
+3238008832,3238010879,RO
 3238010880,3238017023,CH
 3238017024,3238018303,DK
 3238018304,3238018559,UA
@@ -73147,7 +76790,6 @@
 3239541248,3239541503,UA
 3239541504,3239541759,FR
 3239541760,3239542015,GB
-3239542272,3239542527,RU
 3239543808,3239544831,DE
 3239544832,3239545087,GB
 3239545088,3239545343,SI
@@ -73443,7 +77085,7 @@
 3239901952,3239902207,DE
 3239902720,3239902975,EE
 3239903232,3239904255,DE
-3239904512,3239904767,GB
+3239904512,3239904767,DE
 3239905536,3239905791,DE
 3239907328,3239907583,UA
 3239908096,3239908351,RU
@@ -73780,7 +77422,7 @@
 3240312320,3240312575,IR
 3240312576,3240312831,RU
 3240312832,3240316927,GB
-3240321024,3240321791,RU
+3240321024,3240321535,RU
 3240321792,3240322047,PL
 3240322048,3240322303,RU
 3240322560,3240324095,CZ
@@ -74533,7 +78175,6 @@
 3244828160,3244828415,FI
 3244828416,3244828671,FR
 3244828672,3244828927,SA
-3244828928,3244829183,MD
 3244829184,3244829439,CH
 3244829440,3244829695,DK
 3244829696,3244829951,IL
@@ -74579,7 +78220,6 @@
 3244841216,3244841471,GB
 3244841472,3244841727,DE
 3244841728,3244842239,GB
-3244842496,3244842751,RU
 3244842752,3244843007,DE
 3244843008,3244843263,UA
 3244843264,3244843519,RU
@@ -74594,7 +78234,6 @@
 3244845568,3244845823,RO
 3244845824,3244846335,GB
 3244846336,3244846591,TR
-3244846592,3244846847,CZ
 3244846848,3244847103,NL
 3244847104,3244847359,SE
 3244847360,3244847615,GB
@@ -74613,7 +78252,6 @@
 3244850688,3244850943,GB
 3244850944,3244851455,RU
 3244851456,3244851711,NL
-3244851712,3244851967,TR
 3244851968,3244852223,GB
 3244852224,3244852479,CH
 3244852480,3244852735,UA
@@ -74673,7 +78311,6 @@
 3244868352,3244868607,RU
 3244868608,3244868863,FI
 3244868864,3244869119,RU
-3244869120,3244869375,GB
 3244869376,3244869631,FR
 3244869632,3244869887,GR
 3244869888,3244870143,TR
@@ -74814,7 +78451,6 @@
 3244909312,3244909567,IL
 3244909568,3244909823,RU
 3244909824,3244910079,NL
-3244910080,3244910335,CY
 3244910336,3244910591,DE
 3244910592,3244910847,GB
 3244910848,3244911103,DE
@@ -74905,8 +78541,7 @@
 3244935424,3244935679,UA
 3244935680,3244935935,PL
 3244935936,3244936191,IL
-3244936192,3244936959,AT
-3244936960,3244937215,KZ
+3244936192,3244937215,AT
 3244937216,3244937471,TR
 3244937472,3244937727,GB
 3244937728,3244937983,UA
@@ -75084,7 +78719,6 @@
 3245093888,3245094911,RO
 3245094912,3245095935,UA
 3245095936,3245096959,IT
-3245096960,3245099007,CZ
 3245099008,3245103103,GB
 3245105664,3245106175,NL
 3245106176,3245106687,AT
@@ -75122,7 +78756,8 @@
 3245127936,3245128191,LV
 3245128192,3245128447,IT
 3245128448,3245128703,CH
-3245128704,3245129471,DK
+3245128704,3245129215,LU
+3245129216,3245129471,DK
 3245129472,3245129983,GB
 3245129984,3245130239,DE
 3245130240,3245130495,PL
@@ -75375,11 +79010,10 @@
 3245298688,3245298943,GB
 3245298944,3245299199,UA
 3245299456,3245299711,AT
-3245299712,3245299967,DE
 3245299968,3245300223,BG
 3245300736,3245300991,RU
 3245300992,3245301247,FI
-3245301248,3245301503,DK
+3245301248,3245301503,NL
 3245301504,3245301759,BE
 3245301760,3245302783,SK
 3245302784,3245303807,DE
@@ -75394,7 +79028,6 @@
 3245312000,3245314047,DE
 3245314048,3245315071,PL
 3245317120,3245318143,UA
-3245318144,3245318399,IT
 3245318400,3245318655,RO
 3245318656,3245318911,DK
 3245318912,3245319167,DE
@@ -75436,7 +79069,11 @@
 3245931520,3245932543,IE
 3245932544,3245998079,BE
 3245998080,3246129151,GB
-3246129152,3246260223,RU
+3246129152,3246163967,RU
+3246163968,3246166015,DE
+3246166016,3246191615,RU
+3246191616,3246192639,DE
+3246192640,3246260223,RU
 3246260224,3246325759,PT
 3246351616,3246352639,ES
 3246370816,3246371073,ES
@@ -75549,7 +79186,9 @@
 3247253504,3247254527,DE
 3247254528,3247267839,NL
 3247267840,3247268351,DE
-3247268352,3247290367,NL
+3247268352,3247289855,NL
+3247289856,3247290111,DE
+3247290112,3247290367,NL
 3247290368,3247291391,DE
 3247291392,3247292415,NL
 3247292416,3247300607,DE
@@ -76032,7 +79671,6 @@
 3249676800,3249677055,UA
 3249677056,3249677311,SE
 3249678336,3249678847,IE
-3249679104,3249679359,CH
 3249681664,3249681919,IE
 3249683456,3249684479,SE
 3249684480,3249696767,IE
@@ -76926,7 +80564,6 @@
 3252379648,3252379903,ES
 3252379904,3252380159,GB
 3252380160,3252380415,BE
-3252380416,3252380671,UA
 3252380672,3252380927,SI
 3252381184,3252381439,IT
 3252381440,3252381695,ES
@@ -77152,7 +80789,9 @@
 3253075968,3253139455,RO
 3253139456,3253139711,MD
 3253139712,3253207039,RO
-3253207040,3253270527,RU
+3253207040,3253230591,RU
+3253230592,3253230847,BY
+3253230848,3253270527,RU
 3253270528,3253271551,BY
 3253271552,3253338111,RU
 3253338112,3253338367,PL
@@ -77397,7 +81036,9 @@
 3253741818,3253741823,SE
 3253741824,3253744415,GB
 3253744416,3253744447,CH
-3253744448,3253745983,GB
+3253744448,3253744511,GB
+3253744512,3253744512,US
+3253744513,3253745983,GB
 3253745984,3253745999,SE
 3253746000,3253746007,DK
 3253746008,3253746015,IE
@@ -77445,17 +81086,29 @@
 3253770984,3253770984,DE
 3253770985,3253771199,GB
 3253771200,3253771263,IE
-3253771264,3253772063,GB
+3253771264,3253771561,GB
+3253771562,3253771562,DE
+3253771563,3253772063,GB
 3253772064,3253772095,DE
-3253772096,3253772191,GB
-3253772192,3253772207,DE
-3253772208,3253773055,GB
+3253772096,3253772519,GB
+3253772520,3253772527,DE
+3253772528,3253773055,GB
 3253773056,3253773311,DE
-3253773312,3253775807,GB
+3253773312,3253774583,GB
+3253774584,3253774591,DE
+3253774592,3253775183,GB
+3253775184,3253775191,FR
+3253775192,3253775599,GB
+3253775600,3253775607,IT
+3253775608,3253775807,GB
 3253775808,3253775823,DE
 3253775824,3253776159,GB
 3253776160,3253776175,DE
-3253776176,3253796863,GB
+3253776176,3253778231,GB
+3253778232,3253778239,FR
+3253778240,3253778271,GB
+3253778272,3253778287,DE
+3253778288,3253796863,GB
 3253796864,3253862399,SE
 3253862400,3253862655,GB
 3253862656,3253882879,FR
@@ -78593,7 +82246,9 @@
 3257742336,3257743359,DE
 3257743360,3257748479,NL
 3257748480,3257749503,DE
-3257749504,3257765887,NL
+3257749504,3257753087,NL
+3257753088,3257753343,DE
+3257753344,3257765887,NL
 3257765888,3257767935,DE
 3257767936,3257782271,NL
 3257782272,3257784319,DE
@@ -78760,7 +82415,6 @@
 3258103552,3258103807,AE
 3258104320,3258104575,PL
 3258104576,3258104831,DE
-3258105088,3258105343,CZ
 3258105600,3258105855,DE
 3258105856,3258109951,CZ
 3258109952,3258110207,DK
@@ -78861,7 +82515,7 @@
 3258694144,3258694399,RU
 3258694656,3258694911,GB
 3258694912,3258701311,DE
-3258702848,3258712063,DE
+3258703616,3258712063,DE
 3258712064,3258728447,GB
 3258728448,3258729471,FR
 3258729472,3258729727,DE
@@ -79035,7 +82689,8 @@
 3259481088,3259484671,SE
 3259484672,3259485183,ES
 3259485184,3259490303,SE
-3259490304,3259490815,IN
+3259490304,3259490559,IN
+3259490560,3259490815,NL
 3259490816,3259491071,SE
 3259491072,3259491327,LI
 3259491328,3259495935,SE
@@ -79076,7 +82731,9 @@
 3259963392,3259964415,PL
 3259964416,3259964927,GB
 3259964928,3259964959,NL
-3259964960,3259965439,GB
+3259964960,3259965023,GB
+3259965024,3259965031,DE
+3259965032,3259965439,GB
 3259965440,3259966463,RU
 3259967488,3259968511,RS
 3259968512,3259969535,RU
@@ -79258,10 +82915,9 @@
 3261767680,3261775871,RS
 3261775872,3261776383,PL
 3261776384,3261777407,RU
-3261777408,3261777449,IR
+3261777408,3261777449,GB
 3261777450,3261777451,NL
-3261777452,3261777663,IR
-3261777664,3261777919,GB
+3261777452,3261777919,GB
 3261777920,3261778431,PL
 3261778944,3261779455,RO
 3261779456,3261779967,DE
@@ -79369,7 +83025,7 @@
 3262043648,3262043903,NL
 3262043904,3262044159,GB
 3262044160,3262044415,RS
-3262044416,3262044671,DE
+3262044416,3262044671,LU
 3262044672,3262044927,GR
 3262044928,3262045183,UA
 3262045184,3262045439,LT
@@ -79850,7 +83506,9 @@
 3263647744,3263651619,LT
 3263651620,3263651620,RU
 3263651621,3263651839,LT
-3263651840,3263666175,RU
+3263651840,3263660031,RU
+3263660032,3263661055,DE
+3263661056,3263666175,RU
 3263666176,3263676415,AZ
 3263676416,3263678463,RU
 3263678464,3263680511,DE
@@ -80090,7 +83748,9 @@
 3264614912,3264615167,SE
 3264615168,3264616263,GB
 3264616264,3264616271,CH
-3264616272,3264617983,GB
+3264616272,3264616335,GB
+3264616336,3264616337,CH
+3264616338,3264617983,GB
 3264617984,3264618239,US
 3264618240,3264619391,GB
 3264619392,3264619519,BE
@@ -80225,7 +83885,6 @@
 3264846464,3264846591,NO
 3264846848,3264846911,DK
 3264846912,3264847103,CY
-3264847168,3264847199,IE
 3264847232,3264847263,CH
 3264847264,3264847295,LI
 3264847296,3264847359,CY
@@ -80279,7 +83938,9 @@
 3265069056,3265134591,FI
 3265134592,3265134863,CH
 3265134864,3265134879,BE
-3265134880,3265135039,CH
+3265134880,3265135017,CH
+3265135018,3265135018,BE
+3265135019,3265135039,CH
 3265135040,3265135071,BE
 3265135072,3265137983,CH
 3265137984,3265138047,NL
@@ -80297,7 +83958,9 @@
 3265141552,3265141555,IE
 3265141556,3265141759,CH
 3265141760,3265142015,GB
-3265142016,3265142783,CH
+3265142016,3265142220,CH
+3265142221,3265142221,GB
+3265142222,3265142783,CH
 3265142784,3265150975,MT
 3265150976,3265159167,AD
 3265159168,3265167359,FR
@@ -80514,10 +84177,12 @@
 3266781184,3266789375,PL
 3266789376,3266797567,SM
 3266797568,3266797823,GB
-3266797824,3266798079,ES
-3266798080,3266798847,GB
+3266797824,3266798207,ES
+3266798208,3266798847,GB
 3266798848,3266798879,CZ
-3266798880,3266804639,GB
+3266798880,3266804099,GB
+3266804100,3266804100,NL
+3266804101,3266804639,GB
 3266804640,3266804643,NL
 3266804644,3266805759,GB
 3266805760,3266813951,AT
@@ -80583,9 +84248,17 @@
 3267095552,3267096575,PL
 3267096576,3267097599,DE
 3267097600,3267098623,KZ
-3267098624,3267099391,GB
-3267099392,3267099399,BE
-3267099400,3267099647,GB
+3267098624,3267099007,GB
+3267099008,3267099043,FR
+3267099044,3267099135,GB
+3267099136,3267099263,DE
+3267099264,3267099327,NL
+3267099328,3267099383,GB
+3267099384,3267099387,NL
+3267099388,3267099399,BE
+3267099400,3267099407,GB
+3267099408,3267099415,DE
+3267099416,3267099647,GB
 3267099648,3267100671,IT
 3267100672,3267166207,FI
 3267166208,3267231743,GB
@@ -80975,8 +84648,7 @@
 3270650368,3270650623,DK
 3270650624,3270651135,FR
 3270651648,3270651903,FR
-3270652416,3270652671,DK
-3270652672,3270652927,CH
+3270652416,3270652927,CH
 3270652928,3270653183,PL
 3270653184,3270653439,UA
 3270653440,3270653695,NL
@@ -81730,6 +85402,8 @@
 3273339136,3273339391,DE
 3273339392,3273340415,GB
 3273340928,3273341711,FR
+3273342022,3273342022,GB
+3273342034,3273342034,GB
 3273342208,3273342231,AE
 3273342464,3273342975,DE
 3273342976,3273343999,GB
@@ -81840,7 +85514,7 @@
 3273436672,3273437183,DE
 3273437184,3273437695,RO
 3273438208,3273438719,IL
-3273438720,3273439231,GB
+3273438720,3273439231,UA
 3273439232,3273439743,RO
 3273439744,3273440255,DE
 3273440256,3273440767,RO
@@ -82301,7 +85975,6 @@
 3275138048,3275138559,DE
 3275139072,3275139583,PT
 3275140096,3275140607,AT
-3275140608,3275141119,NL
 3275141120,3275141631,RU
 3275141632,3275142143,GE
 3275142144,3275142655,KG
@@ -82963,7 +86636,9 @@
 3276886364,3276886367,DE
 3276886368,3276886649,GB
 3276886650,3276886650,DE
-3276886651,3276890175,GB
+3276886651,3276886911,GB
+3276886912,3276886927,DE
+3276886928,3276890175,GB
 3276890176,3276890191,US
 3276890192,3276892159,GB
 3276892160,3276893183,IT
@@ -82973,7 +86648,9 @@
 3276897728,3276897791,BE
 3276897792,3276898671,GB
 3276898672,3276898687,CH
-3276898688,3276901613,GB
+3276898688,3276898783,GB
+3276898784,3276898799,CH
+3276898800,3276901613,GB
 3276901614,3276901614,CH
 3276901615,3276902141,GB
 3276902142,3276902142,CH
@@ -82981,7 +86658,11 @@
 3276902368,3276902399,CH
 3276902400,3276902655,GB
 3276902656,3276902911,SE
-3276902912,3276907519,GB
+3276902912,3276903423,GB
+3276903424,3276903487,SE
+3276903488,3276903551,GB
+3276903552,3276903679,SE
+3276903680,3276907519,GB
 3276907520,3276907551,NL
 3276907552,3276911167,GB
 3276911168,3276911199,IT
@@ -83202,7 +86883,9 @@
 3277403904,3277404159,GB
 3277404160,3277404415,DE
 3277404416,3277404655,IT
-3277404656,3277404671,GB
+3277404656,3277404664,GB
+3277404665,3277404665,IT
+3277404666,3277404671,GB
 3277404672,3277404735,CH
 3277404736,3277404927,GB
 3277404928,3277405183,NL
@@ -83590,7 +87273,6 @@
 3279054848,3279055359,RU
 3279055360,3279055871,SA
 3279056896,3279057151,RU
-3279057152,3279057407,GB
 3279057408,3279057919,FR
 3279058944,3279059455,UA
 3279059456,3279060479,RU
@@ -83632,7 +87314,9 @@
 3279586816,3279587327,DE
 3279587328,3279587583,GB
 3279587584,3279588095,DE
-3279588096,3279590911,GB
+3279588096,3279590399,GB
+3279590400,3279590655,US
+3279590656,3279590911,GB
 3279590912,3279591167,DE
 3279591168,3279593407,GB
 3279593408,3279593440,DE
@@ -83907,7 +87591,15 @@
 3280928832,3280928847,RU
 3280928848,3280928855,GB
 3280928856,3280928863,RU
-3280928864,3280952783,GB
+3280928864,3280934927,GB
+3280934928,3280934935,DE
+3280934936,3280935055,GB
+3280935056,3280935063,IT
+3280935064,3280935087,GB
+3280935088,3280935095,ES
+3280935096,3280935119,GB
+3280935120,3280935127,FR
+3280935128,3280952783,GB
 3280952784,3280952799,DE
 3280952800,3280955707,GB
 3280955708,3280955711,DE
@@ -83915,7 +87607,9 @@
 3280958920,3280958927,DE
 3280958928,3280963375,GB
 3280963376,3280963383,DE
-3280963384,3280991231,GB
+3280963384,3280985279,GB
+3280985280,3280985343,CH
+3280985344,3280991231,GB
 3280991232,3280991743,DE
 3280991744,3280994559,GB
 3280994560,3280994815,RU
@@ -84398,7 +88092,7 @@
 3283977728,3283978751,RU
 3283978752,3283979263,RO
 3283979264,3283979775,IL
-3283979776,3283980287,NO
+3283979776,3283980287,NL
 3283980288,3283980799,RO
 3283980800,3283981823,CH
 3283981824,3283982335,RO
@@ -84485,7 +88179,9 @@
 3284030480,3284030495,FR
 3284030496,3284030615,GB
 3284030616,3284030623,SE
-3284030624,3284030991,GB
+3284030624,3284030775,GB
+3284030776,3284030783,SE
+3284030784,3284030991,GB
 3284030992,3284031007,FR
 3284031008,3284033535,GB
 3284033536,3284041727,RU
@@ -84736,7 +88432,8 @@
 3285120512,3285121023,RO
 3285121024,3285121535,SE
 3285121536,3285122047,CY
-3285122048,3285123071,RU
+3285122048,3285122303,GB
+3285122304,3285123071,RU
 3285123072,3285188607,BE
 3285188608,3285319679,RU
 3285319680,3285320191,HU
@@ -84942,8 +88639,8 @@
 3285913648,3285913655,IE
 3285913656,3285913703,GB
 3285913704,3285913711,FI
-3285913712,3285913863,GB
-3285913872,3285913903,GB
+3285913712,3285913903,GB
+3285913920,3285913951,GB
 3285917696,3285918207,GB
 3285919744,3285921791,QA
 3285922048,3285922303,FR
@@ -84958,6 +88655,7 @@
 3285924992,3285924995,FR
 3285924996,3285924999,CZ
 3285925000,3285925007,RU
+3285925008,3285925015,DE
 3285925164,3285925171,CH
 3285926432,3285926463,CH
 3285926592,3285926623,DE
@@ -84966,23 +88664,26 @@
 3285931528,3285931551,DE
 3285935872,3285936127,GB
 3285936136,3285936147,FR
+3285936152,3285936159,FR
 3285939136,3285939175,GB
 3285939184,3285939191,GB
 3285939744,3285939759,GB
 3285939840,3285939967,GB
 3285940736,3285940767,IT
 3285941248,3285941503,ES
+3285943808,3285944063,CH
 3285949604,3285949607,CH
 3285949856,3285949887,ES
 3285950208,3285950463,IT
 3285951648,3285951679,ES
 3285954048,3285954303,AE
-3285954560,3285954567,GB
+3285954560,3285954567,RO
 3285954568,3285954575,PL
 3285954576,3285954815,GB
+3285961984,3285961991,GB
 3285962752,3285963775,DE
 3285964800,3285964935,DE
-3285965056,3285965567,DE
+3285965056,3285965823,DE
 3285968896,3285970943,GB
 3285975040,3286013695,FR
 3286013696,3286013951,RE
@@ -85106,7 +88807,9 @@
 3286425344,3286425599,IT
 3286425600,3286433791,KW
 3286433792,3286499327,DE
-3286499328,3286502143,HU
+3286499328,3286499583,HU
+3286499584,3286499839,BG
+3286499840,3286502143,HU
 3286502144,3286502399,BG
 3286502400,3286510335,HU
 3286510336,3286510591,BG
@@ -85466,7 +89169,7 @@
 3287662592,3287662847,DE
 3287662848,3287663103,DK
 3287663104,3287663359,LV
-3287663616,3287663871,ES
+3287663616,3287663871,NL
 3287663872,3287664127,PT
 3287664128,3287664383,PL
 3287664384,3287664639,NL
@@ -85676,7 +89379,7 @@
 3288248832,3288249855,GB
 3288249856,3288250367,RO
 3288250368,3288250879,PL
-3288250880,3288251903,RU
+3288251392,3288251903,RU
 3288251904,3288252415,AT
 3288252416,3288260607,NO
 3288260608,3288268799,IT
@@ -85712,6 +89415,7 @@
 3288428544,3288428799,CU
 3288428800,3288429311,IN
 3288429312,3288429567,ZA
+3288429568,3288430079,KE
 3288430080,3288430335,GH
 3288430336,3288430591,EG
 3288430592,3288432639,SC
@@ -85815,7 +89519,8 @@
 3288782592,3288782847,KE
 3288782848,3288783359,NG
 3288783360,3288784127,KE
-3288784128,3288784895,ZA
+3288784128,3288785407,ZA
+3288785408,3288785663,UG
 3288787968,3288788223,EG
 3288788224,3288792831,ZA
 3288792832,3288793087,AO
@@ -85852,9 +89557,10 @@
 3289053952,3289055231,NG
 3289055232,3289071103,ZA
 3289071104,3289071359,SO
-3289071616,3289074431,ZA
+3289071360,3289074431,ZA
 3289074432,3289074687,DZ
 3289074688,3289075711,ZA
+3289075712,3289077759,MW
 3289077760,3289078271,KE
 3289078272,3289078527,GH
 3289078528,3289081599,ZA
@@ -85865,7 +89571,7 @@
 3289089792,3289090047,MZ
 3289090048,3289093631,ZA
 3289093632,3289094143,NG
-3289096192,3289100031,ZA
+3289094144,3289100031,ZA
 3289100032,3289100287,LS
 3289102336,3289103359,NG
 3289103360,3289103615,ZA
@@ -85903,7 +89609,8 @@
 3289213440,3289213951,ZA
 3289213952,3289214207,MA
 3289214208,3289214463,AO
-3289214976,3289215231,NG
+3289214464,3289214719,CD
+3289214720,3289215231,NG
 3289215232,3289217279,ZA
 3289217280,3289217535,KE
 3289217536,3289217791,UG
@@ -85926,7 +89633,7 @@
 3289234176,3289235199,ZA
 3289235200,3289235455,KE
 3289235456,3289237503,GH
-3289237504,3289237759,ZA
+3289237504,3289238015,ZA
 3289238528,3289238783,AO
 3289238784,3289239039,ZA
 3289239040,3289239295,EG
@@ -86046,6 +89753,7 @@
 3291004928,3291021311,NG
 3291021312,3291029503,ZA
 3291029504,3291037695,TZ
+3291037952,3291038207,ZA
 3291045888,3291078655,ZA
 3291078656,3291086847,DZ
 3291086848,3291103231,PR
@@ -86205,11 +89913,24 @@
 3291549184,3291549439,GH
 3291549440,3291549695,UG
 3291549696,3291549951,LR
-3291611136,3291611391,ZA
-3291742208,3292004351,US
+3291549952,3291550207,GA
+3291611136,3291611647,ZA
+3291742208,3291939062,US
+3291939063,3291939063,JP
+3291939064,3292004351,US
 3292004352,3292266495,SC
-3292397568,3292528639,ZA
+3292397568,3292463103,US
+3292463104,3292528639,ZA
+3292528640,3294625791,MA
+3294625792,3295674367,KE
+3295674368,3296722943,MA
+3296722944,3298820095,EG
+3299344384,3299606527,TG
+3299606528,3299868671,GH
+3299868672,3300130815,TN
+3300130816,3300392959,CI
 3300392960,3300655103,TN
+3300655104,3300917247,ET
 3300917248,3300921343,MU
 3300921344,3300925439,BJ
 3300925440,3300929535,MG
@@ -86218,7 +89939,7 @@
 3300941824,3300950015,MU
 3300953088,3300954111,MU
 3300954112,3300958207,NG
-3300966400,3301113855,ZA
+3300958208,3301113855,ZA
 3301113856,3301138431,NG
 3301138432,3301140479,ZA
 3301140480,3301146623,NG
@@ -86277,6 +89998,7 @@
 3301507328,3301507583,MU
 3301507584,3301507839,GH
 3301507840,3301508095,EG
+3301508096,3301508607,GH
 3301508608,3301509119,ZA
 3301510144,3301511167,MW
 3301511168,3301512191,ZW
@@ -86297,7 +90019,7 @@
 3301570560,3301572607,KE
 3301572608,3301605375,EG
 3301605376,3301613567,SD
-3301621760,3301629951,KE
+3301613568,3301629951,KE
 3301632000,3301634047,CM
 3301634048,3301636095,LS
 3301636096,3301637119,ZA
@@ -86360,6 +90082,8 @@
 3302545920,3302546431,TZ
 3302546432,3302546943,SL
 3302546944,3302547455,KE
+3302547456,3302547967,ZW
+3302547968,3302548479,CI
 3302548480,3302548991,GH
 3302548992,3302549503,ZA
 3302549504,3302550015,KE
@@ -86438,7 +90162,9 @@
 3304062976,3304456191,SC
 3304456192,3304521727,NG
 3304521728,3304587263,SC
-3304587264,3304718335,ZA
+3304587264,3304669183,ZA
+3304669184,3304685567,TZ
+3304701952,3304718335,AO
 3304849408,3305111551,ZA
 3305111552,3307208703,TN
 3307208704,3309305855,EG
@@ -86779,7 +90505,10 @@
 3322880000,3322888191,AU
 3322888192,3322945535,US
 3322945536,3322951679,CN
-3322951680,3322970111,US
+3322951680,3322953727,US
+3322953728,3322960895,NL
+3322960896,3322969343,US
+3322969344,3322970111,NL
 3322970112,3323002879,CA
 3323002880,3323003135,US
 3323003392,3323004671,US
@@ -86847,8 +90576,7 @@
 3323391232,3323391487,CA
 3323391488,3323394559,US
 3323394560,3323395071,CL
-3323395072,3323402751,US
-3323403264,3323416399,US
+3323395072,3323416399,US
 3323416400,3323416479,GB
 3323416480,3323437823,US
 3323437824,3323438079,CA
@@ -86936,9 +90664,17 @@
 3324526592,3324579839,US
 3324582912,3324583935,CA
 3324583936,3324587775,CL
-3324587776,3324636671,US
-3324636672,3324637183,NZ
-3324637184,3324642303,US
+3324587776,3324633087,US
+3324633088,3324634111,PE
+3324634112,3324635135,AR
+3324635136,3324635391,SG
+3324635392,3324635647,US
+3324635648,3324635903,HK
+3324635904,3324636159,US
+3324636160,3324637183,NZ
+3324637184,3324638207,DE
+3324638208,3324638719,IN
+3324638720,3324642303,US
 3324642304,3324642559,CA
 3324642560,3324645887,US
 3324645888,3324646143,CA
@@ -87020,7 +90756,8 @@
 3325067264,3325100287,CA
 3325100288,3325100543,US
 3325101056,3325108223,US
-3325110272,3325128703,US
+3325110272,3325122559,US
+3325123072,3325128703,US
 3325128704,3325129215,TH
 3325129216,3325131775,US
 3325131776,3325132031,AU
@@ -87072,7 +90809,9 @@
 3325218308,3325218311,ES
 3325218312,3325218519,CA
 3325218520,3325218523,US
-3325218524,3325220635,CA
+3325218524,3325219807,CA
+3325219808,3325219811,US
+3325219812,3325220635,CA
 3325220636,3325220636,US
 3325220637,3325220863,CA
 3325220864,3325220879,US
@@ -87094,7 +90833,9 @@
 3325226593,3325226593,US
 3325226594,3325226751,CA
 3325226752,3325227007,US
-3325227008,3325229591,CA
+3325227008,3325227575,CA
+3325227576,3325227583,US
+3325227584,3325229591,CA
 3325229592,3325229599,US
 3325229600,3325230319,CA
 3325230320,3325230323,US
@@ -87138,56 +90879,58 @@
 3325307904,3325313023,CA
 3325313024,3325337599,US
 3325337600,3325338111,GB
-3325338112,3325362175,US
+3325338112,3325340671,US
+3325340672,3325340927,CA
+3325340928,3325362175,US
 3325362176,3325427711,CA
 3325427712,3325427967,US
-3325427968,3325430527,MU
+3325427968,3325430527,ZA
 3325430528,3325431551,US
-3325431552,3325433343,MU
-3325433344,3325438975,ZA
-3325438976,3325442559,MU
-3325442560,3325443583,ZA
+3325431552,3325441023,ZA
+3325441024,3325441279,MU
+3325441280,3325443583,ZA
 3325443584,3325444095,US
-3325444096,3325448447,MU
+3325444096,3325444863,ZA
+3325444864,3325445119,MU
+3325445120,3325448447,ZA
 3325448448,3325448959,US
-3325448960,3325450239,MU
+3325448960,3325449215,MU
+3325449216,3325450239,ZA
 3325450240,3325451007,US
-3325451008,3325451263,MU
+3325451008,3325451263,ZA
 3325451264,3325452799,US
-3325452800,3325453311,MU
+3325452800,3325453311,ZA
 3325453312,3325454335,CA
 3325454336,3325463807,US
-3325463808,3325466623,MU
+3325463808,3325464063,ZA
+3325464064,3325465087,NA
+3325465088,3325466623,ZA
 3325466624,3325467135,US
-3325467136,3325469695,MU
+3325467136,3325469695,ZA
 3325469696,3325469951,US
-3325469952,3325470207,MU
+3325469952,3325470207,ZA
 3325470208,3325471231,US
-3325471232,3325471487,MU
+3325471232,3325471487,ZA
 3325471488,3325471999,US
-3325472000,3325474303,MU
+3325472000,3325474303,ZA
 3325474304,3325474559,US
-3325474560,3325478655,MU
-3325478656,3325478911,ZA
+3325474560,3325478911,ZA
 3325478912,3325479423,US
-3325479424,3325479679,MU
-3325479680,3325481471,ZA
-3325481472,3325481727,MU
+3325479424,3325481727,ZA
 3325481728,3325481983,US
 3325481984,3325483007,CA
 3325483008,3325483775,US
-3325483776,3325484287,MU
+3325483776,3325484287,ZA
 3325484288,3325484799,US
 3325484800,3325485055,ZA
 3325485056,3325485311,US
-3325485312,3325486591,MU
+3325485312,3325486591,ZA
 3325486592,3325486847,US
-3325486848,3325487103,ZA
-3325487104,3325487359,MU
+3325486848,3325487359,ZA
 3325487360,3325487615,US
 3325487616,3325487871,ZA
 3325487872,3325490943,US
-3325490944,3325492991,MU
+3325490944,3325492991,ZA
 3325492992,3325497343,US
 3325497344,3325499903,PR
 3325499904,3325505535,US
@@ -87288,8 +91031,8 @@
 3327426560,3327459327,CA
 3327459328,3327723519,US
 3327723520,3327725311,CA
-3327725312,3327788287,US
-3327788288,3327789055,CA
+3327725312,3327788543,US
+3327788544,3327789055,CA
 3327789056,3327806463,US
 3327806464,3327811583,CA
 3327811584,3327885311,US
@@ -87487,7 +91230,8 @@
 3331636480,3331636735,AU
 3331636736,3331637247,US
 3331637248,3331638271,KR
-3331638272,3331647231,US
+3331638272,3331638783,AU
+3331638784,3331647231,US
 3331647232,3331647487,CA
 3331647488,3331649279,US
 3331649280,3331649535,CA
@@ -87663,7 +91407,9 @@
 3333717248,3333717503,FR
 3333717504,3333717759,SG
 3333717760,3333718015,NL
-3333718016,3333781503,US
+3333718016,3333721599,US
+3333721600,3333721855,JP
+3333721856,3333781503,US
 3333781504,3333783551,CA
 3333783552,3333801727,US
 3333801728,3333801983,CA
@@ -87784,7 +91530,9 @@
 3337650432,3337650943,US
 3337650944,3337651199,HK
 3337651200,3337682943,CH
-3337682944,3337892607,US
+3337682944,3337882111,US
+3337882112,3337882623,AU
+3337882624,3337892607,US
 3337892608,3337892671,HK
 3337892672,3337893119,US
 3337893120,3337893375,CN
@@ -87819,7 +91567,9 @@
 3338017792,3338018815,CA
 3338018816,3338021887,US
 3338021888,3338022911,CA
-3338022912,3338069247,US
+3338022912,3338067711,US
+3338067712,3338067967,SG
+3338067968,3338069247,US
 3338069248,3338069759,BB
 3338069760,3338207487,US
 3338207488,3338207743,CA
@@ -87909,7 +91659,9 @@
 3338350592,3338354687,CA
 3338354688,3338359817,US
 3338359818,3338359818,GB
-3338359819,3338371071,US
+3338359819,3338360831,US
+3338360832,3338361087,RU
+3338361088,3338371071,US
 3338371072,3338403839,CA
 3338403840,3338424319,US
 3338424320,3338428415,CA
@@ -87942,8 +91694,7 @@
 3338993664,3339000575,US
 3339000832,3339043327,US
 3339043328,3339043583,CA
-3339043584,3339063039,US
-3339063296,3339075583,US
+3339043584,3339075583,US
 3339075584,3339076863,GB
 3339076864,3339077631,NO
 3339077632,3339077887,SG
@@ -88045,7 +91796,7 @@
 3340098560,3340107775,US
 3340107776,3340369919,CA
 3340369920,3340383743,US
-3340384256,3340386559,US
+3340384256,3340386815,US
 3340387328,3340388351,CA
 3340388352,3340390399,US
 3340390400,3340391423,CA
@@ -88170,7 +91921,9 @@
 3341760512,3341762559,CA
 3341762560,3341777919,US
 3341777920,3341778943,CA
-3341778944,3341796607,US
+3341778944,3341784575,US
+3341784576,3341784831,CH
+3341784832,3341796607,US
 3341796608,3341796863,AU
 3341796864,3341797375,JP
 3341797376,3341807615,US
@@ -88190,7 +91943,9 @@
 3341891072,3341891327,AU
 3341891328,3342139391,US
 3342139392,3342204927,CH
-3342204928,3342487551,US
+3342204928,3342470399,US
+3342470400,3342470655,CA
+3342471168,3342487551,US
 3342487552,3342488575,CA
 3342488576,3342496767,US
 3342496768,3342497791,CA
@@ -88220,7 +91975,9 @@
 3342603264,3342604799,US
 3342604800,3342605311,CA
 3342605312,3342605567,US
-3342605568,3342627839,CA
+3342605568,3342623743,CA
+3342624000,3342624255,US
+3342624256,3342627839,CA
 3342627840,3342628095,US
 3342628096,3342629631,CA
 3342629632,3342629887,US
@@ -88247,6 +92004,7 @@
 3343171584,3343172607,BM
 3343172608,3343319295,US
 3343319296,3343342847,CA
+3343342848,3343343103,PR
 3343343104,3343346175,CA
 3343346176,3343346687,US
 3343346688,3343355391,CA
@@ -88270,7 +92028,9 @@
 3343465472,3343466495,JM
 3343466496,3343649791,US
 3343649792,3343650815,VI
-3343650816,3343858687,US
+3343650816,3343653631,US
+3343653632,3343653695,CA
+3343653696,3343858687,US
 3343858688,3343859199,VG
 3343859200,3344116223,US
 3344116224,3344116735,CA
@@ -88328,8 +92088,7 @@
 3344486400,3344488447,NL
 3344488448,3344534271,US
 3344534272,3344534527,CA
-3344534528,3344536831,US
-3344537088,3344633855,US
+3344534528,3344633855,US
 3344633856,3344637951,CH
 3344637952,3344649215,US
 3344649216,3344650239,PR
@@ -88341,7 +92100,11 @@
 3344660480,3344670719,US
 3344670720,3344671743,GP
 3344671744,3344676863,US
-3344676864,3344677407,CA
+3344676864,3344677247,CA
+3344677248,3344677263,US
+3344677264,3344677279,CA
+3344677280,3344677295,US
+3344677296,3344677407,CA
 3344677408,3344677423,US
 3344677424,3344678911,CA
 3344678912,3344681983,US
@@ -88484,7 +92247,7 @@
 3346529280,3346530303,CA
 3346530304,3346545151,US
 3346545664,3346568703,US
-3346569216,3346591231,US
+3346569216,3346591487,US
 3346591488,3346591743,CA
 3346591744,3346663167,US
 3346663168,3346663423,CA
@@ -88531,7 +92294,8 @@
 3349545984,3349549567,CA
 3349550080,3349551103,CA
 3349551104,3349553663,US
-3349553664,3349605375,CA
+3349553664,3349554687,IN
+3349554688,3349605375,CA
 3349605376,3349605631,US
 3349605632,3349607423,CA
 3349607936,3349608447,CA
@@ -88623,8 +92387,8 @@
 3350823424,3350823935,US
 3350823936,3350834687,CA
 3350834688,3350835199,US
-3350835200,3350836735,CA
-3350836736,3350836991,US
+3350835200,3350836223,CA
+3350836224,3350836991,US
 3350836992,3350837247,CA
 3350837248,3350837759,US
 3350837760,3350843391,CA
@@ -88829,9 +92593,10 @@
 3351869440,3351871487,CA
 3351871488,3351895551,US
 3351895552,3351895807,CA
-3351895808,3351896319,US
-3351896576,3351904255,US
-3351904256,3351927551,CA
+3351895808,3351904255,US
+3351904256,3351912703,CA
+3351912704,3351912959,US
+3351912960,3351927551,CA
 3351927552,3351927807,US
 3351927808,3351933951,CA
 3351933952,3351939071,US
@@ -88875,7 +92640,9 @@
 3353335336,3353335337,NL
 3353335338,3353653503,US
 3353653504,3353653759,GB
-3353653760,3353714431,US
+3353653760,3353688063,US
+3353688064,3353688575,GB
+3353688576,3353714431,US
 3353714432,3353714687,BE
 3353714688,3353722367,US
 3353722368,3353722623,GB
@@ -89211,8 +92978,7 @@
 3356052480,3356053247,BR
 3356053248,3356054015,CL
 3356054016,3356054527,US
-3356054528,3356056575,BR
-3356056832,3356057087,BR
+3356054528,3356057087,BR
 3356057088,3356057343,CO
 3356057344,3356057599,BR
 3356057600,3356057855,EC
@@ -89222,6 +92988,7 @@
 3356061696,3356062463,BR
 3356062464,3356062719,JM
 3356062720,3356063743,CR
+3356063744,3356063999,HN
 3356064000,3356064255,BR
 3356064256,3356064511,CL
 3356064512,3356065791,BR
@@ -89239,9 +93006,11 @@
 3356076288,3356078079,BR
 3356078080,3356078335,EC
 3356078336,3356079359,CL
+3356079360,3356079615,AR
 3356079616,3356080127,MX
 3356080128,3356080383,BR
 3356080384,3356080639,MX
+3356080640,3356080895,BR
 3356080896,3356082431,NI
 3356082432,3356082687,CL
 3356082688,3356082943,AR
@@ -89250,7 +93019,7 @@
 3356084480,3356084735,CL
 3356084736,3356085247,BR
 3356085248,3356085759,CL
-3356085760,3356086015,BR
+3356085760,3356086271,BR
 3356086272,3356086527,AR
 3356086528,3356087295,CR
 3356087296,3356087807,AR
@@ -89280,7 +93049,11 @@
 3356102400,3356102655,PA
 3356102656,3356105727,CL
 3356105728,3356106751,SV
-3356106752,3356109263,BR
+3356106752,3356107975,BR
+3356107976,3356107983,IS
+3356107984,3356109119,BR
+3356109120,3356109135,FR
+3356109136,3356109263,BR
 3356109264,3356109271,DE
 3356109272,3356109495,BR
 3356109496,3356109503,IT
@@ -89293,6 +93066,7 @@
 3356131840,3356132351,PE
 3356132352,3356134143,BR
 3356134144,3356134655,AR
+3356134656,3356134911,PY
 3356134912,3356135167,DO
 3356135168,3356135423,MX
 3356135424,3356135679,BR
@@ -89303,15 +93077,20 @@
 3356137728,3356138239,BR
 3356138240,3356138495,US
 3356138496,3356138751,BR
+3356139008,3356139263,CL
 3356139264,3356139519,BR
 3356139520,3356139775,US
 3356139776,3356140031,AR
 3356140032,3356140287,DO
+3356140288,3356140543,BR
+3356140544,3356140799,CO
 3356140800,3356141311,BM
 3356141312,3356142847,CL
+3356142848,3356143103,GT
 3356143104,3356143615,BR
 3356144128,3356145151,BR
 3356145152,3356145407,CL
+3356145408,3356145663,BR
 3356145664,3356145919,CL
 3356145920,3356146175,BR
 3356146176,3356146431,AR
@@ -89330,6 +93109,7 @@
 3356150528,3356150783,PA
 3356150784,3356151039,AR
 3356151040,3356151295,NI
+3356151296,3356151551,BR
 3356151552,3356151807,AR
 3356151808,3356152063,CL
 3356152064,3356152575,BR
@@ -89342,7 +93122,8 @@
 3356157952,3356158207,CL
 3356158208,3356158463,MX
 3356158464,3356158719,CL
-3356158976,3356159999,CL
+3356158976,3356159743,CL
+3356159744,3356159999,BR
 3356160000,3356160255,MX
 3356160256,3356160511,GT
 3356160512,3356160767,CL
@@ -89417,13 +93198,11 @@
 3356332032,3356334079,CU
 3356334080,3356336127,BO
 3356336128,3356336895,SV
-3356336896,3356337663,HN
-3356337664,3356337919,SV
-3356337920,3356338175,HN
+3356336896,3356338175,HN
 3356338176,3356339967,SV
 3356339968,3356341247,HN
-3356341248,3356341759,SV
-3356341760,3356342271,HN
+3356341248,3356341503,SV
+3356341504,3356342271,HN
 3356342272,3356343039,SV
 3356343040,3356343551,HN
 3356343552,3356344319,SV
@@ -89567,12 +93346,7 @@
 3357442392,3357442395,HN
 3357442396,3357442559,GT
 3357442560,3357442815,NI
-3357442816,3357442847,GT
-3357442848,3357442879,SV
-3357442880,3357442959,GT
-3357442960,3357442967,SV
-3357442968,3357443007,GT
-3357443008,3357443071,SV
+3357442816,3357443071,SV
 3357443072,3357443327,NI
 3357443328,3357443583,GT
 3357443584,3357444351,HN
@@ -89586,7 +93360,9 @@
 3357448448,3357448703,SV
 3357448704,3357448959,GT
 3357448960,3357449487,HN
-3357449488,3357449695,GT
+3357449488,3357449519,GT
+3357449520,3357449527,HN
+3357449528,3357449695,GT
 3357449696,3357449703,HN
 3357449704,3357450751,GT
 3357450752,3357451007,SV
@@ -89664,7 +93440,9 @@
 3357480336,3357480343,CO
 3357480344,3357480359,AR
 3357480360,3357480367,CO
-3357480368,3357480463,AR
+3357480368,3357480407,AR
+3357480408,3357480415,CO
+3357480416,3357480463,AR
 3357480464,3357480479,CO
 3357480480,3357480511,AR
 3357480512,3357480543,CO
@@ -89688,7 +93466,9 @@
 3357559936,3357560063,VE
 3357560064,3357560159,AR
 3357560160,3357560167,VE
-3357560168,3357560199,AR
+3357560168,3357560175,AR
+3357560176,3357560183,VE
+3357560184,3357560199,AR
 3357560200,3357560207,VE
 3357560208,3357560247,AR
 3357560248,3357560255,VE
@@ -89706,6 +93486,7 @@
 3357607168,3357613055,MX
 3357613056,3357613311,AR
 3357613312,3357618943,MX
+3357618944,3357619199,SV
 3357619200,3357623039,MX
 3357623040,3357623295,AR
 3357623296,3357626623,MX
@@ -89839,8 +93620,8 @@
 3358523904,3358524415,AR
 3358524416,3358525951,VE
 3358525952,3358526463,AR
-3358526464,3358529535,VE
-3358529536,3358530303,AR
+3358526464,3358527487,VE
+3358527488,3358530303,AR
 3358530304,3358530943,VE
 3358530944,3358531071,AR
 3358531072,3358531583,VE
@@ -89849,9 +93630,11 @@
 3358532352,3358532863,AR
 3358532864,3358534399,VE
 3358534400,3358534655,AR
-3358534656,3358535167,VE
-3358535168,3358535679,AR
-3358535680,3358539519,VE
+3358534656,3358534911,VE
+3358534912,3358535679,AR
+3358535680,3358536447,VE
+3358536448,3358536703,AR
+3358536704,3358539519,VE
 3358539520,3358539775,AR
 3358539776,3358543871,VE
 3358543872,3358544127,MX
@@ -89862,9 +93645,13 @@
 3358548224,3358548479,AR
 3358548480,3358549759,VE
 3358549760,3358550015,AR
-3358550016,3358553599,VE
+3358550016,3358552063,VE
+3358552064,3358553087,AR
+3358553088,3358553599,VE
 3358553600,3358553855,AR
-3358553856,3358556159,VE
+3358553856,3358554879,VE
+3358554880,3358555135,AR
+3358555136,3358556159,VE
 3358556160,3358558463,AR
 3358558464,3358558591,PY
 3358558592,3358559231,AR
@@ -89874,31 +93661,7 @@
 3358562304,3358563327,PE
 3358563328,3358564095,CO
 3358564096,3358564351,MX
-3358564352,3358564415,AR
-3358564416,3358564447,VE
-3358564448,3358564479,AR
-3358564480,3358564511,VE
-3358564512,3358564575,AR
-3358564576,3358564607,VE
-3358564608,3358564623,AR
-3358564624,3358564719,VE
-3358564720,3358564751,AR
-3358564752,3358564767,VE
-3358564768,3358564783,AR
-3358564784,3358564807,VE
-3358564808,3358564815,AR
-3358564816,3358564839,VE
-3358564840,3358564847,AR
-3358564848,3358565183,VE
-3358565184,3358565247,AR
-3358565248,3358565311,VE
-3358565312,3358565343,AR
-3358565344,3358565375,VE
-3358565376,3358566399,AR
-3358566400,3358566847,VE
-3358566848,3358566879,AR
-3358566880,3358566911,VE
-3358566912,3358566975,AR
+3358564352,3358566975,AR
 3358566976,3358567103,VE
 3358567104,3358567167,AR
 3358567168,3358567231,VE
@@ -90020,7 +93783,9 @@
 3359621120,3359637503,EC
 3359637504,3359789583,MX
 3359789584,3359789599,US
-3359789600,3359797247,MX
+3359789600,3359789823,MX
+3359789824,3359789887,US
+3359789888,3359797247,MX
 3359797248,3359801343,BR
 3359801344,3359899647,MX
 3359899648,3359916031,CL
@@ -90040,34 +93805,24 @@
 3360120832,3360124927,CO
 3360124928,3360125951,VE
 3360125952,3360127999,BR
-3360128000,3360129023,HN
+3360128000,3360128319,HN
+3360128320,3360128327,IT
+3360128328,3360128543,HN
+3360128544,3360128575,US
+3360128576,3360129023,HN
 3360129024,3360145407,VE
 3360145408,3360153599,CL
 3360153600,3360157695,AR
 3360157696,3360159743,VE
 3360159744,3360161791,BQ
-3360161792,3360227327,CL
-3360227328,3360228095,CO
-3360228096,3360228991,CL
-3360228992,3360229007,CO
+3360161792,3360229007,CL
 3360229008,3360229012,US
 3360229013,3360229013,CL
 3360229014,3360229023,US
-3360229024,3360231423,CO
-3360231424,3360231775,CL
+3360229024,3360231775,CL
 3360231776,3360231807,US
-3360231808,3360231935,CL
-3360231936,3360232447,CO
-3360232448,3360232703,CL
-3360232704,3360235263,CO
-3360235264,3360235271,CL
-3360235272,3360235487,CO
-3360235488,3360235495,CL
-3360235496,3360236303,CO
-3360236304,3360236311,CL
-3360236312,3360243711,CO
-3360243712,3360243967,CL
-3360243968,3360244479,CO
+3360231808,3360244223,CL
+3360244224,3360244479,CO
 3360244480,3360244735,CL
 3360244736,3360245759,CO
 3360245760,3360246783,CL
@@ -90143,8 +93898,8 @@
 3360692736,3360692799,AR
 3360692800,3360692863,CO
 3360692864,3360693247,AR
-3360693248,3360693311,CO
-3360693312,3360693343,AR
+3360693248,3360693279,CO
+3360693280,3360693343,AR
 3360693344,3360693407,CO
 3360693408,3360693423,AR
 3360693424,3360693503,CO
@@ -90175,16 +93930,16 @@
 3360701696,3360701951,AR
 3360701952,3360702207,CO
 3360702208,3360705535,AR
-3360705536,3360706047,US
-3360706048,3360707071,AR
+3360705536,3360705791,US
+3360705792,3360707071,AR
 3360707072,3360707327,US
 3360707328,3360707583,AR
 3360707584,3360708095,US
 3360708096,3360708223,AR
 3360708224,3360708351,US
 3360708352,3360708479,AR
-3360708480,3360708735,US
-3360708736,3360708991,AR
+3360708480,3360708863,US
+3360708864,3360708991,AR
 3360708992,3360709247,US
 3360709248,3360709631,AR
 3360709632,3360709759,US
@@ -90202,7 +93957,11 @@
 3360780304,3360780319,BR
 3360780320,3360780399,AR
 3360780400,3360780415,BR
-3360780416,3360781839,AR
+3360780416,3360780991,AR
+3360780992,3360780995,BR
+3360780996,3360781791,AR
+3360781792,3360781795,MX
+3360781796,3360781839,AR
 3360781840,3360781847,DO
 3360781848,3360781943,AR
 3360781944,3360781947,MX
@@ -90228,9 +93987,7 @@
 3361054720,3361058815,NI
 3361058816,3361062911,AR
 3361062912,3361071103,CL
-3361071104,3361072639,CO
-3361072640,3361072767,VE
-3361072768,3361079295,CO
+3361071104,3361079295,CO
 3361079296,3361144831,CL
 3361144832,3361210367,BO
 3361210368,3361275903,DO
@@ -90306,8 +94063,8 @@
 3362447360,3362448895,HN
 3362448896,3362449151,SV
 3362449152,3362449407,HN
-3362449408,3362451199,SV
-3362451200,3362451455,HN
+3362449408,3362450431,SV
+3362450432,3362451455,HN
 3362451456,3362452479,AR
 3362452480,3362452991,BO
 3362452992,3362453247,HN
@@ -90339,7 +94096,9 @@
 3362552144,3362552159,PR
 3362552160,3362553023,AR
 3362553024,3362553039,PR
-3362553040,3362553247,AR
+3362553040,3362553167,AR
+3362553168,3362553183,DO
+3362553184,3362553247,AR
 3362553248,3362553263,CO
 3362553264,3362553855,AR
 3362553856,3362557951,PY
@@ -90468,7 +94227,9 @@
 3367788544,3367796735,BR
 3367796736,3367804927,MX
 3367804928,3367840767,BR
-3367840768,3367841791,HN
+3367840768,3367841023,HN
+3367841024,3367841039,CA
+3367841040,3367841791,HN
 3367841792,3368052991,BR
 3368052992,3368053247,PE
 3368053760,3368086527,BR
@@ -90651,7 +94412,8 @@
 3382677504,3382681599,BR
 3382681600,3382683647,MX
 3382683648,3382685695,CL
-3382685696,3382686719,MX
+3382685696,3382686655,MX
+3382686656,3382686719,US
 3382686720,3382689791,BR
 3382689792,3382695935,MX
 3382695936,3382696959,AR
@@ -90810,7 +94572,10 @@
 3389020672,3389020927,AU
 3389020928,3389021183,PH
 3389021184,3389021695,ID
-3389021952,3389023231,AU
+3389021696,3389021951,BD
+3389021952,3389022463,AU
+3389022464,3389022719,IN
+3389022720,3389023231,AU
 3389023232,3389023743,CN
 3389023744,3389023999,AU
 3389024000,3389024255,IN
@@ -90831,9 +94596,11 @@
 3389029888,3389030399,SG
 3389030400,3389034495,HK
 3389034496,3389035519,PH
+3389035520,3389035775,IN
 3389035776,3389036031,SG
+3389036032,3389036287,AU
 3389036288,3389036543,NZ
-3389037056,3389037567,AU
+3389036800,3389037567,AU
 3389037568,3389038591,NC
 3389038592,3389044735,HK
 3389044736,3389046783,AU
@@ -90888,6 +94655,7 @@
 3389211136,3389211391,IN
 3389211392,3389211647,AU
 3389211648,3389212671,TH
+3389212672,3389213183,IN
 3389213184,3389213439,AU
 3389213952,3389214207,IN
 3389214208,3389214463,SG
@@ -90897,7 +94665,8 @@
 3389222912,3389223935,US
 3389223936,3389226239,IN
 3389226240,3389226495,AU
-3389226496,3389227007,IN
+3389226496,3389226751,SG
+3389226752,3389227007,IN
 3389227008,3389227519,CN
 3389227520,3389228031,PK
 3389228032,3389228799,AU
@@ -90925,6 +94694,7 @@
 3389302016,3389302527,AU
 3389302528,3389302783,PK
 3389302784,3389303039,VN
+3389303040,3389303295,IN
 3389303296,3389303807,ID
 3389303808,3389304063,IN
 3389304064,3389304319,BD
@@ -90951,6 +94721,7 @@
 3389326336,3389326847,TW
 3389326848,3389327359,AU
 3389327360,3389329407,TW
+3389329408,3389333503,PH
 3389333504,3389341695,BD
 3389341696,3389345791,JP
 3389345792,3389349887,TH
@@ -90958,6 +94729,8 @@
 3389358080,3389366271,PK
 3389366272,3389374463,AU
 3389374464,3389378559,MN
+3389378560,3389381631,CN
+3389381632,3389382655,JP
 3389382656,3389390847,TW
 3389390848,3389391359,HK
 3389391360,3389391615,VN
@@ -90970,7 +94743,8 @@
 3389407744,3389408255,CN
 3389408256,3389409279,JP
 3389409280,3389409791,CN
-3389409792,3389412351,AU
+3389409792,3389411327,AU
+3389411584,3389412351,AU
 3389412352,3389412607,NZ
 3389412608,3389412863,PH
 3389412864,3389413119,AU
@@ -91013,6 +94787,8 @@
 3389458432,3389460479,AU
 3389460480,3389464575,JP
 3389464576,3389469695,NZ
+3389469696,3389470719,KH
+3389470720,3389471231,AU
 3389471232,3389471487,IN
 3389471744,3389472767,NZ
 3389472768,3389480959,AU
@@ -91066,6 +94842,7 @@
 3389600512,3389601791,CN
 3389601792,3389602047,AU
 3389602048,3389602815,CN
+3389602816,3389603839,HK
 3389604096,3389604351,AU
 3389604352,3389604863,SG
 3389605120,3389605375,ID
@@ -91088,7 +94865,9 @@
 3389610752,3389611519,IN
 3389611520,3389612031,AU
 3389612032,3389616127,MY
-3389620224,3389640703,IN
+3389616128,3389617151,AU
+3389617152,3389618175,NZ
+3389618176,3389640703,IN
 3389640704,3389644799,JP
 3389644800,3389645823,NZ
 3389645824,3389661183,AU
@@ -91096,6 +94875,7 @@
 3389669376,3389673471,CN
 3389673472,3389677567,AU
 3389677568,3389681663,JP
+3389681664,3389685759,CN
 3389685760,3389718527,AU
 3389718528,3389784063,JP
 3389784064,3389784319,NZ
@@ -91119,6 +94899,7 @@
 3389802496,3389802751,CN
 3389802752,3389803263,TH
 3389803264,3389803519,ID
+3389803520,3389804543,TW
 3389804544,3389805567,IN
 3389805568,3389806079,CN
 3389806080,3389807359,AU
@@ -91149,6 +94930,7 @@
 3389847552,3389849599,NZ
 3389849600,3389915135,JP
 3389915136,3389916159,AU
+3389916160,3389917183,HK
 3389917184,3389919231,SG
 3389919232,3389931519,NZ
 3389931520,3389932031,CN
@@ -91186,6 +94968,7 @@
 3389944832,3389945087,AU
 3389945088,3389945343,TH
 3389945344,3389945855,CN
+3389945856,3389946879,IN
 3389946880,3389947391,CN
 3389947392,3389947647,AU
 3389947648,3389947903,CN
@@ -91208,8 +94991,7 @@
 3389957376,3389957631,KR
 3389957632,3389957887,AU
 3389957888,3389958399,NZ
-3389958400,3389959167,CN
-3389960192,3389960447,CN
+3389958400,3389960447,CN
 3389960448,3389962239,AU
 3389962240,3389962751,CN
 3389962752,3389963007,AU
@@ -91274,6 +95056,8 @@
 3390375936,3390377983,AU
 3390377984,3390382079,NZ
 3390382080,3390384127,LK
+3390384128,3390386175,IN
+3390386176,3390390271,CN
 3390390272,3390398463,NZ
 3390398464,3390406655,MN
 3390406656,3390406911,NZ
@@ -91297,7 +95081,9 @@
 3390414336,3390414847,SG
 3390414848,3390418943,JP
 3390418944,3390423039,MV
-3390423040,3390439423,SG
+3390423040,3390429439,SG
+3390429440,3390429951,HK
+3390429952,3390439423,SG
 3390439424,3390441471,NZ
 3390441472,3390443519,TH
 3390443520,3390447359,NZ
@@ -91321,9 +95107,12 @@
 3390770432,3390770687,AU
 3390770944,3390771199,AU
 3390771200,3390775295,SG
-3390775296,3390801919,NZ
+3390775296,3390790399,NZ
+3390790400,3390790655,AU
+3390790656,3390801919,NZ
 3390801920,3390802431,CN
-3390802432,3390832639,NZ
+3390802432,3390825727,NZ
+3390826496,3390832639,NZ
 3390832640,3390963711,TH
 3390963712,3391094783,KR
 3391094784,3391356927,JP
@@ -91335,7 +95124,9 @@
 3391444480,3391444991,VN
 3391444992,3391453183,NZ
 3391453184,3391453439,ID
-3391453440,3391487999,NZ
+3391453440,3391469055,NZ
+3391469056,3391469311,AU
+3391469312,3391487999,NZ
 3391488000,3391489023,CN
 3391489024,3391490047,NP
 3391490048,3391492095,CN
@@ -91397,7 +95188,9 @@
 3391717888,3391718399,CN
 3391718400,3391718911,IN
 3391718912,3391719423,JP
-3391719424,3391721471,NZ
+3391719424,3391720959,NZ
+3391720960,3391721215,CN
+3391721216,3391721471,NZ
 3391721472,3391721983,AU
 3391721984,3391722239,TW
 3391722240,3391722495,PH
@@ -91406,6 +95199,7 @@
 3391725568,3391733759,TH
 3391733760,3391734015,CN
 3391734016,3391734783,AU
+3391734784,3391736831,CN
 3391736832,3391737855,IN
 3391737856,3391741951,JP
 3391741952,3391746047,IN
@@ -91438,6 +95232,8 @@
 3391843328,3391844351,VN
 3391844352,3391845887,ID
 3391845888,3391846399,PK
+3391846400,3391847423,IN
+3391847424,3391848447,HK
 3391848448,3391852543,AU
 3391852544,3391856639,CN
 3391856640,3391864831,ID
@@ -91451,6 +95247,7 @@
 3391881216,3391885311,TH
 3391885312,3391889407,CN
 3391889408,3391893503,TH
+3391893504,3391894527,CN
 3391894528,3391895551,TH
 3391895552,3391896575,IN
 3391896576,3391897599,NZ
@@ -91535,6 +95332,7 @@
 3392100864,3392101887,ID
 3392101888,3392102143,PK
 3392102144,3392102399,AU
+3392102400,3392106495,CN
 3392106496,3392108543,IN
 3392108544,3392109567,AU
 3392109824,3392110079,PH
@@ -91556,8 +95354,7 @@
 3392130816,3392135167,ID
 3392135168,3392143359,TH
 3392143360,3392208895,JP
-3392208896,3392217343,NZ
-3392217600,3392287743,NZ
+3392208896,3392287743,NZ
 3392287744,3392288767,NP
 3392288768,3392324607,NZ
 3392324608,3392325119,AU
@@ -91576,6 +95373,7 @@
 3392385024,3392389119,BD
 3392389120,3392401407,ID
 3392401408,3392403455,SG
+3392403456,3392404479,IN
 3392404480,3392405503,ID
 3392405504,3392406015,NP
 3392406016,3392406527,IN
@@ -91638,7 +95436,11 @@
 3392487424,3392499711,IN
 3392499712,3392503807,JP
 3392503808,3392505343,HK
+3392505344,3392505855,IN
 3392506880,3392507903,HK
+3392507904,3392508927,KH
+3392508928,3392510975,HK
+3392510976,3392511999,MM
 3392512000,3392516095,BD
 3392516096,3392519167,AU
 3392519168,3392519679,NZ
@@ -91678,6 +95480,8 @@
 3392733184,3392741375,ID
 3392741376,3392765951,PH
 3392765952,3392782335,TH
+3392782336,3392786431,CN
+3392787456,3392789503,CN
 3392789504,3392790527,HK
 3392790528,3392794623,JP
 3392794624,3392798975,CN
@@ -91693,6 +95497,9 @@
 3392823296,3392824319,KH
 3392824320,3392824831,AU
 3392824832,3392825343,IN
+3392825344,3392826367,CN
+3392826368,3392827391,BD
+3392827392,3392828415,CN
 3392828416,3392829439,JP
 3392829440,3392830463,IN
 3392830464,3392830719,ID
@@ -91719,6 +95526,8 @@
 3392861184,3392861439,TH
 3392861440,3392861695,VN
 3392861696,3392862207,AU
+3392862208,3392863231,KI
+3392863232,3392864255,BD
 3392864256,3392864511,CN
 3392864768,3392865279,IN
 3392865280,3392866303,NU
@@ -91779,13 +95588,20 @@
 3392998400,3392999423,AU
 3392999424,3393003519,JP
 3393003520,3393011711,PK
+3393011712,3393012735,PH
+3393012736,3393013759,CN
+3393013760,3393014783,AU
+3393014784,3393015807,CN
+3393015808,3393016831,IN
+3393016832,3393017855,HK
+3393017856,3393018879,CN
+3393018880,3393019903,AU
 3393019904,3393020159,ID
 3393020160,3393020415,MN
 3393020416,3393021439,ID
 3393021440,3393021695,IN
 3393021696,3393021951,HK
 3393021952,3393022463,ID
-3393022464,3393022975,SG
 3393022976,3393023231,PH
 3393023232,3393023487,AU
 3393023488,3393023743,SG
@@ -91796,6 +95612,7 @@
 3393025280,3393025535,IN
 3393025536,3393025791,PH
 3393025792,3393026047,AU
+3393026048,3393026559,IN
 3393026560,3393026815,AU
 3393027072,3393028095,ID
 3393028096,3393060863,AU
@@ -91839,6 +95656,7 @@
 3393260544,3393265663,AU
 3393265664,3393273855,CK
 3393273856,3393282047,AU
+3393282048,3393286143,CN
 3393286144,3393290239,ID
 3393290240,3393298431,IN
 3393298432,3393300479,NZ
@@ -91848,6 +95666,10 @@
 3393314816,3393318911,ID
 3393318912,3393320959,SG
 3393320960,3393363967,HK
+3393363968,3393364991,AU
+3393364992,3393366015,IN
+3393366016,3393367039,CN
+3393367040,3393372159,IN
 3393372160,3393374975,HK
 3393374976,3393375743,SG
 3393375744,3393388543,HK
@@ -91906,6 +95728,7 @@
 3393634304,3393638399,CN
 3393638400,3393650687,JP
 3393650688,3393658879,IN
+3393658880,3393662975,CN
 3393662976,3393675263,JP
 3393675264,3393679359,MY
 3393679360,3393683455,TH
@@ -91922,8 +95745,11 @@
 3393741824,3393742847,US
 3393742848,3393743871,TL
 3393743872,3393744895,US
+3393744896,3393748991,CN
 3393748992,3393765375,AU
 3393765376,3393773567,ID
+3393773568,3393774591,IN
+3393774592,3393775615,HK
 3393775616,3393777663,BD
 3393777664,3393779711,MN
 3393779712,3393780735,IN
@@ -91942,6 +95768,7 @@
 3393830912,3393835007,NZ
 3393835008,3393839103,JP
 3393839104,3393843199,ID
+3393843200,3393847295,CN
 3393847296,3393848319,HK
 3393848320,3393849343,JP
 3393849344,3393851391,CN
@@ -91970,17 +95797,16 @@
 3393863680,3393865727,AU
 3393865728,3393867775,ID
 3393867776,3393871871,CN
-3393871872,3393872383,HK
-3393872384,3393872895,IN
-3393872896,3393874943,HK
+3393871872,3393874943,HK
 3393874944,3393875967,AU
 3393875968,3393876991,HK
 3393876992,3393878015,SG
 3393878016,3393879039,IN
-3393879040,3393879551,JP
-3393879552,3393880063,HK
+3393879040,3393880063,HK
 3393880064,3393896447,AU
 3393896448,3393906687,NZ
+3393906688,3393907711,CN
+3393907712,3393908735,ID
 3393908736,3393910783,BD
 3393910784,3393911807,PH
 3393911808,3393912063,AU
@@ -92007,7 +95833,9 @@
 3394035712,3394039807,MY
 3394039808,3394040575,SG
 3394040576,3394040831,IN
-3394040832,3394041855,SG
+3394040832,3394041087,SG
+3394041088,3394041343,MY
+3394041344,3394041855,SG
 3394041856,3394042879,AU
 3394042880,3394043903,CN
 3394043904,3394060287,HK
@@ -92076,6 +95904,7 @@
 3394330624,3394338815,AU
 3394338816,3394347007,IN
 3394347008,3394351103,PH
+3394351104,3394355199,CN
 3394355200,3394359295,IN
 3394359296,3394363391,AU
 3394363392,3394375839,HK
@@ -92085,6 +95914,8 @@
 3394453504,3394461695,AU
 3394461696,3394465791,SG
 3394465792,3394467839,AU
+3394467840,3394468863,ID
+3394468864,3394469887,BD
 3394469888,3394478079,JP
 3394478080,3394482175,PK
 3394482176,3394484223,AU
@@ -92097,6 +95928,7 @@
 3394502656,3394503679,HK
 3394503680,3394507263,CN
 3394507264,3394507775,JP
+3394507776,3394508287,AU
 3394508544,3394508799,PH
 3394508800,3394510847,CN
 3394510848,3394514943,BD
@@ -92144,6 +95976,10 @@
 3394756608,3394760703,JP
 3394760704,3394764799,ID
 3394764800,3394772991,HK
+3394772992,3394774015,CN
+3394774016,3394775039,HK
+3394775040,3394776063,BD
+3394776064,3394777087,NZ
 3394777088,3394781183,JP
 3394781184,3394789375,MP
 3394789376,3394797567,HK
@@ -92156,7 +95992,7 @@
 3394832384,3394834431,CN
 3394834432,3394834559,HK
 3394834560,3394834575,JP
-3394834576,3394834591,HK
+3394834576,3394834591,SG
 3394834592,3394834599,JP
 3394834600,3394834607,SG
 3394834608,3394834687,HK
@@ -92181,8 +96017,10 @@
 3394838528,3394846719,NZ
 3394846720,3394850815,IN
 3394850816,3394854911,JP
+3394854912,3394855935,CN
 3394855936,3394856959,AU
 3394856960,3394857983,IN
+3394857984,3394859007,CN
 3394859008,3394860031,JP
 3394860032,3394860543,ID
 3394860544,3394860799,IN
@@ -92200,6 +96038,7 @@
 3394895872,3394896895,CN
 3394896896,3394897919,TH
 3394897920,3394899967,JP
+3394899968,3394904063,CN
 3394904064,3394904319,AU
 3394904320,3394904575,IN
 3394904576,3394905087,AU
@@ -92212,7 +96051,7 @@
 3394908160,3394910207,AU
 3394910208,3394912255,NZ
 3394912256,3394920447,PF
-3394924544,3394928639,CN
+3394920448,3394928639,CN
 3394928640,3394936831,PH
 3394936832,3394940927,AU
 3394940928,3394945023,JP
@@ -92297,10 +96136,11 @@
 3395180032,3395180287,JP
 3395180288,3395180543,HK
 3395180544,3395181055,VN
+3395181056,3395181567,TH
 3395181568,3395182591,CN
 3395182592,3395190783,SG
 3395190784,3395198975,JP
-3395198976,3395203071,MY
+3395200768,3395201023,MY
 3395203072,3395215359,JP
 3395215360,3395219455,HK
 3395219456,3395223551,TH
@@ -92332,6 +96172,7 @@
 3397026304,3397026815,TH
 3397026816,3397027071,CN
 3397027072,3397027327,PH
+3397027328,3397027839,IN
 3397027840,3397029887,JP
 3397029888,3397033983,MY
 3397033984,3397038079,ID
@@ -92341,7 +96182,6 @@
 3397070848,3397074943,PH
 3397074944,3397083135,HK
 3397083136,3397087231,CN
-3397087232,3397088255,JP
 3397088256,3397090303,CN
 3397090304,3397091327,TW
 3397091328,3397093375,GU
@@ -92390,8 +96230,7 @@
 3397213184,3397213439,IN
 3397213440,3397213695,AU
 3397213696,3397214207,ID
-3397214208,3397214719,BD
-3397214720,3397215231,AU
+3397214208,3397215231,AU
 3397215232,3397215743,ID
 3397215744,3397216255,PH
 3397216256,3397216767,AU
@@ -92425,7 +96264,9 @@
 3397323776,3397328895,CN
 3397328896,3397330943,ID
 3397330944,3397337087,CN
-3397337088,3397338375,HK
+3397337088,3397338039,HK
+3397338040,3397338043,SG
+3397338044,3397338375,HK
 3397338376,3397338379,JP
 3397338380,3397339647,HK
 3397339648,3397339687,SG
@@ -92472,8 +96313,7 @@
 3397500928,3397501951,BD
 3397501952,3397503999,IN
 3397504000,3397505023,TH
-3397505280,3397505535,IN
-3397506048,3397506559,IN
+3397505024,3397506559,IN
 3397506560,3397506815,AU
 3397506816,3397507071,IN
 3397507072,3397507583,ID
@@ -92525,10 +96365,15 @@
 3397715968,3397718015,HK
 3397718016,3397722111,KR
 3397722112,3397726207,CN
-3397726208,3397730303,IN
+3397726208,3397734399,IN
+3397734400,3397735423,MY
+3397735424,3397736447,MM
+3397736448,3397737471,BD
+3397737472,3397738495,IN
 3397738496,3397742591,MY
 3397742592,3397746687,JP
 3397746688,3397763071,TH
+3397763072,3397771263,PH
 3397771264,3397779455,TW
 3397779456,3397781503,ID
 3397781504,3397783551,BD
@@ -92547,39 +96392,30 @@
 3397794816,3397812223,HK
 3397812224,3397816319,CN
 3397816320,3397832703,IN
+3397832704,3397836799,CN
 3397836800,3397844991,AU
-3397844992,3397845247,JP
-3397845248,3397845503,AU
-3397845504,3397846015,JP
-3397846016,3397846271,AU
-3397846272,3397854719,JP
+3397844992,3397854719,JP
 3397854720,3397854975,NZ
-3397854976,3397857791,JP
-3397857792,3397858559,AU
-3397858560,3397861887,JP
-3397861888,3397862399,PH
-3397862400,3397869823,JP
+3397854976,3397869823,JP
 3397869824,3397870079,AU
-3397870080,3397871871,JP
-3397871872,3397872127,AU
-3397872128,3397878527,JP
-3397878528,3397878783,TW
-3397878784,3397881855,JP
-3397881856,3397882111,HK
-3397882112,3397887999,JP
+3397870080,3397887999,JP
 3397888000,3397889023,IN
-3397889024,3397895423,JP
-3397895424,3397895679,AU
-3397895680,3397910527,JP
+3397889024,3397906111,JP
+3397906112,3397906175,IN
+3397906176,3397910527,JP
 3397910528,3397918719,SG
 3397918720,3397922815,AU
 3397922816,3397926911,CN
+3397926912,3397933055,IN
+3397933056,3397934079,BD
+3397934080,3397935103,PH
 3397935104,3397939199,AU
 3397939200,3397951487,KR
 3397951488,3397959679,SG
 3397959680,3397963775,JP
 3397963776,3397971967,CN
 3397971968,3397974015,LA
+3397974016,3397975039,CN
 3397975040,3397976063,AU
 3397976064,3397984255,ID
 3397984256,3397992447,JP
@@ -92606,13 +96442,16 @@
 3398074368,3398090751,PH
 3398090752,3398098943,AU
 3398098944,3398107135,ID
-3398107136,3398156287,AU
+3398107136,3398107586,AU
+3398107587,3398107587,US
+3398107588,3398156287,AU
 3398156288,3398164479,TH
 3398164480,3398172671,AU
 3398172672,3398180863,JP
 3398180864,3398189055,IN
 3398189056,3398205439,HK
-3398207488,3398208511,IN
+3398205440,3398208511,IN
+3398208512,3398213631,CN
 3398213632,3398221823,TW
 3398221824,3398230015,JP
 3398230016,3398238207,HK
@@ -92638,6 +96477,9 @@
 3398381568,3398383615,AU
 3398383616,3398385663,CN
 3398385664,3398393855,JP
+3398393856,3398394879,IN
+3398394880,3398396927,CN
+3398396928,3398397951,VN
 3398397952,3398402047,PK
 3398402048,3398418431,TH
 3398418432,3398434815,JP
@@ -92681,7 +96523,9 @@
 3398640672,3398640695,SG
 3398640696,3398642431,JP
 3398642432,3398642687,AU
-3398642688,3398646783,JP
+3398642688,3398643679,JP
+3398643680,3398643695,NZ
+3398643696,3398646783,JP
 3398646784,3398647039,AU
 3398647040,3398647807,JP
 3398647808,3398655999,IN
@@ -92692,6 +96536,7 @@
 3398684672,3398688767,JP
 3398688768,3398705151,ID
 3398705152,3398709247,CN
+3398711296,3398713343,IN
 3398713344,3398729727,CN
 3398729728,3398737919,AU
 3398737920,3398742015,SG
@@ -92800,6 +96645,14 @@
 3399514112,3399515135,SG
 3399515136,3399515647,VN
 3399515648,3399516159,AU
+3399516160,3399517183,SG
+3399517184,3399518207,IN
+3399518208,3399519231,ID
+3399519232,3399520255,CN
+3399520256,3399521279,IN
+3399521280,3399522303,NZ
+3399522304,3399523327,HK
+3399523328,3399524351,CN
 3399524352,3399528447,IN
 3399528448,3399532543,CN
 3399532544,3399548927,SG
@@ -92862,6 +96715,8 @@
 3399827456,3399835647,AU
 3399835648,3399839743,CN
 3399839744,3399841791,JP
+3399841792,3399842815,HK
+3399842816,3399843839,AU
 3399843840,3399852031,TW
 3399852032,3399856127,JP
 3399856128,3399860223,CN
@@ -92906,11 +96761,17 @@
 3400004864,3400007679,SG
 3400007680,3400024063,AU
 3400024064,3400028159,MY
-3400030208,3400031231,IN
+3400028160,3400029183,CN
+3400029184,3400031231,IN
 3400031232,3400031743,SG
 3400031744,3400031999,IN
 3400032000,3400032255,HK
 3400032256,3400040447,AU
+3400040448,3400044543,CN
+3400044544,3400045567,IN
+3400045568,3400046591,HK
+3400046592,3400047615,KR
+3400047616,3400048639,IN
 3400048640,3400056831,CN
 3400056832,3400060927,TW
 3400060928,3400062975,HK
@@ -92937,7 +96798,9 @@
 3400171520,3400179711,CN
 3400179712,3400183807,NZ
 3400183808,3400187903,JP
-3400187904,3400189951,AU
+3400187904,3400188927,CA
+3400188928,3400189951,AU
+3400189952,3400191999,IN
 3400192000,3400194047,JP
 3400194048,3400204287,CN
 3400204288,3400212479,ID
@@ -92981,7 +96844,7 @@
 3400351744,3400359935,ID
 3400359936,3400364031,JP
 3400364032,3400365055,CN
-3400365056,3400366079,AU
+3400365056,3400366079,US
 3400366080,3400367103,CN
 3400367104,3400368127,IN
 3400368128,3400388607,AU
@@ -93004,6 +96867,7 @@
 3400431616,3400431871,IN
 3400431872,3400432127,HK
 3400432128,3400432639,IN
+3400432640,3400433663,CN
 3400433664,3400435711,HK
 3400435712,3400435967,BD
 3400435968,3400441855,HK
@@ -93017,6 +96881,8 @@
 3400503296,3400507391,JP
 3400507392,3400515583,MO
 3400515584,3400531967,PH
+3400531968,3400532991,IN
+3400532992,3400534015,MY
 3400534016,3400535039,JP
 3400535040,3400535551,MY
 3400535552,3400536063,AU
@@ -93030,7 +96896,8 @@
 3400608768,3400609791,IN
 3400609792,3400630271,JP
 3400630272,3400646655,IN
-3400646656,3400647679,SG
+3400646656,3400646911,HK
+3400646912,3400647679,SG
 3400647680,3400648191,AU
 3400648192,3400648677,SG
 3400648678,3400648678,HK
@@ -93051,6 +96918,7 @@
 3400736768,3400744959,JP
 3400744960,3400753151,IN
 3400753152,3400761343,MY
+3400769536,3400773631,CN
 3400773632,3400775679,KR
 3400775680,3400777727,ID
 3400777728,3400790015,JP
@@ -93066,6 +96934,13 @@
 3400847360,3400849407,CN
 3400849408,3400851455,MN
 3400851456,3400859647,AU
+3400859648,3400860671,HK
+3400860672,3400861695,IN
+3400861696,3400862719,CN
+3400862720,3400864767,BD
+3400864768,3400865791,AU
+3400865792,3400866815,HK
+3400866816,3400867839,CN
 3400867840,3400884223,AU
 3400884224,3400888319,JP
 3400888320,3400892415,CN
@@ -93616,7 +97491,8 @@
 3406835968,3406836735,CN
 3406836736,3406838271,AU
 3406838272,3406838527,CN
-3406838528,3406857471,AU
+3406838528,3406839551,AU
+3406839808,3406857471,AU
 3406857472,3406857727,CN
 3406857728,3406864639,AU
 3406864640,3406865151,CN
@@ -93876,7 +97752,8 @@
 3407240192,3407241215,CN
 3407241216,3407241983,AU
 3407241984,3407242239,CN
-3407242240,3407243775,AU
+3407242240,3407243263,AU
+3407243264,3407243775,HK
 3407243776,3407244031,CN
 3407244032,3407244287,AU
 3407244800,3407247871,AU
@@ -93905,7 +97782,8 @@
 3407282176,3407282431,CN
 3407282688,3407294207,AU
 3407294208,3407294463,CN
-3407294464,3407297791,AU
+3407294464,3407295487,AU
+3407295744,3407297791,AU
 3407297792,3407298559,CN
 3407298560,3407300863,AU
 3407300864,3407301119,CN
@@ -93950,7 +97828,8 @@
 3407352320,3407352575,CN
 3407352576,3407354623,AU
 3407354624,3407354879,CN
-3407354880,3407358719,AU
+3407354880,3407357439,AU
+3407357696,3407358719,AU
 3407358720,3407358975,CN
 3407358976,3407360511,AU
 3407360512,3407361023,ID
@@ -94102,7 +97981,9 @@
 3407523328,3407523583,AU
 3407523584,3407523839,JP
 3407523840,3407524095,CN
-3407524096,3407526143,AU
+3407524096,3407524607,AU
+3407524608,3407524863,NZ
+3407524864,3407526143,AU
 3407526144,3407526399,CN
 3407526400,3407530495,AU
 3407530496,3407531007,CN
@@ -94160,7 +98041,9 @@
 3407595520,3407595775,CN
 3407595776,3407596031,AU
 3407596032,3407596287,CN
-3407596288,3407603967,AU
+3407596288,3407602943,AU
+3407602944,3407603199,JP
+3407603200,3407603967,AU
 3407603968,3407604223,CN
 3407604224,3407604479,AU
 3407604480,3407604735,IN
@@ -94168,7 +98051,9 @@
 3407606016,3407606271,CN
 3407606272,3407608319,AU
 3407608320,3407608575,CN
-3407608576,3407612415,AU
+3407608576,3407608715,AU
+3407608716,3407608736,JP
+3407608737,3407612415,AU
 3407612416,3407612671,CN
 3407612672,3407612927,AU
 3407612928,3407613183,CN
@@ -94288,7 +98173,7 @@
 3407748608,3407750655,AU
 3407750656,3407751167,SG
 3407751168,3407753215,AU
-3407753216,3407753727,SG
+3407753216,3407753727,HK
 3407753728,3407757823,AU
 3407757824,3407758079,CN
 3407758080,3407761663,AU
@@ -94301,7 +98186,8 @@
 3407771904,3407772159,CN
 3407772160,3407772415,AU
 3407772416,3407772671,CN
-3407772672,3407779839,AU
+3407772672,3407773439,AU
+3407773696,3407779839,AU
 3407779840,3407780095,CN
 3407780096,3407780863,AU
 3407780864,3407781119,CN
@@ -94353,7 +98239,9 @@
 3407826944,3407827199,CN
 3407827200,3407828223,AU
 3407828224,3407828479,CN
-3407828480,3407831295,AU
+3407828480,3407828991,AU
+3407828992,3407829503,US
+3407829504,3407831295,AU
 3407831296,3407831551,CN
 3407831552,3407833343,AU
 3407833344,3407833855,CN
@@ -94427,7 +98315,7 @@
 3407910912,3407911167,CN
 3407911168,3407919615,AU
 3407919616,3407920127,CN
-3407920128,3407921151,AU
+3407920384,3407921151,AU
 3407921152,3407921407,CN
 3407921408,3407922175,AU
 3407922176,3407922431,CN
@@ -94551,7 +98439,8 @@
 3408055296,3408056319,CN
 3408056320,3408062463,AU
 3408062464,3408062719,CN
-3408062720,3408064511,AU
+3408062720,3408063999,AU
+3408064256,3408064511,AU
 3408064512,3408064767,CN
 3408065024,3408065279,CN
 3408065280,3408065791,AU
@@ -94571,7 +98460,7 @@
 3409387008,3409387263,CN
 3409387264,3409396479,AU
 3409396480,3409396735,PH
-3409396736,3409403135,AU
+3409396992,3409403135,AU
 3409403136,3409403391,CN
 3409403392,3409405183,AU
 3409405184,3409405439,CN
@@ -94585,7 +98474,9 @@
 3409412096,3409412607,CN
 3409412608,3409416703,AU
 3409416704,3409417215,CN
-3409417216,3409420287,AU
+3409417216,3409418495,AU
+3409418496,3409418751,PL
+3409418752,3409420287,AU
 3409420288,3409420543,IN
 3409420544,3409423615,AU
 3409423616,3409423871,IN
@@ -94762,6 +98653,14 @@
 3410799616,3410800639,SG
 3410800640,3410804735,IN
 3410804736,3410808831,PH
+3410808832,3410811903,CN
+3410811904,3410812927,BD
+3410812928,3410813951,AU
+3410813952,3410814975,IN
+3410814976,3410817023,HK
+3410817024,3410819071,CN
+3410819072,3410820095,IN
+3410820096,3410821119,LA
 3410821120,3410853887,TW
 3410853888,3410862079,HK
 3410862080,3410866175,AU
@@ -94783,6 +98682,10 @@
 3410903040,3410911231,HK
 3410911232,3410915327,TH
 3410915328,3410919423,ID
+3410923520,3410924543,BD
+3410924544,3410925567,SG
+3410925568,3410926591,MH
+3410926592,3410927615,CN
 3410927616,3410931711,NP
 3410931712,3410935807,TW
 3410935808,3410939903,MY
@@ -94835,16 +98738,21 @@
 3411128320,3411130367,HK
 3411130368,3411132415,ID
 3411132416,3411144703,PK
+3411144704,3411145727,IN
+3411145728,3411146751,CN
 3411146752,3411147775,ID
 3411147776,3411148799,HK
 3411148800,3411149311,CN
 3411149312,3411149823,MV
 3411149824,3411150847,IN
 3411150848,3411154943,HK
+3411154944,3411155967,AU
+3411155968,3411156991,HK
 3411156992,3411161087,PH
 3411161088,3411165183,PK
 3411165184,3411173375,MY
 3411173376,3411177471,AU
+3411177472,3411181567,CN
 3411181568,3411189759,JP
 3411189760,3411197951,AU
 3411197952,3411202047,BD
@@ -94852,11 +98760,13 @@
 3411204608,3411204863,IN
 3411204864,3411205631,KR
 3411205632,3411206143,HK
+3411206144,3411210239,CN
 3411210240,3411212287,KR
 3411212288,3411213311,IN
 3411213312,3411214335,HK
 3411214336,3411215359,CN
 3411215360,3411216383,AU
+3411216384,3411218431,CN
 3411218432,3411220479,PG
 3411220480,3411226623,ID
 3411226624,3411228671,IO
@@ -94933,7 +98843,7 @@
 3411673088,3411674111,CN
 3411674112,3411674623,IN
 3411674624,3411675135,HK
-3411675136,3411676159,CN
+3411675136,3411677183,CN
 3411677184,3411679231,JP
 3411679232,3411681279,AU
 3411681280,3411689471,KR
@@ -94978,6 +98888,12 @@
 3412004864,3412017151,JP
 3412017152,3412025343,SG
 3412025344,3412049919,CN
+3412049920,3412050943,HK
+3412050944,3412051967,KH
+3412051968,3412055039,CN
+3412055040,3412056063,HK
+3412056064,3412057087,IN
+3412057088,3412058111,BD
 3412058112,3412066303,CN
 3412066304,3412213759,NZ
 3412213760,3412221951,AU
@@ -95082,6 +98998,7 @@
 3413106688,3413110783,PH
 3413110784,3413112831,JP
 3413112832,3413113855,IN
+3413113856,3413114879,HK
 3413114880,3413133311,JP
 3413133312,3413135359,BD
 3413135360,3413139455,HK
@@ -95096,6 +99013,12 @@
 3413245952,3413251071,MY
 3413251072,3413262335,JP
 3413262336,3413263359,PH
+3413263360,3413264383,IN
+3413264384,3413264639,ID
+3413264640,3413264895,AU
+3413264896,3413265407,SG
+3413265408,3413266431,AU
+3413266432,3413270527,CN
 3413270528,3413278719,TH
 3413278720,3413295103,NZ
 3413295104,3413303295,JP
@@ -95167,7 +99090,15 @@
 3413606400,3413639167,CN
 3413639168,3413704703,SG
 3413704704,3413737471,MY
-3413737472,3413753855,TH
+3413737472,3413741567,SG
+3413741568,3413742591,TH
+3413742592,3413744127,SG
+3413744128,3413748479,TH
+3413748480,3413749503,SG
+3413749504,3413750271,TH
+3413750272,3413751039,SG
+3413751040,3413753087,TH
+3413753088,3413753855,JP
 3413753856,3413762047,AU
 3413762048,3413770239,TW
 3413770240,3413786623,IN
@@ -95262,7 +99193,12 @@
 3415080960,3415082239,MY
 3415082240,3415083007,SG
 3415083008,3415083519,AU
-3415083520,3415088127,SG
+3415083520,3415084031,SG
+3415084032,3415084543,CN
+3415084544,3415085055,US
+3415085056,3415087615,SG
+3415087616,3415087871,US
+3415087872,3415088127,SG
 3415088128,3415089151,HK
 3415089152,3415097343,MY
 3415097344,3415103487,ID
@@ -95310,6 +99246,7 @@
 3415474176,3415495679,CN
 3415495680,3415496191,ID
 3415496192,3415496703,CN
+3415496704,3415497727,BD
 3415497728,3415497983,TW
 3415497984,3415498751,AU
 3415498752,3415506943,JP
@@ -95319,7 +99256,19 @@
 3415564288,3415568383,JP
 3415568384,3415572479,KR
 3415572480,3415605247,SG
-3415605248,3415752703,TH
+3415605248,3415736319,TH
+3415736320,3415737599,SG
+3415737600,3415737855,TH
+3415737856,3415738879,SG
+3415738880,3415739135,TH
+3415739136,3415740159,SG
+3415740160,3415740415,TH
+3415740416,3415741695,SG
+3415741696,3415747071,TH
+3415747072,3415747839,SG
+3415747840,3415748351,TH
+3415748352,3415749375,SG
+3415749376,3415752703,TH
 3415752704,3415760895,CN
 3415760896,3415769087,NZ
 3415769088,3415777279,CN
@@ -95329,12 +99278,14 @@
 3415801856,3415802879,CN
 3415802880,3415803391,HK
 3415803392,3415805951,PH
-3415808000,3415810047,ID
+3415805952,3415806975,AU
+3415806976,3415810047,ID
 3415810048,3415814399,IN
 3415814400,3415814655,ID
 3415814656,3415815167,TH
 3415815168,3415816191,IN
 3415816192,3415817215,JP
+3415817216,3415818239,MY
 3415818240,3415822335,JP
 3415822336,3415826431,MY
 3415826432,3415834623,ID
@@ -95369,6 +99320,7 @@
 3416293376,3416293631,ID
 3416293632,3416293887,CN
 3416293888,3416294399,PH
+3416294400,3416295423,VN
 3416295424,3416295679,IN
 3416295680,3416295935,TH
 3416295936,3416296447,IN
@@ -95381,7 +99333,9 @@
 3416327168,3416328191,HK
 3416328192,3416330239,AU
 3416330240,3416334335,ID
-3416334336,3416342527,SG
+3416334336,3416339455,SG
+3416339456,3416339711,IN
+3416339712,3416342527,SG
 3416342528,3416371199,AU
 3416371200,3416371711,PH
 3416371712,3416371967,VN
@@ -95397,9 +99351,7 @@
 3416391680,3416457215,VN
 3416457216,3416474583,JP
 3416474584,3416474599,AU
-3416474600,3416474639,JP
-3416474640,3416474647,NZ
-3416474648,3416475391,JP
+3416474600,3416475391,JP
 3416475392,3416475647,NZ
 3416475648,3416482047,JP
 3416482048,3416482055,SG
@@ -95425,7 +99377,12 @@
 3416709632,3416710143,AU
 3416710144,3416711167,HK
 3416711168,3416719359,AU
-3416719360,3416723455,PH
+3416719360,3416721407,PH
+3416721408,3416723455,VN
+3416723456,3416724479,KH
+3416724480,3416725503,HK
+3416725504,3416726527,AU
+3416726528,3416727551,CN
 3416727552,3416735743,JP
 3416735744,3416752127,PH
 3416752128,3416784895,NZ
@@ -95554,6 +99511,7 @@
 3417338880,3417339903,PH
 3417339904,3417340415,AU
 3417340416,3417340927,NZ
+3417340928,3417341951,HK
 3417341952,3417346047,KH
 3417346048,3417348095,MY
 3417348096,3417348351,AU
@@ -95626,6 +99584,8 @@
 3418208256,3418210303,LK
 3418210304,3418218495,CN
 3418218496,3418220543,BD
+3418220544,3418223615,CN
+3418223616,3418226687,IN
 3418226688,3418227711,BD
 3418227712,3418228735,KR
 3418228736,3418230783,BD
@@ -95633,6 +99593,7 @@
 3418232832,3418233343,AU
 3418233344,3418233855,KR
 3418233856,3418234879,JP
+3418234880,3418235903,BD
 3418235904,3418236415,ID
 3418236416,3418236927,HK
 3418236928,3418241023,ID
@@ -95652,7 +99613,9 @@
 3418282240,3418282495,AU
 3418282496,3418283519,PH
 3418283520,3418284031,AU
-3418284032,3418286079,SG
+3418284032,3418285567,SG
+3418285568,3418285823,JP
+3418285824,3418286079,SG
 3418286080,3418287103,AU
 3418287104,3418288127,SG
 3418288128,3418290175,ID
@@ -95667,13 +99630,16 @@
 3418294272,3418296319,VN
 3418296320,3418297343,HK
 3418297344,3418298367,CN
-3418298368,3418299391,HK
+3418298368,3418298879,HK
+3418298880,3418299135,CN
+3418299136,3418299391,HK
 3418299392,3418300415,CN
 3418300416,3418300927,BD
 3418300928,3418301439,IN
 3418301440,3418302463,AU
 3418302464,3418304511,ID
 3418304512,3418306559,VN
+3418306560,3418308607,IN
 3418308608,3418324991,CN
 3418324992,3418326015,VU
 3418326016,3418326271,AU
@@ -95731,6 +99697,8 @@
 3418587136,3418621951,CN
 3418621952,3418623999,HK
 3418624000,3418626047,JP
+3418626048,3418627071,VN
+3418627072,3418628095,CN
 3418628096,3418636287,AU
 3418636288,3418642943,JP
 3418642944,3418643199,ID
@@ -95825,6 +99793,7 @@
 3419668480,3419672575,CN
 3419672576,3419674623,AU
 3419674624,3419675647,IN
+3419675648,3419676671,PK
 3419676672,3419684863,JP
 3419684864,3419688959,IN
 3419688960,3419693055,CN
@@ -95878,6 +99847,7 @@
 3420034048,3420035071,AU
 3420036096,3420037119,JP
 3420037120,3420037631,AU
+3420038144,3420039167,CN
 3420039168,3420040191,KH
 3420040192,3420040703,ID
 3420040704,3420040959,IN
@@ -96085,7 +100055,9 @@
 3426482688,3426484223,CA
 3426484224,3426617855,US
 3426617856,3426618367,CA
-3426618368,3426666495,US
+3426618368,3426646527,US
+3426646528,3426646783,GB
+3426646784,3426666495,US
 3426666752,3426717695,US
 3426719744,3426729471,US
 3426729472,3426729983,CA
@@ -96516,8 +100488,7 @@
 3432585216,3432585727,MX
 3432585728,3432606463,US
 3432606464,3432606719,GB
-3432606720,3432610303,US
-3432610560,3432613631,US
+3432606720,3432613631,US
 3432613632,3432613887,CA
 3432613888,3432634111,US
 3432634112,3432634367,CA
@@ -96583,7 +100554,9 @@
 3435271680,3435507711,US
 3435507712,3435511807,CA
 3435511808,3436249343,US
-3436249344,3436255743,CA
+3436249344,3436252415,CA
+3436252416,3436253183,US
+3436253184,3436255743,CA
 3436255744,3436256255,US
 3436256256,3436278271,CA
 3436278272,3436278527,US
@@ -96788,7 +100761,9 @@
 3448987648,3448989695,IN
 3448989696,3448990719,HK
 3448990720,3448991743,IN
-3448991744,3449098751,US
+3448991744,3449098239,US
+3449098240,3449098495,GB
+3449098496,3449098751,US
 3449098752,3449099263,DE
 3449099264,3449100799,US
 3449100800,3449101311,AU
@@ -97171,6 +101146,7 @@
 3452895488,3452902399,CA
 3452902400,3452902655,US
 3452902656,3452912127,CA
+3452912128,3452912383,US
 3452912384,3452914175,CA
 3452914176,3452914431,US
 3452914432,3452919551,CA
@@ -97262,7 +101238,9 @@
 3453408256,3453409023,BB
 3453409024,3453409535,KN
 3453409536,3453411327,BB
-3453411328,3453552127,US
+3453411328,3453419519,US
+3453419520,3453427711,MO
+3453427712,3453552127,US
 3453552128,3453552383,GB
 3453552384,3453552639,US
 3453552640,3453552895,GB
@@ -97478,7 +101456,15 @@
 3455713280,3455778815,CA
 3455778816,3455871999,US
 3455872000,3455872255,ZM
-3455872256,3456303103,US
+3455872256,3455903967,US
+3455903968,3455903983,HK
+3455903984,3455909887,US
+3455909888,3455962591,SG
+3455962592,3455962599,US
+3455962600,3455963967,SG
+3455963968,3455963975,US
+3455963976,3455975423,SG
+3455975424,3456303103,US
 3456303104,3456311295,JP
 3456311296,3456360447,US
 3456360448,3456364543,BG
@@ -97665,13 +101651,13 @@
 3459596288,3459615743,US
 3459615744,3459615999,CA
 3459616000,3459616255,DM
-3459616512,3459616767,US
+3459616256,3459616767,US
 3459616768,3459617999,CA
 3459618000,3459618000,ID
 3459618001,3459620863,CA
-3459620864,3459622911,US
+3459620864,3459624959,US
 3459624960,3459629055,BM
-3459629056,3459631103,US
+3459629056,3459631359,US
 3459633152,3459686399,US
 3459686400,3459688479,NL
 3459688480,3459689215,US
@@ -98037,8 +102023,7 @@
 3464421632,3464421887,CA
 3464421888,3464426495,US
 3464426496,3464426751,GD
-3464426752,3464428287,US
-3464428800,3464429311,US
+3464426752,3464429311,US
 3464429312,3464429567,CA
 3464429568,3464548351,US
 3464548352,3464548607,AG
@@ -98051,15 +102036,17 @@
 3464550144,3464550399,LC
 3464550400,3464626175,US
 3464626176,3464626687,CA
-3464626688,3464627711,US
+3464626688,3464627967,US
 3464627968,3464628735,CA
 3464628736,3464628991,US
 3464628992,3464630271,CA
 3464630272,3464631295,US
 3464631296,3464639487,CA
+3464639488,3464639743,US
 3464639744,3464642047,CA
 3464642048,3464642559,US
 3464642560,3464642815,CA
+3464642816,3464643071,US
 3464643072,3464647935,CA
 3464647936,3464648191,US
 3464648192,3464648703,CA
@@ -98069,6 +102056,7 @@
 3464664320,3464684543,CA
 3464684544,3464684799,BL
 3464684800,3464688383,CA
+3464688384,3464688639,US
 3464688640,3464691711,CA
 3464691712,3464740863,US
 3464740864,3464744959,PH
@@ -98088,7 +102076,9 @@
 3465412608,3465412863,HK
 3465412864,3465462783,US
 3465462784,3465463039,GB
-3465463040,3465468159,US
+3465463040,3465466495,US
+3465466496,3465466527,GB
+3465466528,3465468159,US
 3465468160,3465468415,GB
 3465468416,3465510911,US
 3465510912,3465543679,JP
@@ -98340,7 +102330,9 @@
 3470794752,3470802943,PA
 3470802944,3470884863,US
 3470884864,3470885887,HK
-3470885888,3471057919,US
+3470885888,3470886655,US
+3470886656,3470886911,GB
+3470886912,3471057919,US
 3471057920,3471058943,VE
 3471058944,3471059455,US
 3471059456,3471060223,ES
@@ -98359,7 +102351,9 @@
 3471558656,3471560703,CA
 3471560704,3471570943,US
 3471570944,3471572991,CA
-3471572992,3472375807,US
+3471572992,3472249343,US
+3472249344,3472249599,CA
+3472249600,3472375807,US
 3472375808,3472392191,PR
 3472392192,3472408575,CA
 3472408576,3472721919,US
@@ -98437,7 +102431,9 @@
 3475916544,3475916799,HK
 3475916800,3475918287,US
 3475918288,3475918303,HK
-3475918304,3475996671,US
+3475918304,3475931135,US
+3475931136,3475939327,HK
+3475939328,3475996671,US
 3475996672,3476029439,CA
 3476029440,3476111359,US
 3476111360,3476111871,CA
@@ -98453,7 +102449,9 @@
 3478114304,3478118399,PE
 3478118400,3478192127,US
 3478192128,3478257663,CA
-3478257664,3478274823,US
+3478257664,3478261775,US
+3478261776,3478261791,SG
+3478261792,3478274823,US
 3478274824,3478274831,GB
 3478274832,3478275983,US
 3478275984,3478275999,GB
@@ -98611,8 +102609,8 @@
 3481934848,3481958271,US
 3481958272,3481958399,NL
 3481958400,3481959020,US
-3481959021,3481959021,GB
-3481959022,3481964575,US
+3481959021,3481959022,GB
+3481959023,3481964575,US
 3481964576,3481964579,IE
 3481964580,3481993791,US
 3481993792,3481993799,CA
@@ -98752,9 +102750,7 @@
 3484322048,3484325887,US
 3484326912,3484327423,US
 3484327424,3484327935,CA
-3484327936,3484341247,US
-3484341248,3484342271,VG
-3484342272,3484438527,US
+3484327936,3484438527,US
 3484438528,3484438783,ZM
 3484438784,3484439039,US
 3484439040,3484439295,GB
@@ -98852,7 +102848,11 @@
 3485597696,3485695999,CA
 3485696000,3485959423,US
 3485959424,3485960191,CA
-3485960192,3486023679,US
+3485960192,3485960703,US
+3485960704,3485960959,CA
+3485960960,3485970431,US
+3485970432,3485970687,CA
+3485970688,3486023679,US
 3486023680,3486031871,CA
 3486031872,3486269439,US
 3486269440,3486285823,JM
@@ -99184,7 +103184,9 @@
 3491651584,3491659775,VI
 3491659776,3491743743,US
 3491743744,3491745791,CO
-3491745792,3491969023,US
+3491745792,3491943447,US
+3491943448,3491943455,BR
+3491943456,3491969023,US
 3491969024,3491970047,PR
 3491970048,3492151295,US
 3492151296,3492167679,CA
@@ -99229,7 +103231,9 @@
 3492968448,3492969471,US
 3492969472,3492969727,VI
 3492969728,3492998911,US
-3492998912,3492999167,GB
+3492998912,3492999136,GB
+3492999137,3492999137,US
+3492999138,3492999167,GB
 3492999168,3493009151,US
 3493009152,3493009205,MX
 3493009206,3493009206,US
@@ -99258,7 +103262,8 @@
 3493901024,3493901031,HK
 3493901032,3493901311,US
 3493901312,3493901567,AE
-3493901568,3493936127,US
+3493901568,3493929983,US
+3493931008,3493936127,US
 3493936128,3493937151,CA
 3493937152,3493939199,US
 3493939200,3493941247,CA
@@ -99335,7 +103340,9 @@
 3494359040,3494360063,CA
 3494360064,3494361087,US
 3494361088,3494362111,CA
-3494362112,3494380543,US
+3494362112,3494368255,US
+3494368256,3494369279,CN
+3494369280,3494380543,US
 3494380544,3494381567,CA
 3494381568,3494386687,US
 3494387712,3494402559,US
@@ -99467,11 +103474,9 @@
 3495193600,3495215103,US
 3495215104,3495217151,VI
 3495217152,3495219199,VC
-3495219200,3495225343,US
-3495225600,3495225855,US
+3495219200,3495225855,US
 3495225856,3495226111,GB
-3495226624,3495226879,US
-3495227392,3495251967,US
+3495226112,3495251967,US
 3495251968,3495254015,CA
 3495254016,3495260159,US
 3495260160,3495261183,CA
@@ -99494,7 +103499,9 @@
 3495375872,3495376895,CA
 3495376896,3495399423,US
 3495399424,3495400447,KN
-3495400448,3495406335,US
+3495400448,3495405055,US
+3495405056,3495405567,HK
+3495405568,3495406335,US
 3495406336,3495406591,LB
 3495406592,3495412735,US
 3495412736,3495413759,CA
@@ -99532,8 +103539,7 @@
 3495618560,3495619583,CA
 3495619584,3495620607,US
 3495620608,3495622655,CA
-3495622656,3495647743,US
-3495648000,3495651327,US
+3495622656,3495651327,US
 3495653376,3495654143,US
 3495654144,3495654399,CA
 3495654400,3495673855,US
@@ -100170,7 +104176,8 @@
 3510269952,3510270719,LY
 3510270720,3510270975,SY
 3510270976,3510284287,US
-3510284288,3510288383,SG
+3510284288,3510286335,SG
+3510286336,3510288383,HK
 3510288384,3510321151,US
 3510321152,3510321663,VG
 3510321664,3510321919,AG
@@ -100370,7 +104377,11 @@
 3512594176,3512594431,MY
 3512594432,3512647679,US
 3512647680,3512655871,TT
-3512655872,3512844287,US
+3512655872,3512679511,US
+3512679512,3512679515,HK
+3512679516,3512680339,US
+3512680340,3512680340,SG
+3512680341,3512844287,US
 3512844288,3512852479,CA
 3512852480,3512931583,US
 3512931584,3512931839,CA
@@ -100679,7 +104690,9 @@
 3518472192,3518762495,US
 3518762496,3518762751,GB
 3518762752,3518765311,US
-3518765312,3518765567,CA
+3518765312,3518765343,CA
+3518765344,3518765351,US
+3518765352,3518765567,CA
 3518765568,3518912511,US
 3518912512,3518912767,IN
 3518912768,3518918143,US
@@ -100844,7 +104857,8 @@
 3523297280,3523317759,PH
 3523317760,3523330047,JP
 3523330048,3523338239,AU
-3523338240,3523340287,MY
+3523338240,3523339775,MY
+3523339776,3523340287,HK
 3523340288,3523341311,AU
 3523341312,3523342335,JP
 3523342336,3523346431,BD
@@ -100891,14 +104905,69 @@
 3523674112,3523682303,FJ
 3523682304,3523686399,NZ
 3523686400,3523688447,AU
+3523688448,3523690495,CN
 3523690496,3523698687,IN
-3523698688,3523700735,JP
+3523698688,3523698863,HK
+3523698864,3523698879,JP
+3523698880,3523698943,HK
+3523698944,3523698975,JP
+3523698976,3523699007,HK
+3523699008,3523699071,JP
+3523699072,3523699199,HK
+3523699200,3523699711,US
+3523699712,3523700223,JP
+3523700224,3523700287,US
+3523700288,3523700351,JP
+3523700352,3523700415,US
+3523700416,3523700671,JP
+3523700672,3523700679,HK
+3523700680,3523700735,JP
 3523700736,3523701759,HK
-3523701760,3523707903,JP
+3523701760,3523702783,JP
+3523702784,3523702799,SG
+3523702800,3523702807,SN
+3523702808,3523702847,SG
+3523702848,3523702871,JP
+3523702872,3523702911,SG
+3523702912,3523703039,JP
+3523703040,3523703103,SG
+3523703104,3523704703,JP
+3523704704,3523704719,SG
+3523704720,3523704751,JP
+3523704752,3523704783,SG
+3523704784,3523704791,JP
+3523704792,3523704831,SG
+3523704832,3523704839,HK
+3523704840,3523706879,JP
+3523706880,3523707039,AU
+3523707040,3523707071,JP
+3523707072,3523707103,AU
+3523707104,3523707119,JP
+3523707120,3523707135,AU
+3523707136,3523707903,GB
 3523707904,3523708159,AU
-3523708160,3523723263,JP
+3523708160,3523708287,JP
+3523708288,3523708319,AU
+3523708320,3523708351,JP
+3523708352,3523708415,AU
+3523708416,3523708927,JP
+3523708928,3523708975,AU
+3523708976,3523708991,JP
+3523708992,3523709183,AU
+3523709184,3523713023,JP
+3523713024,3523713135,AU
+3523713136,3523714047,JP
+3523714048,3523714719,AU
+3523714720,3523714799,JP
+3523714800,3523714943,AU
+3523714944,3523715007,GB
+3523715008,3523715031,JP
+3523715032,3523715071,AU
+3523715072,3523723263,JP
 3523723264,3523725311,US
-3523725312,3523739647,JP
+3523725312,3523737599,JP
+3523737600,3523738111,US
+3523738112,3523739647,JP
 3523739648,3524001791,AU
 3524001792,3524132863,CN
 3524132864,3524145151,PH
@@ -100907,9 +104976,20 @@
 3524157440,3524161535,AU
 3524161536,3524247551,CN
 3524247552,3524263935,AU
-3524263936,3524274175,PH
+3524263936,3524266495,PH
+3524266496,3524266751,SG
+3524266752,3524274175,PH
 3524274176,3524274431,SG
 3524274432,3524280319,PH
+3524280320,3524281343,JP
+3524281344,3524282367,AU
+3524282368,3524288511,IN
+3524288512,3524289535,HK
+3524289536,3524290559,IN
+3524290560,3524291583,CN
+3524291584,3524294655,IN
+3524294656,3524295679,SG
+3524295680,3524296703,PH
 3524296704,3524313087,CN
 3524313088,3524329471,KR
 3524329472,3524362239,TW
@@ -100927,7 +105007,9 @@
 3524745984,3524747263,MP
 3524747264,3524755455,PH
 3524755456,3524763647,AU
-3524763648,3524788223,PH
+3524763648,3524781791,PH
+3524781792,3524781823,SG
+3524781824,3524788223,PH
 3524788224,3524853759,SG
 3524853760,3526361087,CN
 3526361088,3526393855,NZ
@@ -100955,7 +105037,9 @@
 3526926336,3526934527,JP
 3526934528,3526942719,CN
 3526942720,3526950911,AU
-3526950912,3527004159,JP
+3526950912,3527002111,JP
+3527002112,3527003647,IN
+3527003648,3527004159,JP
 3527004160,3527008255,ID
 3527008256,3527016447,KR
 3527016448,3527933951,TW
@@ -101279,13 +105363,9 @@
 3558203392,3558211583,ES
 3558211584,3558219775,GB
 3558219776,3558227967,ES
-3558227968,3558228479,RU
-3558228480,3558228735,FR
-3558228736,3558232063,RU
+3558227968,3558232063,RU
 3558232064,3558232575,LB
-3558232576,3558234623,RU
-3558234624,3558234879,UA
-3558234880,3558235647,RU
+3558232576,3558235647,RU
 3558235648,3558235903,LB
 3558235904,3558236159,RU
 3558236160,3558244351,GB
@@ -101309,7 +105389,9 @@
 3558292256,3558292271,SE
 3558292272,3558293055,GB
 3558293056,3558293087,NL
-3558293088,3558293503,GB
+3558293088,3558293199,GB
+3558293200,3558293215,NL
+3558293216,3558293503,GB
 3558293504,3558301695,RU
 3558301696,3558318079,DE
 3558318080,3558334463,FR
@@ -101426,9 +105508,15 @@
 3559186432,3559194623,RU
 3559194624,3559197439,SE
 3559197440,3559197567,FI
-3559197568,3559200255,SE
+3559197568,3559200143,SE
+3559200144,3559200151,FI
+3559200152,3559200255,SE
 3559200256,3559200511,FI
-3559200512,3559202815,SE
+3559200512,3559200639,SE
+3559200640,3559200671,FI
+3559200672,3559201607,SE
+3559201608,3559201615,FI
+3559201616,3559202815,SE
 3559202816,3559211007,DE
 3559211008,3559219199,SK
 3559219200,3559227391,SE
@@ -101816,7 +105904,9 @@
 3561609216,3561609471,FR
 3561609472,3561610495,GB
 3561610496,3561610751,FR
-3561610752,3561612543,GB
+3561610752,3561611519,GB
+3561611520,3561611775,FR
+3561611776,3561612543,GB
 3561612544,3561612799,FR
 3561612800,3561615871,GB
 3561615872,3561616127,FR
@@ -101947,9 +106037,7 @@
 3562504192,3562512383,DE
 3562512384,3562520575,UA
 3562528768,3562536959,PL
-3562536960,3562544127,AT
-3562544128,3562544383,SK
-3562544384,3562545151,AT
+3562536960,3562545151,AT
 3562545152,3562553343,GB
 3562553344,3562561535,DK
 3562561536,3562569727,UG
@@ -102272,8 +106360,7 @@
 3564896256,3564904447,RU
 3564904448,3564912639,DE
 3564912640,3564918783,NL
-3564918784,3564919807,IT
-3564919808,3564920831,NL
+3564918784,3564920831,IT
 3564920832,3564922111,DE
 3564922112,3564929023,US
 3564929024,3564937215,AT
@@ -102507,7 +106594,9 @@
 3567389440,3567390975,DE
 3567390976,3567391231,GB
 3567391232,3567391487,DE
-3567391488,3567394815,GB
+3567391488,3567393801,GB
+3567393802,3567393802,SI
+3567393803,3567394815,GB
 3567394816,3567395071,IE
 3567395072,3567403007,GB
 3567403008,3567419391,IT
@@ -102525,7 +106614,9 @@
 3567459936,3567459943,ES
 3567459944,3567465983,GB
 3567465984,3567466239,ES
-3567466240,3567495679,GB
+3567466240,3567490047,GB
+3567490048,3567490303,ES
+3567490304,3567495679,GB
 3567495680,3567495935,ES
 3567495936,3567499007,GB
 3567499008,3567499135,ES
@@ -102604,9 +106695,7 @@
 3568795648,3568803839,GB
 3568803840,3568812031,IT
 3568812032,3568828415,ES
-3568828416,3568904191,DE
-3568904192,3568904447,GB
-3568904448,3568959487,DE
+3568828416,3568959487,DE
 3568959488,3569025023,AT
 3569025024,3569057791,NL
 3569057792,3569074687,GB
@@ -102665,7 +106754,9 @@
 3571286016,3571318783,DE
 3571318784,3571321055,GB
 3571321056,3571321071,DE
-3571321072,3571384319,GB
+3571321072,3571321823,GB
+3571321824,3571321855,DE
+3571321856,3571384319,GB
 3571384320,3571425695,DE
 3571425696,3571425727,ES
 3571425728,3571474431,DE
@@ -103119,7 +107210,9 @@
 3579019264,3579052031,DK
 3579052032,3579117567,NL
 3579117568,3579183103,RU
-3579183104,3579193759,GB
+3579183104,3579193607,GB
+3579193608,3579193615,NL
+3579193616,3579193759,GB
 3579193760,3579193775,NL
 3579193776,3579197311,GB
 3579197312,3579197439,US
@@ -103142,13 +107235,13 @@
 3579740160,3579772927,IE
 3579772928,3579838463,DE
 3579838464,3580100607,ES
-3580100608,3580103679,SE
-3580103680,3580106751,LV
-3580106752,3580112895,SE
+3580100608,3580103167,SE
+3580103168,3580107775,LV
+3580107776,3580112895,SE
 3580112896,3580116991,LV
 3580116992,3580131327,SE
-3580131328,3580133375,LV
-3580133376,3580135423,SE
+3580131328,3580134399,LV
+3580134400,3580135423,SE
 3580135424,3580135935,EE
 3580135936,3580136447,SE
 3580136448,3580138495,HR
@@ -103158,30 +107251,38 @@
 3580162048,3580164095,EE
 3580164096,3580165887,SE
 3580165888,3580166143,NL
-3580166144,3580199935,SE
+3580166144,3580198911,SE
+3580198912,3580199551,LV
+3580199552,3580199935,SE
 3580199936,3580200447,EE
-3580200448,3580201983,SE
-3580201984,3580203007,LT
-3580203008,3580204543,SE
+3580200448,3580200959,SE
+3580200960,3580203007,LT
+3580203008,3580203647,SE
+3580203648,3580203775,AT
+3580203776,3580204543,SE
 3580204544,3580205055,NL
 3580205056,3580206079,SE
 3580206080,3580207103,HR
 3580207104,3580208127,LV
 3580208128,3580209151,EE
 3580209152,3580213247,HR
-3580213248,3580214271,LV
-3580214272,3580215295,SE
+3580213248,3580215295,LV
 3580215296,3580217343,EE
-3580217344,3580223487,SE
+3580217344,3580220415,SE
+3580220416,3580221951,LV
+3580221952,3580223487,SE
 3580223488,3580231679,DE
-3580231680,3580232447,SE
+3580231680,3580231935,SE
+3580231936,3580232191,LV
+3580232192,3580232447,SE
 3580232448,3580233215,LT
 3580233216,3580233727,SE
 3580233728,3580235263,LT
 3580235264,3580235775,SE
 3580235776,3580236799,LT
 3580236800,3580237567,LV
-3580237568,3580239871,SE
+3580237568,3580237823,SE
+3580237824,3580239871,LV
 3580239872,3580241919,EE
 3580241920,3580243967,SE
 3580243968,3580244991,EE
@@ -103190,7 +107291,8 @@
 3580248064,3580254207,EE
 3580254208,3580255231,LV
 3580255232,3580258303,DE
-3580258304,3580258815,SE
+3580258304,3580258559,LV
+3580258560,3580258815,SE
 3580258816,3580260351,DE
 3580260352,3580265471,AT
 3580265472,3580266495,SE
@@ -103209,7 +107311,9 @@
 3580624896,3580626943,RU
 3580626944,3580628991,PL
 3580628992,3580631039,RU
-3580631040,3580633087,NL
+3580631040,3580632063,NL
+3580632064,3580632319,PL
+3580632320,3580633087,NL
 3580633088,3580635135,RU
 3580635136,3580637183,UA
 3580639232,3580641279,PL
@@ -103343,7 +107447,9 @@
 3582443520,3582451711,DE
 3582451712,3582459903,LU
 3582459904,3582468095,NL
-3582468096,3582476287,SE
+3582468096,3582476239,SE
+3582476240,3582476247,DK
+3582476248,3582476287,SE
 3582476288,3582484479,DE
 3582484480,3582492671,CI
 3582492672,3582509055,IT
@@ -103472,8 +107578,7 @@
 3583418368,3583426559,TN
 3583426560,3583428607,CV
 3583428608,3583430655,CI
-3583430656,3583432703,ZA
-3583432704,3583434751,CI
+3583430656,3583434751,ZA
 3583434752,3583442943,AT
 3583442944,3583451135,RU
 3583451136,3583459327,IL
@@ -103837,7 +107942,15 @@
 3585982464,3585998847,RU
 3585998848,3586007039,ES
 3586007040,3586015231,LT
-3586015232,3586023423,FR
+3586015232,3586022687,FR
+3586022688,3586022688,GB
+3586022689,3586022689,TN
+3586022690,3586022690,SE
+3586022691,3586022691,BE
+3586022692,3586022692,DK
+3586022693,3586022693,DE
+3586022694,3586022694,IT
+3586022695,3586023423,FR
 3586023424,3586031615,IS
 3586031616,3586039807,IE
 3586039808,3586047999,GB
@@ -104202,7 +108315,7 @@
 3589582976,3589583103,NL
 3589583104,3589586943,GB
 3589586944,3589587199,DE
-3589587200,3589587455,RS
+3589587200,3589587455,NL
 3589587456,3589587967,CH
 3589587968,3589599231,RS
 3589599232,3589601279,SE
@@ -104224,6 +108337,7 @@
 3589810432,3589810687,PL
 3589810688,3589816319,RU
 3589825792,3589826047,DE
+3589826718,3589826718,AT
 3589827584,3589827647,DE
 3589827712,3589827839,DE
 3589828736,3589828991,NL
@@ -104239,7 +108353,9 @@
 3589947392,3589963775,FI
 3589963776,3589980159,ES
 3589980160,3589996543,CZ
-3589996544,3590012927,GB
+3589996544,3589998591,GB
+3589998592,3589998607,ES
+3589998608,3590012927,GB
 3590012928,3590029311,BE
 3590029312,3590045695,FR
 3590045696,3590062079,RU
@@ -104251,7 +108367,9 @@
 3590144000,3590156287,SI
 3590156288,3590157311,HR
 3590157312,3590158335,RS
-3590158336,3590160383,SI
+3590158336,3590158591,SI
+3590158592,3590158847,RS
+3590158848,3590160383,SI
 3590160384,3590176767,GB
 3590176768,3590193151,HU
 3590193152,3590201343,IT
@@ -104261,8 +108379,8 @@
 3590234112,3590242303,GB
 3590242304,3590244351,US
 3590244352,3590244607,DE
-3590244608,3590245263,FR
-3590245264,3590245271,GB
+3590244608,3590245255,FR
+3590245256,3590245271,GB
 3590245272,3590245311,FR
 3590245312,3590245439,US
 3590245440,3590247048,FR
@@ -104435,7 +108553,9 @@
 3626332160,3626336255,CA
 3626336256,3626508287,US
 3626508288,3626512383,CA
-3626512384,3626524671,US
+3626512384,3626515967,US
+3626515968,3626516223,GB
+3626516224,3626524671,US
 3626524672,3626532863,CA
 3626532864,3626852351,US
 3626852352,3626860543,CA
@@ -104457,7 +108577,11 @@
 3627532288,3627544575,CA
 3627544576,3627659263,US
 3627659264,3627663359,CA
-3627663360,3627679743,US
+3627663360,3627667561,US
+3627667562,3627667562,CA
+3627667563,3627667564,US
+3627667565,3627667565,CA
+3627667566,3627679743,US
 3627679744,3627712511,CA
 3627712512,3627753471,US
 3627753472,3627753727,AR
@@ -104818,8 +108942,7 @@
 3633757440,3633757695,IN
 3633757696,3633757951,US
 3633757952,3633758207,PH
-3633758208,3633785343,US
-3633785600,3633815807,US
+3633758208,3633815807,US
 3633815808,3633816063,CA
 3633816064,3633817087,US
 3633817088,3633817343,CA
@@ -104840,7 +108963,9 @@
 3633975040,3634020351,CA
 3634020352,3634037247,US
 3634037248,3634037759,CA
-3634037760,3634052863,US
+3634037760,3634046719,US
+3634046720,3634046975,CA
+3634046976,3634052863,US
 3634052864,3634053119,CA
 3634053120,3634061311,CL
 3634061312,3634094079,US
@@ -104932,7 +109057,9 @@
 3635752192,3635752447,CA
 3635752448,3635752703,US
 3635752704,3635754239,CA
-3635754240,3635755007,US
+3635754240,3635754362,US
+3635754363,3635754363,CA
+3635754364,3635755007,US
 3635755008,3635755519,CA
 3635755520,3635755775,US
 3635755776,3635760895,CA
@@ -105096,7 +109223,9 @@
 3638874112,3638878207,CA
 3638878208,3638880511,US
 3638880512,3638880767,CA
-3638880768,3638984703,US
+3638880768,3638898943,US
+3638898944,3638899199,MX
+3638899200,3638984703,US
 3638984704,3638992895,GT
 3638992896,3638996991,US
 3639001088,3639052031,US
@@ -105229,7 +109358,9 @@
 3639678928,3639678935,CL
 3639678936,3639679231,CO
 3639679232,3639679247,CL
-3639679248,3639679359,CO
+3639679248,3639679263,CO
+3639679264,3639679279,CL
+3639679280,3639679359,CO
 3639679360,3639679383,CL
 3639679384,3639679455,CO
 3639679456,3639679463,CL
@@ -105632,7 +109763,9 @@
 3642535936,3642540031,IS
 3642540032,3642544127,SE
 3642544128,3642552319,RU
-3642552320,3642554111,UA
+3642552320,3642553936,UA
+3642553937,3642553937,US
+3642553938,3642554111,UA
 3642554112,3642554367,RU
 3642554368,3642554623,LT
 3642554624,3642554720,UA
@@ -106188,7 +110321,9 @@
 3648512000,3648516095,NL
 3648516096,3648519167,RS
 3648519168,3648520191,MK
-3648520192,3648782335,NL
+3648520192,3648747229,NL
+3648747230,3648747230,US
+3648747231,3648782335,NL
 3648782336,3649044479,ES
 3649044480,3649110015,FR
 3649110016,3649175551,PT
@@ -106342,7 +110477,9 @@
 3650560000,3650564095,GB
 3650564096,3650568191,SE
 3650568192,3650572287,RU
-3650572288,3650576383,DE
+3650572288,3650575103,DE
+3650575104,3650575167,AT
+3650575168,3650576383,DE
 3650576384,3650580479,GB
 3650580480,3650584575,CH
 3650584576,3650588671,RU
@@ -106351,7 +110488,9 @@
 3650600960,3650605055,SE
 3650605056,3650610175,DE
 3650610176,3650611711,RU
-3650611712,3650611835,LB
+3650611712,3650611782,LB
+3650611783,3650611783,RU
+3650611784,3650611835,LB
 3650611836,3650611836,RU
 3650611837,3650611866,LB
 3650611867,3650611867,RU
@@ -106374,7 +110513,9 @@
 3650920928,3650920959,LB
 3650920960,3650920991,GB
 3650920992,3650921007,IL
-3650921008,3650922799,GB
+3650921008,3650921087,GB
+3650921088,3650921215,GR
+3650921216,3650922799,GB
 3650922800,3650922815,FR
 3650922816,3650926335,GB
 3650926336,3650926591,DE
@@ -106676,10 +110817,10 @@
 3654811648,3654942719,ES
 3654942720,3655073791,IR
 3655073792,3655335935,IT
-3655335936,3656043519,DE
-3656043520,3656043775,PL
-3656043776,3657433087,DE
-3657433088,3659530239,CN
+3655335936,3657433087,DE
+3657433088,3659415455,CN
+3659415456,3659415487,SG
+3659415488,3659530239,CN
 3659530240,3659595775,TW
 3659595776,3659628543,ID
 3659628544,3659661311,JP
@@ -106705,7 +110846,7 @@
 3663992320,3663992575,MY
 3663992576,3663993599,NZ
 3663993600,3663996159,ID
-3663996160,3663996415,AU
+3663996160,3663996415,BD
 3663996416,3663996671,TH
 3663996672,3663997183,AU
 3663997184,3663997439,ID
@@ -106758,6 +110899,7 @@
 3669614592,3669616639,NZ
 3669616640,3669618687,AU
 3669618688,3669620735,CN
+3669620736,3669622783,IN
 3669622784,3669688319,SG
 3669688320,3669753855,TW
 3669753856,3670015999,HK
@@ -106793,6 +110935,8 @@
 3679715328,3679977471,TW
 3679977472,3680108543,NZ
 3680108544,3680124927,TW
+3680124928,3680125951,IN
+3680125952,3680129023,CN
 3680129024,3680133119,PH
 3680133120,3680137215,IN
 3680137216,3680141311,HK
@@ -106840,6 +110984,28 @@
 3701301248,3701305343,ID
 3701305344,3701309439,TW
 3701309440,3701374975,JP
+3701374976,3701375999,IN
+3701376000,3701377023,HK
+3701377024,3701380095,IN
+3701380096,3701381119,KH
+3701381120,3701390335,IN
+3701390336,3701391359,AU
+3701391360,3701392383,IN
+3701392384,3701393407,HK
+3701393408,3701394431,MY
+3701394432,3701395455,BD
+3701395456,3701396479,HK
+3701396480,3701397503,NZ
+3701397504,3701398527,JP
+3701398528,3701399551,MV
+3701399552,3701400575,HK
+3701400576,3701401599,TW
+3701401600,3701402623,BD
+3701402624,3701403647,BT
+3701403648,3701404671,CN
+3701404672,3701405695,HK
+3701405696,3701406719,JP
+3701406720,3701407743,HK
 3701407744,3701473279,JP
 3701473280,3704619007,CN
 3704619008,3705667583,JP
@@ -106862,8 +111028,10 @@
 3706978304,3707109375,AU
 3707109376,3707174911,HK
 3707174912,3707207679,JP
+3707207680,3707208703,BD
+3707208704,3707209727,NZ
 3707209728,3707211775,CN
-3707211776,3707215871,ID
+3707211776,3707215871,NZ
 3707215872,3707217919,BD
 3707217920,3707219967,ID
 3707219968,3707222015,AU
@@ -106896,10 +111064,21 @@
 3715743744,3715760127,JP
 3715760128,3715891199,CN
 3715891200,3716153343,HK
-3716153344,3716169727,SG
-3716169728,3716175615,JP
-3716175616,3716184575,TH
-3716184576,3716186111,JP
+3716153344,3716170751,SG
+3716170752,3716172287,JP
+3716172288,3716173055,SG
+3716173056,3716174335,JP
+3716174336,3716175359,SG
+3716175360,3716176895,JP
+3716176896,3716178175,SG
+3716178176,3716178943,TH
+3716178944,3716179967,SG
+3716179968,3716180991,JP
+3716180992,3716181759,TH
+3716181760,3716182783,SG
+3716182784,3716184575,TH
+3716184576,3716185087,JP
+3716185088,3716186111,SG
 3716186112,3716415487,CN
 3716415488,3716431871,VN
 3716431872,3716440063,KR
@@ -106969,7 +111148,8 @@
 3743006720,3743014911,TH
 3743014912,3743016959,AU
 3743016960,3743019007,SG
-3743019008,3743023103,MY
+3743019008,3743022079,MY
+3743022080,3743023103,BD
 3743023104,3743027199,TW
 3743027200,3743031295,SG
 3743031296,3743035391,IN
@@ -107006,10 +111186,15 @@
 3743252480,3743264767,NC
 3743264768,3743268863,JP
 3743268864,3743272959,IN
+3743272960,3743273983,CN
+3743273984,3743275007,BD
+3743275008,3743276031,HK
+3743276032,3743277055,IN
 3743277056,3743281151,PK
 3743281152,3743282175,AU
 3743282176,3743283199,JP
 3743283200,3743284223,HK
+3743284224,3743285247,CN
 3743285248,3743416319,IN
 3743416320,3745513471,KR
 3745513472,3749052415,CN
@@ -107017,8 +111202,11 @@
 3749183488,3749838847,CN
 3749838848,3749839871,SG
 3749839872,3749840895,IN
+3749840896,3749841919,CN
 3749841920,3749842943,AU
+3749842944,3749843967,PH
 3749843968,3749846015,AU
+3749846016,3749847039,IN
 3749847040,3749855231,HK
 3749855232,3749969919,KR
 3749969920,3750232063,JP
@@ -107075,6 +111263,7 @@
 3758091264,3758092287,CN
 3758092288,3758093311,HK
 3758093312,3758094335,IN
+3758094336,3758095359,HK
 3758095360,3758095871,CN
 3758095872,3758096127,SG
 3758096128,3758096383,AU
diff --git a/src/config/geoip6 b/src/config/geoip6
index 2e3dbc3..228b046 100644
--- a/src/config/geoip6
+++ b/src/config/geoip6
@@ -1,14 +1,22 @@
-# Last updated based on October 9 2015 Maxmind GeoLite2 Country
+# Last updated based on February 2 2016 Maxmind GeoLite2 Country
 # wget https://geolite.maxmind.com/download/geoip/database/GeoLite2-Country.mmdb.gz
 # gunzip GeoLite2-Country.mmdb.gz
 # python mmdb-convert.py GeoLite2-Country.mmdb
+76:96:42:219::,76:96:42:219:ffff:ffff:ffff:ffff,US
+600:8801:9400:580::,600:8801:9400:580::,US
 2001:200::,2001:200::7fff:ffff:ffff:ffff:ffff,JP
 2001:200:120::,2001:200:120:7fff:ffff:ffff:ffff:ffff,JP
+2001:200:148::,2001:200:148:7fff:ffff:ffff:ffff:ffff,JP
 2001:200:167::,2001:200:167:7fff:ffff:ffff:ffff:ffff,JP
-2001:200:180:8000::,2001:200:180:ffff:ffff:ffff:ffff:ffff,JP
+2001:200:180::,2001:200:180:ffff:ffff:ffff:ffff:ffff,JP
 2001:200:1c0::,2001:200:1c0:7fff:ffff:ffff:ffff:ffff,JP
+2001:200:601::,2001:200:601:7fff:ffff:ffff:ffff:ffff,AU
+2001:200:905::,2001:200:905:7fff:ffff:ffff:ffff:ffff,JP
+2001:208:3::,2001:208:3:7fff:ffff:ffff:ffff:ffff,SG
 2001:208:5::,2001:208:5:7fff:ffff:ffff:ffff:ffff,SG
-2001:218::,2001:218:ffff:ffff:ffff:ffff:ffff:ffff,JP
+2001:218::,2001:218:e000:ffff:ffff:ffff:ffff:ffff,JP
+2001:218:e001::,2001:218:e001:7fff:ffff:ffff:ffff:ffff,US
+2001:218:e001:8000::,2001:218:ffff:ffff:ffff:ffff:ffff:ffff,JP
 2001:220::,2001:220:ffff:ffff:ffff:ffff:ffff:ffff,KR
 2001:230::,2001:230:ffff:ffff:ffff:ffff:ffff:ffff,KR
 2001:238::,2001:238:ffff:ffff:ffff:ffff:ffff:ffff,TW
@@ -41,7 +49,6 @@
 2001:310::,2001:310:ffff:ffff:ffff:ffff:ffff:ffff,JP
 2001:318::,2001:318:ffff:ffff:ffff:ffff:ffff:ffff,JP
 2001:320::,2001:320:ffff:ffff:ffff:ffff:ffff:ffff,KR
-2001:328::,2001:328:ffff:ffff:ffff:ffff:ffff:ffff,MY
 2001:330::,2001:330:ffff:ffff:ffff:ffff:ffff:ffff,KR
 2001:338::,2001:338:ffff:ffff:ffff:ffff:ffff:ffff,JP
 2001:340::,2001:340:ffff:ffff:ffff:ffff:ffff:ffff,JP
@@ -72,17 +79,77 @@
 2001:408::,2001:408:ffff:ffff:ffff:ffff:ffff:ffff,US
 2001:410::,2001:410:ffff:ffff:ffff:ffff:ffff:ffff,CA
 2001:418::,2001:418:ffff:ffff:ffff:ffff:ffff:ffff,US
-2001:420::,2001:420:5040:ffff:ffff:ffff:ffff:ffff,US
+2001:420::,2001:420:283f:ffff:ffff:ffff:ffff:ffff,US
+2001:420:2840::,2001:420:2840:7fff:ffff:ffff:ffff:ffff,CA
+2001:420:2840:8000::,2001:420:284c:12ff:ffff:ffff:ffff:ffff,US
+2001:420:284c:1300::,2001:420:284c:13ff:ffff:ffff:ffff:ffff,CA
+2001:420:284c:1400::,2001:420:4049:ffff:ffff:ffff:ffff:ffff,US
+2001:420:404a::,2001:420:404a:7fff:ffff:ffff:ffff:ffff,GB
+2001:420:404a:8000::,2001:420:4081:ffff:ffff:ffff:ffff:ffff,US
+2001:420:4082::,2001:420:4082:7fff:ffff:ffff:ffff:ffff,GB
+2001:420:4082:8000::,2001:420:4083:ffff:ffff:ffff:ffff:ffff,US
+2001:420:4084::,2001:420:4084:7fff:ffff:ffff:ffff:ffff,GB
+2001:420:4084:8000::,2001:420:4085:ffff:ffff:ffff:ffff:ffff,US
+2001:420:4086::,2001:420:4086:7fff:ffff:ffff:ffff:ffff,GB
+2001:420:4086:8000::,2001:420:4490:ffff:ffff:ffff:ffff:ffff,US
+2001:420:4491::,2001:420:4491:7fff:ffff:ffff:ffff:ffff,NL
+2001:420:4491:8000::,2001:420:44d9:ffff:ffff:ffff:ffff:ffff,US
+2001:420:44da::,2001:420:44da:7fff:ffff:ffff:ffff:ffff,ES
+2001:420:44da:8000::,2001:420:44ef:ffff:ffff:ffff:ffff:ffff,US
+2001:420:44f0::,2001:420:44f0:7fff:ffff:ffff:ffff:ffff,FR
+2001:420:44f0:8000::,2001:420:4c41:ffff:ffff:ffff:ffff:ffff,US
+2001:420:4c42::,2001:420:4c42:7fff:ffff:ffff:ffff:ffff,SA
+2001:420:4c42:8000::,2001:420:5040:ffff:ffff:ffff:ffff:ffff,US
 2001:420:5041::,2001:420:5041:7fff:ffff:ffff:ffff:ffff,AU
 2001:420:5041:8000::,2001:420:5042:ffff:ffff:ffff:ffff:ffff,US
 2001:420:5043::,2001:420:5043:7fff:ffff:ffff:ffff:ffff,AU
-2001:420:5043:8000::,2001:420:c0cf:ffff:ffff:ffff:ffff:ffff,US
+2001:420:5043:8000::,2001:420:5044:ffff:ffff:ffff:ffff:ffff,US
+2001:420:5045::,2001:420:5045:7fff:ffff:ffff:ffff:ffff,AU
+2001:420:5045:8000::,2001:420:5046:ffff:ffff:ffff:ffff:ffff,US
+2001:420:5047::,2001:420:5047:7fff:ffff:ffff:ffff:ffff,AU
+2001:420:5047:8000::,2001:420:5049:ffff:ffff:ffff:ffff:ffff,US
+2001:420:504a::,2001:420:504a:7fff:ffff:ffff:ffff:ffff,AU
+2001:420:504a:8000::,2001:420:5441:ffff:ffff:ffff:ffff:ffff,US
+2001:420:5442::,2001:420:5442:7fff:ffff:ffff:ffff:ffff,IN
+2001:420:5442:8000::,2001:420:5442:ffff:ffff:ffff:ffff:ffff,US
+2001:420:5443::,2001:420:5443:7fff:ffff:ffff:ffff:ffff,IN
+2001:420:5443:8000::,2001:420:5504:ffff:ffff:ffff:ffff:ffff,US
+2001:420:5505::,2001:420:5505:7fff:ffff:ffff:ffff:ffff,IN
+2001:420:5505:8000::,2001:420:5882:ffff:ffff:ffff:ffff:ffff,US
+2001:420:5883::,2001:420:5883:7fff:ffff:ffff:ffff:ffff,CN
+2001:420:5883:8000::,2001:420:5894:11ff:ffff:ffff:ffff:ffff,US
+2001:420:5894:1200::,2001:420:5894:12ff:ffff:ffff:ffff:ffff,CN
+2001:420:5894:1300::,2001:420:5894:ffff:ffff:ffff:ffff:ffff,US
+2001:420:5895::,2001:420:5895:7fff:ffff:ffff:ffff:ffff,CN
+2001:420:5895:8000::,2001:420:5899:ffff:ffff:ffff:ffff:ffff,US
+2001:420:589a::,2001:420:589a:7fff:ffff:ffff:ffff:ffff,CN
+2001:420:589a:8000::,2001:420:5a3f:ffff:ffff:ffff:ffff:ffff,US
+2001:420:5a40::,2001:420:5a40:7fff:ffff:ffff:ffff:ffff,CN
+2001:420:5a40:8000::,2001:420:5a43:ffff:ffff:ffff:ffff:ffff,US
+2001:420:5a44::,2001:420:5a44:7fff:ffff:ffff:ffff:ffff,CN
+2001:420:5a44:8000::,2001:420:5c3f:ffff:ffff:ffff:ffff:ffff,US
+2001:420:5c40::,2001:420:5c40:7fff:ffff:ffff:ffff:ffff,SG
+2001:420:5c40:8000::,2001:420:5c40:ffff:ffff:ffff:ffff:ffff,US
+2001:420:5c41::,2001:420:5c41:7fff:ffff:ffff:ffff:ffff,SG
+2001:420:5c41:8000::,2001:420:5c41:ffff:ffff:ffff:ffff:ffff,US
+2001:420:5c42::,2001:420:5c42:7fff:ffff:ffff:ffff:ffff,SG
+2001:420:5c42:8000::,2001:420:5c43:ffff:ffff:ffff:ffff:ffff,US
+2001:420:5c44::,2001:420:5c44:7fff:ffff:ffff:ffff:ffff,SG
+2001:420:5c44:8000::,2001:420:5c46:ffff:ffff:ffff:ffff:ffff,US
+2001:420:5c47::,2001:420:5c47:7fff:ffff:ffff:ffff:ffff,SG
+2001:420:5c47:8000::,2001:420:5e40:11ff:ffff:ffff:ffff:ffff,US
+2001:420:5e40:1200::,2001:420:5e40:12ff:ffff:ffff:ffff:ffff,JP
+2001:420:5e40:1300::,2001:420:c0c0:ffff:ffff:ffff:ffff:ffff,US
+2001:420:c0c1::,2001:420:c0c1:7fff:ffff:ffff:ffff:ffff,CH
+2001:420:c0c1:8000::,2001:420:c0cf:ffff:ffff:ffff:ffff:ffff,US
 2001:420:c0d0::,2001:420:c0d0:7fff:ffff:ffff:ffff:ffff,AU
-2001:420:c0d0:8000::,2001:420:c0d7:ffff:ffff:ffff:ffff:ffff,US
+2001:420:c0d0:8000::,2001:420:c0d3:ffff:ffff:ffff:ffff:ffff,US
+2001:420:c0d4::,2001:420:c0d4:7fff:ffff:ffff:ffff:ffff,SG
+2001:420:c0d4:8000::,2001:420:c0d7:ffff:ffff:ffff:ffff:ffff,US
 2001:420:c0d8::,2001:420:c0d8:7fff:ffff:ffff:ffff:ffff,CN
-2001:420:c0d8:8000::,2001:420:c0df:ffff:ffff:ffff:ffff:ffff,US
-2001:420:c0e0::,2001:420:c0e0:7fff:ffff:ffff:ffff:ffff,IN
-2001:420:c0e0:8000::,2001:420:ffff:ffff:ffff:ffff:ffff:ffff,US
+2001:420:c0d8:8000::,2001:420:c0db:ffff:ffff:ffff:ffff:ffff,US
+2001:420:c0dc::,2001:420:c0dc:7fff:ffff:ffff:ffff:ffff,JP
+2001:420:c0dc:8000::,2001:420:ffff:ffff:ffff:ffff:ffff:ffff,US
 2001:428::,2001:428:ffff:ffff:ffff:ffff:ffff:ffff,US
 2001:430::,2001:430:ffff:ffff:ffff:ffff:ffff:ffff,US
 2001:438::,2001:438:ffff:ffff:ffff:ffff:ffff:ffff,US
@@ -100,44 +167,67 @@
 2001:470::,2001:470:0:284::,US
 2001:470:0:284::1,2001:470:0:284::1,AT
 2001:470:0:284::2,2001:470:17:ffff:ffff:ffff:ffff:ffff,US
-2001:470:18::,2001:470:18:7fff:ffff:ffff:ffff:ffff,TW
+2001:470:18::,2001:470:18:7fff:ffff:ffff:ffff:ffff,CN
 2001:470:18:8000::,2001:470:18:ffff:ffff:ffff:ffff:ffff,US
-2001:470:19::,2001:470:19:7fff:ffff:ffff:ffff:ffff,CN
-2001:470:19:8000::,2001:470:1c:ffff:ffff:ffff:ffff:ffff,US
+2001:470:19::,2001:470:19:7fff:ffff:ffff:ffff:ffff,HK
+2001:470:19:8000::,2001:470:1c:ff:ffff:ffff:ffff:ffff,US
+2001:470:1c:100::,2001:470:1c:7ff:ffff:ffff:ffff:ffff,CA
+2001:470:1c:800::,2001:470:1c:8ff:ffff:ffff:ffff:ffff,US
+2001:470:1c:900::,2001:470:1c:bff:ffff:ffff:ffff:ffff,CA
+2001:470:1c:c00::,2001:470:1c:ffff:ffff:ffff:ffff:ffff,US
 2001:470:1d::,2001:470:1d:7fff:ffff:ffff:ffff:ffff,CA
-2001:470:1d:8000::,2001:470:26:7ff:ffff:ffff:ffff:ffff,US
-2001:470:26:800::,2001:470:26:fff:ffff:ffff:ffff:ffff,IT
-2001:470:26:1000::,2001:470:26:ffff:ffff:ffff:ffff:ffff,US
-2001:470:27::,2001:470:27:7fff:ffff:ffff:ffff:ffff,RU
-2001:470:27:8000::,2001:470:28:35:ffff:ffff:ffff:ffff,US
+2001:470:1d:8000::,2001:470:23:7ff:ffff:ffff:ffff:ffff,US
+2001:470:23:800::,2001:470:23:bff:ffff:ffff:ffff:ffff,KR
+2001:470:23:c00::,2001:470:26:b6c:ffff:ffff:ffff:ffff,US
+2001:470:26:b6d::,2001:470:26:b6d:ffff:ffff:ffff:ffff,AT
+2001:470:26:b6e::,2001:470:27:1a5:ffff:ffff:ffff:ffff,US
+2001:470:27:1a6::,2001:470:27:1a6:ffff:ffff:ffff:ffff,RU
+2001:470:27:1a7::,2001:470:28:35:ffff:ffff:ffff:ffff,US
 2001:470:28:36::,2001:470:28:36:ffff:ffff:ffff:ffff,SE
 2001:470:28:37::,2001:470:28:1a5:ffff:ffff:ffff:ffff,US
 2001:470:28:1a6::,2001:470:28:1a6:ffff:ffff:ffff:ffff,RU
-2001:470:28:1a7::,2001:470:28:9c1:ffff:ffff:ffff:ffff,US
+2001:470:28:1a7::,2001:470:28:2df:ffff:ffff:ffff:ffff,US
+2001:470:28:2e0::,2001:470:28:2e0:ffff:ffff:ffff:ffff,SE
+2001:470:28:2e1::,2001:470:28:9c1:ffff:ffff:ffff:ffff,US
 2001:470:28:9c2::,2001:470:28:9c2:ffff:ffff:ffff:ffff,SE
 2001:470:28:9c3::,2001:470:28:a2b:ffff:ffff:ffff:ffff,US
 2001:470:28:a2c::,2001:470:28:a2c:ffff:ffff:ffff:ffff,SE
-2001:470:28:a2d::,2001:470:6c:ffff:ffff:ffff:ffff:ffff,US
-2001:470:6d::,2001:470:6d:7fff:ffff:ffff:ffff:ffff,RU
-2001:470:6d:8000::,2001:470:6e:ffff:ffff:ffff:ffff:ffff,US
+2001:470:28:a2d::,2001:470:3c:ffff:ffff:ffff:ffff:ffff,US
+2001:470:3d::,2001:470:3d:7fff:ffff:ffff:ffff:ffff,PH
+2001:470:3d:8000::,2001:470:6e:ffff:ffff:ffff:ffff:ffff,US
 2001:470:6f::,2001:470:6f:49e:ffff:ffff:ffff:ffff,CZ
 2001:470:6f:49f::,2001:470:6f:49f:ffff:ffff:ffff:ffff,SK
 2001:470:6f:4a0::,2001:470:6f:7fff:ffff:ffff:ffff:ffff,CZ
-2001:470:6f:8000::,2001:470:70:ffff:ffff:ffff:ffff:ffff,US
-2001:470:71::,2001:470:71:3ff:ffff:ffff:ffff:ffff,PL
-2001:470:71:400::,2001:470:71:4ff:ffff:ffff:ffff:ffff,RU
-2001:470:71:500::,2001:470:71:6ff:ffff:ffff:ffff:ffff,PL
-2001:470:71:700::,2001:470:d2:ffff:ffff:ffff:ffff:ffff,US
+2001:470:6f:8000::,2001:470:70:6ff:ffff:ffff:ffff:ffff,US
+2001:470:70:700::,2001:470:70:7ff:ffff:ffff:ffff:ffff,RU
+2001:470:70:800::,2001:470:71:5ff:ffff:ffff:ffff:ffff,US
+2001:470:71:600::,2001:470:71:600:ffff:ffff:ffff:ffff,PL
+2001:470:71:601::,2001:470:71:60b:ffff:ffff:ffff:ffff,US
+2001:470:71:60c::,2001:470:71:60c:ffff:ffff:ffff:ffff,PL
+2001:470:71:60d::,2001:470:d2:ffff:ffff:ffff:ffff:ffff,US
 2001:470:d3::,2001:470:d3:7fff:ffff:ffff:ffff:ffff,DE
-2001:470:d3:8000::,2001:470:1eff:ffff:ffff:ffff:ffff:ffff,US
-2001:470:1f00::,2001:470:1f00:7fff:ffff:ffff:ffff:ffff,AU
-2001:470:1f00:8000::,2001:470:1f07:ffff:ffff:ffff:ffff:ffff,US
-2001:470:1f08::,2001:470:1f08:fff:ffff:ffff:ffff:ffff,GB
-2001:470:1f08:1000::,2001:470:1f08:ffff:ffff:ffff:ffff:ffff,US
-2001:470:1f09::,2001:470:1f09:7fff:ffff:ffff:ffff:ffff,GB
-2001:470:1f09:8000::,2001:470:1f09:ffff:ffff:ffff:ffff:ffff,US
-2001:470:1f0a::,2001:470:1f0a:7fff:ffff:ffff:ffff:ffff,RU
-2001:470:1f0a:8000::,2001:470:1f0b:30e:ffff:ffff:ffff:ffff,US
+2001:470:d3:8000::,2001:470:1857:ffff:ffff:ffff:ffff:ffff,US
+2001:470:1858::,2001:470:1858:7fff:ffff:ffff:ffff:ffff,GB
+2001:470:1858:8000::,2001:470:18ae:ffff:ffff:ffff:ffff:ffff,US
+2001:470:18af::,2001:470:18af:7fff:ffff:ffff:ffff:ffff,GB
+2001:470:18af:8000::,2001:470:18c1:7fff:ffff:ffff:ffff:ffff,US
+2001:470:18c1:8000::,2001:470:18c1:ffff:ffff:ffff:ffff:ffff,GB
+2001:470:18c2::,2001:470:1f07:ffff:ffff:ffff:ffff:ffff,US
+2001:470:1f08::,2001:470:1f08:3ff:ffff:ffff:ffff:ffff,GB
+2001:470:1f08:400::,2001:470:1f08:415::1,US
+2001:470:1f08:415::2,2001:470:1f08:415::2,GB
+2001:470:1f08:415::3,2001:470:1f08:fff:ffff:ffff:ffff:ffff,US
+2001:470:1f08:1000::,2001:470:1f08:11ff:ffff:ffff:ffff:ffff,GB
+2001:470:1f08:1200::,2001:470:1f08:13ff:ffff:ffff:ffff:ffff,RU
+2001:470:1f08:1400::,2001:470:1f08:17ff:ffff:ffff:ffff:ffff,US
+2001:470:1f08:1800::,2001:470:1f08:1fff:ffff:ffff:ffff:ffff,GB
+2001:470:1f08:2000::,2001:470:1f09:2b5:ffff:ffff:ffff:ffff,US
+2001:470:1f09:2b6::,2001:470:1f09:2b6:ffff:ffff:ffff:ffff,GB
+2001:470:1f09:2b7::,2001:470:1f09:414:ffff:ffff:ffff:ffff,US
+2001:470:1f09:415::,2001:470:1f09:415:ffff:ffff:ffff:ffff,GB
+2001:470:1f09:416::,2001:470:1f0a:7ff:ffff:ffff:ffff:ffff,US
+2001:470:1f0a:800::,2001:470:1f0a:bff:ffff:ffff:ffff:ffff,RU
+2001:470:1f0a:c00::,2001:470:1f0b:30e:ffff:ffff:ffff:ffff,US
 2001:470:1f0b:30f::,2001:470:1f0b:30f:ffff:ffff:ffff:ffff,DE
 2001:470:1f0b:310::,2001:470:1f0b:4b0:ffff:ffff:ffff:ffff,US
 2001:470:1f0b:4b1::,2001:470:1f0b:4b1:ffff:ffff:ffff:ffff,UA
@@ -145,103 +235,544 @@
 2001:470:1f0b:77a::,2001:470:1f0b:77a:ffff:ffff:ffff:ffff,DE
 2001:470:1f0b:77b::,2001:470:1f0b:784:ffff:ffff:ffff:ffff,US
 2001:470:1f0b:785::,2001:470:1f0b:785:ffff:ffff:ffff:ffff,PL
-2001:470:1f0b:786::,2001:470:1f11:ffff:ffff:ffff:ffff:ffff,US
-2001:470:1f12::,2001:470:1f12:7fff:ffff:ffff:ffff:ffff,HU
-2001:470:1f12:8000::,2001:470:1f12:ffff:ffff:ffff:ffff:ffff,US
-2001:470:1f13::,2001:470:1f13:7fff:ffff:ffff:ffff:ffff,FR
-2001:470:1f13:8000::,2001:470:1f14:ffff:ffff:ffff:ffff:ffff,US
-2001:470:1f15::,2001:470:1f15:44f:ffff:ffff:ffff:ffff,RU
+2001:470:1f0b:786::,2001:470:1f12:bff:ffff:ffff:ffff:ffff,US
+2001:470:1f12:c00::,2001:470:1f12:fff:ffff:ffff:ffff:ffff,FR
+2001:470:1f12:1000::,2001:470:1f13:7ff:ffff:ffff:ffff:ffff,US
+2001:470:1f13:800::,2001:470:1f13:bff:ffff:ffff:ffff:ffff,FR
+2001:470:1f13:c00::,2001:470:1f13:fff:ffff:ffff:ffff:ffff,GB
+2001:470:1f13:1000::,2001:470:1f13:11ff:ffff:ffff:ffff:ffff,US
+2001:470:1f13:1200::,2001:470:1f13:12ff:ffff:ffff:ffff:ffff,FR
+2001:470:1f13:1300::,2001:470:1f15:44f:ffff:ffff:ffff:ffff,US
 2001:470:1f15:450::,2001:470:1f15:450:ffff:ffff:ffff:ffff,NL
-2001:470:1f15:451::,2001:470:1f15:a5f:ffff:ffff:ffff:ffff,RU
+2001:470:1f15:451::,2001:470:1f15:5ab:ffff:ffff:ffff:ffff,US
+2001:470:1f15:5ac::,2001:470:1f15:5ac:ffff:ffff:ffff:ffff,NL
+2001:470:1f15:5ad::,2001:470:1f15:9c5:ffff:ffff:ffff:ffff,US
+2001:470:1f15:9c6::,2001:470:1f15:9c6:ffff:ffff:ffff:ffff,AT
+2001:470:1f15:9c7::,2001:470:1f15:a5f:ffff:ffff:ffff:ffff,US
 2001:470:1f15:a60::,2001:470:1f15:a60:ffff:ffff:ffff:ffff,NL
-2001:470:1f15:a61::,2001:470:1f15:7fff:ffff:ffff:ffff:ffff,RU
-2001:470:1f15:8000::,2001:470:1f1a:ffff:ffff:ffff:ffff:ffff,US
-2001:470:1f1b::,2001:470:1f1b:ff:ffff:ffff:ffff:ffff,HU
-2001:470:1f1b:100::,2001:470:207f:ffff:ffff:ffff:ffff:ffff,US
+2001:470:1f15:a61::,2001:470:1f15:ffff:ffff:ffff:ffff:ffff,US
+2001:470:1f16::,2001:470:1f16:7fff:ffff:ffff:ffff:ffff,CA
+2001:470:1f16:8000::,2001:470:1f16:ffff:ffff:ffff:ffff:ffff,US
+2001:470:1f17::,2001:470:1f17:7fff:ffff:ffff:ffff:ffff,CA
+2001:470:1f17:8000::,2001:470:1f1b:ffff:ffff:ffff:ffff:ffff,US
+2001:470:1f1c::,2001:470:1f1c:7fff:ffff:ffff:ffff:ffff,GB
+2001:470:1f1c:8000::,2001:470:1f1d:195:ffff:ffff:ffff:ffff,US
+2001:470:1f1d:196::,2001:470:1f1d:196:ffff:ffff:ffff:ffff,GB
+2001:470:1f1d:197::,2001:470:2050:ffff:ffff:ffff:ffff:ffff,US
+2001:470:2051::,2001:470:2051:7fff:ffff:ffff:ffff:ffff,RO
+2001:470:2051:8000::,2001:470:207f:ffff:ffff:ffff:ffff:ffff,US
 2001:470:2080::,2001:470:2080:7fff:ffff:ffff:ffff:ffff,UA
 2001:470:2080:8000::,2001:470:2092:ffff:ffff:ffff:ffff:ffff,US
 2001:470:2093::,2001:470:2093:7fff:ffff:ffff:ffff:ffff,SI
-2001:470:2093:8000::,2001:470:49e5:7fff:ffff:ffff:ffff:ffff,US
+2001:470:2093:8000::,2001:470:3028:ffff:ffff:ffff:ffff:ffff,US
+2001:470:3029::,2001:470:3029:7fff:ffff:ffff:ffff:ffff,CA
+2001:470:3029:8000::,2001:470:302d:ffff:ffff:ffff:ffff:ffff,US
+2001:470:302e::,2001:470:302e:7fff:ffff:ffff:ffff:ffff,CA
+2001:470:302e:8000::,2001:470:3049:ffff:ffff:ffff:ffff:ffff,US
+2001:470:304a::,2001:470:304a:7fff:ffff:ffff:ffff:ffff,MX
+2001:470:304a:8000::,2001:470:3051:7fff:ffff:ffff:ffff:ffff,US
+2001:470:3051:8000::,2001:470:3051:ffff:ffff:ffff:ffff:ffff,CA
+2001:470:3052::,2001:470:48ab:ffff:ffff:ffff:ffff:ffff,US
+2001:470:48ac::,2001:470:48ac:7fff:ffff:ffff:ffff:ffff,AU
+2001:470:48ac:8000::,2001:470:48d0:ffff:ffff:ffff:ffff:ffff,US
+2001:470:48d1::,2001:470:48d1:7fff:ffff:ffff:ffff:ffff,CA
+2001:470:48d1:8000::,2001:470:49e5:7fff:ffff:ffff:ffff:ffff,US
 2001:470:49e5:8000::,2001:470:49e5:ffff:ffff:ffff:ffff:ffff,CN
-2001:470:49e6::,2001:470:591a:ffff:ffff:ffff:ffff:ffff,US
+2001:470:49e6::,2001:470:507c:ffff:ffff:ffff:ffff:ffff,US
+2001:470:507d::,2001:470:507d:7fff:ffff:ffff:ffff:ffff,UA
+2001:470:507d:8000::,2001:470:51e8:ffff:ffff:ffff:ffff:ffff,US
+2001:470:51e9::,2001:470:51e9:7fff:ffff:ffff:ffff:ffff,DE
+2001:470:51e9:8000::,2001:470:52ba:ffff:ffff:ffff:ffff:ffff,US
+2001:470:52bb::,2001:470:52bb:7fff:ffff:ffff:ffff:ffff,UA
+2001:470:52bb:8000::,2001:470:52c5:ffff:ffff:ffff:ffff:ffff,US
+2001:470:52c6::,2001:470:52c6:7fff:ffff:ffff:ffff:ffff,DE
+2001:470:52c6:8000::,2001:470:532d:ffff:ffff:ffff:ffff:ffff,US
+2001:470:532e::,2001:470:532e:7fff:ffff:ffff:ffff:ffff,RU
+2001:470:532e:8000::,2001:470:5803:7fff:ffff:ffff:ffff:ffff,US
+2001:470:5803:8000::,2001:470:5803:ffff:ffff:ffff:ffff:ffff,CZ
+2001:470:5804::,2001:470:5853:ffff:ffff:ffff:ffff:ffff,US
+2001:470:5854::,2001:470:5854:7fff:ffff:ffff:ffff:ffff,CZ
+2001:470:5854:8000::,2001:470:587d:ffff:ffff:ffff:ffff:ffff,US
+2001:470:587e::,2001:470:587e:7fff:ffff:ffff:ffff:ffff,CZ
+2001:470:587e:8000::,2001:470:591a:ffff:ffff:ffff:ffff:ffff,US
 2001:470:591b::,2001:470:591b:7fff:ffff:ffff:ffff:ffff,CZ
 2001:470:591b:8000::,2001:470:591c:ffff:ffff:ffff:ffff:ffff,US
 2001:470:591d::,2001:470:591d:7fff:ffff:ffff:ffff:ffff,CZ
-2001:470:591d:8000::,2001:470:5a34:ffff:ffff:ffff:ffff:ffff,US
+2001:470:591d:8000::,2001:470:5948:ffff:ffff:ffff:ffff:ffff,US
+2001:470:5949::,2001:470:5949:7fff:ffff:ffff:ffff:ffff,CZ
+2001:470:5949:8000::,2001:470:598f:ffff:ffff:ffff:ffff:ffff,US
+2001:470:5990::,2001:470:5990:7fff:ffff:ffff:ffff:ffff,CZ
+2001:470:5990:8000::,2001:470:59c0:ffff:ffff:ffff:ffff:ffff,US
+2001:470:59c1::,2001:470:59c1:7fff:ffff:ffff:ffff:ffff,CZ
+2001:470:59c1:8000::,2001:470:59d7:ffff:ffff:ffff:ffff:ffff,US
+2001:470:59d8::,2001:470:59d8:7fff:ffff:ffff:ffff:ffff,CZ
+2001:470:59d8:8000::,2001:470:5a34:ffff:ffff:ffff:ffff:ffff,US
 2001:470:5a35::,2001:470:5a35:ffff:ffff:ffff:ffff:ffff,CZ
 2001:470:5a36::,2001:470:5a39:ffff:ffff:ffff:ffff:ffff,US
 2001:470:5a3a::,2001:470:5a3a:ffff:ffff:ffff:ffff:ffff,CZ
-2001:470:5a3b::,2001:470:6b38:ffff:ffff:ffff:ffff:ffff,US
+2001:470:5a3b::,2001:470:5a80:ffff:ffff:ffff:ffff:ffff,US
+2001:470:5a81::,2001:470:5a81:ffff:ffff:ffff:ffff:ffff,CZ
+2001:470:5a82::,2001:470:60a2:ffff:ffff:ffff:ffff:ffff,US
+2001:470:60a3::,2001:470:60a3:7fff:ffff:ffff:ffff:ffff,BY
+2001:470:60a3:8000::,2001:470:60e4:ffff:ffff:ffff:ffff:ffff,US
+2001:470:60e5::,2001:470:60e5:7fff:ffff:ffff:ffff:ffff,PL
+2001:470:60e5:8000::,2001:470:60f4:7fff:ffff:ffff:ffff:ffff,US
+2001:470:60f4:8000::,2001:470:60f4:ffff:ffff:ffff:ffff:ffff,PL
+2001:470:60f5::,2001:470:613f:ffff:ffff:ffff:ffff:ffff,US
+2001:470:6140::,2001:470:6140:7fff:ffff:ffff:ffff:ffff,PL
+2001:470:6140:8000::,2001:470:618d:ffff:ffff:ffff:ffff:ffff,US
+2001:470:618e::,2001:470:618e:7fff:ffff:ffff:ffff:ffff,PL
+2001:470:618e:8000::,2001:470:619f:ffff:ffff:ffff:ffff:ffff,US
+2001:470:61a0::,2001:470:61a0:7fff:ffff:ffff:ffff:ffff,RU
+2001:470:61a0:8000::,2001:470:6228:ffff:ffff:ffff:ffff:ffff,US
+2001:470:6229::,2001:470:6229:7fff:ffff:ffff:ffff:ffff,PL
+2001:470:6229:8000::,2001:470:6808:7fff:ffff:ffff:ffff:ffff,US
+2001:470:6808:8000::,2001:470:6808:ffff:ffff:ffff:ffff:ffff,GB
+2001:470:6809::,2001:470:688b:ffff:ffff:ffff:ffff:ffff,US
+2001:470:688c::,2001:470:688c:7fff:ffff:ffff:ffff:ffff,GB
+2001:470:688c:8000::,2001:470:68a5:ffff:ffff:ffff:ffff:ffff,US
+2001:470:68a6::,2001:470:68a6:7fff:ffff:ffff:ffff:ffff,ES
+2001:470:68a6:8000::,2001:470:68df:ffff:ffff:ffff:ffff:ffff,US
+2001:470:68e0::,2001:470:68e0:7fff:ffff:ffff:ffff:ffff,IL
+2001:470:68e0:8000::,2001:470:68e9:ffff:ffff:ffff:ffff:ffff,US
+2001:470:68ea::,2001:470:68ea:7fff:ffff:ffff:ffff:ffff,GB
+2001:470:68ea:8000::,2001:470:6914:ffff:ffff:ffff:ffff:ffff,US
+2001:470:6915::,2001:470:6915:7fff:ffff:ffff:ffff:ffff,ES
+2001:470:6915:8000::,2001:470:6924:ffff:ffff:ffff:ffff:ffff,US
+2001:470:6925::,2001:470:6925:7fff:ffff:ffff:ffff:ffff,NL
+2001:470:6925:8000::,2001:470:6978:ffff:ffff:ffff:ffff:ffff,US
+2001:470:6979::,2001:470:6979:7fff:ffff:ffff:ffff:ffff,ES
+2001:470:6979:8000::,2001:470:6a20:ffff:ffff:ffff:ffff:ffff,US
+2001:470:6a21::,2001:470:6a21:7fff:ffff:ffff:ffff:ffff,GB
+2001:470:6a21:8000::,2001:470:6a62:ffff:ffff:ffff:ffff:ffff,US
+2001:470:6a63::,2001:470:6a63:7fff:ffff:ffff:ffff:ffff,GB
+2001:470:6a63:8000::,2001:470:6af6:ffff:ffff:ffff:ffff:ffff,US
+2001:470:6af7::,2001:470:6af7:7fff:ffff:ffff:ffff:ffff,GB
+2001:470:6af7:8000::,2001:470:6b28:ffff:ffff:ffff:ffff:ffff,US
+2001:470:6b29::,2001:470:6b29:7fff:ffff:ffff:ffff:ffff,GB
+2001:470:6b29:8000::,2001:470:6b2e:ffff:ffff:ffff:ffff:ffff,US
+2001:470:6b2f::,2001:470:6b2f:7fff:ffff:ffff:ffff:ffff,GB
+2001:470:6b2f:8000::,2001:470:6b38:ffff:ffff:ffff:ffff:ffff,US
 2001:470:6b39::,2001:470:6b39:7fff:ffff:ffff:ffff:ffff,GB
-2001:470:6b39:8000::,2001:470:6c0d:ffff:ffff:ffff:ffff:ffff,US
+2001:470:6b39:8000::,2001:470:6b76:ffff:ffff:ffff:ffff:ffff,US
+2001:470:6b77::,2001:470:6b77:7fff:ffff:ffff:ffff:ffff,GB
+2001:470:6b77:8000::,2001:470:6bba:ffff:ffff:ffff:ffff:ffff,US
+2001:470:6bbb::,2001:470:6bbb:7fff:ffff:ffff:ffff:ffff,GB
+2001:470:6bbb:8000::,2001:470:6bee:7fff:ffff:ffff:ffff:ffff,US
+2001:470:6bee:8000::,2001:470:6bee:ffff:ffff:ffff:ffff:ffff,IN
+2001:470:6bef::,2001:470:6c0d:ffff:ffff:ffff:ffff:ffff,US
 2001:470:6c0e::,2001:470:6c0e:7fff:ffff:ffff:ffff:ffff,GB
-2001:470:6c0e:8000::,2001:470:70a1:7fff:ffff:ffff:ffff:ffff,US
+2001:470:6c0e:8000::,2001:470:6c1b:ffff:ffff:ffff:ffff:ffff,US
+2001:470:6c1c::,2001:470:6c1c:7fff:ffff:ffff:ffff:ffff,GB
+2001:470:6c1c:8000::,2001:470:6c5a:ffff:ffff:ffff:ffff:ffff,US
+2001:470:6c5b::,2001:470:6c5b:7fff:ffff:ffff:ffff:ffff,GB
+2001:470:6c5b:8000::,2001:470:6c7f:ffff:ffff:ffff:ffff:ffff,US
+2001:470:6c80::,2001:470:6c80:7fff:ffff:ffff:ffff:ffff,RU
+2001:470:6c80:8000::,2001:470:6c8e:ffff:ffff:ffff:ffff:ffff,US
+2001:470:6c8f::,2001:470:6c8f:7fff:ffff:ffff:ffff:ffff,GB
+2001:470:6c8f:8000::,2001:470:6c96:ffff:ffff:ffff:ffff:ffff,US
+2001:470:6c97::,2001:470:6c97:7fff:ffff:ffff:ffff:ffff,RU
+2001:470:6c97:8000::,2001:470:6cee:ffff:ffff:ffff:ffff:ffff,US
+2001:470:6cef::,2001:470:6cef:7fff:ffff:ffff:ffff:ffff,ES
+2001:470:6cef:8000::,2001:470:6d37:ffff:ffff:ffff:ffff:ffff,US
+2001:470:6d38::,2001:470:6d38:7fff:ffff:ffff:ffff:ffff,GB
+2001:470:6d38:8000::,2001:470:6d44:ffff:ffff:ffff:ffff:ffff,US
+2001:470:6d45::,2001:470:6d45:7fff:ffff:ffff:ffff:ffff,GB
+2001:470:6d45:8000::,2001:470:6d54:ffff:ffff:ffff:ffff:ffff,US
+2001:470:6d55::,2001:470:6d55:7fff:ffff:ffff:ffff:ffff,GB
+2001:470:6d55:8000::,2001:470:6d5b:ffff:ffff:ffff:ffff:ffff,US
+2001:470:6d5c::,2001:470:6d5c:7fff:ffff:ffff:ffff:ffff,GB
+2001:470:6d5c:8000::,2001:470:7000:ffff:ffff:ffff:ffff:ffff,US
+2001:470:7001::,2001:470:7001:7fff:ffff:ffff:ffff:ffff,DE
+2001:470:7001:8000::,2001:470:700d:ffff:ffff:ffff:ffff:ffff,US
+2001:470:700e::,2001:470:700e:7fff:ffff:ffff:ffff:ffff,DE
+2001:470:700e:8000::,2001:470:7069:ffff:ffff:ffff:ffff:ffff,US
+2001:470:706a::,2001:470:706a:7fff:ffff:ffff:ffff:ffff,DE
+2001:470:706a:8000::,2001:470:7073:7fff:ffff:ffff:ffff:ffff,US
+2001:470:7073:8000::,2001:470:7073:ffff:ffff:ffff:ffff:ffff,DE
+2001:470:7074::,2001:470:70a1:7fff:ffff:ffff:ffff:ffff,US
 2001:470:70a1:8000::,2001:470:70a1:ffff:ffff:ffff:ffff:ffff,RU
-2001:470:70a2::,2001:470:70aa:ffff:ffff:ffff:ffff:ffff,US
+2001:470:70a2::,2001:470:70a7:ffff:ffff:ffff:ffff:ffff,US
+2001:470:70a8::,2001:470:70a8:7fff:ffff:ffff:ffff:ffff,DE
+2001:470:70a8:8000::,2001:470:70aa:ffff:ffff:ffff:ffff:ffff,US
 2001:470:70ab::,2001:470:70ab:7fff:ffff:ffff:ffff:ffff,DE
 2001:470:70ab:8000::,2001:470:710f:ffff:ffff:ffff:ffff:ffff,US
 2001:470:7110::,2001:470:7110:7fff:ffff:ffff:ffff:ffff,RU
 2001:470:7110:8000::,2001:470:7170:ffff:ffff:ffff:ffff:ffff,US
 2001:470:7171::,2001:470:7171:ffff:ffff:ffff:ffff:ffff,DE
-2001:470:7172::,2001:470:7286:ffff:ffff:ffff:ffff:ffff,US
+2001:470:7172::,2001:470:7179:ffff:ffff:ffff:ffff:ffff,US
+2001:470:717a::,2001:470:717a:7fff:ffff:ffff:ffff:ffff,DE
+2001:470:717a:8000::,2001:470:7192:ffff:ffff:ffff:ffff:ffff,US
+2001:470:7193::,2001:470:7193:7fff:ffff:ffff:ffff:ffff,DE
+2001:470:7193:8000::,2001:470:71d4:ffff:ffff:ffff:ffff:ffff,US
+2001:470:71d5::,2001:470:71d5:7fff:ffff:ffff:ffff:ffff,UA
+2001:470:71d5:8000::,2001:470:71f7:ffff:ffff:ffff:ffff:ffff,US
+2001:470:71f8::,2001:470:71f8:7fff:ffff:ffff:ffff:ffff,DE
+2001:470:71f8:8000::,2001:470:7280:ffff:ffff:ffff:ffff:ffff,US
+2001:470:7281::,2001:470:7281:7fff:ffff:ffff:ffff:ffff,DE
+2001:470:7281:8000::,2001:470:7286:ffff:ffff:ffff:ffff:ffff,US
 2001:470:7287::,2001:470:7287:ffff:ffff:ffff:ffff:ffff,PL
-2001:470:7288::,2001:470:74e0:ffff:ffff:ffff:ffff:ffff,US
+2001:470:7288::,2001:470:72bd:ffff:ffff:ffff:ffff:ffff,US
+2001:470:72be::,2001:470:72be:7fff:ffff:ffff:ffff:ffff,DE
+2001:470:72be:8000::,2001:470:72da:ffff:ffff:ffff:ffff:ffff,US
+2001:470:72db::,2001:470:72db:7fff:ffff:ffff:ffff:ffff,RU
+2001:470:72db:8000::,2001:470:7309:ffff:ffff:ffff:ffff:ffff,US
+2001:470:730a::,2001:470:730a:7fff:ffff:ffff:ffff:ffff,DE
+2001:470:730a:8000::,2001:470:7368:ffff:ffff:ffff:ffff:ffff,US
+2001:470:7369::,2001:470:7369:7fff:ffff:ffff:ffff:ffff,TR
+2001:470:7369:8000::,2001:470:7383:ffff:ffff:ffff:ffff:ffff,US
+2001:470:7384::,2001:470:7384:7fff:ffff:ffff:ffff:ffff,BG
+2001:470:7384:8000::,2001:470:73d1:ffff:ffff:ffff:ffff:ffff,US
+2001:470:73d2::,2001:470:73d2:7fff:ffff:ffff:ffff:ffff,DE
+2001:470:73d2:8000::,2001:470:73e8:7fff:ffff:ffff:ffff:ffff,US
+2001:470:73e8:8000::,2001:470:73e8:ffff:ffff:ffff:ffff:ffff,DE
+2001:470:73e9::,2001:470:742b:7fff:ffff:ffff:ffff:ffff,US
+2001:470:742b:8000::,2001:470:742b:ffff:ffff:ffff:ffff:ffff,RU
+2001:470:742c::,2001:470:7479:ffff:ffff:ffff:ffff:ffff,US
+2001:470:747a::,2001:470:747a:7fff:ffff:ffff:ffff:ffff,DE
+2001:470:747a:8000::,2001:470:74b8:ffff:ffff:ffff:ffff:ffff,US
+2001:470:74b9::,2001:470:74b9:7fff:ffff:ffff:ffff:ffff,RS
+2001:470:74b9:8000::,2001:470:74e0:ffff:ffff:ffff:ffff:ffff,US
 2001:470:74e1::,2001:470:74e1:7fff:ffff:ffff:ffff:ffff,DE
-2001:470:74e1:8000::,2001:470:7ba6:ffff:ffff:ffff:ffff:ffff,US
+2001:470:74e1:8000::,2001:470:7552:ffff:ffff:ffff:ffff:ffff,US
+2001:470:7553::,2001:470:7553:7fff:ffff:ffff:ffff:ffff,DE
+2001:470:7553:8000::,2001:470:7563:7fff:ffff:ffff:ffff:ffff,US
+2001:470:7563:8000::,2001:470:7563:ffff:ffff:ffff:ffff:ffff,UA
+2001:470:7564::,2001:470:759e:ffff:ffff:ffff:ffff:ffff,US
+2001:470:759f::,2001:470:759f:7fff:ffff:ffff:ffff:ffff,DE
+2001:470:759f:8000::,2001:470:75c1:ffff:ffff:ffff:ffff:ffff,US
+2001:470:75c2::,2001:470:75c2:7fff:ffff:ffff:ffff:ffff,DE
+2001:470:75c2:8000::,2001:470:75c2:ffff:ffff:ffff:ffff:ffff,US
+2001:470:75c3::,2001:470:75c3:7fff:ffff:ffff:ffff:ffff,DE
+2001:470:75c3:8000::,2001:470:75f0:ffff:ffff:ffff:ffff:ffff,US
+2001:470:75f1::,2001:470:75f1:7fff:ffff:ffff:ffff:ffff,DE
+2001:470:75f1:8000::,2001:470:7804:ffff:ffff:ffff:ffff:ffff,US
+2001:470:7805::,2001:470:7805:7fff:ffff:ffff:ffff:ffff,NL
+2001:470:7805:8000::,2001:470:7859:ffff:ffff:ffff:ffff:ffff,US
+2001:470:785a::,2001:470:785a:ffff:ffff:ffff:ffff:ffff,AT
+2001:470:785b::,2001:470:78ab:ffff:ffff:ffff:ffff:ffff,US
+2001:470:78ac::,2001:470:78ac:7fff:ffff:ffff:ffff:ffff,NL
+2001:470:78ac:8000::,2001:470:78c7:ffff:ffff:ffff:ffff:ffff,US
+2001:470:78c8::,2001:470:78c8:7fff:ffff:ffff:ffff:ffff,NL
+2001:470:78c8:8000::,2001:470:78db:ffff:ffff:ffff:ffff:ffff,US
+2001:470:78dc::,2001:470:78dc:7fff:ffff:ffff:ffff:ffff,NL
+2001:470:78dc:8000::,2001:470:78e3:ffff:ffff:ffff:ffff:ffff,US
+2001:470:78e4::,2001:470:78e4:7fff:ffff:ffff:ffff:ffff,NL
+2001:470:78e4:8000::,2001:470:78e8:ffff:ffff:ffff:ffff:ffff,US
+2001:470:78e9::,2001:470:78e9:7fff:ffff:ffff:ffff:ffff,LV
+2001:470:78e9:8000::,2001:470:790c:ffff:ffff:ffff:ffff:ffff,US
+2001:470:790d::,2001:470:790d:7fff:ffff:ffff:ffff:ffff,NL
+2001:470:790d:8000::,2001:470:79ff:ffff:ffff:ffff:ffff:ffff,US
+2001:470:7a00::,2001:470:7a00:7fff:ffff:ffff:ffff:ffff,NL
+2001:470:7a00:8000::,2001:470:7a91:ffff:ffff:ffff:ffff:ffff,US
+2001:470:7a92::,2001:470:7a92:7fff:ffff:ffff:ffff:ffff,DE
+2001:470:7a92:8000::,2001:470:7a99:ffff:ffff:ffff:ffff:ffff,US
+2001:470:7a9a::,2001:470:7a9a:ffff:ffff:ffff:ffff:ffff,NL
+2001:470:7a9b::,2001:470:7b22:ffff:ffff:ffff:ffff:ffff,US
+2001:470:7b23::,2001:470:7b23:7fff:ffff:ffff:ffff:ffff,ES
+2001:470:7b23:8000::,2001:470:7ba6:ffff:ffff:ffff:ffff:ffff,US
 2001:470:7ba7::,2001:470:7ba7:7fff:ffff:ffff:ffff:ffff,NL
-2001:470:7ba7:8000::,2001:470:7c4f:ffff:ffff:ffff:ffff:ffff,US
+2001:470:7ba7:8000::,2001:470:7baf:ffff:ffff:ffff:ffff:ffff,US
+2001:470:7bb0::,2001:470:7bb0:7fff:ffff:ffff:ffff:ffff,BE
+2001:470:7bb0:8000::,2001:470:7bbf:ffff:ffff:ffff:ffff:ffff,US
+2001:470:7bc0::,2001:470:7bc0:ffff:ffff:ffff:ffff:ffff,NL
+2001:470:7bc1::,2001:470:7c01:ffff:ffff:ffff:ffff:ffff,US
+2001:470:7c02::,2001:470:7c02:7fff:ffff:ffff:ffff:ffff,NL
+2001:470:7c02:8000::,2001:470:7c14:ffff:ffff:ffff:ffff:ffff,US
+2001:470:7c15::,2001:470:7c15:7fff:ffff:ffff:ffff:ffff,DE
+2001:470:7c15:8000::,2001:470:7c4f:ffff:ffff:ffff:ffff:ffff,US
 2001:470:7c50::,2001:470:7c50:7fff:ffff:ffff:ffff:ffff,NL
-2001:470:7c50:8000::,2001:470:8091:ffff:ffff:ffff:ffff:ffff,US
+2001:470:7c50:8000::,2001:470:7ca1:7fff:ffff:ffff:ffff:ffff,US
+2001:470:7ca1:8000::,2001:470:7ca1:ffff:ffff:ffff:ffff:ffff,NL
+2001:470:7ca2::,2001:470:7d16:ffff:ffff:ffff:ffff:ffff,US
+2001:470:7d17::,2001:470:7d17:7fff:ffff:ffff:ffff:ffff,NL
+2001:470:7d17:8000::,2001:470:7d59:ffff:ffff:ffff:ffff:ffff,US
+2001:470:7d5a::,2001:470:7d5a:7fff:ffff:ffff:ffff:ffff,NL
+2001:470:7d5a:8000::,2001:470:8091:ffff:ffff:ffff:ffff:ffff,US
 2001:470:8092::,2001:470:8092:7fff:ffff:ffff:ffff:ffff,CN
 2001:470:8092:8000::,2001:470:80b6:ffff:ffff:ffff:ffff:ffff,US
 2001:470:80b7::,2001:470:80b7:7fff:ffff:ffff:ffff:ffff,CN
-2001:470:80b7:8000::,2001:470:83bb:ffff:ffff:ffff:ffff:ffff,US
+2001:470:80b7:8000::,2001:470:80ec:ffff:ffff:ffff:ffff:ffff,US
+2001:470:80ed::,2001:470:80ed:7fff:ffff:ffff:ffff:ffff,AU
+2001:470:80ed:8000::,2001:470:80f0:ffff:ffff:ffff:ffff:ffff,US
+2001:470:80f1::,2001:470:80f1:7fff:ffff:ffff:ffff:ffff,AU
+2001:470:80f1:8000::,2001:470:814c:ffff:ffff:ffff:ffff:ffff,US
+2001:470:814d::,2001:470:814d:7fff:ffff:ffff:ffff:ffff,AU
+2001:470:814d:8000::,2001:470:81b0:ffff:ffff:ffff:ffff:ffff,US
+2001:470:81b1::,2001:470:81b1:7fff:ffff:ffff:ffff:ffff,CN
+2001:470:81b1:8000::,2001:470:81ee:ffff:ffff:ffff:ffff:ffff,US
+2001:470:81ef::,2001:470:81ef:7fff:ffff:ffff:ffff:ffff,CA
+2001:470:81ef:8000::,2001:470:828d:ffff:ffff:ffff:ffff:ffff,US
+2001:470:828e::,2001:470:828e:7fff:ffff:ffff:ffff:ffff,CA
+2001:470:828e:8000::,2001:470:8327:ffff:ffff:ffff:ffff:ffff,US
+2001:470:8328::,2001:470:8328:7fff:ffff:ffff:ffff:ffff,CN
+2001:470:8328:8000::,2001:470:83a2:ffff:ffff:ffff:ffff:ffff,US
+2001:470:83a3::,2001:470:83a3:7fff:ffff:ffff:ffff:ffff,AU
+2001:470:83a3:8000::,2001:470:83bb:ffff:ffff:ffff:ffff:ffff,US
 2001:470:83bc::,2001:470:83bc:7fff:ffff:ffff:ffff:ffff,CN
-2001:470:83bc:8000::,2001:470:83e8:ffff:ffff:ffff:ffff:ffff,US
+2001:470:83bc:8000::,2001:470:83d0:7fff:ffff:ffff:ffff:ffff,US
+2001:470:83d0:8000::,2001:470:83d0:ffff:ffff:ffff:ffff:ffff,CN
+2001:470:83d1::,2001:470:83e8:ffff:ffff:ffff:ffff:ffff,US
 2001:470:83e9::,2001:470:83e9:7fff:ffff:ffff:ffff:ffff,CN
-2001:470:83e9:8000::,2001:470:9794:ffff:ffff:ffff:ffff:ffff,US
+2001:470:83e9:8000::,2001:470:8551:ffff:ffff:ffff:ffff:ffff,US
+2001:470:8552::,2001:470:8552:7fff:ffff:ffff:ffff:ffff,CN
+2001:470:8552:8000::,2001:470:8578:ffff:ffff:ffff:ffff:ffff,US
+2001:470:8579::,2001:470:8579:7fff:ffff:ffff:ffff:ffff,CN
+2001:470:8579:8000::,2001:470:859e:ffff:ffff:ffff:ffff:ffff,US
+2001:470:859f::,2001:470:859f:7fff:ffff:ffff:ffff:ffff,AU
+2001:470:859f:8000::,2001:470:8c3f:ffff:ffff:ffff:ffff:ffff,US
+2001:470:8c40::,2001:470:8c40:7fff:ffff:ffff:ffff:ffff,CA
+2001:470:8c40:8000::,2001:470:8c6b:ffff:ffff:ffff:ffff:ffff,US
+2001:470:8c6c::,2001:470:8c6c:7fff:ffff:ffff:ffff:ffff,AU
+2001:470:8c6c:8000::,2001:470:94f2:7fff:ffff:ffff:ffff:ffff,US
+2001:470:94f2:8000::,2001:470:94f2:ffff:ffff:ffff:ffff:ffff,CZ
+2001:470:94f3::,2001:470:9616:ffff:ffff:ffff:ffff:ffff,US
+2001:470:9617::,2001:470:9617:7fff:ffff:ffff:ffff:ffff,GB
+2001:470:9617:8000::,2001:470:9678:ffff:ffff:ffff:ffff:ffff,US
+2001:470:9679::,2001:470:9679:7fff:ffff:ffff:ffff:ffff,GB
+2001:470:9679:8000::,2001:470:974e:ffff:ffff:ffff:ffff:ffff,US
+2001:470:974f::,2001:470:974f:7fff:ffff:ffff:ffff:ffff,GB
+2001:470:974f:8000::,2001:470:9794:ffff:ffff:ffff:ffff:ffff,US
 2001:470:9795::,2001:470:9795:ffff:ffff:ffff:ffff:ffff,GB
-2001:470:9796::,2001:470:999c:ffff:ffff:ffff:ffff:ffff,US
+2001:470:9796::,2001:470:98e1:ffff:ffff:ffff:ffff:ffff,US
+2001:470:98e2::,2001:470:98e2:7fff:ffff:ffff:ffff:ffff,DE
+2001:470:98e2:8000::,2001:470:999c:ffff:ffff:ffff:ffff:ffff,US
 2001:470:999d::,2001:470:999d:ffff:ffff:ffff:ffff:ffff,DE
-2001:470:999e::,2001:470:9d38:ffff:ffff:ffff:ffff:ffff,US
+2001:470:999e::,2001:470:99b8:ffff:ffff:ffff:ffff:ffff,US
+2001:470:99b9::,2001:470:99b9:7fff:ffff:ffff:ffff:ffff,DE
+2001:470:99b9:8000::,2001:470:9d38:ffff:ffff:ffff:ffff:ffff,US
 2001:470:9d39::,2001:470:9d39:7fff:ffff:ffff:ffff:ffff,DE
-2001:470:9d39:8000::,2001:470:b0e1:ffff:ffff:ffff:ffff:ffff,US
+2001:470:9d39:8000::,2001:470:9f5e:ffff:ffff:ffff:ffff:ffff,US
+2001:470:9f5f::,2001:470:9f5f:7fff:ffff:ffff:ffff:ffff,RU
+2001:470:9f5f:8000::,2001:470:b009:ffff:ffff:ffff:ffff:ffff,US
+2001:470:b00a::,2001:470:b00a:7fff:ffff:ffff:ffff:ffff,CA
+2001:470:b00a:8000::,2001:470:b047:ffff:ffff:ffff:ffff:ffff,US
+2001:470:b048::,2001:470:b048:7fff:ffff:ffff:ffff:ffff,CA
+2001:470:b048:8000::,2001:470:b083:ffff:ffff:ffff:ffff:ffff,US
+2001:470:b084::,2001:470:b084:7fff:ffff:ffff:ffff:ffff,CA
+2001:470:b084:8000::,2001:470:b08d:ffff:ffff:ffff:ffff:ffff,US
+2001:470:b08e::,2001:470:b08e:7fff:ffff:ffff:ffff:ffff,CA
+2001:470:b08e:8000::,2001:470:b0e1:ffff:ffff:ffff:ffff:ffff,US
 2001:470:b0e2::,2001:470:b0e2:ffff:ffff:ffff:ffff:ffff,CA
-2001:470:b0e3::,2001:470:b59e:ffff:ffff:ffff:ffff:ffff,US
+2001:470:b0e3::,2001:470:b136:7fff:ffff:ffff:ffff:ffff,US
+2001:470:b136:8000::,2001:470:b136:ffff:ffff:ffff:ffff:ffff,CA
+2001:470:b137::,2001:470:b14d:ffff:ffff:ffff:ffff:ffff,US
+2001:470:b14e::,2001:470:b14e:7fff:ffff:ffff:ffff:ffff,CA
+2001:470:b14e:8000::,2001:470:b16f:ffff:ffff:ffff:ffff:ffff,US
+2001:470:b170::,2001:470:b170:7fff:ffff:ffff:ffff:ffff,CA
+2001:470:b170:8000::,2001:470:b1c3:ffff:ffff:ffff:ffff:ffff,US
+2001:470:b1c4::,2001:470:b1c4:7fff:ffff:ffff:ffff:ffff,CA
+2001:470:b1c4:8000::,2001:470:b218:ffff:ffff:ffff:ffff:ffff,US
+2001:470:b219::,2001:470:b219:7fff:ffff:ffff:ffff:ffff,CA
+2001:470:b219:8000::,2001:470:b23e:ffff:ffff:ffff:ffff:ffff,US
+2001:470:b23f::,2001:470:b23f:7fff:ffff:ffff:ffff:ffff,CA
+2001:470:b23f:8000::,2001:470:b24b:ffff:ffff:ffff:ffff:ffff,US
+2001:470:b24c::,2001:470:b24c:7fff:ffff:ffff:ffff:ffff,DO
+2001:470:b24c:8000::,2001:470:b27e:ffff:ffff:ffff:ffff:ffff,US
+2001:470:b27f::,2001:470:b27f:7fff:ffff:ffff:ffff:ffff,CA
+2001:470:b27f:8000::,2001:470:b2a6:ffff:ffff:ffff:ffff:ffff,US
+2001:470:b2a7::,2001:470:b2a7:7fff:ffff:ffff:ffff:ffff,CA
+2001:470:b2a7:8000::,2001:470:b2d4:ffff:ffff:ffff:ffff:ffff,US
+2001:470:b2d5::,2001:470:b2d5:7fff:ffff:ffff:ffff:ffff,CA
+2001:470:b2d5:8000::,2001:470:b2d9:ffff:ffff:ffff:ffff:ffff,US
+2001:470:b2da::,2001:470:b2da:7fff:ffff:ffff:ffff:ffff,CA
+2001:470:b2da:8000::,2001:470:b30c:ffff:ffff:ffff:ffff:ffff,US
+2001:470:b30d::,2001:470:b30d:7fff:ffff:ffff:ffff:ffff,CN
+2001:470:b30d:8000::,2001:470:b328:ffff:ffff:ffff:ffff:ffff,US
+2001:470:b329::,2001:470:b329:7fff:ffff:ffff:ffff:ffff,CA
+2001:470:b329:8000::,2001:470:b336:7fff:ffff:ffff:ffff:ffff,US
+2001:470:b336:8000::,2001:470:b336:ffff:ffff:ffff:ffff:ffff,CA
+2001:470:b337::,2001:470:b34f:ffff:ffff:ffff:ffff:ffff,US
+2001:470:b350::,2001:470:b350:7fff:ffff:ffff:ffff:ffff,CA
+2001:470:b350:8000::,2001:470:b36c:ffff:ffff:ffff:ffff:ffff,US
+2001:470:b36d::,2001:470:b36d:7fff:ffff:ffff:ffff:ffff,CA
+2001:470:b36d:8000::,2001:470:b398:ffff:ffff:ffff:ffff:ffff,US
+2001:470:b399::,2001:470:b399:7fff:ffff:ffff:ffff:ffff,CA
+2001:470:b399:8000::,2001:470:b3b5:ffff:ffff:ffff:ffff:ffff,US
+2001:470:b3b6::,2001:470:b3b6:7fff:ffff:ffff:ffff:ffff,CA
+2001:470:b3b6:8000::,2001:470:b41b:ffff:ffff:ffff:ffff:ffff,US
+2001:470:b41c::,2001:470:b41c:7fff:ffff:ffff:ffff:ffff,CH
+2001:470:b41c:8000::,2001:470:b431:7fff:ffff:ffff:ffff:ffff,US
+2001:470:b431:8000::,2001:470:b431:ffff:ffff:ffff:ffff:ffff,CH
+2001:470:b432::,2001:470:b4a4:ffff:ffff:ffff:ffff:ffff,US
+2001:470:b4a5::,2001:470:b4a5:7fff:ffff:ffff:ffff:ffff,DE
+2001:470:b4a5:8000::,2001:470:b4e9:ffff:ffff:ffff:ffff:ffff,US
+2001:470:b4ea::,2001:470:b4ea:ffff:ffff:ffff:ffff:ffff,AT
+2001:470:b4eb::,2001:470:b517:ffff:ffff:ffff:ffff:ffff,US
+2001:470:b518::,2001:470:b518:7fff:ffff:ffff:ffff:ffff,PL
+2001:470:b518:8000::,2001:470:b59e:ffff:ffff:ffff:ffff:ffff,US
 2001:470:b59f::,2001:470:b59f:7fff:ffff:ffff:ffff:ffff,CH
-2001:470:b59f:8000::,2001:470:b625:ffff:ffff:ffff:ffff:ffff,US
-2001:470:b626::,2001:470:b626:ff:ffff:ffff:ffff:ffff,DE
-2001:470:b626:100::,2001:470:c9b2:ffff:ffff:ffff:ffff:ffff,US
+2001:470:b59f:8000::,2001:470:b5f5:ffff:ffff:ffff:ffff:ffff,US
+2001:470:b5f6::,2001:470:b5f6:7fff:ffff:ffff:ffff:ffff,DE
+2001:470:b5f6:8000::,2001:470:b60d:ffff:ffff:ffff:ffff:ffff,US
+2001:470:b60e::,2001:470:b60e:7fff:ffff:ffff:ffff:ffff,DE
+2001:470:b60e:8000::,2001:470:b625:ffff:ffff:ffff:ffff:ffff,US
+2001:470:b626::,2001:470:b626:7fff:ffff:ffff:ffff:ffff,DE
+2001:470:b626:8000::,2001:470:b7b6:ffff:ffff:ffff:ffff:ffff,US
+2001:470:b7b7::,2001:470:b7b7:7fff:ffff:ffff:ffff:ffff,AT
+2001:470:b7b7:8000::,2001:470:b8e6:ffff:ffff:ffff:ffff:ffff,US
+2001:470:b8e7::,2001:470:b8e7:7fff:ffff:ffff:ffff:ffff,CR
+2001:470:b8e7:8000::,2001:470:c17a:ffff:ffff:ffff:ffff:ffff,US
+2001:470:c17b::,2001:470:c17b:7fff:ffff:ffff:ffff:ffff,CA
+2001:470:c17b:8000::,2001:470:c322:ffff:ffff:ffff:ffff:ffff,US
+2001:470:c323::,2001:470:c323:7fff:ffff:ffff:ffff:ffff,CA
+2001:470:c323:8000::,2001:470:c385:ffff:ffff:ffff:ffff:ffff,US
+2001:470:c386::,2001:470:c386:7fff:ffff:ffff:ffff:ffff,CA
+2001:470:c386:8000::,2001:470:c81c:ffff:ffff:ffff:ffff:ffff,US
+2001:470:c81d::,2001:470:c81d:7fff:ffff:ffff:ffff:ffff,TN
+2001:470:c81d:8000::,2001:470:c8b7:7fff:ffff:ffff:ffff:ffff,US
+2001:470:c8b7:8000::,2001:470:c8b7:ffff:ffff:ffff:ffff:ffff,FR
+2001:470:c8b8::,2001:470:c8f1:ffff:ffff:ffff:ffff:ffff,US
+2001:470:c8f2::,2001:470:c8f2:7fff:ffff:ffff:ffff:ffff,ES
+2001:470:c8f2:8000::,2001:470:c9b2:ffff:ffff:ffff:ffff:ffff,US
 2001:470:c9b3::,2001:470:c9b3:7fff:ffff:ffff:ffff:ffff,ES
-2001:470:c9b3:8000::,2001:470:d6b8:ffff:ffff:ffff:ffff:ffff,US
+2001:470:c9b3:8000::,2001:470:cd93:7fff:ffff:ffff:ffff:ffff,US
+2001:470:cd93:8000::,2001:470:cd93:ffff:ffff:ffff:ffff:ffff,FR
+2001:470:cd94::,2001:470:d050:ffff:ffff:ffff:ffff:ffff,US
+2001:470:d051::,2001:470:d051:7fff:ffff:ffff:ffff:ffff,NL
+2001:470:d051:8000::,2001:470:d075:ffff:ffff:ffff:ffff:ffff,US
+2001:470:d076::,2001:470:d076:7fff:ffff:ffff:ffff:ffff,NL
+2001:470:d076:8000::,2001:470:d17a:ffff:ffff:ffff:ffff:ffff,US
+2001:470:d17b::,2001:470:d17b:7fff:ffff:ffff:ffff:ffff,PL
+2001:470:d17b:8000::,2001:470:d4ec:ffff:ffff:ffff:ffff:ffff,US
+2001:470:d4ed::,2001:470:d4ed:7fff:ffff:ffff:ffff:ffff,FR
+2001:470:d4ed:8000::,2001:470:d6b8:ffff:ffff:ffff:ffff:ffff,US
 2001:470:d6b9::,2001:470:d6b9:7fff:ffff:ffff:ffff:ffff,RU
-2001:470:d6b9:8000::,2001:470:dd94:ffff:ffff:ffff:ffff:ffff,US
+2001:470:d6b9:8000::,2001:470:d6e2:ffff:ffff:ffff:ffff:ffff,US
+2001:470:d6e3::,2001:470:d6e3:7fff:ffff:ffff:ffff:ffff,NL
+2001:470:d6e3:8000::,2001:470:d890:ffff:ffff:ffff:ffff:ffff,US
+2001:470:d891::,2001:470:d891:7fff:ffff:ffff:ffff:ffff,BR
+2001:470:d891:8000::,2001:470:d9cc:ffff:ffff:ffff:ffff:ffff,US
+2001:470:d9cd::,2001:470:d9cd:7fff:ffff:ffff:ffff:ffff,DO
+2001:470:d9cd:8000::,2001:470:da01:ffff:ffff:ffff:ffff:ffff,US
+2001:470:da02::,2001:470:da02:7fff:ffff:ffff:ffff:ffff,AR
+2001:470:da02:8000::,2001:470:db28:ffff:ffff:ffff:ffff:ffff,US
+2001:470:db29::,2001:470:db29:7fff:ffff:ffff:ffff:ffff,DO
+2001:470:db29:8000::,2001:470:dc00:ffff:ffff:ffff:ffff:ffff,US
+2001:470:dc01::,2001:470:dc01:7fff:ffff:ffff:ffff:ffff,SE
+2001:470:dc01:8000::,2001:470:dc08:ffff:ffff:ffff:ffff:ffff,US
+2001:470:dc09::,2001:470:dc09:7fff:ffff:ffff:ffff:ffff,SE
+2001:470:dc09:8000::,2001:470:dc24:ffff:ffff:ffff:ffff:ffff,US
+2001:470:dc25::,2001:470:dc25:7fff:ffff:ffff:ffff:ffff,RU
+2001:470:dc25:8000::,2001:470:dc59:ffff:ffff:ffff:ffff:ffff,US
+2001:470:dc5a::,2001:470:dc5a:7fff:ffff:ffff:ffff:ffff,SE
+2001:470:dc5a:8000::,2001:470:dcb3:ffff:ffff:ffff:ffff:ffff,US
+2001:470:dcb4::,2001:470:dcb4:7fff:ffff:ffff:ffff:ffff,NO
+2001:470:dcb4:8000::,2001:470:dcc3:ffff:ffff:ffff:ffff:ffff,US
+2001:470:dcc4::,2001:470:dcc4:7fff:ffff:ffff:ffff:ffff,SE
+2001:470:dcc4:8000::,2001:470:dcd0:ffff:ffff:ffff:ffff:ffff,US
+2001:470:dcd1::,2001:470:dcd1:7fff:ffff:ffff:ffff:ffff,SE
+2001:470:dcd1:8000::,2001:470:dd03:ffff:ffff:ffff:ffff:ffff,US
+2001:470:dd04::,2001:470:dd04:7fff:ffff:ffff:ffff:ffff,SE
+2001:470:dd04:8000::,2001:470:dd3a:ffff:ffff:ffff:ffff:ffff,US
+2001:470:dd3b::,2001:470:dd3b:7fff:ffff:ffff:ffff:ffff,FI
+2001:470:dd3b:8000::,2001:470:dd94:ffff:ffff:ffff:ffff:ffff,US
 2001:470:dd95::,2001:470:dd95:7fff:ffff:ffff:ffff:ffff,UA
-2001:470:dd95:8000::,2001:470:deb5:7fff:ffff:ffff:ffff:ffff,US
+2001:470:dd95:8000::,2001:470:dda1:ffff:ffff:ffff:ffff:ffff,US
+2001:470:dda2::,2001:470:dda2:7fff:ffff:ffff:ffff:ffff,SE
+2001:470:dda2:8000::,2001:470:dde6:ffff:ffff:ffff:ffff:ffff,US
+2001:470:dde7::,2001:470:dde7:7fff:ffff:ffff:ffff:ffff,SE
+2001:470:dde7:8000::,2001:470:ddf5:ffff:ffff:ffff:ffff:ffff,US
+2001:470:ddf6::,2001:470:ddf6:7fff:ffff:ffff:ffff:ffff,SE
+2001:470:ddf6:8000::,2001:470:de4a:ffff:ffff:ffff:ffff:ffff,US
+2001:470:de4b::,2001:470:de4b:7fff:ffff:ffff:ffff:ffff,SE
+2001:470:de4b:8000::,2001:470:de8a:ffff:ffff:ffff:ffff:ffff,US
+2001:470:de8b::,2001:470:de8b:7fff:ffff:ffff:ffff:ffff,RU
+2001:470:de8b:8000::,2001:470:deb5:7fff:ffff:ffff:ffff:ffff,US
 2001:470:deb5:8000::,2001:470:deb5:ffff:ffff:ffff:ffff:ffff,RU
-2001:470:deb6::,2001:470:dec3:ffff:ffff:ffff:ffff:ffff,US
+2001:470:deb6::,2001:470:debb:ffff:ffff:ffff:ffff:ffff,US
+2001:470:debc::,2001:470:debc:7fff:ffff:ffff:ffff:ffff,SE
+2001:470:debc:8000::,2001:470:dec3:ffff:ffff:ffff:ffff:ffff,US
 2001:470:dec4::,2001:470:dec4:ffff:ffff:ffff:ffff:ffff,SE
-2001:470:dec5::,2001:470:ea76:ffff:ffff:ffff:ffff:ffff,US
+2001:470:dec5::,2001:470:df35:ffff:ffff:ffff:ffff:ffff,US
+2001:470:df36::,2001:470:df36:7fff:ffff:ffff:ffff:ffff,RU
+2001:470:df36:8000::,2001:470:df6f:ffff:ffff:ffff:ffff:ffff,US
+2001:470:df70::,2001:470:df70:7fff:ffff:ffff:ffff:ffff,SE
+2001:470:df70:8000::,2001:470:df7c:ffff:ffff:ffff:ffff:ffff,US
+2001:470:df7d::,2001:470:df7d:7fff:ffff:ffff:ffff:ffff,SE
+2001:470:df7d:8000::,2001:470:dfd5:ffff:ffff:ffff:ffff:ffff,US
+2001:470:dfd6::,2001:470:dfd6:7fff:ffff:ffff:ffff:ffff,NO
+2001:470:dfd6:8000::,2001:470:e1e4:ffff:ffff:ffff:ffff:ffff,US
+2001:470:e1e5::,2001:470:e1e5:7fff:ffff:ffff:ffff:ffff,CA
+2001:470:e1e5:8000::,2001:470:e20e:ffff:ffff:ffff:ffff:ffff,US
+2001:470:e20f::,2001:470:e20f:7fff:ffff:ffff:ffff:ffff,CA
+2001:470:e20f:8000::,2001:470:e2fa:ffff:ffff:ffff:ffff:ffff,US
+2001:470:e2fb::,2001:470:e2fb:7fff:ffff:ffff:ffff:ffff,CA
+2001:470:e2fb:8000::,2001:470:e939:ffff:ffff:ffff:ffff:ffff,US
+2001:470:e93a::,2001:470:e93a:7fff:ffff:ffff:ffff:ffff,CA
+2001:470:e93a:8000::,2001:470:e97e:ffff:ffff:ffff:ffff:ffff,US
+2001:470:e97f::,2001:470:e97f:7fff:ffff:ffff:ffff:ffff,CA
+2001:470:e97f:8000::,2001:470:e9ef:ffff:ffff:ffff:ffff:ffff,US
+2001:470:e9f0::,2001:470:e9f0:7fff:ffff:ffff:ffff:ffff,CA
+2001:470:e9f0:8000::,2001:470:ea08:ffff:ffff:ffff:ffff:ffff,US
+2001:470:ea09::,2001:470:ea09:7fff:ffff:ffff:ffff:ffff,CA
+2001:470:ea09:8000::,2001:470:ea76:ffff:ffff:ffff:ffff:ffff,US
 2001:470:ea77::,2001:470:ea77:7fff:ffff:ffff:ffff:ffff,AU
-2001:470:ea77:8000::,2001:470:ed42:ffff:ffff:ffff:ffff:ffff,US
+2001:470:ea77:8000::,2001:470:ecf5:ffff:ffff:ffff:ffff:ffff,US
+2001:470:ecf6::,2001:470:ecf6:7fff:ffff:ffff:ffff:ffff,ID
+2001:470:ecf6:8000::,2001:470:ecf6:ffff:ffff:ffff:ffff:ffff,US
+2001:470:ecf7::,2001:470:ecf7:7fff:ffff:ffff:ffff:ffff,ID
+2001:470:ecf7:8000::,2001:470:ed26:ffff:ffff:ffff:ffff:ffff,US
+2001:470:ed27::,2001:470:ed27:7fff:ffff:ffff:ffff:ffff,ID
+2001:470:ed27:8000::,2001:470:ed39:ffff:ffff:ffff:ffff:ffff,US
+2001:470:ed3a::,2001:470:ed3a:7fff:ffff:ffff:ffff:ffff,SG
+2001:470:ed3a:8000::,2001:470:ed3c:ffff:ffff:ffff:ffff:ffff,US
+2001:470:ed3d::,2001:470:ed3d:7fff:ffff:ffff:ffff:ffff,SG
+2001:470:ed3d:8000::,2001:470:ed42:ffff:ffff:ffff:ffff:ffff,US
 2001:470:ed43::,2001:470:ed43:7fff:ffff:ffff:ffff:ffff,ID
 2001:470:ed43:8000::,2001:470:ef84:ffff:ffff:ffff:ffff:ffff,US
 2001:470:ef85::,2001:470:ef85:7fff:ffff:ffff:ffff:ffff,CN
 2001:470:ef85:8000::,2001:470:f088:ffff:ffff:ffff:ffff:ffff,US
 2001:470:f089::,2001:470:f089:7fff:ffff:ffff:ffff:ffff,CN
-2001:470:f089:8000::,2001:470:f891:ffff:ffff:ffff:ffff:ffff,US
+2001:470:f089:8000::,2001:470:f091:ffff:ffff:ffff:ffff:ffff,US
+2001:470:f092::,2001:470:f092:7fff:ffff:ffff:ffff:ffff,CN
+2001:470:f092:8000::,2001:470:f1fa:ffff:ffff:ffff:ffff:ffff,US
+2001:470:f1fb::,2001:470:f1fb:7fff:ffff:ffff:ffff:ffff,CN
+2001:470:f1fb:8000::,2001:470:f270:ffff:ffff:ffff:ffff:ffff,US
+2001:470:f271::,2001:470:f271:7fff:ffff:ffff:ffff:ffff,AU
+2001:470:f271:8000::,2001:470:f382:ffff:ffff:ffff:ffff:ffff,US
+2001:470:f383::,2001:470:f383:7fff:ffff:ffff:ffff:ffff,CN
+2001:470:f383:8000::,2001:470:f3bd:ffff:ffff:ffff:ffff:ffff,US
+2001:470:f3be::,2001:470:f3be:ffff:ffff:ffff:ffff:ffff,CN
+2001:470:f3bf::,2001:470:f4b4:7fff:ffff:ffff:ffff:ffff,US
+2001:470:f4b4:8000::,2001:470:f4b4:ffff:ffff:ffff:ffff:ffff,CN
+2001:470:f4b5::,2001:470:f4c3:ffff:ffff:ffff:ffff:ffff,US
+2001:470:f4c4::,2001:470:f4c4:7fff:ffff:ffff:ffff:ffff,CN
+2001:470:f4c4:8000::,2001:470:f818:ffff:ffff:ffff:ffff:ffff,US
+2001:470:f819::,2001:470:f819:7fff:ffff:ffff:ffff:ffff,CN
+2001:470:f819:8000::,2001:470:f83d:7fff:ffff:ffff:ffff:ffff,US
+2001:470:f83d:8000::,2001:470:f83d:ffff:ffff:ffff:ffff:ffff,CN
+2001:470:f83e::,2001:470:f891:ffff:ffff:ffff:ffff:ffff,US
 2001:470:f892::,2001:470:f892:7fff:ffff:ffff:ffff:ffff,CN
-2001:470:f892:8000::,2001:470:fb3b:ffff:ffff:ffff:ffff:ffff,US
+2001:470:f892:8000::,2001:470:f90f:7fff:ffff:ffff:ffff:ffff,US
+2001:470:f90f:8000::,2001:470:f90f:ffff:ffff:ffff:ffff:ffff,CN
+2001:470:f910::,2001:470:f91b:ffff:ffff:ffff:ffff:ffff,US
+2001:470:f91c::,2001:470:f91c:7fff:ffff:ffff:ffff:ffff,CN
+2001:470:f91c:8000::,2001:470:fa48:ffff:ffff:ffff:ffff:ffff,US
+2001:470:fa49::,2001:470:fa49:7fff:ffff:ffff:ffff:ffff,CN
+2001:470:fa49:8000::,2001:470:fa6b:ffff:ffff:ffff:ffff:ffff,US
+2001:470:fa6c::,2001:470:fa6c:7fff:ffff:ffff:ffff:ffff,HK
+2001:470:fa6c:8000::,2001:470:fa87:ffff:ffff:ffff:ffff:ffff,US
+2001:470:fa88::,2001:470:fa88:7fff:ffff:ffff:ffff:ffff,HK
+2001:470:fa88:8000::,2001:470:fabc:ffff:ffff:ffff:ffff:ffff,US
+2001:470:fabd::,2001:470:fabd:7fff:ffff:ffff:ffff:ffff,HK
+2001:470:fabd:8000::,2001:470:fb3b:ffff:ffff:ffff:ffff:ffff,US
 2001:470:fb3c::,2001:470:fb3c:7fff:ffff:ffff:ffff:ffff,CN
-2001:470:fb3c:8000::,2001:470:fc78:ffff:ffff:ffff:ffff:ffff,US
+2001:470:fb3c:8000::,2001:470:fc62:ffff:ffff:ffff:ffff:ffff,US
+2001:470:fc63::,2001:470:fc63:7fff:ffff:ffff:ffff:ffff,CN
+2001:470:fc63:8000::,2001:470:fc78:ffff:ffff:ffff:ffff:ffff,US
 2001:470:fc79::,2001:470:fc79:7fff:ffff:ffff:ffff:ffff,JP
 2001:470:fc79:8000::,2001:470:fc86:7fff:ffff:ffff:ffff:ffff,US
 2001:470:fc86:8000::,2001:470:fc86:ffff:ffff:ffff:ffff:ffff,JP
 2001:470:fc87::,2001:470:fdfe:ffff:ffff:ffff:ffff:ffff,US
 2001:470:fdff::,2001:470:fdff:7fff:ffff:ffff:ffff:ffff,JP
-2001:470:fdff:8000::,2001:470:fe7c:7fff:ffff:ffff:ffff:ffff,US
+2001:470:fdff:8000::,2001:470:fe3f:ffff:ffff:ffff:ffff:ffff,US
+2001:470:fe40::,2001:470:fe40:7fff:ffff:ffff:ffff:ffff,JP
+2001:470:fe40:8000::,2001:470:fe7c:7fff:ffff:ffff:ffff:ffff,US
 2001:470:fe7c:8000::,2001:470:fe7c:ffff:ffff:ffff:ffff:ffff,CN
-2001:470:fe7d::,2001:470:ffff:ffff:ffff:ffff:ffff:ffff,US
+2001:470:fe7d::,2001:470:fecb:ffff:ffff:ffff:ffff:ffff,US
+2001:470:fecc::,2001:470:fecc:7fff:ffff:ffff:ffff:ffff,CN
+2001:470:fecc:8000::,2001:470:ffff:ffff:ffff:ffff:ffff:ffff,US
 2001:478::,2001:478:ffff:ffff:ffff:ffff:ffff:ffff,KN
 2001:480::,2001:480:ffff:ffff:ffff:ffff:ffff:ffff,US
 2001:490::,2001:490:ffff:ffff:ffff:ffff:ffff:ffff,US
@@ -354,6 +885,7 @@
 2001:504:43::,2001:504:45:ffff:ffff:ffff:ffff:ffff,US
 2001:504:46::,2001:504:46:ffff:ffff:ffff:ffff:ffff,CA
 2001:504:47::,2001:504:47:ffff:ffff:ffff:ffff:ffff,US
+2001:504:57::,2001:504:58:ffff:ffff:ffff:ffff:ffff,US
 2001:506::,2001:506:1:ffff:ffff:ffff:ffff:ffff,US
 2001:506:8::,2001:506:8:ffff:ffff:ffff:ffff:ffff,US
 2001:506:20::,2001:506:20:ffff:ffff:ffff:ffff:ffff,CA
@@ -376,7 +908,13 @@
 2001:550:0:1000::9a19:326,2001:550:0:1000::9a19:326,SI
 2001:550:0:1000::9a19:327,2001:550:0:1000::9a36:2631,US
 2001:550:0:1000::9a36:2632,2001:550:0:1000::9a36:2632,DE
-2001:550:0:1000::9a36:2633,2001:550:909:ffff:ffff:ffff:ffff:ffff,US
+2001:550:0:1000::9a36:2633,2001:550:7ff:ffff:ffff:ffff:ffff:ffff,US
+2001:550:800::,2001:550:800:7fff:ffff:ffff:ffff:ffff,CA
+2001:550:800:8000::,2001:550:801:ffff:ffff:ffff:ffff:ffff,US
+2001:550:802::,2001:550:802:7fff:ffff:ffff:ffff:ffff,CA
+2001:550:802:8000::,2001:550:907:ffff:ffff:ffff:ffff:ffff,US
+2001:550:908::,2001:550:908:7fff:ffff:ffff:ffff:ffff,CA
+2001:550:908:8000::,2001:550:909:ffff:ffff:ffff:ffff:ffff,US
 2001:550:90a::,2001:550:90a:7fff:ffff:ffff:ffff:ffff,CA
 2001:550:90a:8000::,2001:550:ffff:ffff:ffff:ffff:ffff:ffff,US
 2001:558::,2001:560:ffff:ffff:ffff:ffff:ffff:ffff,US
@@ -394,9 +932,15 @@
 2001:5b8::,2001:5b8:ffff:ffff:ffff:ffff:ffff:ffff,US
 2001:5c0:1000::,2001:5c0:10ff:ffff:ffff:ffff:ffff:ffff,CA
 2001:5c0:1100::,2001:5c0:1100::,US
-2001:5c0:1100::1,2001:5c0:1505:7fff:ffff:ffff:ffff:ffff,CA
+2001:5c0:1100::1,2001:5c0:1100:7fff:ffff:ffff:ffff:ffff,CA
+2001:5c0:1100:8000::,2001:5c0:1100:bfff:ffff:ffff:ffff:ffff,US
+2001:5c0:1100:c000::,2001:5c0:1501:7fff:ffff:ffff:ffff:ffff,CA
+2001:5c0:1501:8000::,2001:5c0:1501:ffff:ffff:ffff:ffff:ffff,RU
+2001:5c0:1502::,2001:5c0:1505:7fff:ffff:ffff:ffff:ffff,CA
 2001:5c0:1505:8000::,2001:5c0:1505:ffff:ffff:ffff:ffff:ffff,RU
-2001:5c0:1506::,2001:5c0:1fff:ffff:ffff:ffff:ffff:ffff,CA
+2001:5c0:1506::,2001:5c0:1508:7fff:ffff:ffff:ffff:ffff,CA
+2001:5c0:1508:8000::,2001:5c0:1508:ffff:ffff:ffff:ffff:ffff,ES
+2001:5c0:1509::,2001:5c0:1fff:ffff:ffff:ffff:ffff:ffff,CA
 2001:5c8::,2001:5c8:ffff:ffff:ffff:ffff:ffff:ffff,US
 2001:5d0::,2001:5d0:ffff:ffff:ffff:ffff:ffff:ffff,US
 2001:5d8::,2001:5d8:ffff:ffff:ffff:ffff:ffff:ffff,US
@@ -415,9 +959,11 @@
 2001:648::,2001:64f:ffff:ffff:ffff:ffff:ffff:ffff,GR
 2001:650::,2001:65f:ffff:ffff:ffff:ffff:ffff:ffff,DE
 2001:660::,2001:667:ffff:ffff:ffff:ffff:ffff:ffff,FR
-2001:668::,2001:668:1f:3d:ffff:ffff:ffff:ffff,DE
+2001:668::,2001:668:1e:ffff:ffff:ffff:ffff:ffff,DE
+2001:668:1f::,2001:668:1f:3d:ffff:ffff:ffff:ffff,US
 2001:668:1f:3e::,2001:668:1f:3e:ffff:ffff:ffff:ffff,GB
-2001:668:1f:3f::,2001:66f:ffff:ffff:ffff:ffff:ffff:ffff,DE
+2001:668:1f:3f::,2001:668:1f:7fff:ffff:ffff:ffff:ffff,US
+2001:668:1f:8000::,2001:66f:ffff:ffff:ffff:ffff:ffff:ffff,DE
 2001:670::,2001:673:ffff:ffff:ffff:ffff:ffff:ffff,FI
 2001:678:1::,2001:678:1:ffff:ffff:ffff:ffff:ffff,CZ
 2001:678:2::,2001:678:2:ffff:ffff:ffff:ffff:ffff,DE
@@ -468,7 +1014,25 @@
 2001:678:9c::,2001:678:9c:ffff:ffff:ffff:ffff:ffff,SK
 2001:678:a0::,2001:678:a0:ffff:ffff:ffff:ffff:ffff,FI
 2001:678:a4::,2001:678:a4:ffff:ffff:ffff:ffff:ffff,AT
+2001:678:a8::,2001:678:a8:ffff:ffff:ffff:ffff:ffff,NL
+2001:678:ac::,2001:678:ac:ffff:ffff:ffff:ffff:ffff,SE
 2001:678:b0::,2001:678:b3:ffff:ffff:ffff:ffff:ffff,IR
+2001:678:c0::,2001:678:c0:ffff:ffff:ffff:ffff:ffff,DE
+2001:678:c4::,2001:678:c4:ffff:ffff:ffff:ffff:ffff,DE
+2001:678:c8::,2001:678:c8:ffff:ffff:ffff:ffff:ffff,UA
+2001:678:cc::,2001:678:cc:ffff:ffff:ffff:ffff:ffff,SA
+2001:678:d0::,2001:678:d0:ffff:ffff:ffff:ffff:ffff,NL
+2001:678:d4::,2001:678:d4:ffff:ffff:ffff:ffff:ffff,IT
+2001:678:d8::,2001:678:d8:ffff:ffff:ffff:ffff:ffff,LV
+2001:678:dc::,2001:678:dc:ffff:ffff:ffff:ffff:ffff,NL
+2001:678:e0::,2001:678:e0:ffff:ffff:ffff:ffff:ffff,MD
+2001:678:e4::,2001:678:e4:ffff:ffff:ffff:ffff:ffff,SE
+2001:678:e8::,2001:678:e8:ffff:ffff:ffff:ffff:ffff,CZ
+2001:678:ec::,2001:678:ec:ffff:ffff:ffff:ffff:ffff,RU
+2001:678:f0::,2001:678:f0:ffff:ffff:ffff:ffff:ffff,SE
+2001:678:f4::,2001:678:f4:ffff:ffff:ffff:ffff:ffff,RU
+2001:678:f8::,2001:678:f8:ffff:ffff:ffff:ffff:ffff,DE
+2001:678:fc::,2001:678:fc:ffff:ffff:ffff:ffff:ffff,LT
 2001:67c::,2001:67c::ffff:ffff:ffff:ffff:ffff,IE
 2001:67c:4::,2001:67c:4:ffff:ffff:ffff:ffff:ffff,DE
 2001:67c:8::,2001:67c:8:ffff:ffff:ffff:ffff:ffff,CH
@@ -494,10 +1058,11 @@
 2001:67c:58::,2001:67c:58:ffff:ffff:ffff:ffff:ffff,SI
 2001:67c:5c::,2001:67c:5c:ffff:ffff:ffff:ffff:ffff,BE
 2001:67c:60::,2001:67c:60:ffff:ffff:ffff:ffff:ffff,NL
-2001:67c:64::,2001:67c:64:ffff:ffff:ffff:ffff:ffff,NL
+2001:67c:64::,2001:67c:64:ffff:ffff:ffff:ffff:ffff,RO
 2001:67c:68::,2001:67c:68:ffff:ffff:ffff:ffff:ffff,CZ
 2001:67c:6c::,2001:67c:6c:ffff:ffff:ffff:ffff:ffff,IS
 2001:67c:70::,2001:67c:70:ffff:ffff:ffff:ffff:ffff,FR
+2001:67c:78::,2001:67c:78:ffff:ffff:ffff:ffff:ffff,NL
 2001:67c:7c::,2001:67c:7c:ffff:ffff:ffff:ffff:ffff,AT
 2001:67c:80::,2001:67c:80:ffff:ffff:ffff:ffff:ffff,GB
 2001:67c:84::,2001:67c:84:ffff:ffff:ffff:ffff:ffff,CZ
@@ -540,6 +1105,7 @@
 2001:67c:11c::,2001:67c:11c:ffff:ffff:ffff:ffff:ffff,PL
 2001:67c:120::,2001:67c:120:ffff:ffff:ffff:ffff:ffff,BE
 2001:67c:124::,2001:67c:124:ffff:ffff:ffff:ffff:ffff,SI
+2001:67c:128::,2001:67c:128:ffff:ffff:ffff:ffff:ffff,DE
 2001:67c:12c::,2001:67c:12c:ffff:ffff:ffff:ffff:ffff,FI
 2001:67c:130::,2001:67c:130:ffff:ffff:ffff:ffff:ffff,SA
 2001:67c:134::,2001:67c:134:ffff:ffff:ffff:ffff:ffff,DE
@@ -608,6 +1174,9 @@
 2001:67c:230::,2001:67c:230:ffff:ffff:ffff:ffff:ffff,NO
 2001:67c:234::,2001:67c:234:ffff:ffff:ffff:ffff:ffff,CH
 2001:67c:238::,2001:67c:238:ffff:ffff:ffff:ffff:ffff,DK
+2001:67c:23c::,2001:67c:23c:ffff:ffff:ffff:ffff:ffff,SE
+2001:67c:240::,2001:67c:240:ffff:ffff:ffff:ffff:ffff,AT
+2001:67c:244::,2001:67c:244:ffff:ffff:ffff:ffff:ffff,UA
 2001:67c:248::,2001:67c:248:ffff:ffff:ffff:ffff:ffff,AT
 2001:67c:24c::,2001:67c:24c:ffff:ffff:ffff:ffff:ffff,PL
 2001:67c:250::,2001:67c:250:ffff:ffff:ffff:ffff:ffff,DE
@@ -652,7 +1221,8 @@
 2001:67c:2f0::,2001:67c:2f0:ffff:ffff:ffff:ffff:ffff,RU
 2001:67c:2f4::,2001:67c:2f4:ffff:ffff:ffff:ffff:ffff,LU
 2001:67c:2f8::,2001:67c:2f8:ffff:ffff:ffff:ffff:ffff,CH
-2001:67c:2fc::,2001:67c:2fc:ffff:ffff:ffff:ffff:ffff,DE
+2001:67c:2fc::,2001:67c:2fc:7fff:ffff:ffff:ffff:ffff,DE
+2001:67c:2fc:8000::,2001:67c:2fc:ffff:ffff:ffff:ffff:ffff,US
 2001:67c:300::,2001:67c:300:ffff:ffff:ffff:ffff:ffff,SI
 2001:67c:304::,2001:67c:304:ffff:ffff:ffff:ffff:ffff,BE
 2001:67c:308::,2001:67c:308:ffff:ffff:ffff:ffff:ffff,DE
@@ -744,7 +1314,6 @@
 2001:67c:464::,2001:67c:464:ffff:ffff:ffff:ffff:ffff,TR
 2001:67c:468::,2001:67c:468:ffff:ffff:ffff:ffff:ffff,PL
 2001:67c:46c::,2001:67c:46c:ffff:ffff:ffff:ffff:ffff,CH
-2001:67c:470::,2001:67c:470:ffff:ffff:ffff:ffff:ffff,RO
 2001:67c:478::,2001:67c:478:ffff:ffff:ffff:ffff:ffff,NL
 2001:67c:47c::,2001:67c:47c:ffff:ffff:ffff:ffff:ffff,CH
 2001:67c:480::,2001:67c:480:ffff:ffff:ffff:ffff:ffff,NO
@@ -837,6 +1406,7 @@
 2001:67c:5e8::,2001:67c:5e8:ffff:ffff:ffff:ffff:ffff,UA
 2001:67c:5ec::,2001:67c:5ec:ffff:ffff:ffff:ffff:ffff,DE
 2001:67c:5f0::,2001:67c:5f0:ffff:ffff:ffff:ffff:ffff,SI
+2001:67c:5f4::,2001:67c:5f4:ffff:ffff:ffff:ffff:ffff,SE
 2001:67c:5f8::,2001:67c:5f8:ffff:ffff:ffff:ffff:ffff,NL
 2001:67c:5fc::,2001:67c:5fc:ffff:ffff:ffff:ffff:ffff,AT
 2001:67c:600::,2001:67c:600:ffff:ffff:ffff:ffff:ffff,PL
@@ -970,9 +1540,11 @@
 2001:67c:1034::,2001:67c:1034:ffff:ffff:ffff:ffff:ffff,RO
 2001:67c:1038::,2001:67c:1038:ffff:ffff:ffff:ffff:ffff,RO
 2001:67c:103c::,2001:67c:103c:ffff:ffff:ffff:ffff:ffff,CZ
+2001:67c:1040::,2001:67c:1040:ffff:ffff:ffff:ffff:ffff,DE
 2001:67c:1044::,2001:67c:1044:ffff:ffff:ffff:ffff:ffff,CH
 2001:67c:1048::,2001:67c:1048:ffff:ffff:ffff:ffff:ffff,GB
 2001:67c:104c::,2001:67c:104c:ffff:ffff:ffff:ffff:ffff,NL
+2001:67c:1050::,2001:67c:1050:ffff:ffff:ffff:ffff:ffff,SK
 2001:67c:1054::,2001:67c:1054:ffff:ffff:ffff:ffff:ffff,DE
 2001:67c:1058::,2001:67c:1058:ffff:ffff:ffff:ffff:ffff,NL
 2001:67c:105c::,2001:67c:105c:ffff:ffff:ffff:ffff:ffff,GB
@@ -1035,7 +1607,6 @@
 2001:67c:1154::,2001:67c:1154:ffff:ffff:ffff:ffff:ffff,TR
 2001:67c:1158::,2001:67c:1158:ffff:ffff:ffff:ffff:ffff,PL
 2001:67c:115c::,2001:67c:115c:ffff:ffff:ffff:ffff:ffff,RO
-2001:67c:1160::,2001:67c:1160:ffff:ffff:ffff:ffff:ffff,RO
 2001:67c:1164::,2001:67c:1164:ffff:ffff:ffff:ffff:ffff,UA
 2001:67c:1168::,2001:67c:1168:ffff:ffff:ffff:ffff:ffff,PL
 2001:67c:116c::,2001:67c:116c:ffff:ffff:ffff:ffff:ffff,SE
@@ -1106,7 +1677,6 @@
 2001:67c:12a4::,2001:67c:12a4:ffff:ffff:ffff:ffff:ffff,TR
 2001:67c:12a8::,2001:67c:12a8:ffff:ffff:ffff:ffff:ffff,FI
 2001:67c:12ac::,2001:67c:12ac:ffff:ffff:ffff:ffff:ffff,LU
-2001:67c:12b0::,2001:67c:12b0:ffff:ffff:ffff:ffff:ffff,FR
 2001:67c:12b4::,2001:67c:12b4:ffff:ffff:ffff:ffff:ffff,GB
 2001:67c:12b8::,2001:67c:12b8:ffff:ffff:ffff:ffff:ffff,DE
 2001:67c:12bc::,2001:67c:12bc:ffff:ffff:ffff:ffff:ffff,SI
@@ -1143,7 +1713,9 @@
 2001:67c:1344::,2001:67c:1344:ffff:ffff:ffff:ffff:ffff,RU
 2001:67c:1348::,2001:67c:1348:ffff:ffff:ffff:ffff:ffff,FR
 2001:67c:134c::,2001:67c:134c:ffff:ffff:ffff:ffff:ffff,CZ
-2001:67c:1350::,2001:67c:1350:ffff:ffff:ffff:ffff:ffff,CY
+2001:67c:1350::,2001:67c:1350:1fff:ffff:ffff:ffff:ffff,CY
+2001:67c:1350:2000::,2001:67c:1350:3fff:ffff:ffff:ffff:ffff,SE
+2001:67c:1350:4000::,2001:67c:1350:ffff:ffff:ffff:ffff:ffff,CY
 2001:67c:1354::,2001:67c:1354:ffff:ffff:ffff:ffff:ffff,GB
 2001:67c:1358::,2001:67c:1358:ffff:ffff:ffff:ffff:ffff,RU
 2001:67c:135c::,2001:67c:135c:ffff:ffff:ffff:ffff:ffff,SE
@@ -1164,6 +1736,7 @@
 2001:67c:1398::,2001:67c:1398:ffff:ffff:ffff:ffff:ffff,SE
 2001:67c:139c::,2001:67c:139c:ffff:ffff:ffff:ffff:ffff,AT
 2001:67c:13a0::,2001:67c:13a0:ffff:ffff:ffff:ffff:ffff,UA
+2001:67c:13a4::,2001:67c:13a4:ffff:ffff:ffff:ffff:ffff,RO
 2001:67c:13a8::,2001:67c:13a8:ffff:ffff:ffff:ffff:ffff,GB
 2001:67c:13ac::,2001:67c:13ac:ffff:ffff:ffff:ffff:ffff,FI
 2001:67c:13b0::,2001:67c:13b0:ffff:ffff:ffff:ffff:ffff,DE
@@ -1199,6 +1772,7 @@
 2001:67c:149c::,2001:67c:149c:ffff:ffff:ffff:ffff:ffff,SI
 2001:67c:14a0::,2001:67c:14a0:ffff:ffff:ffff:ffff:ffff,CZ
 2001:67c:14a4::,2001:67c:14a4:ffff:ffff:ffff:ffff:ffff,BG
+2001:67c:14a8::,2001:67c:14a8:ffff:ffff:ffff:ffff:ffff,KZ
 2001:67c:14ac::,2001:67c:14ac:ffff:ffff:ffff:ffff:ffff,FR
 2001:67c:14b0::,2001:67c:14b0:ffff:ffff:ffff:ffff:ffff,NL
 2001:67c:14b4::,2001:67c:14b4:ffff:ffff:ffff:ffff:ffff,RU
@@ -1217,7 +1791,6 @@
 2001:67c:1508::,2001:67c:1508:ffff:ffff:ffff:ffff:ffff,AT
 2001:67c:150c::,2001:67c:150c:ffff:ffff:ffff:ffff:ffff,CH
 2001:67c:1510::,2001:67c:1510:ffff:ffff:ffff:ffff:ffff,GB
-2001:67c:1514::,2001:67c:1514:ffff:ffff:ffff:ffff:ffff,RO
 2001:67c:1518::,2001:67c:1518:ffff:ffff:ffff:ffff:ffff,UA
 2001:67c:151c::,2001:67c:151c:ffff:ffff:ffff:ffff:ffff,AT
 2001:67c:1520::,2001:67c:1520:ffff:ffff:ffff:ffff:ffff,GB
@@ -1239,6 +1812,7 @@
 2001:67c:1570::,2001:67c:1570:ffff:ffff:ffff:ffff:ffff,RU
 2001:67c:1574::,2001:67c:1574:ffff:ffff:ffff:ffff:ffff,RU
 2001:67c:1578::,2001:67c:1578:ffff:ffff:ffff:ffff:ffff,CZ
+2001:67c:157c::,2001:67c:157c:ffff:ffff:ffff:ffff:ffff,FR
 2001:67c:1580::,2001:67c:1580:ffff:ffff:ffff:ffff:ffff,CH
 2001:67c:1584::,2001:67c:1584:ffff:ffff:ffff:ffff:ffff,UA
 2001:67c:1588::,2001:67c:1588:ffff:ffff:ffff:ffff:ffff,UA
@@ -1340,7 +1914,6 @@
 2001:67c:17a4::,2001:67c:17a4:ffff:ffff:ffff:ffff:ffff,CH
 2001:67c:17a8::,2001:67c:17a8:ffff:ffff:ffff:ffff:ffff,SE
 2001:67c:17ac::,2001:67c:17ac:ffff:ffff:ffff:ffff:ffff,SE
-2001:67c:17b0::,2001:67c:17b0:ffff:ffff:ffff:ffff:ffff,PL
 2001:67c:17b4::,2001:67c:17b4:ffff:ffff:ffff:ffff:ffff,CZ
 2001:67c:17b8::,2001:67c:17b8:ffff:ffff:ffff:ffff:ffff,CZ
 2001:67c:17bc::,2001:67c:17bc:ffff:ffff:ffff:ffff:ffff,SE
@@ -1365,6 +1938,7 @@
 2001:67c:1808::,2001:67c:1809:ffff:ffff:ffff:ffff:ffff,BE
 2001:67c:1810::,2001:67c:1810:ffff:ffff:ffff:ffff:ffff,BE
 2001:67c:1814::,2001:67c:1814:ffff:ffff:ffff:ffff:ffff,FR
+2001:67c:1818::,2001:67c:1818:ffff:ffff:ffff:ffff:ffff,CH
 2001:67c:181c::,2001:67c:181c:ffff:ffff:ffff:ffff:ffff,DE
 2001:67c:1820::,2001:67c:1820:ffff:ffff:ffff:ffff:ffff,DE
 2001:67c:1824::,2001:67c:1824:ffff:ffff:ffff:ffff:ffff,IS
@@ -1388,7 +1962,6 @@
 2001:67c:186c::,2001:67c:186c:ffff:ffff:ffff:ffff:ffff,SE
 2001:67c:1870::,2001:67c:1870:ffff:ffff:ffff:ffff:ffff,NL
 2001:67c:1874::,2001:67c:1874:ffff:ffff:ffff:ffff:ffff,CZ
-2001:67c:1878::,2001:67c:1878:ffff:ffff:ffff:ffff:ffff,RO
 2001:67c:187c::,2001:67c:187c:ffff:ffff:ffff:ffff:ffff,RO
 2001:67c:1880::,2001:67c:1880:ffff:ffff:ffff:ffff:ffff,SE
 2001:67c:1884::,2001:67c:1884:ffff:ffff:ffff:ffff:ffff,GB
@@ -1407,7 +1980,6 @@
 2001:67c:18b8::,2001:67c:18b8:ffff:ffff:ffff:ffff:ffff,DE
 2001:67c:18bc::,2001:67c:18bc:ffff:ffff:ffff:ffff:ffff,DE
 2001:67c:18c0::,2001:67c:18c0:ffff:ffff:ffff:ffff:ffff,RO
-2001:67c:18c4::,2001:67c:18c4:ffff:ffff:ffff:ffff:ffff,RO
 2001:67c:18c8::,2001:67c:18c9:ffff:ffff:ffff:ffff:ffff,SA
 2001:67c:18d0::,2001:67c:18d0:ffff:ffff:ffff:ffff:ffff,RU
 2001:67c:18d4::,2001:67c:18d4:ffff:ffff:ffff:ffff:ffff,NZ
@@ -1442,6 +2014,7 @@
 2001:67c:1960::,2001:67c:1960:ffff:ffff:ffff:ffff:ffff,RO
 2001:67c:1964::,2001:67c:1964:ffff:ffff:ffff:ffff:ffff,UA
 2001:67c:1968::,2001:67c:1968:ffff:ffff:ffff:ffff:ffff,DE
+2001:67c:196c::,2001:67c:196c:ffff:ffff:ffff:ffff:ffff,DE
 2001:67c:1970::,2001:67c:1970:ffff:ffff:ffff:ffff:ffff,RU
 2001:67c:1974::,2001:67c:1974:ffff:ffff:ffff:ffff:ffff,AT
 2001:67c:1978::,2001:67c:1978:ffff:ffff:ffff:ffff:ffff,RO
@@ -1453,6 +2026,7 @@
 2001:67c:1990::,2001:67c:1990:ffff:ffff:ffff:ffff:ffff,RO
 2001:67c:1994::,2001:67c:1994:ffff:ffff:ffff:ffff:ffff,DE
 2001:67c:1998::,2001:67c:1998:ffff:ffff:ffff:ffff:ffff,LU
+2001:67c:199c::,2001:67c:199c:ffff:ffff:ffff:ffff:ffff,DE
 2001:67c:19a0::,2001:67c:19a0:ffff:ffff:ffff:ffff:ffff,SE
 2001:67c:19a4::,2001:67c:19a4:ffff:ffff:ffff:ffff:ffff,SE
 2001:67c:19a8::,2001:67c:19a8:ffff:ffff:ffff:ffff:ffff,RO
@@ -1488,6 +2062,7 @@
 2001:67c:1b2c::,2001:67c:1b2c:ffff:ffff:ffff:ffff:ffff,SE
 2001:67c:1b30::,2001:67c:1b30:ffff:ffff:ffff:ffff:ffff,RO
 2001:67c:1b34::,2001:67c:1b34:ffff:ffff:ffff:ffff:ffff,DE
+2001:67c:1b38::,2001:67c:1b38:ffff:ffff:ffff:ffff:ffff,PL
 2001:67c:1b3c::,2001:67c:1b3c:ffff:ffff:ffff:ffff:ffff,SI
 2001:67c:1b40::,2001:67c:1b43:ffff:ffff:ffff:ffff:ffff,GB
 2001:67c:1b50::,2001:67c:1b50:ffff:ffff:ffff:ffff:ffff,CZ
@@ -1513,7 +2088,9 @@
 2001:67c:1ba4::,2001:67c:1ba4:ffff:ffff:ffff:ffff:ffff,SE
 2001:67c:1ba8::,2001:67c:1ba8:ffff:ffff:ffff:ffff:ffff,DE
 2001:67c:1bac::,2001:67c:1bac:ffff:ffff:ffff:ffff:ffff,GB
+2001:67c:1bb0::,2001:67c:1bb0:ffff:ffff:ffff:ffff:ffff,FI
 2001:67c:1bb4::,2001:67c:1bb4:ffff:ffff:ffff:ffff:ffff,RO
+2001:67c:1bb8::,2001:67c:1bb8:ffff:ffff:ffff:ffff:ffff,SE
 2001:67c:1bbc::,2001:67c:1bbc:ffff:ffff:ffff:ffff:ffff,NL
 2001:67c:1bc0::,2001:67c:1bc0:ffff:ffff:ffff:ffff:ffff,RU
 2001:67c:1bc4::,2001:67c:1bc4:ffff:ffff:ffff:ffff:ffff,CZ
@@ -1615,6 +2192,7 @@
 2001:67c:214c::,2001:67c:214c:ffff:ffff:ffff:ffff:ffff,DE
 2001:67c:2150::,2001:67c:2150:ffff:ffff:ffff:ffff:ffff,NL
 2001:67c:2154::,2001:67c:2154:ffff:ffff:ffff:ffff:ffff,BG
+2001:67c:2158::,2001:67c:2158:7fff:ffff:ffff:ffff:ffff,PL
 2001:67c:2158:8000::,2001:67c:2158:ffff:ffff:ffff:ffff:ffff,RU
 2001:67c:215c::,2001:67c:215c:ffff:ffff:ffff:ffff:ffff,RU
 2001:67c:2160::,2001:67c:2160:ffff:ffff:ffff:ffff:ffff,FR
@@ -1899,7 +2477,6 @@
 2001:67c:25fc::,2001:67c:25fc:ffff:ffff:ffff:ffff:ffff,AT
 2001:67c:2600::,2001:67c:2600:ffff:ffff:ffff:ffff:ffff,AT
 2001:67c:2604::,2001:67c:2604:ffff:ffff:ffff:ffff:ffff,SK
-2001:67c:2608::,2001:67c:2608:ffff:ffff:ffff:ffff:ffff,PL
 2001:67c:260c::,2001:67c:260c:ffff:ffff:ffff:ffff:ffff,AT
 2001:67c:2610::,2001:67c:2610:ffff:ffff:ffff:ffff:ffff,AT
 2001:67c:2614::,2001:67c:2614:ffff:ffff:ffff:ffff:ffff,CH
@@ -1915,6 +2492,7 @@
 2001:67c:263c::,2001:67c:263c:ffff:ffff:ffff:ffff:ffff,AT
 2001:67c:2640::,2001:67c:2640:ffff:ffff:ffff:ffff:ffff,AE
 2001:67c:2644::,2001:67c:2644:ffff:ffff:ffff:ffff:ffff,GB
+2001:67c:2648::,2001:67c:2648:ffff:ffff:ffff:ffff:ffff,CH
 2001:67c:264c::,2001:67c:264c:ffff:ffff:ffff:ffff:ffff,AT
 2001:67c:2650::,2001:67c:2650:ffff:ffff:ffff:ffff:ffff,SE
 2001:67c:2654::,2001:67c:2654:ffff:ffff:ffff:ffff:ffff,AE
@@ -2000,6 +2578,10 @@
 2001:67c:27a4::,2001:67c:27a4:ffff:ffff:ffff:ffff:ffff,SE
 2001:67c:27a8::,2001:67c:27a8:ffff:ffff:ffff:ffff:ffff,DK
 2001:67c:27ac::,2001:67c:27ac:ffff:ffff:ffff:ffff:ffff,DE
+2001:67c:27b0::,2001:67c:27b0:ffff:ffff:ffff:ffff:ffff,FI
+2001:67c:27b4::,2001:67c:27b4:ffff:ffff:ffff:ffff:ffff,UA
+2001:67c:27b8::,2001:67c:27b8:ffff:ffff:ffff:ffff:ffff,SA
+2001:67c:27bc::,2001:67c:27bc:ffff:ffff:ffff:ffff:ffff,DE
 2001:67c:27c0::,2001:67c:27c0:ffff:ffff:ffff:ffff:ffff,GB
 2001:67c:27c4::,2001:67c:27c4:ffff:ffff:ffff:ffff:ffff,RU
 2001:67c:27c8::,2001:67c:27c8:ffff:ffff:ffff:ffff:ffff,RU
@@ -2017,7 +2599,6 @@
 2001:67c:27f8::,2001:67c:27f8:ffff:ffff:ffff:ffff:ffff,SE
 2001:67c:27fc::,2001:67c:27fc:ffff:ffff:ffff:ffff:ffff,DE
 2001:67c:2800::,2001:67c:2800:ffff:ffff:ffff:ffff:ffff,CH
-2001:67c:2804::,2001:67c:2804:ffff:ffff:ffff:ffff:ffff,NO
 2001:67c:2808::,2001:67c:2808:ffff:ffff:ffff:ffff:ffff,PL
 2001:67c:280c::,2001:67c:280c:ffff:ffff:ffff:ffff:ffff,FR
 2001:67c:2810::,2001:67c:2810:ffff:ffff:ffff:ffff:ffff,DK
@@ -2101,7 +2682,6 @@
 2001:67c:29d8::,2001:67c:29d8:ffff:ffff:ffff:ffff:ffff,AE
 2001:67c:29dc::,2001:67c:29dc:ffff:ffff:ffff:ffff:ffff,DE
 2001:67c:29e0::,2001:67c:29e0:ffff:ffff:ffff:ffff:ffff,UA
-2001:67c:29e4::,2001:67c:29e4:ffff:ffff:ffff:ffff:ffff,DE
 2001:67c:29e8::,2001:67c:29e8:ffff:ffff:ffff:ffff:ffff,TR
 2001:67c:29ec::,2001:67c:29ec:ffff:ffff:ffff:ffff:ffff,NO
 2001:67c:29f0::,2001:67c:29f0:ffff:ffff:ffff:ffff:ffff,BG
@@ -2308,7 +2888,6 @@
 2001:67c:2d50::,2001:67c:2d50:ffff:ffff:ffff:ffff:ffff,DE
 2001:67c:2d54::,2001:67c:2d54:ffff:ffff:ffff:ffff:ffff,NL
 2001:67c:2d58::,2001:67c:2d58:ffff:ffff:ffff:ffff:ffff,AT
-2001:67c:2d5c::,2001:67c:2d5c:ffff:ffff:ffff:ffff:ffff,RO
 2001:67c:2d60::,2001:67c:2d60:ffff:ffff:ffff:ffff:ffff,DK
 2001:67c:2d64::,2001:67c:2d64:ffff:ffff:ffff:ffff:ffff,BE
 2001:67c:2d68::,2001:67c:2d68:ffff:ffff:ffff:ffff:ffff,NO
@@ -2330,6 +2909,7 @@
 2001:67c:2da8::,2001:67c:2da8:ffff:ffff:ffff:ffff:ffff,DE
 2001:67c:2dac::,2001:67c:2dac:ffff:ffff:ffff:ffff:ffff,DE
 2001:67c:2db0::,2001:67c:2db0:ffff:ffff:ffff:ffff:ffff,IT
+2001:67c:2db4::,2001:67c:2db4:ffff:ffff:ffff:ffff:ffff,PL
 2001:67c:2db8::,2001:67c:2db8:ffff:ffff:ffff:ffff:ffff,MD
 2001:67c:2dbc::,2001:67c:2dbc:ffff:ffff:ffff:ffff:ffff,IL
 2001:67c:2dc0::,2001:67c:2dc0:ffff:ffff:ffff:ffff:ffff,LI
@@ -2341,7 +2921,6 @@
 2001:67c:2dd8::,2001:67c:2dd8:ffff:ffff:ffff:ffff:ffff,SI
 2001:67c:2ddc::,2001:67c:2ddc:ffff:ffff:ffff:ffff:ffff,PL
 2001:67c:2de0::,2001:67c:2de0:ffff:ffff:ffff:ffff:ffff,SI
-2001:67c:2de4::,2001:67c:2de4:ffff:ffff:ffff:ffff:ffff,CH
 2001:67c:2de8::,2001:67c:2de8:ffff:ffff:ffff:ffff:ffff,CH
 2001:67c:2dec::,2001:67c:2dec:ffff:ffff:ffff:ffff:ffff,RU
 2001:67c:2df0::,2001:67c:2df0:ffff:ffff:ffff:ffff:ffff,BG
@@ -2364,11 +2943,13 @@
 2001:67c:2e38::,2001:67c:2e38:ffff:ffff:ffff:ffff:ffff,CH
 2001:67c:2e3c::,2001:67c:2e3c:ffff:ffff:ffff:ffff:ffff,PL
 2001:67c:2e40::,2001:67c:2e40:ffff:ffff:ffff:ffff:ffff,RU
+2001:67c:2e44::,2001:67c:2e44:ffff:ffff:ffff:ffff:ffff,SI
 2001:67c:2e48::,2001:67c:2e48:ffff:ffff:ffff:ffff:ffff,SE
 2001:67c:2e4c::,2001:67c:2e4c:ffff:ffff:ffff:ffff:ffff,RU
 2001:67c:2e50::,2001:67c:2e50:ffff:ffff:ffff:ffff:ffff,PL
 2001:67c:2e54::,2001:67c:2e54:ffff:ffff:ffff:ffff:ffff,SE
 2001:67c:2e58::,2001:67c:2e58:ffff:ffff:ffff:ffff:ffff,UA
+2001:67c:2e5c::,2001:67c:2e5c:ffff:ffff:ffff:ffff:ffff,UA
 2001:67c:2e60::,2001:67c:2e60:ffff:ffff:ffff:ffff:ffff,DE
 2001:67c:2e64::,2001:67c:2e64:ffff:ffff:ffff:ffff:ffff,NL
 2001:67c:2e68::,2001:67c:2e69:ffff:ffff:ffff:ffff:ffff,FR
@@ -2381,11 +2962,57 @@
 2001:67c:2e8c::,2001:67c:2e8c:ffff:ffff:ffff:ffff:ffff,DE
 2001:67c:2e90::,2001:67c:2e90:ffff:ffff:ffff:ffff:ffff,BG
 2001:67c:2e94::,2001:67c:2e94:ffff:ffff:ffff:ffff:ffff,FI
+2001:67c:2e98::,2001:67c:2e98:ffff:ffff:ffff:ffff:ffff,RU
+2001:67c:2e9c::,2001:67c:2e9c:ffff:ffff:ffff:ffff:ffff,RU
+2001:67c:2ea0::,2001:67c:2ea0:ffff:ffff:ffff:ffff:ffff,DE
+2001:67c:2ea4::,2001:67c:2ea4:ffff:ffff:ffff:ffff:ffff,DE
+2001:67c:2ea8::,2001:67c:2ea8:ffff:ffff:ffff:ffff:ffff,LV
+2001:67c:2eac::,2001:67c:2eac:ffff:ffff:ffff:ffff:ffff,DE
+2001:67c:2eb0::,2001:67c:2eb0:ffff:ffff:ffff:ffff:ffff,DE
+2001:67c:2eb4::,2001:67c:2eb4:ffff:ffff:ffff:ffff:ffff,DE
+2001:67c:2eb8::,2001:67c:2eb8:ffff:ffff:ffff:ffff:ffff,DE
+2001:67c:2ebc::,2001:67c:2ebc:ffff:ffff:ffff:ffff:ffff,RU
+2001:67c:2ec0::,2001:67c:2ec0:ffff:ffff:ffff:ffff:ffff,DE
+2001:67c:2ec4::,2001:67c:2ec4:ffff:ffff:ffff:ffff:ffff,DK
+2001:67c:2ec8::,2001:67c:2ec8:ffff:ffff:ffff:ffff:ffff,RU
+2001:67c:2ecc::,2001:67c:2ecc:ffff:ffff:ffff:ffff:ffff,DE
+2001:67c:2ed0::,2001:67c:2ed0:ffff:ffff:ffff:ffff:ffff,DE
+2001:67c:2ed4::,2001:67c:2ed4:ffff:ffff:ffff:ffff:ffff,RO
+2001:67c:2ed8::,2001:67c:2ed8:ffff:ffff:ffff:ffff:ffff,DE
+2001:67c:2edc::,2001:67c:2edc:ffff:ffff:ffff:ffff:ffff,SE
+2001:67c:2ee0::,2001:67c:2ee0:ffff:ffff:ffff:ffff:ffff,RU
+2001:67c:2ee4::,2001:67c:2ee4:ffff:ffff:ffff:ffff:ffff,UA
+2001:67c:2ee8::,2001:67c:2ee8:ffff:ffff:ffff:ffff:ffff,PL
+2001:67c:2eec::,2001:67c:2eec:ffff:ffff:ffff:ffff:ffff,RO
+2001:67c:2ef0::,2001:67c:2ef0:ffff:ffff:ffff:ffff:ffff,NL
+2001:67c:2ef4::,2001:67c:2ef4:ffff:ffff:ffff:ffff:ffff,DE
+2001:67c:2ef8::,2001:67c:2ef8:ffff:ffff:ffff:ffff:ffff,FI
+2001:67c:2efc::,2001:67c:2efc:ffff:ffff:ffff:ffff:ffff,AT
+2001:67c:2f00::,2001:67c:2f00:ffff:ffff:ffff:ffff:ffff,CH
+2001:67c:2f04::,2001:67c:2f04:ffff:ffff:ffff:ffff:ffff,NL
+2001:67c:2f08::,2001:67c:2f08:ffff:ffff:ffff:ffff:ffff,GB
+2001:67c:2f0c::,2001:67c:2f0c:ffff:ffff:ffff:ffff:ffff,DE
+2001:67c:2f10::,2001:67c:2f10:ffff:ffff:ffff:ffff:ffff,UA
+2001:67c:2f14::,2001:67c:2f14:ffff:ffff:ffff:ffff:ffff,DE
+2001:67c:2f18::,2001:67c:2f18:ffff:ffff:ffff:ffff:ffff,CZ
+2001:67c:2f1c::,2001:67c:2f1c:ffff:ffff:ffff:ffff:ffff,GB
+2001:67c:2f20::,2001:67c:2f20:ffff:ffff:ffff:ffff:ffff,DE
+2001:67c:2f24::,2001:67c:2f24:ffff:ffff:ffff:ffff:ffff,HR
+2001:67c:2f28::,2001:67c:2f28:ffff:ffff:ffff:ffff:ffff,PL
+2001:67c:2f2c::,2001:67c:2f2c:ffff:ffff:ffff:ffff:ffff,SE
+2001:67c:2f30::,2001:67c:2f30:ffff:ffff:ffff:ffff:ffff,DE
+2001:67c:2f34::,2001:67c:2f34:ffff:ffff:ffff:ffff:ffff,AT
+2001:67c:2f38::,2001:67c:2f38:ffff:ffff:ffff:ffff:ffff,GB
+2001:67c:2f3c::,2001:67c:2f3c:ffff:ffff:ffff:ffff:ffff,GB
+2001:67c:2f40::,2001:67c:2f40:ffff:ffff:ffff:ffff:ffff,BG
+2001:67c:2f44::,2001:67c:2f44:ffff:ffff:ffff:ffff:ffff,DE
+2001:67c:2f48::,2001:67c:2f48:ffff:ffff:ffff:ffff:ffff,UA
+2001:67c:2f4c::,2001:67c:2f4c:ffff:ffff:ffff:ffff:ffff,BG
 2001:680::,2001:680:ffff:ffff:ffff:ffff:ffff:ffff,DE
 2001:688::,2001:688:ffff:ffff:ffff:ffff:ffff:ffff,FR
 2001:690::,2001:697:ffff:ffff:ffff:ffff:ffff:ffff,PT
 2001:6a0::,2001:6a0:ffff:ffff:ffff:ffff:ffff:ffff,PL
-2001:6a8::,2001:6a8:ffff:ffff:ffff:ffff:ffff:ffff,BE
+2001:6a8::,2001:6af:ffff:ffff:ffff:ffff:ffff:ffff,BE
 2001:6b0::,2001:6b0:ffff:ffff:ffff:ffff:ffff:ffff,SE
 2001:6b8::,2001:6b8:ffff:ffff:ffff:ffff:ffff:ffff,IT
 2001:6c8::,2001:6cf:ffff:ffff:ffff:ffff:ffff:ffff,DK
@@ -2394,17 +3021,49 @@
 2001:6e0::,2001:6e0:ffff:ffff:ffff:ffff:ffff:ffff,NL
 2001:6e8::,2001:6ef:ffff:ffff:ffff:ffff:ffff:ffff,FI
 2001:6f0::,2001:6f7:ffff:ffff:ffff:ffff:ffff:ffff,SE
-2001:6f8::,2001:6f8:2ff:ffff:ffff:ffff:ffff:ffff,GB
+2001:6f8::,2001:6f8:202:7fff:ffff:ffff:ffff:ffff,GB
+2001:6f8:202:8000::,2001:6f8:202:ffff:ffff:ffff:ffff:ffff,BE
+2001:6f8:203::,2001:6f8:2ff:ffff:ffff:ffff:ffff:ffff,GB
 2001:6f8:300::,2001:6f8:3ff:ffff:ffff:ffff:ffff:ffff,BE
-2001:6f8:400::,2001:6f8:12d8:ffff:ffff:ffff:ffff:ffff,GB
+2001:6f8:400::,2001:6f8:8ff:ffff:ffff:ffff:ffff:ffff,GB
+2001:6f8:900::,2001:6f8:900:ffff:ffff:ffff:ffff:ffff,DE
+2001:6f8:901::,2001:6f8:91c:ffff:ffff:ffff:ffff:ffff,GB
+2001:6f8:91d::,2001:6f8:91d:7fff:ffff:ffff:ffff:ffff,DE
+2001:6f8:91d:8000::,2001:6f8:96b:ffff:ffff:ffff:ffff:ffff,GB
+2001:6f8:96c::,2001:6f8:96c:7fff:ffff:ffff:ffff:ffff,DE
+2001:6f8:96c:8000::,2001:6f8:1011:ffff:ffff:ffff:ffff:ffff,GB
+2001:6f8:1012::,2001:6f8:1012:7fff:ffff:ffff:ffff:ffff,DE
+2001:6f8:1012:8000::,2001:6f8:107c:ffff:ffff:ffff:ffff:ffff,GB
+2001:6f8:107d::,2001:6f8:107d:7fff:ffff:ffff:ffff:ffff,DE
+2001:6f8:107d:8000::,2001:6f8:10f1:ffff:ffff:ffff:ffff:ffff,GB
+2001:6f8:10f2::,2001:6f8:10f2:7fff:ffff:ffff:ffff:ffff,DE
+2001:6f8:10f2:8000::,2001:6f8:1182:ffff:ffff:ffff:ffff:ffff,GB
+2001:6f8:1183::,2001:6f8:1183:7fff:ffff:ffff:ffff:ffff,DE
+2001:6f8:1183:8000::,2001:6f8:11ab:ffff:ffff:ffff:ffff:ffff,GB
+2001:6f8:11ac::,2001:6f8:11ac:7fff:ffff:ffff:ffff:ffff,DE
+2001:6f8:11ac:8000::,2001:6f8:11b1:ffff:ffff:ffff:ffff:ffff,GB
+2001:6f8:11b2::,2001:6f8:11b2:7fff:ffff:ffff:ffff:ffff,AT
+2001:6f8:11b2:8000::,2001:6f8:11cf:ffff:ffff:ffff:ffff:ffff,GB
+2001:6f8:11d0::,2001:6f8:11d0:7fff:ffff:ffff:ffff:ffff,DE
+2001:6f8:11d0:8000::,2001:6f8:12ca:7fff:ffff:ffff:ffff:ffff,GB
+2001:6f8:12ca:8000::,2001:6f8:12ca:ffff:ffff:ffff:ffff:ffff,DE
+2001:6f8:12cb::,2001:6f8:12d8:ffff:ffff:ffff:ffff:ffff,GB
 2001:6f8:12d9::,2001:6f8:12d9:7fff:ffff:ffff:ffff:ffff,DE
-2001:6f8:12d9:8000::,2001:6f8:13ff:ffff:ffff:ffff:ffff:ffff,GB
+2001:6f8:12d9:8000::,2001:6f8:1368:ffff:ffff:ffff:ffff:ffff,GB
+2001:6f8:1369::,2001:6f8:1369:7fff:ffff:ffff:ffff:ffff,DE
+2001:6f8:1369:8000::,2001:6f8:13e0:ffff:ffff:ffff:ffff:ffff,GB
+2001:6f8:13e1::,2001:6f8:13e1:7fff:ffff:ffff:ffff:ffff,DE
+2001:6f8:13e1:8000::,2001:6f8:13ff:ffff:ffff:ffff:ffff:ffff,GB
 2001:6f8:1400::,2001:6f8:14ff:ffff:ffff:ffff:ffff:ffff,BE
-2001:6f8:1500::,2001:6f8:1c00:7fff:ffff:ffff:ffff:ffff,GB
-2001:6f8:1c00:8000::,2001:6f8:1c00:ffff:ffff:ffff:ffff:ffff,DE
-2001:6f8:1c01::,2001:6f8:1d57:ffff:ffff:ffff:ffff:ffff,GB
+2001:6f8:1500::,2001:6f8:1c8a:ffff:ffff:ffff:ffff:ffff,GB
+2001:6f8:1c8b::,2001:6f8:1c8b:7fff:ffff:ffff:ffff:ffff,DE
+2001:6f8:1c8b:8000::,2001:6f8:1cba:ffff:ffff:ffff:ffff:ffff,GB
+2001:6f8:1cbb::,2001:6f8:1cbb:7fff:ffff:ffff:ffff:ffff,DE
+2001:6f8:1cbb:8000::,2001:6f8:1d57:ffff:ffff:ffff:ffff:ffff,GB
 2001:6f8:1d58::,2001:6f8:1d58:7fff:ffff:ffff:ffff:ffff,DE
-2001:6f8:1d58:8000::,2001:6f8:ffff:ffff:ffff:ffff:ffff:ffff,GB
+2001:6f8:1d58:8000::,2001:6f8:1d69:ffff:ffff:ffff:ffff:ffff,GB
+2001:6f8:1d6a::,2001:6f8:1d6a:7fff:ffff:ffff:ffff:ffff,DE
+2001:6f8:1d6a:8000::,2001:6f8:ffff:ffff:ffff:ffff:ffff:ffff,GB
 2001:700::,2001:700:ffff:ffff:ffff:ffff:ffff:ffff,NO
 2001:708::,2001:708:ffff:ffff:ffff:ffff:ffff:ffff,FI
 2001:710::,2001:710:ffff:ffff:ffff:ffff:ffff:ffff,GB
@@ -2430,16 +3089,17 @@
 2001:7b8::,2001:7bf:ffff:ffff:ffff:ffff:ffff:ffff,NL
 2001:7c0::,2001:7c7:ffff:ffff:ffff:ffff:ffff:ffff,DE
 2001:7c8::,2001:7c8:ffff:ffff:ffff:ffff:ffff:ffff,IE
-2001:7d0::,2001:7d0:8cc1:7fff:ffff:ffff:ffff:ffff,EE
-2001:7d0:8cc1:8000::,2001:7d0:8cc1:ffff:ffff:ffff:ffff:ffff,GB
-2001:7d0:8cc2::,2001:7d0:ffff:ffff:ffff:ffff:ffff:ffff,EE
+2001:7d0::,2001:7d0:ffff:ffff:ffff:ffff:ffff:ffff,EE
 2001:7d8::,2001:7d8:ffff:ffff:ffff:ffff:ffff:ffff,DE
 2001:7e0::,2001:7e0:ffff:ffff:ffff:ffff:ffff:ffff,GB
-2001:7e8::,2001:7e8:ffff:ffff:ffff:ffff:ffff:ffff,LU
+2001:7e8::,2001:7e8:c036:ffff:ffff:ffff:ffff:ffff,LU
+2001:7e8:c037::,2001:7e8:c037:7fff:ffff:ffff:ffff:ffff,FR
+2001:7e8:c037:8000::,2001:7e8:ffff:ffff:ffff:ffff:ffff:ffff,LU
 2001:7f8::,2001:7f8::ffff:ffff:ffff:ffff:ffff,DE
 2001:7f8:1::,2001:7f8:1:ffff:ffff:ffff:ffff:ffff,NL
 2001:7f8:2::,2001:7f8:2:ffff:ffff:ffff:ffff:ffff,IT
 2001:7f8:3::,2001:7f8:4:ffff:ffff:ffff:ffff:ffff,GB
+2001:7f8:5::,2001:7f8:5:ffff:ffff:ffff:ffff:ffff,RU
 2001:7f8:6::,2001:7f8:6:ffff:ffff:ffff:ffff:ffff,BG
 2001:7f8:7::,2001:7f8:7:ffff:ffff:ffff:ffff:ffff,FI
 2001:7f8:8::,2001:7f8:8:ffff:ffff:ffff:ffff:ffff,DE
@@ -2456,9 +3116,11 @@
 2001:7f8:13::,2001:7f8:13:ffff:ffff:ffff:ffff:ffff,NL
 2001:7f8:14::,2001:7f8:14:ffff:ffff:ffff:ffff:ffff,CZ
 2001:7f8:15::,2001:7f8:15:ffff:ffff:ffff:ffff:ffff,EE
+2001:7f8:16::,2001:7f8:16:ffff:ffff:ffff:ffff:ffff,LV
 2001:7f8:17::,2001:7f8:17:ffff:ffff:ffff:ffff:ffff,GB
 2001:7f8:18::,2001:7f8:18:ffff:ffff:ffff:ffff:ffff,IE
 2001:7f8:19::,2001:7f8:19:ffff:ffff:ffff:ffff:ffff,DE
+2001:7f8:1a::,2001:7f8:1a:ffff:ffff:ffff:ffff:ffff,NL
 2001:7f8:1b::,2001:7f8:1b:ffff:ffff:ffff:ffff:ffff,BE
 2001:7f8:1c::,2001:7f8:1c:ffff:ffff:ffff:ffff:ffff,CH
 2001:7f8:1d::,2001:7f8:1d:ffff:ffff:ffff:ffff:ffff,FI
@@ -2550,6 +3212,7 @@
 2001:7f8:7d::,2001:7f8:7d:ffff:ffff:ffff:ffff:ffff,RU
 2001:7f8:7e::,2001:7f8:7e:ffff:ffff:ffff:ffff:ffff,ES
 2001:7f8:7f::,2001:7f8:7f:ffff:ffff:ffff:ffff:ffff,CZ
+2001:7f8:80::,2001:7f8:80:ffff:ffff:ffff:ffff:ffff,UA
 2001:7f8:81::,2001:7f8:81:ffff:ffff:ffff:ffff:ffff,FR
 2001:7f8:82::,2001:7f8:82:ffff:ffff:ffff:ffff:ffff,RU
 2001:7f8:83::,2001:7f8:83:ffff:ffff:ffff:ffff:ffff,PL
@@ -2569,11 +3232,15 @@
 2001:7f8:92::,2001:7f8:92:ffff:ffff:ffff:ffff:ffff,DE
 2001:7f8:93::,2001:7f8:93:ffff:ffff:ffff:ffff:ffff,AT
 2001:7f8:94::,2001:7f8:94:ffff:ffff:ffff:ffff:ffff,AM
+2001:7f8:95::,2001:7f8:95:ffff:ffff:ffff:ffff:ffff,DE
+2001:7f8:96::,2001:7f8:96:ffff:ffff:ffff:ffff:ffff,BG
 2001:7f8:97::,2001:7f8:97:ffff:ffff:ffff:ffff:ffff,RO
 2001:7f8:98::,2001:7f8:98:ffff:ffff:ffff:ffff:ffff,BG
 2001:7f8:99::,2001:7f8:99:ffff:ffff:ffff:ffff:ffff,FR
 2001:7f8:9a::,2001:7f8:9a:ffff:ffff:ffff:ffff:ffff,RU
 2001:7f8:9b::,2001:7f8:9b:ffff:ffff:ffff:ffff:ffff,PL
+2001:7f8:9c::,2001:7f8:9e:ffff:ffff:ffff:ffff:ffff,DE
+2001:7f8:9f::,2001:7f8:9f:ffff:ffff:ffff:ffff:ffff,BG
 2001:7fa:0:1::,2001:7fa::1:ffff:ffff:ffff:ffff,HK
 2001:7fa:0:2::,2001:7fa::2:ffff:ffff:ffff:ffff,KR
 2001:7fa:0:3::,2001:7fa::3:ffff:ffff:ffff:ffff,JP
@@ -2608,7 +3275,11 @@
 2001:888::,2001:88f:ffff:ffff:ffff:ffff:ffff:ffff,NL
 2001:890::,2001:891:ffff:ffff:ffff:ffff:ffff:ffff,AT
 2001:898::,2001:89f:ffff:ffff:ffff:ffff:ffff:ffff,NL
-2001:8a0::,2001:8a7:ffff:ffff:ffff:ffff:ffff:ffff,PT
+2001:8a0::,2001:8a0:5f5e:ffff:ffff:ffff:ffff:ffff,PT
+2001:8a0:5f5f::,2001:8a0:5f5f:7fff:ffff:ffff:ffff:ffff,DE
+2001:8a0:5f5f:8000::,2001:8a0:ddae:7fff:ffff:ffff:ffff:ffff,PT
+2001:8a0:ddae:8000::,2001:8a0:ddae:ffff:ffff:ffff:ffff:ffff,AU
+2001:8a0:ddaf::,2001:8a7:ffff:ffff:ffff:ffff:ffff:ffff,PT
 2001:8a8::,2001:8a8:ffff:ffff:ffff:ffff:ffff:ffff,CH
 2001:8b0::,2001:8b0:ffff:ffff:ffff:ffff:ffff:ffff,GB
 2001:8b8::,2001:8bf:ffff:ffff:ffff:ffff:ffff:ffff,FI
@@ -2625,11 +3296,21 @@
 2001:918::,2001:918:ffff:ffff:ffff:ffff:ffff:ffff,CH
 2001:920::,2001:920:1845:ffff:ffff:ffff:ffff:ffff,GB
 2001:920:1846::,2001:920:1846:7fff:ffff:ffff:ffff:ffff,DE
-2001:920:1846:8000::,2001:920:18ad:ffff:ffff:ffff:ffff:ffff,GB
+2001:920:1846:8000::,2001:920:186a:ffff:ffff:ffff:ffff:ffff,GB
+2001:920:186b::,2001:920:186b:ffff:ffff:ffff:ffff:ffff,DE
+2001:920:186c::,2001:920:187f:ffff:ffff:ffff:ffff:ffff,GB
+2001:920:1880::,2001:920:1880:7fff:ffff:ffff:ffff:ffff,DE
+2001:920:1880:8000::,2001:920:18a0:ffff:ffff:ffff:ffff:ffff,GB
+2001:920:18a1::,2001:920:18a1:7fff:ffff:ffff:ffff:ffff,DE
+2001:920:18a1:8000::,2001:920:18ad:ffff:ffff:ffff:ffff:ffff,GB
 2001:920:18ae::,2001:920:18ae:7fff:ffff:ffff:ffff:ffff,DE
-2001:920:18ae:8000::,2001:920:5809:ffff:ffff:ffff:ffff:ffff,GB
+2001:920:18ae:8000::,2001:920:18c0:ffff:ffff:ffff:ffff:ffff,GB
+2001:920:18c1::,2001:920:18c1:7fff:ffff:ffff:ffff:ffff,DE
+2001:920:18c1:8000::,2001:920:5809:ffff:ffff:ffff:ffff:ffff,GB
 2001:920:580a::,2001:920:580a:7fff:ffff:ffff:ffff:ffff,ES
-2001:920:580a:8000::,2001:927:ffff:ffff:ffff:ffff:ffff:ffff,GB
+2001:920:580a:8000::,2001:920:5845:ffff:ffff:ffff:ffff:ffff,GB
+2001:920:5846::,2001:920:5846:ffff:ffff:ffff:ffff:ffff,ES
+2001:920:5847::,2001:927:ffff:ffff:ffff:ffff:ffff:ffff,GB
 2001:928::,2001:928:ffff:ffff:ffff:ffff:ffff:ffff,DE
 2001:930::,2001:930:ffff:ffff:ffff:ffff:ffff:ffff,TR
 2001:938::,2001:938:ffff:ffff:ffff:ffff:ffff:ffff,AT
@@ -2643,14 +3324,16 @@
 2001:978:2:39::5:2,2001:978:2:39::5:2,SI
 2001:978:2:39::5:3,2001:978:1200:ffff:ffff:ffff:ffff:ffff,DE
 2001:978:1201::,2001:978:1201:7fff:ffff:ffff:ffff:ffff,ES
-2001:978:1201:8000::,2001:978:2300:2ff:ffff:ffff:ffff:ffff,DE
-2001:978:2300:300::,2001:978:2300:3ff:ffff:ffff:ffff:ffff,GB
-2001:978:2300:400::,2001:978:29ff:ffff:ffff:ffff:ffff:ffff,DE
+2001:978:1201:8000::,2001:978:22ff:ffff:ffff:ffff:ffff:ffff,DE
+2001:978:2300::,2001:978:2300:7fff:ffff:ffff:ffff:ffff,GB
+2001:978:2300:8000::,2001:978:29ff:ffff:ffff:ffff:ffff:ffff,DE
 2001:978:2a00::,2001:978:2a00:ffff:ffff:ffff:ffff:ffff,IE
-2001:978:2a01::,2001:978:ffff:ffff:ffff:ffff:ffff:ffff,DE
-2001:980::,2001:981:1c63:ffff:ffff:ffff:ffff:ffff,NL
-2001:981:1c64::,2001:981:1c64:7fff:ffff:ffff:ffff:ffff,CA
-2001:981:1c64:8000::,2001:987:ffff:ffff:ffff:ffff:ffff:ffff,NL
+2001:978:2a01::,2001:978:3bff:ffff:ffff:ffff:ffff:ffff,DE
+2001:978:3c00::,2001:978:3c00:7fff:ffff:ffff:ffff:ffff,NL
+2001:978:3c00:8000::,2001:978:ffff:ffff:ffff:ffff:ffff:ffff,DE
+2001:980::,2001:984:645a:ffff:ffff:ffff:ffff:ffff,NL
+2001:984:645b::,2001:984:645b:7fff:ffff:ffff:ffff:ffff,US
+2001:984:645b:8000::,2001:987:ffff:ffff:ffff:ffff:ffff:ffff,NL
 2001:988::,2001:988:ffff:ffff:ffff:ffff:ffff:ffff,FR
 2001:990::,2001:990:ffff:ffff:ffff:ffff:ffff:ffff,NL
 2001:998::,2001:99b:ffff:ffff:ffff:ffff:ffff:ffff,FI
@@ -2675,7 +3358,9 @@
 2001:a48::,2001:a48:ffff:ffff:ffff:ffff:ffff:ffff,PL
 2001:a50::,2001:a50:ffff:ffff:ffff:ffff:ffff:ffff,ES
 2001:a58::,2001:a58:ffff:ffff:ffff:ffff:ffff:ffff,RU
-2001:a60::,2001:a67:ffff:ffff:ffff:ffff:ffff:ffff,DE
+2001:a60::,2001:a61:2175:7fff:ffff:ffff:ffff:ffff,DE
+2001:a61:2175:8000::,2001:a61:2175:ffff:ffff:ffff:ffff:ffff,CH
+2001:a61:2176::,2001:a67:ffff:ffff:ffff:ffff:ffff:ffff,DE
 2001:a68::,2001:a68:ffff:ffff:ffff:ffff:ffff:ffff,FI
 2001:a70::,2001:a70:ffff:ffff:ffff:ffff:ffff:ffff,FR
 2001:a78::,2001:a78:ffff:ffff:ffff:ffff:ffff:ffff,DE
@@ -2687,9 +3372,11 @@
 2001:aa8::,2001:ab7:ffff:ffff:ffff:ffff:ffff:ffff,DE
 2001:ab8::,2001:ab8:ffff:ffff:ffff:ffff:ffff:ffff,FR
 2001:ac0::,2001:ac7:ffff:ffff:ffff:ffff:ffff:ffff,ES
-2001:ac8::,2001:ac8:ffff:ffff:ffff:ffff:ffff:ffff,GB
+2001:ac8::,2001:ac8:20::ffff:ffff:ffff:ffff,GB
+2001:ac8:20:1::,2001:ac8:20:1:ffff:ffff:ffff:ffff,DE
+2001:ac8:20:2::,2001:ac8:ffff:ffff:ffff:ffff:ffff:ffff,GB
 2001:ad0::,2001:ad0:ffff:ffff:ffff:ffff:ffff:ffff,EE
-2001:ad8::,2001:ae0:ffff:ffff:ffff:ffff:ffff:ffff,DE
+2001:ad8::,2001:ae1:ffff:ffff:ffff:ffff:ffff:ffff,DE
 2001:ae8::,2001:ae8:ffff:ffff:ffff:ffff:ffff:ffff,CZ
 2001:af0::,2001:af0:ffff:ffff:ffff:ffff:ffff:ffff,CZ
 2001:af8::,2001:af8:ffff:ffff:ffff:ffff:ffff:ffff,AT
@@ -2719,9 +3406,13 @@
 2001:bd0::,2001:bd0:ffff:ffff:ffff:ffff:ffff:ffff,GB
 2001:be0::,2001:be7:ffff:ffff:ffff:ffff:ffff:ffff,GB
 2001:be8::,2001:be8:ffff:ffff:ffff:ffff:ffff:ffff,SE
-2001:bf0::,2001:bf7:130f:ffff:ffff:ffff:ffff:ffff,DE
+2001:bf0::,2001:bf7:10f:ffff:ffff:ffff:ffff:ffff,DE
+2001:bf7:110::,2001:bf7:110:7fff:ffff:ffff:ffff:ffff,NL
+2001:bf7:110:8000::,2001:bf7:130f:ffff:ffff:ffff:ffff:ffff,DE
 2001:bf7:1310::,2001:bf7:1310:7fff:ffff:ffff:ffff:ffff,NL
-2001:bf7:1310:8000::,2001:bf7:ffff:ffff:ffff:ffff:ffff:ffff,DE
+2001:bf7:1310:8000::,2001:bf7:131f:ffff:ffff:ffff:ffff:ffff,DE
+2001:bf7:1320::,2001:bf7:1320:7fff:ffff:ffff:ffff:ffff,NL
+2001:bf7:1320:8000::,2001:bf7:ffff:ffff:ffff:ffff:ffff:ffff,DE
 2001:bf8::,2001:bf8:ffff:ffff:ffff:ffff:ffff:ffff,IL
 2001:c00::,2001:c00:ffff:ffff:ffff:ffff:ffff:ffff,TH
 2001:c08::,2001:c08:ffff:ffff:ffff:ffff:ffff:ffff,TW
@@ -2767,7 +3458,9 @@
 2001:d58::,2001:d58:ffff:ffff:ffff:ffff:ffff:ffff,TW
 2001:d68::,2001:d68:ffff:ffff:ffff:ffff:ffff:ffff,ID
 2001:d70::,2001:d73:ffff:ffff:ffff:ffff:ffff:ffff,JP
-2001:d80::,2001:d80:ffff:ffff:ffff:ffff:ffff:ffff,JP
+2001:d80::,2001:d80:e07f:ffff:ffff:ffff:ffff:ffff,JP
+2001:d80:e080::,2001:d80:e080:7fff:ffff:ffff:ffff:ffff,CN
+2001:d80:e080:8000::,2001:d80:ffff:ffff:ffff:ffff:ffff:ffff,JP
 2001:d88::,2001:d88:ffff:ffff:ffff:ffff:ffff:ffff,JP
 2001:d90::,2001:d90:ffff:ffff:ffff:ffff:ffff:ffff,JP
 2001:d98::,2001:d98:ffff:ffff:ffff:ffff:ffff:ffff,SG
@@ -2815,6 +3508,7 @@
 2001:dd8:24::,2001:dd8:25:ffff:ffff:ffff:ffff:ffff,NP
 2001:dda::,2001:dda::ffff:ffff:ffff:ffff:ffff,JP
 2001:ddc::,2001:ddc::ffff:ffff:ffff:ffff:ffff,MY
+2001:ddd::,2001:ddd::ffff:ffff:ffff:ffff:ffff,AU
 2001:de1::,2001:de1:3f:ffff:ffff:ffff:ffff:ffff,JP
 2001:de8::,2001:de8::ffff:ffff:ffff:ffff:ffff,TH
 2001:de8:1::,2001:de8:1:ffff:ffff:ffff:ffff:ffff,IN
@@ -2842,6 +3536,7 @@
 2001:de8:1e::,2001:de8:1e:ffff:ffff:ffff:ffff:ffff,JP
 2001:de8:8000::,2001:de8:8000:ffff:ffff:ffff:ffff:ffff,WS
 2001:de9::,2001:de9::ffff:ffff:ffff:ffff:ffff,LK
+2001:de9:8000::,2001:de9:8000:ffff:ffff:ffff:ffff:ffff,ID
 2001:dea::,2001:dea::ffff:ffff:ffff:ffff:ffff,AU
 2001:deb::,2001:deb::ffff:ffff:ffff:ffff:ffff,TH
 2001:dec::,2001:dec::ffff:ffff:ffff:ffff:ffff,VU
@@ -3058,7 +3753,6 @@
 2001:df0:26c::,2001:df0:26c:ffff:ffff:ffff:ffff:ffff,SG
 2001:df0:26d::,2001:df0:26f:ffff:ffff:ffff:ffff:ffff,ID
 2001:df0:270::,2001:df0:270:ffff:ffff:ffff:ffff:ffff,IN
-2001:df0:271::,2001:df0:271:ffff:ffff:ffff:ffff:ffff,AU
 2001:df0:272::,2001:df0:272:ffff:ffff:ffff:ffff:ffff,MY
 2001:df0:273::,2001:df0:273:ffff:ffff:ffff:ffff:ffff,ID
 2001:df0:274::,2001:df0:277:ffff:ffff:ffff:ffff:ffff,NP
@@ -3149,7 +3843,6 @@
 2001:df0:401::,2001:df0:401:ffff:ffff:ffff:ffff:ffff,JP
 2001:df0:402::,2001:df0:403:ffff:ffff:ffff:ffff:ffff,AU
 2001:df0:404::,2001:df0:404:ffff:ffff:ffff:ffff:ffff,SG
-2001:df0:405::,2001:df0:405:ffff:ffff:ffff:ffff:ffff,AU
 2001:df0:407::,2001:df0:407:ffff:ffff:ffff:ffff:ffff,AU
 2001:df0:408::,2001:df0:408:ffff:ffff:ffff:ffff:ffff,NZ
 2001:df0:409::,2001:df0:409:ffff:ffff:ffff:ffff:ffff,ID
@@ -3216,35 +3909,57 @@
 2001:df0:46a::,2001:df0:46a:ffff:ffff:ffff:ffff:ffff,ID
 2001:df0:46b::,2001:df0:46b:ffff:ffff:ffff:ffff:ffff,MY
 2001:df0:46c::,2001:df0:46c:ffff:ffff:ffff:ffff:ffff,ID
-2001:df0:500::,2001:df0:5ff:ffff:ffff:ffff:ffff:ffff,AU
+2001:df0:500::,2001:df0:600:ffff:ffff:ffff:ffff:ffff,AU
 2001:df0:800::,2001:df0:800:ffff:ffff:ffff:ffff:ffff,ID
+2001:df0:a00::,2001:df0:a00:ffff:ffff:ffff:ffff:ffff,ID
 2001:df0:c00::,2001:df0:c00:ffff:ffff:ffff:ffff:ffff,MY
+2001:df0:e00::,2001:df0:e00:ffff:ffff:ffff:ffff:ffff,ID
 2001:df0:1000::,2001:df0:1000:ffff:ffff:ffff:ffff:ffff,TH
+2001:df0:1200::,2001:df0:1200:ffff:ffff:ffff:ffff:ffff,IN
 2001:df0:1400::,2001:df0:1400:ffff:ffff:ffff:ffff:ffff,SG
+2001:df0:1600::,2001:df0:1600:ffff:ffff:ffff:ffff:ffff,AU
 2001:df0:1800::,2001:df0:1800:ffff:ffff:ffff:ffff:ffff,JP
+2001:df0:1a00::,2001:df0:1a00:ffff:ffff:ffff:ffff:ffff,IN
 2001:df0:1c00::,2001:df0:1c00:ffff:ffff:ffff:ffff:ffff,AU
+2001:df0:1e00::,2001:df0:1e00:ffff:ffff:ffff:ffff:ffff,AU
 2001:df0:2000::,2001:df0:2000:ffff:ffff:ffff:ffff:ffff,AU
+2001:df0:2200::,2001:df0:2200:ffff:ffff:ffff:ffff:ffff,IN
 2001:df0:2400::,2001:df0:2400:ffff:ffff:ffff:ffff:ffff,SG
+2001:df0:2600::,2001:df0:2600:ffff:ffff:ffff:ffff:ffff,ID
 2001:df0:2800::,2001:df0:2800:ffff:ffff:ffff:ffff:ffff,AU
+2001:df0:2a00::,2001:df0:2a00:ffff:ffff:ffff:ffff:ffff,VN
 2001:df0:2c00::,2001:df0:2c00:ffff:ffff:ffff:ffff:ffff,AU
+2001:df0:2e00::,2001:df0:2e00:ffff:ffff:ffff:ffff:ffff,CN
 2001:df0:3000::,2001:df0:3000:ffff:ffff:ffff:ffff:ffff,PH
+2001:df0:3200::,2001:df0:3200:ffff:ffff:ffff:ffff:ffff,PK
+2001:df0:3600::,2001:df0:3600:ffff:ffff:ffff:ffff:ffff,SG
 2001:df0:3800::,2001:df0:3800:ffff:ffff:ffff:ffff:ffff,MY
+2001:df0:3a00::,2001:df0:3a00:ffff:ffff:ffff:ffff:ffff,IN
 2001:df0:3c00::,2001:df0:3c00:ffff:ffff:ffff:ffff:ffff,AU
+2001:df0:3e00::,2001:df0:3e00:ffff:ffff:ffff:ffff:ffff,AU
 2001:df0:4000::,2001:df0:4000:ffff:ffff:ffff:ffff:ffff,HK
+2001:df0:4200::,2001:df0:4200:ffff:ffff:ffff:ffff:ffff,AU
 2001:df0:4400::,2001:df0:4400:ffff:ffff:ffff:ffff:ffff,ID
+2001:df0:4600::,2001:df0:4600:ffff:ffff:ffff:ffff:ffff,SG
 2001:df0:4800::,2001:df0:4800:ffff:ffff:ffff:ffff:ffff,HK
-2001:df0:4c00::,2001:df0:4c00:ffff:ffff:ffff:ffff:ffff,HK
+2001:df0:4a00::,2001:df0:4a00:ffff:ffff:ffff:ffff:ffff,PK
+2001:df0:4e00::,2001:df0:4e00:ffff:ffff:ffff:ffff:ffff,TW
 2001:df0:5000::,2001:df0:5000:ffff:ffff:ffff:ffff:ffff,IN
+2001:df0:5200::,2001:df0:5200:ffff:ffff:ffff:ffff:ffff,IN
 2001:df0:5400::,2001:df0:5400:ffff:ffff:ffff:ffff:ffff,AU
+2001:df0:5600::,2001:df0:5600:ffff:ffff:ffff:ffff:ffff,MY
 2001:df0:5800::,2001:df0:5800:ffff:ffff:ffff:ffff:ffff,ID
+2001:df0:5a00::,2001:df0:5a00:ffff:ffff:ffff:ffff:ffff,BD
 2001:df0:5c00::,2001:df0:5c00:ffff:ffff:ffff:ffff:ffff,BD
+2001:df0:5e00::,2001:df0:5e00:ffff:ffff:ffff:ffff:ffff,AU
 2001:df0:6000::,2001:df0:6000:ffff:ffff:ffff:ffff:ffff,IN
+2001:df0:6200::,2001:df0:6200:ffff:ffff:ffff:ffff:ffff,MY
 2001:df0:6400::,2001:df0:6400:ffff:ffff:ffff:ffff:ffff,SG
+2001:df0:6600::,2001:df0:6600:ffff:ffff:ffff:ffff:ffff,SG
 2001:df0:6800::,2001:df0:6800:ffff:ffff:ffff:ffff:ffff,JP
-2001:df0:6c00::,2001:df0:6c00:ffff:ffff:ffff:ffff:ffff,HK
+2001:df0:6a00::,2001:df0:6a00:ffff:ffff:ffff:ffff:ffff,HK
 2001:df0:7000::,2001:df0:7000:ffff:ffff:ffff:ffff:ffff,AU
 2001:df0:7400::,2001:df0:7400:ffff:ffff:ffff:ffff:ffff,IN
-2001:df0:7800::,2001:df0:7800:ffff:ffff:ffff:ffff:ffff,WS
 2001:df0:7c00::,2001:df0:7c00:ffff:ffff:ffff:ffff:ffff,HK
 2001:df0:8000::,2001:df0:8000:ffff:ffff:ffff:ffff:ffff,IN
 2001:df0:8400::,2001:df0:8400:ffff:ffff:ffff:ffff:ffff,IN
@@ -3295,7 +4010,6 @@
 2001:df1:4800::,2001:df1:4800:ffff:ffff:ffff:ffff:ffff,IN
 2001:df1:4c00::,2001:df1:4c00:ffff:ffff:ffff:ffff:ffff,HK
 2001:df1:5000::,2001:df1:5000:ffff:ffff:ffff:ffff:ffff,HK
-2001:df1:5400::,2001:df1:5400:ffff:ffff:ffff:ffff:ffff,KR
 2001:df1:5800::,2001:df1:5800:ffff:ffff:ffff:ffff:ffff,BD
 2001:df1:5c00::,2001:df1:5c00:ffff:ffff:ffff:ffff:ffff,ID
 2001:df1:6000::,2001:df1:6000:ffff:ffff:ffff:ffff:ffff,SG
@@ -3326,7 +4040,7 @@
 2001:df1:c800::,2001:df1:c800:ffff:ffff:ffff:ffff:ffff,HK
 2001:df1:cc00::,2001:df1:cc00:ffff:ffff:ffff:ffff:ffff,AU
 2001:df1:d000::,2001:df1:d000:ffff:ffff:ffff:ffff:ffff,AU
-2001:df1:d400::,2001:df1:d400:ffff:ffff:ffff:ffff:ffff,HK
+2001:df1:d400::,2001:df1:d401:ffff:ffff:ffff:ffff:ffff,HK
 2001:df1:d800::,2001:df1:d800:ffff:ffff:ffff:ffff:ffff,AU
 2001:df1:e000::,2001:df1:e000:ffff:ffff:ffff:ffff:ffff,ID
 2001:df1:e400::,2001:df1:e400:ffff:ffff:ffff:ffff:ffff,ID
@@ -3352,7 +4066,6 @@
 2001:df2:3400::,2001:df2:3400:ffff:ffff:ffff:ffff:ffff,NZ
 2001:df2:3800::,2001:df2:3800:ffff:ffff:ffff:ffff:ffff,TH
 2001:df2:3c00::,2001:df2:3c07:ffff:ffff:ffff:ffff:ffff,AU
-2001:df2:4000::,2001:df2:4000:ffff:ffff:ffff:ffff:ffff,HK
 2001:df2:4400::,2001:df2:4400:ffff:ffff:ffff:ffff:ffff,AU
 2001:df2:4c00::,2001:df2:4c00:ffff:ffff:ffff:ffff:ffff,ID
 2001:df2:5000::,2001:df2:5000:ffff:ffff:ffff:ffff:ffff,IN
@@ -3376,7 +4089,7 @@
 2001:df2:a000::,2001:df2:a000:ffff:ffff:ffff:ffff:ffff,ID
 2001:df2:a400::,2001:df2:a400:ffff:ffff:ffff:ffff:ffff,MY
 2001:df2:a800::,2001:df2:a800:ffff:ffff:ffff:ffff:ffff,IN
-2001:df2:ac00::,2001:df2:ac00:ffff:ffff:ffff:ffff:ffff,TH
+2001:df2:ac00::,2001:df2:ac01:ffff:ffff:ffff:ffff:ffff,TH
 2001:df2:b000::,2001:df2:b000:ffff:ffff:ffff:ffff:ffff,IN
 2001:df2:b400::,2001:df2:b400:ffff:ffff:ffff:ffff:ffff,IN
 2001:df2:bc00::,2001:df2:bc00:ffff:ffff:ffff:ffff:ffff,ID
@@ -3555,7 +4268,6 @@
 2001:df5:8800::,2001:df5:8800:ffff:ffff:ffff:ffff:ffff,IN
 2001:df5:8c00::,2001:df5:8c00:ffff:ffff:ffff:ffff:ffff,AU
 2001:df5:9000::,2001:df5:9000:ffff:ffff:ffff:ffff:ffff,IN
-2001:df5:9400::,2001:df5:9400:ffff:ffff:ffff:ffff:ffff,CN
 2001:df5:9800::,2001:df5:9800:ffff:ffff:ffff:ffff:ffff,SG
 2001:df5:9c00::,2001:df5:9c00:ffff:ffff:ffff:ffff:ffff,ID
 2001:df5:a000::,2001:df5:a000:ffff:ffff:ffff:ffff:ffff,ID
@@ -3575,7 +4287,6 @@
 2001:df5:d800::,2001:df5:d800:ffff:ffff:ffff:ffff:ffff,SG
 2001:df5:dc00::,2001:df5:dc00:ffff:ffff:ffff:ffff:ffff,SG
 2001:df5:e000::,2001:df5:e000:ffff:ffff:ffff:ffff:ffff,MY
-2001:df5:e400::,2001:df5:e400:ffff:ffff:ffff:ffff:ffff,AU
 2001:df5:e800::,2001:df5:e800:ffff:ffff:ffff:ffff:ffff,PH
 2001:df5:ec00::,2001:df5:ec00:ffff:ffff:ffff:ffff:ffff,ID
 2001:df5:f000::,2001:df5:f000:ffff:ffff:ffff:ffff:ffff,ID
@@ -3613,52 +4324,101 @@
 2001:df6:7000::,2001:df6:7000:ffff:ffff:ffff:ffff:ffff,VN
 2001:df6:7400::,2001:df6:7400:ffff:ffff:ffff:ffff:ffff,TH
 2001:df6:7800::,2001:df6:7800:ffff:ffff:ffff:ffff:ffff,HK
+2001:df6:7c00::,2001:df6:7c00:ffff:ffff:ffff:ffff:ffff,AU
 2001:df6:8000::,2001:df6:8000:ffff:ffff:ffff:ffff:ffff,JP
+2001:df6:8400::,2001:df6:8400:ffff:ffff:ffff:ffff:ffff,AU
 2001:df6:8800::,2001:df6:8800:ffff:ffff:ffff:ffff:ffff,AU
+2001:df6:8c00::,2001:df6:8c00:ffff:ffff:ffff:ffff:ffff,TH
 2001:df6:9000::,2001:df6:9000:ffff:ffff:ffff:ffff:ffff,AU
+2001:df6:9400::,2001:df6:9400:ffff:ffff:ffff:ffff:ffff,IN
 2001:df6:9800::,2001:df6:9800:ffff:ffff:ffff:ffff:ffff,AU
+2001:df6:9c00::,2001:df6:9c00:ffff:ffff:ffff:ffff:ffff,TH
 2001:df6:a000::,2001:df6:a000:ffff:ffff:ffff:ffff:ffff,JP
+2001:df6:a400::,2001:df6:a400:ffff:ffff:ffff:ffff:ffff,SG
 2001:df6:a800::,2001:df6:a800:ffff:ffff:ffff:ffff:ffff,IN
+2001:df6:ac00::,2001:df6:ac00:ffff:ffff:ffff:ffff:ffff,ID
 2001:df6:b000::,2001:df6:b000:ffff:ffff:ffff:ffff:ffff,TH
+2001:df6:b400::,2001:df6:b400:ffff:ffff:ffff:ffff:ffff,MY
 2001:df6:b800::,2001:df6:b800:ffff:ffff:ffff:ffff:ffff,SG
+2001:df6:bc00::,2001:df6:bc00:ffff:ffff:ffff:ffff:ffff,HK
+2001:df6:c400::,2001:df6:c400:ffff:ffff:ffff:ffff:ffff,AU
 2001:df6:c800::,2001:df6:c800:ffff:ffff:ffff:ffff:ffff,IN
+2001:df6:cc00::,2001:df6:cc00:ffff:ffff:ffff:ffff:ffff,ID
 2001:df6:d000::,2001:df6:d000:ffff:ffff:ffff:ffff:ffff,HK
+2001:df6:d400::,2001:df6:d400:ffff:ffff:ffff:ffff:ffff,IN
 2001:df6:d800::,2001:df6:d800:ffff:ffff:ffff:ffff:ffff,BD
+2001:df6:dc00::,2001:df6:dc00:ffff:ffff:ffff:ffff:ffff,ID
+2001:df6:e400::,2001:df6:e400:ffff:ffff:ffff:ffff:ffff,IN
 2001:df6:e800::,2001:df6:e800:ffff:ffff:ffff:ffff:ffff,IN
+2001:df6:ec00::,2001:df6:ec00:ffff:ffff:ffff:ffff:ffff,ID
 2001:df6:f000::,2001:df6:f000:ffff:ffff:ffff:ffff:ffff,HK
+2001:df6:f400::,2001:df6:f400:ffff:ffff:ffff:ffff:ffff,CN
 2001:df6:f800::,2001:df6:f800:ffff:ffff:ffff:ffff:ffff,AU
+2001:df6:fc00::,2001:df6:fc00:ffff:ffff:ffff:ffff:ffff,AU
 2001:df7::,2001:df7::ffff:ffff:ffff:ffff:ffff,IN
+2001:df7:400::,2001:df7:400:ffff:ffff:ffff:ffff:ffff,HK
 2001:df7:800::,2001:df7:800:ffff:ffff:ffff:ffff:ffff,IN
+2001:df7:c00::,2001:df7:c00:ffff:ffff:ffff:ffff:ffff,TW
 2001:df7:1000::,2001:df7:1000:ffff:ffff:ffff:ffff:ffff,IN
+2001:df7:1400::,2001:df7:1400:ffff:ffff:ffff:ffff:ffff,AU
 2001:df7:1800::,2001:df7:1800:ffff:ffff:ffff:ffff:ffff,AU
+2001:df7:1c00::,2001:df7:1c00:ffff:ffff:ffff:ffff:ffff,ID
 2001:df7:2000::,2001:df7:2000:ffff:ffff:ffff:ffff:ffff,AU
+2001:df7:2400::,2001:df7:2400:ffff:ffff:ffff:ffff:ffff,AU
 2001:df7:2800::,2001:df7:2800:ffff:ffff:ffff:ffff:ffff,AU
+2001:df7:2c00::,2001:df7:2c00:ffff:ffff:ffff:ffff:ffff,IN
 2001:df7:3000::,2001:df7:3001:ffff:ffff:ffff:ffff:ffff,NZ
+2001:df7:3400::,2001:df7:3400:ffff:ffff:ffff:ffff:ffff,ID
 2001:df7:3800::,2001:df7:3800:ffff:ffff:ffff:ffff:ffff,AU
+2001:df7:3c00::,2001:df7:3c00:ffff:ffff:ffff:ffff:ffff,ID
 2001:df7:4000::,2001:df7:4000:ffff:ffff:ffff:ffff:ffff,SG
+2001:df7:4400::,2001:df7:4400:ffff:ffff:ffff:ffff:ffff,IN
 2001:df7:4800::,2001:df7:481f:ffff:ffff:ffff:ffff:ffff,JP
+2001:df7:4c00::,2001:df7:4c00:ffff:ffff:ffff:ffff:ffff,IN
 2001:df7:5000::,2001:df7:5000:ffff:ffff:ffff:ffff:ffff,IN
+2001:df7:5400::,2001:df7:5400:ffff:ffff:ffff:ffff:ffff,ID
 2001:df7:5800::,2001:df7:5800:ffff:ffff:ffff:ffff:ffff,AU
+2001:df7:5c00::,2001:df7:5c00:ffff:ffff:ffff:ffff:ffff,HK
 2001:df7:6000::,2001:df7:6000:ffff:ffff:ffff:ffff:ffff,IN
+2001:df7:6400::,2001:df7:6400:ffff:ffff:ffff:ffff:ffff,MY
 2001:df7:6800::,2001:df7:6800:ffff:ffff:ffff:ffff:ffff,IN
+2001:df7:6c00::,2001:df7:6c00:ffff:ffff:ffff:ffff:ffff,ID
 2001:df7:7000::,2001:df7:7000:ffff:ffff:ffff:ffff:ffff,HK
+2001:df7:7400::,2001:df7:7400:ffff:ffff:ffff:ffff:ffff,ID
 2001:df7:7800::,2001:df7:7800:ffff:ffff:ffff:ffff:ffff,JP
+2001:df7:7c00::,2001:df7:7c00:ffff:ffff:ffff:ffff:ffff,TH
+2001:df7:8400::,2001:df7:8401:ffff:ffff:ffff:ffff:ffff,IN
 2001:df7:8800::,2001:df7:8800:ffff:ffff:ffff:ffff:ffff,ID
+2001:df7:8c00::,2001:df7:8c00:ffff:ffff:ffff:ffff:ffff,MM
+2001:df7:9400::,2001:df7:9400:ffff:ffff:ffff:ffff:ffff,HK
 2001:df7:9800::,2001:df7:9800:ffff:ffff:ffff:ffff:ffff,NZ
+2001:df7:9c00::,2001:df7:9c00:ffff:ffff:ffff:ffff:ffff,AU
 2001:df7:a000::,2001:df7:a000:ffff:ffff:ffff:ffff:ffff,AU
+2001:df7:a400::,2001:df7:a400:ffff:ffff:ffff:ffff:ffff,SG
 2001:df7:a800::,2001:df7:a800:ffff:ffff:ffff:ffff:ffff,JP
+2001:df7:ac00::,2001:df7:ac00:ffff:ffff:ffff:ffff:ffff,AU
 2001:df7:b000::,2001:df7:b000:ffff:ffff:ffff:ffff:ffff,IN
+2001:df7:b400::,2001:df7:b400:ffff:ffff:ffff:ffff:ffff,ID
 2001:df7:b800::,2001:df7:b800:ffff:ffff:ffff:ffff:ffff,SG
+2001:df7:bc00::,2001:df7:bc00:ffff:ffff:ffff:ffff:ffff,ID
 2001:df7:c000::,2001:df7:c003:ffff:ffff:ffff:ffff:ffff,SG
+2001:df7:c400::,2001:df7:c400:ffff:ffff:ffff:ffff:ffff,NZ
 2001:df7:c800::,2001:df7:c800:ffff:ffff:ffff:ffff:ffff,IN
+2001:df7:cc00::,2001:df7:cc00:ffff:ffff:ffff:ffff:ffff,VN
 2001:df7:d000::,2001:df7:d000:ffff:ffff:ffff:ffff:ffff,BD
+2001:df7:d400::,2001:df7:d400:ffff:ffff:ffff:ffff:ffff,AU
 2001:df7:d800::,2001:df7:d800:ffff:ffff:ffff:ffff:ffff,AU
+2001:df7:dc00::,2001:df7:dc00:ffff:ffff:ffff:ffff:ffff,TH
 2001:df7:e000::,2001:df7:e000:ffff:ffff:ffff:ffff:ffff,IN
+2001:df7:e400::,2001:df7:e400:ffff:ffff:ffff:ffff:ffff,IN
 2001:df7:e800::,2001:df7:e800:ffff:ffff:ffff:ffff:ffff,AU
+2001:df7:ec00::,2001:df7:ec00:ffff:ffff:ffff:ffff:ffff,AU
 2001:df7:f000::,2001:df7:f000:ffff:ffff:ffff:ffff:ffff,JP
+2001:df7:f400::,2001:df7:f400:ffff:ffff:ffff:ffff:ffff,IN
 2001:df7:f800::,2001:df7:f800:ffff:ffff:ffff:ffff:ffff,IN
+2001:df7:fc00::,2001:df7:fc00:ffff:ffff:ffff:ffff:ffff,SG
 2001:df8::,2001:df8:ffff:ffff:ffff:ffff:ffff:ffff,US
-2001:df9::,2001:df9:ffff:ffff:ffff:ffff:ffff:ffff,ID
+2001:df9::,2001:df9:ffff:ffff:ffff:ffff:ffff:ffff,NZ
 2001:dfa::,2001:dfa:ffff:ffff:ffff:ffff:ffff:ffff,JP
 2001:e00::,2001:e01:ffff:ffff:ffff:ffff:ffff:ffff,ID
 2001:e08::,2001:e08:ffff:ffff:ffff:ffff:ffff:ffff,CN
@@ -3684,7 +4444,6 @@
 2001:eb0::,2001:eb0:ffff:ffff:ffff:ffff:ffff:ffff,HK
 2001:eb8::,2001:eb8:ffff:ffff:ffff:ffff:ffff:ffff,KR
 2001:ec0::,2001:ec0:ffff:ffff:ffff:ffff:ffff:ffff,TH
-2001:ec8::,2001:ec8:ffff:ffff:ffff:ffff:ffff:ffff,PH
 2001:ed0::,2001:ed0:ffff:ffff:ffff:ffff:ffff:ffff,KR
 2001:ed8::,2001:ed8:ffff:ffff:ffff:ffff:ffff:ffff,TW
 2001:ee0::,2001:ee0:ffff:ffff:ffff:ffff:ffff:ffff,VN
@@ -3739,7 +4498,9 @@
 2001:1284::,2001:1284:ffff:ffff:ffff:ffff:ffff:ffff,BR
 2001:1288::,2001:1288:ffff:ffff:ffff:ffff:ffff:ffff,BR
 2001:128c::,2001:128c:ffff:ffff:ffff:ffff:ffff:ffff,BR
-2001:1290::,2001:1291:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2001:1290::,2001:1291:200:88fc:ffff:ffff:ffff:ffff,BR
+2001:1291:200:88fd::,2001:1291:200:88fd:ffff:ffff:ffff:ffff,AR
+2001:1291:200:88fe::,2001:1291:ffff:ffff:ffff:ffff:ffff:ffff,BR
 2001:1294::,2001:1294:ffff:ffff:ffff:ffff:ffff:ffff,BR
 2001:1298::,2001:1298:ffff:ffff:ffff:ffff:ffff:ffff,BR
 2001:129c::,2001:129c:ffff:ffff:ffff:ffff:ffff:ffff,BR
@@ -3824,7 +4585,9 @@
 2001:146a::,2001:146a::7fff:ffff:ffff:ffff:ffff,RU
 2001:146a:0:8000::,2001:146a:81:ffff:ffff:ffff:ffff:ffff,CZ
 2001:146a:82::,2001:146a:82:7fff:ffff:ffff:ffff:ffff,RU
-2001:146a:82:8000::,2001:146f:ffff:ffff:ffff:ffff:ffff:ffff,CZ
+2001:146a:82:8000::,2001:146a:98:ffff:ffff:ffff:ffff:ffff,CZ
+2001:146a:99::,2001:146a:99:7fff:ffff:ffff:ffff:ffff,RU
+2001:146a:99:8000::,2001:146f:ffff:ffff:ffff:ffff:ffff:ffff,CZ
 2001:1470::,2001:1477:ffff:ffff:ffff:ffff:ffff:ffff,SI
 2001:1478::,2001:1478:ffff:ffff:ffff:ffff:ffff:ffff,GB
 2001:1488::,2001:1488:ffff:ffff:ffff:ffff:ffff:ffff,CZ
@@ -3861,7 +4624,17 @@
 2001:15a8::,2001:15a8:ffff:ffff:ffff:ffff:ffff:ffff,IT
 2001:15b0::,2001:15b0:ffff:ffff:ffff:ffff:ffff:ffff,NL
 2001:15b8::,2001:15b8:ffff:ffff:ffff:ffff:ffff:ffff,NL
-2001:15c0::,2001:15c7:ffff:ffff:ffff:ffff:ffff:ffff,SI
+2001:15c0::,2001:15c0:65ff:7fff:ffff:ffff:ffff:ffff,SI
+2001:15c0:65ff:8000::,2001:15c0:65ff:ffff:ffff:ffff:ffff:ffff,AT
+2001:15c0:6600::,2001:15c0:665e:ffff:ffff:ffff:ffff:ffff,SI
+2001:15c0:665f::,2001:15c0:665f:7fff:ffff:ffff:ffff:ffff,AT
+2001:15c0:665f:8000::,2001:15c0:66a2:ffff:ffff:ffff:ffff:ffff,SI
+2001:15c0:66a3::,2001:15c0:66a3:7fff:ffff:ffff:ffff:ffff,RO
+2001:15c0:66a3:8000::,2001:15c0:67cc:ffff:ffff:ffff:ffff:ffff,SI
+2001:15c0:67cd::,2001:15c0:67cd:7fff:ffff:ffff:ffff:ffff,AT
+2001:15c0:67cd:8000::,2001:15c0:67d0:ffff:ffff:ffff:ffff:ffff,SI
+2001:15c0:67d1::,2001:15c0:67d1:7fff:ffff:ffff:ffff:ffff,AT
+2001:15c0:67d1:8000::,2001:15c7:ffff:ffff:ffff:ffff:ffff:ffff,SI
 2001:15c8::,2001:15c8:ffff:ffff:ffff:ffff:ffff:ffff,NL
 2001:15d8::,2001:15df:ffff:ffff:ffff:ffff:ffff:ffff,PT
 2001:15e0::,2001:15e0:ffff:ffff:ffff:ffff:ffff:ffff,GB
@@ -3886,17 +4659,37 @@
 2001:1688::,2001:168f:ffff:ffff:ffff:ffff:ffff:ffff,SI
 2001:1690::,2001:1690:ffff:ffff:ffff:ffff:ffff:ffff,NL
 2001:1698::,2001:1698:ffff:ffff:ffff:ffff:ffff:ffff,LU
-2001:16a0::,2001:16a7:ffff:ffff:ffff:ffff:ffff:ffff,SA
+2001:16a0::,2001:16a2:1d14:7fff:ffff:ffff:ffff:ffff,SA
+2001:16a2:1d14:8000::,2001:16a2:1d14:ffff:ffff:ffff:ffff:ffff,US
+2001:16a2:1d15::,2001:16a2:a5bf:7fff:ffff:ffff:ffff:ffff,SA
+2001:16a2:a5bf:8000::,2001:16a2:a5bf:ffff:ffff:ffff:ffff:ffff,GB
+2001:16a2:a5c0::,2001:16a7:ffff:ffff:ffff:ffff:ffff:ffff,SA
 2001:16a8::,2001:16a8:ffff:ffff:ffff:ffff:ffff:ffff,IT
 2001:16b0::,2001:16b0:ffff:ffff:ffff:ffff:ffff:ffff,PL
 2001:16b8::,2001:16b8:ffff:ffff:ffff:ffff:ffff:ffff,DE
-2001:16c0::,2001:16c7:ffff:ffff:ffff:ffff:ffff:ffff,IR
+2001:16c0::,2001:16c0:1233:ffff:ffff:ffff:ffff:ffff,IR
+2001:16c0:1234::,2001:16c0:1234:7fff:ffff:ffff:ffff:ffff,AU
+2001:16c0:1234:8000::,2001:16c7:ffff:ffff:ffff:ffff:ffff:ffff,IR
 2001:16d0::,2001:16d0:ffff:ffff:ffff:ffff:ffff:ffff,IT
-2001:16d8::,2001:16d8:dd00:7fff:ffff:ffff:ffff:ffff,SE
-2001:16d8:dd00:8000::,2001:16d8:dd00:ffff:ffff:ffff:ffff:ffff,DK
-2001:16d8:dd01::,2001:16d8:dda3:ffff:ffff:ffff:ffff:ffff,SE
+2001:16d8::,2001:16d8:dcff:ffff:ffff:ffff:ffff:ffff,SE
+2001:16d8:dd00::,2001:16d8:dd00:7fff:ffff:ffff:ffff:ffff,DK
+2001:16d8:dd00:8000::,2001:16d8:dd72:ffff:ffff:ffff:ffff:ffff,SE
+2001:16d8:dd73::,2001:16d8:dd73:7fff:ffff:ffff:ffff:ffff,DK
+2001:16d8:dd73:8000::,2001:16d8:dd84:ffff:ffff:ffff:ffff:ffff,SE
+2001:16d8:dd85::,2001:16d8:dd85:7fff:ffff:ffff:ffff:ffff,DK
+2001:16d8:dd85:8000::,2001:16d8:dda3:ffff:ffff:ffff:ffff:ffff,SE
 2001:16d8:dda4::,2001:16d8:dda4:7fff:ffff:ffff:ffff:ffff,DK
-2001:16d8:dda4:8000::,2001:16d8:ffff:ffff:ffff:ffff:ffff:ffff,SE
+2001:16d8:dda4:8000::,2001:16d8:ddc1:ffff:ffff:ffff:ffff:ffff,SE
+2001:16d8:ddc2::,2001:16d8:ddc2:7fff:ffff:ffff:ffff:ffff,DK
+2001:16d8:ddc2:8000::,2001:16d8:ddd6:ffff:ffff:ffff:ffff:ffff,SE
+2001:16d8:ddd7::,2001:16d8:ddd7:7fff:ffff:ffff:ffff:ffff,DK
+2001:16d8:ddd7:8000::,2001:16d8:ee00:7fff:ffff:ffff:ffff:ffff,SE
+2001:16d8:ee00:8000::,2001:16d8:ee00:ffff:ffff:ffff:ffff:ffff,NO
+2001:16d8:ee01::,2001:16d8:ee8f:7fff:ffff:ffff:ffff:ffff,SE
+2001:16d8:ee8f:8000::,2001:16d8:ee8f:ffff:ffff:ffff:ffff:ffff,NO
+2001:16d8:ee90::,2001:16d8:eeca:ffff:ffff:ffff:ffff:ffff,SE
+2001:16d8:eecb::,2001:16d8:eecb:7fff:ffff:ffff:ffff:ffff,NO
+2001:16d8:eecb:8000::,2001:16d8:ffff:ffff:ffff:ffff:ffff:ffff,SE
 2001:16e0::,2001:16e7:ffff:ffff:ffff:ffff:ffff:ffff,DE
 2001:16e8::,2001:16e8:ffff:ffff:ffff:ffff:ffff:ffff,NL
 2001:16f0::,2001:16f7:ffff:ffff:ffff:ffff:ffff:ffff,DE
@@ -3909,7 +4702,9 @@
 2001:1820::,2001:1820:ffff:ffff:ffff:ffff:ffff:ffff,US
 2001:1828::,2001:1828:ffff:ffff:ffff:ffff:ffff:ffff,US
 2001:1830::,2001:1830:ffff:ffff:ffff:ffff:ffff:ffff,US
-2001:1838::,2001:1838:ffff:ffff:ffff:ffff:ffff:ffff,US
+2001:1838::,2001:1838:6000:ffff:ffff:ffff:ffff:ffff,US
+2001:1838:6001::,2001:1838:6001:7fff:ffff:ffff:ffff:ffff,AU
+2001:1838:6001:8000::,2001:1838:ffff:ffff:ffff:ffff:ffff:ffff,US
 2001:1840::,2001:1840:ffff:ffff:ffff:ffff:ffff:ffff,US
 2001:1848::,2001:1848:ffff:ffff:ffff:ffff:ffff:ffff,US
 2001:1850::,2001:1850:ffff:ffff:ffff:ffff:ffff:ffff,US
@@ -3947,7 +4742,9 @@
 2001:1960::,2001:1960:ffff:ffff:ffff:ffff:ffff:ffff,US
 2001:1968::,2001:1968:ffff:ffff:ffff:ffff:ffff:ffff,US
 2001:1970::,2001:1970:ffff:ffff:ffff:ffff:ffff:ffff,CA
-2001:1978::,2001:1978:ffff:ffff:ffff:ffff:ffff:ffff,US
+2001:1978::,2001:1978:10ff:ffff:ffff:ffff:ffff:ffff,US
+2001:1978:1100::,2001:1978:1100:7fff:ffff:ffff:ffff:ffff,CA
+2001:1978:1100:8000::,2001:1978:ffff:ffff:ffff:ffff:ffff:ffff,US
 2001:1980::,2001:1980:ffff:ffff:ffff:ffff:ffff:ffff,US
 2001:1988::,2001:1988:ffff:ffff:ffff:ffff:ffff:ffff,US
 2001:1990::,2001:1990:ffff:ffff:ffff:ffff:ffff:ffff,US
@@ -3964,18 +4761,24 @@
 2001:19e8::,2001:19e8:ffff:ffff:ffff:ffff:ffff:ffff,US
 2001:19f0::,2001:19f0:5000:7fff:ffff:ffff:ffff:ffff,US
 2001:19f0:5000:8000::,2001:19f0:5000:ffff:ffff:ffff:ffff:ffff,NL
-2001:19f0:5001::,2001:19f0:6800:7fff:ffff:ffff:ffff:ffff,US
-2001:19f0:6800:8000::,2001:19f0:6800:ffff:ffff:ffff:ffff:ffff,FR
-2001:19f0:6801::,2001:19f0:7000:7fff:ffff:ffff:ffff:ffff,US
-2001:19f0:7000:8000::,2001:19f0:7000:ffff:ffff:ffff:ffff:ffff,JP
-2001:19f0:7001::,2001:19f0:7400:7fff:ffff:ffff:ffff:ffff,US
+2001:19f0:5001::,2001:19f0:5800:7fff:ffff:ffff:ffff:ffff,US
+2001:19f0:5800:8000::,2001:19f0:5800:ffff:ffff:ffff:ffff:ffff,AU
+2001:19f0:5801::,2001:19f0:6800:7fff:ffff:ffff:ffff:ffff,US
+2001:19f0:6800:8000::,2001:19f0:6800:87ff:ffff:ffff:ffff:ffff,FR
+2001:19f0:6800:8800::,2001:19f0:6c00:7fff:ffff:ffff:ffff:ffff,US
+2001:19f0:6c00:8000::,2001:19f0:6c00:ffff:ffff:ffff:ffff:ffff,DE
+2001:19f0:6c01::,2001:19f0:7000:9bc8:ffff:ffff:ffff:ffff,US
+2001:19f0:7000:9bc9::,2001:19f0:7000:9bc9:ffff:ffff:ffff:ffff,JP
+2001:19f0:7000:9bca::,2001:19f0:7400:7fff:ffff:ffff:ffff:ffff,US
 2001:19f0:7400:8000::,2001:19f0:7400:ffff:ffff:ffff:ffff:ffff,GB
-2001:19f0:7401::,2001:19f0:7800:3fff:ffff:ffff:ffff:ffff,US
+2001:19f0:7401::,2001:19f0:7401:7fff:ffff:ffff:ffff:ffff,US
+2001:19f0:7401:8000::,2001:19f0:7401:ffff:ffff:ffff:ffff:ffff,GB
+2001:19f0:7402::,2001:19f0:7800:3fff:ffff:ffff:ffff:ffff,US
 2001:19f0:7800:4000::,2001:19f0:7800:4000:ffff:ffff:ffff:ffff,CA
 2001:19f0:7800:4001::,2001:19f0:ffff:ffff:ffff:ffff:ffff:ffff,US
 2001:19f8::,2001:19f8:ffff:ffff:ffff:ffff:ffff:ffff,US
 2001:1a08::,2001:1a08:ffff:ffff:ffff:ffff:ffff:ffff,GB
-2001:1a10::,2001:1a10:ffff:ffff:ffff:ffff:ffff:ffff,QA
+2001:1a10::,2001:1a17:ffff:ffff:ffff:ffff:ffff:ffff,QA
 2001:1a18::,2001:1a18:ffff:ffff:ffff:ffff:ffff:ffff,CY
 2001:1a20::,2001:1a20:ffff:ffff:ffff:ffff:ffff:ffff,GB
 2001:1a28::,2001:1a28:ffff:ffff:ffff:ffff:ffff:ffff,DE
@@ -4037,43 +4840,128 @@
 2001:1bf0::,2001:1bf7:ffff:ffff:ffff:ffff:ffff:ffff,EE
 2001:1bf8::,2001:1bf8:ffff:ffff:ffff:ffff:ffff:ffff,LV
 2001:1c00::,2001:1dff:ffff:ffff:ffff:ffff:ffff:ffff,NL
-2001:2002:2f8::,2001:2002:2f8:ffff:ffff:ffff:ffff:ffff,SE
-2001:2002:4e44:8000::,2001:2002:4e45:bfff:ffff:ffff:ffff:ffff,SE
-2001:2002:4e46::,2001:2002:4e46:ffff:ffff:ffff:ffff:ffff,SE
-2001:2002:4e48::,2001:2002:4e48:7fff:ffff:ffff:ffff:ffff,SE
-2001:2002:4e49::,2001:2002:4e49:3fff:ffff:ffff:ffff:ffff,SE
-2001:2002:4e49:6000::,2001:2002:4e49:ffff:ffff:ffff:ffff:ffff,SE
-2001:2002:51e0::,2001:2002:51e0:ffff:ffff:ffff:ffff:ffff,SE
-2001:2002:51e3::,2001:2002:51e3:7fff:ffff:ffff:ffff:ffff,SE
-2001:2002:51e5::,2001:2002:51e5:7fff:ffff:ffff:ffff:ffff,SE
-2001:2002:51e6::,2001:2002:51e7:7fff:ffff:ffff:ffff:ffff,SE
-2001:2002:51e8::,2001:2002:51e8:7fff:ffff:ffff:ffff:ffff,SE
-2001:2002:51e9:8000::,2001:2002:51ec:ffff:ffff:ffff:ffff:ffff,SE
+2001:2002:2f8::,2001:2002:2f8:7fff:ffff:ffff:ffff:ffff,SE
+2001:2002:2f9:8000::,2001:2002:2f9:ffff:ffff:ffff:ffff:ffff,SE
+2001:2002:3e14::,2001:2002:3e14:ffff:ffff:ffff:ffff:ffff,SE
+2001:2002:4e42::,2001:2002:4e44:7fff:ffff:ffff:ffff:ffff,SE
+2001:2002:4e45::,2001:2002:4e45:7fff:ffff:ffff:ffff:ffff,SE
+2001:2002:4e46::,2001:2002:4e46:7fff:ffff:ffff:ffff:ffff,SE
+2001:2002:4e47::,2001:2002:4e47:7fff:ffff:ffff:ffff:ffff,SE
+2001:2002:4e48::,2001:2002:4e48:afff:ffff:ffff:ffff:ffff,SE
+2001:2002:4e48:c000::,2001:2002:4e49:ffff:ffff:ffff:ffff:ffff,SE
+2001:2002:51e0::,2001:2002:51e0:7fff:ffff:ffff:ffff:ffff,SE
+2001:2002:51e1::,2001:2002:51e1:ffff:ffff:ffff:ffff:ffff,SE
+2001:2002:51e3:8000::,2001:2002:51e6:7fff:ffff:ffff:ffff:ffff,SE
+2001:2002:51e7::,2001:2002:51e9:ffff:ffff:ffff:ffff:ffff,SE
+2001:2002:51eb::,2001:2002:51eb:ffff:ffff:ffff:ffff:ffff,SE
+2001:2002:51ec:8000::,2001:2002:51ec:ffff:ffff:ffff:ffff:ffff,SE
 2001:2002:51ed:8000::,2001:2002:51ed:ffff:ffff:ffff:ffff:ffff,SE
 2001:2002:5ae0::,2001:2002:5ae1:7fff:ffff:ffff:ffff:ffff,SE
-2001:2002:5ae3:a000::,2001:2002:5ae3:bfff:ffff:ffff:ffff:ffff,SE
-2001:2002:5ae5:8000::,2001:2002:5ae5:ffff:ffff:ffff:ffff:ffff,SE
-2001:2002:5ae7::,2001:2002:5ae7:7fff:ffff:ffff:ffff:ffff,SE
-2001:2002:5ae7:c000::,2001:2002:5ae7:ffff:ffff:ffff:ffff:ffff,SE
-2001:2002:d540::,2001:2002:d540:ffff:ffff:ffff:ffff:ffff,SE
-2001:2002:d541:8000::,2001:2002:d542:7fff:ffff:ffff:ffff:ffff,SE
+2001:2002:5ae2::,2001:2002:5ae3:ffff:ffff:ffff:ffff:ffff,SE
+2001:2002:5ae4:8000::,2001:2002:5ae4:ffff:ffff:ffff:ffff:ffff,SE
+2001:2002:5ae6:8000::,2001:2002:5ae6:ffff:ffff:ffff:ffff:ffff,SE
+2001:2002:c2ec:8000::,2001:2002:c2ec:ffff:ffff:ffff:ffff:ffff,SE
+2001:2002:c343:8000::,2001:2002:c343:ffff:ffff:ffff:ffff:ffff,SE
+2001:2002:c3c6::,2001:2002:c3c6:7fff:ffff:ffff:ffff:ffff,SE
+2001:2002:c3fc::,2001:2002:c3fc:7fff:ffff:ffff:ffff:ffff,SE
+2001:2002:d540::,2001:2002:d540:7fff:ffff:ffff:ffff:ffff,SE
+2001:2002:d541::,2001:2002:d542:7fff:ffff:ffff:ffff:ffff,SE
 2001:2002:d543::,2001:2002:d543:7fff:ffff:ffff:ffff:ffff,SE
 2001:2002:d9d0::,2001:2002:d9d0:7fff:ffff:ffff:ffff:ffff,SE
-2001:2002:d9d1::,2001:2002:d9d1:ffff:ffff:ffff:ffff:ffff,SE
-2001:2002:d9d2:8000::,2001:2002:d9d3:7fff:ffff:ffff:ffff:ffff,SE
+2001:2002:d9d1::,2001:2002:d9d1:7fff:ffff:ffff:ffff:ffff,SE
+2001:2002:d9d2::,2001:2002:d9d2:ffff:ffff:ffff:ffff:ffff,SE
+2001:2002:d9d3:8000::,2001:2002:d9d3:ffff:ffff:ffff:ffff:ffff,SE
 2001:2002:d9d4:8000::,2001:2002:d9d4:ffff:ffff:ffff:ffff:ffff,SE
-2001:2003:50dc::,2001:2003:50dc:7fff:ffff:ffff:ffff:ffff,FI
-2001:2003:54f9::,2001:2003:54f9:7fff:ffff:ffff:ffff:ffff,FI
+2001:2002:d9d7::,2001:2002:d9d7:ffff:ffff:ffff:ffff:ffff,SE
+2001:2003:50dc::,2001:2003:50df:7fff:ffff:ffff:ffff:ffff,FI
+2001:2003:54f8:4000::,2001:2003:54fb:ffff:ffff:ffff:ffff:ffff,FI
+2001:2003:58c0::,2001:2003:58c1:ffff:ffff:ffff:ffff:ffff,FI
+2001:2003:58c3::,2001:2003:58c3:ffff:ffff:ffff:ffff:ffff,FI
+2001:2003:f042:8000::,2001:2003:f042:ffff:ffff:ffff:ffff:ffff,FI
+2001:2003:f05e:8000::,2001:2003:f05e:ffff:ffff:ffff:ffff:ffff,FI
+2001:2003:f072:8000::,2001:2003:f072:ffff:ffff:ffff:ffff:ffff,FI
+2001:2003:f0ab::,2001:2003:f0ab:7fff:ffff:ffff:ffff:ffff,FI
+2001:2003:f0b6::,2001:2003:f0b6:7fff:ffff:ffff:ffff:ffff,FI
+2001:2003:f0c8:8000::,2001:2003:f0c8:ffff:ffff:ffff:ffff:ffff,FI
+2001:2003:f0e5:8000::,2001:2003:f0e5:ffff:ffff:ffff:ffff:ffff,FI
+2001:2003:f13d:8000::,2001:2003:f13d:ffff:ffff:ffff:ffff:ffff,FI
+2001:2003:f19b::,2001:2003:f19b:7fff:ffff:ffff:ffff:ffff,FI
+2001:2003:f19c:8000::,2001:2003:f19c:ffff:ffff:ffff:ffff:ffff,FI
+2001:2003:f21a::,2001:2003:f21a:7fff:ffff:ffff:ffff:ffff,FI
+2001:2003:f22c::,2001:2003:f22c:7fff:ffff:ffff:ffff:ffff,FI
+2001:2003:f237::,2001:2003:f237:7fff:ffff:ffff:ffff:ffff,FI
+2001:2003:f250:8000::,2001:2003:f250:ffff:ffff:ffff:ffff:ffff,FI
+2001:2003:f2c3:8000::,2001:2003:f2c3:ffff:ffff:ffff:ffff:ffff,FI
+2001:2003:f36f::,2001:2003:f36f:7fff:ffff:ffff:ffff:ffff,FI
+2001:2003:f386::,2001:2003:f386:7fff:ffff:ffff:ffff:ffff,FI
+2001:2003:f388::,2001:2003:f388:7fff:ffff:ffff:ffff:ffff,FI
+2001:2003:f3be:8000::,2001:2003:f3be:ffff:ffff:ffff:ffff:ffff,FI
+2001:2003:f441::,2001:2003:f441:ffff:ffff:ffff:ffff:ffff,FI
+2001:2003:f447::,2001:2003:f447:7fff:ffff:ffff:ffff:ffff,FI
+2001:2003:f44a:8000::,2001:2003:f44a:ffff:ffff:ffff:ffff:ffff,FI
+2001:2003:f45a::,2001:2003:f45a:7fff:ffff:ffff:ffff:ffff,FI
 2001:2003:f468:8000::,2001:2003:f468:ffff:ffff:ffff:ffff:ffff,FI
+2001:2003:f46d:8000::,2001:2003:f46d:ffff:ffff:ffff:ffff:ffff,FI
+2001:2003:f476::,2001:2003:f476:7fff:ffff:ffff:ffff:ffff,FI
+2001:2003:f48c:8000::,2001:2003:f48c:ffff:ffff:ffff:ffff:ffff,FI
+2001:2003:f4a6:8000::,2001:2003:f4a6:ffff:ffff:ffff:ffff:ffff,FI
+2001:2003:f543::,2001:2003:f543:7fff:ffff:ffff:ffff:ffff,FI
+2001:2003:f5dc::,2001:2003:f5dc:7fff:ffff:ffff:ffff:ffff,FI
+2001:2003:f603:8000::,2001:2003:f603:ffff:ffff:ffff:ffff:ffff,FI
+2001:2003:f617::,2001:2003:f617:7fff:ffff:ffff:ffff:ffff,FI
+2001:2003:f620::,2001:2003:f620:7fff:ffff:ffff:ffff:ffff,FI
+2001:2003:f639::,2001:2003:f639:7fff:ffff:ffff:ffff:ffff,FI
+2001:2003:f64e::,2001:2003:f64e:7fff:ffff:ffff:ffff:ffff,FI
+2001:2003:f662::,2001:2003:f662:7fff:ffff:ffff:ffff:ffff,FI
+2001:2003:f67c:8000::,2001:2003:f67c:ffff:ffff:ffff:ffff:ffff,FI
+2001:2003:f6a9:8000::,2001:2003:f6a9:ffff:ffff:ffff:ffff:ffff,FI
+2001:2003:f6ba::,2001:2003:f6ba:7fff:ffff:ffff:ffff:ffff,FI
+2001:2003:f6da::,2001:2003:f6da:7fff:ffff:ffff:ffff:ffff,FI
+2001:2003:f72a::,2001:2003:f72a:7fff:ffff:ffff:ffff:ffff,FI
+2001:2003:f72c:8000::,2001:2003:f72c:ffff:ffff:ffff:ffff:ffff,FI
+2001:2003:f744:8000::,2001:2003:f744:ffff:ffff:ffff:ffff:ffff,FI
+2001:2003:f764::,2001:2003:f764:7fff:ffff:ffff:ffff:ffff,FI
+2001:2003:f786::,2001:2003:f786:7fff:ffff:ffff:ffff:ffff,FI
+2001:2003:f798:8000::,2001:2003:f798:ffff:ffff:ffff:ffff:ffff,FI
+2001:2003:f7a3:8000::,2001:2003:f7a3:ffff:ffff:ffff:ffff:ffff,FI
+2001:2003:f802::,2001:2003:f802:7fff:ffff:ffff:ffff:ffff,FI
+2001:2003:f824::,2001:2003:f824:7fff:ffff:ffff:ffff:ffff,FI
 2001:2003:f825:8000::,2001:2003:f825:ffff:ffff:ffff:ffff:ffff,FI
+2001:2003:f839::,2001:2003:f839:7fff:ffff:ffff:ffff:ffff,FI
+2001:2003:f83c::,2001:2003:f83c:7fff:ffff:ffff:ffff:ffff,FI
+2001:2003:f849::,2001:2003:f849:7fff:ffff:ffff:ffff:ffff,FI
+2001:2003:f882:8000::,2001:2003:f882:ffff:ffff:ffff:ffff:ffff,FI
+2001:2003:f8d4::,2001:2003:f8d4:7fff:ffff:ffff:ffff:ffff,FI
 2001:2003:f8f6:8000::,2001:2003:f8f6:ffff:ffff:ffff:ffff:ffff,FI
-2001:2010:d002::,2001:2010:d002:7fff:ffff:ffff:ffff:ffff,DK
-2001:2010:d003::,2001:2010:d004:7fff:ffff:ffff:ffff:ffff,DK
-2001:2010:d00c::,2001:2010:d00c:7fff:ffff:ffff:ffff:ffff,DK
+2001:2003:f8f9:8000::,2001:2003:f8f9:ffff:ffff:ffff:ffff:ffff,FI
+2001:2003:f969:8000::,2001:2003:f969:ffff:ffff:ffff:ffff:ffff,FI
+2001:2003:f9e7:8000::,2001:2003:f9e7:ffff:ffff:ffff:ffff:ffff,FI
+2001:2003:f9f1::,2001:2003:f9f1:7fff:ffff:ffff:ffff:ffff,FI
+2001:2003:fa67::,2001:2003:fa67:7fff:ffff:ffff:ffff:ffff,FI
+2001:2003:fa6f:8000::,2001:2003:fa6f:ffff:ffff:ffff:ffff:ffff,FI
+2001:2010:d001::,2001:2010:d001:7fff:ffff:ffff:ffff:ffff,DK
+2001:2010:d002::,2001:2010:d007:7fff:ffff:ffff:ffff:ffff,DK
+2001:2010:d009::,2001:2010:d00a:ffff:ffff:ffff:ffff:ffff,DK
+2001:2010:d00b:8000::,2001:2010:d00c:7fff:ffff:ffff:ffff:ffff,DK
+2001:2010:d00d::,2001:2010:d00d:7fff:ffff:ffff:ffff:ffff,DK
 2001:2010:d00e::,2001:2010:d00e:7fff:ffff:ffff:ffff:ffff,DK
+2001:2010:d00f:8000::,2001:2010:d00f:ffff:ffff:ffff:ffff:ffff,DK
+2001:2010:d012:8000::,2001:2010:d014:ffff:ffff:ffff:ffff:ffff,DK
+2001:2010:d01a:8000::,2001:2010:d01c:ffff:ffff:ffff:ffff:ffff,DK
+2001:2010:d01f:8000::,2001:2010:d01f:ffff:ffff:ffff:ffff:ffff,DK
+2001:2010:d023:8000::,2001:2010:d023:ffff:ffff:ffff:ffff:ffff,DK
+2001:2010:d029::,2001:2010:d029:7fff:ffff:ffff:ffff:ffff,DK
 2001:2010:d038:8000::,2001:2010:d038:ffff:ffff:ffff:ffff:ffff,DK
+2001:2010:d039:8000::,2001:2010:d03a:ffff:ffff:ffff:ffff:ffff,DK
 2001:2010:d04e:8000::,2001:2010:d04e:ffff:ffff:ffff:ffff:ffff,DK
+2001:2011:c002::,2001:2011:c002:ffff:ffff:ffff:ffff:ffff,DK
+2001:2012:3ec6::,2001:2012:3ec6:ffff:ffff:ffff:ffff:ffff,DK
+2001:2012:3ec7:8000::,2001:2012:3ec7:ffff:ffff:ffff:ffff:ffff,DK
+2001:2012:c213:8000::,2001:2012:c213:ffff:ffff:ffff:ffff:ffff,DK
 2001:2040:4b::,2001:2040:4b:ffff:ffff:ffff:ffff:ffff,SE
+2001:2040:c006::,2001:2040:c006:ffff:ffff:ffff:ffff:ffff,SE
+2001:2060:41::,2001:2060:41:7fff:ffff:ffff:ffff:ffff,FI
+2001:2060:bffb::,2001:2060:bffb:ffff:ffff:ffff:ffff:ffff,FI
 2001:4000::,2001:4000:ffff:ffff:ffff:ffff:ffff:ffff,FR
 2001:4010::,2001:4010:ffff:ffff:ffff:ffff:ffff:ffff,GB
 2001:4018::,2001:4018:ffff:ffff:ffff:ffff:ffff:ffff,NL
@@ -4127,7 +5015,11 @@
 2001:41c0::,2001:41cf:ffff:ffff:ffff:ffff:ffff:ffff,GB
 2001:41d0::,2001:41d0:2:4dbd:ffff:ffff:ffff:ffff,FR
 2001:41d0:2:4dbe::,2001:41d0:2:4dbe:ffff:ffff:ffff:ffff,CZ
-2001:41d0:2:4dbf::,2001:41d0:ffff:ffff:ffff:ffff:ffff:ffff,FR
+2001:41d0:2:4dbf::,2001:41d0:a:5dff:ffff:ffff:ffff:ffff,FR
+2001:41d0:a:5e00::,2001:41d0:a:5fff:ffff:ffff:ffff:ffff,ES
+2001:41d0:a:6000::,2001:41d0:129:9bff:ffff:ffff:ffff:ffff,FR
+2001:41d0:129:9c00::,2001:41d0:129:9cff:ffff:ffff:ffff:ffff,NL
+2001:41d0:129:9d00::,2001:41d0:ffff:ffff:ffff:ffff:ffff:ffff,FR
 2001:41d8::,2001:41d8:ffff:ffff:ffff:ffff:ffff:ffff,CZ
 2001:41e0::,2001:41e0:ffff:ffff:ffff:ffff:ffff:ffff,CH
 2001:41e8::,2001:41e8:ffff:ffff:ffff:ffff:ffff:ffff,GB
@@ -4306,6 +5198,8 @@
 2001:43f8:ae0::,2001:43f8:ae1:ffff:ffff:ffff:ffff:ffff,GH
 2001:43f8:af0::,2001:43f8:af1:ffff:ffff:ffff:ffff:ffff,BJ
 2001:43f8:b00::,2001:43f8:b00:ffff:ffff:ffff:ffff:ffff,KE
+2001:43f8:b10::,2001:43f8:b10:ffff:ffff:ffff:ffff:ffff,NG
+2001:43f8:b20::,2001:43f8:b20:ffff:ffff:ffff:ffff:ffff,CI
 2001:4400::,2001:4403:ffff:ffff:ffff:ffff:ffff:ffff,NZ
 2001:4408::,2001:4408:ffff:ffff:ffff:ffff:ffff:ffff,IN
 2001:4410::,2001:4410:ffff:ffff:ffff:ffff:ffff:ffff,NZ
@@ -4338,14 +5232,28 @@
 2001:4538::,2001:4538:ffff:ffff:ffff:ffff:ffff:ffff,PK
 2001:4540::,2001:455f:ffff:ffff:ffff:ffff:ffff:ffff,TW
 2001:4580::,2001:45bf:ffff:ffff:ffff:ffff:ffff:ffff,TW
-2001:4600::,2001:46ff:ffff:ffff:ffff:ffff:ffff:ffff,NO
+2001:4600::,2001:4641:eac9:ffff:ffff:ffff:ffff:ffff,NO
+2001:4641:eaca::,2001:4641:eaca:7fff:ffff:ffff:ffff:ffff,DE
+2001:4641:eaca:8000::,2001:46ff:ffff:ffff:ffff:ffff:ffff:ffff,NO
 2001:4800::,2001:4808:ffff:ffff:ffff:ffff:ffff:ffff,US
 2001:4810::,2001:4810:ffff:ffff:ffff:ffff:ffff:ffff,US
 2001:4818::,2001:4818:ffff:ffff:ffff:ffff:ffff:ffff,CA
 2001:4828::,2001:4828:ffff:ffff:ffff:ffff:ffff:ffff,US
-2001:4830::,2001:4830:1207:ffff:ffff:ffff:ffff:ffff,US
+2001:4830::,2001:4830:1100:81ff:ffff:ffff:ffff:ffff,US
+2001:4830:1100:8200::,2001:4830:1100:82ff:ffff:ffff:ffff:ffff,CA
+2001:4830:1100:8300::,2001:4830:1200:7fff:ffff:ffff:ffff:ffff,US
+2001:4830:1200:8000::,2001:4830:1200:ffff:ffff:ffff:ffff:ffff,AU
+2001:4830:1201::,2001:4830:1207:ffff:ffff:ffff:ffff:ffff,US
 2001:4830:1208::,2001:4830:1208:7fff:ffff:ffff:ffff:ffff,AU
-2001:4830:1208:8000::,2001:4830:600f:ffff:ffff:ffff:ffff:ffff,US
+2001:4830:1208:8000::,2001:4830:1212:ffff:ffff:ffff:ffff:ffff,US
+2001:4830:1213::,2001:4830:1213:7fff:ffff:ffff:ffff:ffff,AU
+2001:4830:1213:8000::,2001:4830:1216:ffff:ffff:ffff:ffff:ffff,US
+2001:4830:1217::,2001:4830:1217:7fff:ffff:ffff:ffff:ffff,AU
+2001:4830:1217:8000::,2001:4830:121d:ffff:ffff:ffff:ffff:ffff,US
+2001:4830:121e::,2001:4830:121e:ffff:ffff:ffff:ffff:ffff,AU
+2001:4830:121f::,2001:4830:1301:ffff:ffff:ffff:ffff:ffff,US
+2001:4830:1302::,2001:4830:1302:7fff:ffff:ffff:ffff:ffff,AU
+2001:4830:1302:8000::,2001:4830:600f:ffff:ffff:ffff:ffff:ffff,US
 2001:4830:6010::,2001:4830:601f:ffff:ffff:ffff:ffff:ffff,GB
 2001:4830:6020::,2001:4830:ffff:ffff:ffff:ffff:ffff:ffff,US
 2001:4838::,2001:4838:ffff:ffff:ffff:ffff:ffff:ffff,US
@@ -4356,16 +5264,28 @@
 2001:4860::,2001:4860:ffff:ffff:ffff:ffff:ffff:ffff,US
 2001:4868::,2001:4868:ffff:ffff:ffff:ffff:ffff:ffff,US
 2001:4870::,2001:4871:ffff:ffff:ffff:ffff:ffff:ffff,US
-2001:4878::,2001:4878:8216:ffff:ffff:ffff:ffff:ffff,US
+2001:4878::,2001:4878:8203:ffff:ffff:ffff:ffff:ffff,US
+2001:4878:8204::,2001:4878:8204:7fff:ffff:ffff:ffff:ffff,DE
+2001:4878:8204:8000::,2001:4878:8216:ffff:ffff:ffff:ffff:ffff,US
 2001:4878:8217::,2001:4878:8217:7fff:ffff:ffff:ffff:ffff,ES
-2001:4878:8217:8000::,2001:4878:8224:ffff:ffff:ffff:ffff:ffff,US
+2001:4878:8217:8000::,2001:4878:821f:ffff:ffff:ffff:ffff:ffff,US
+2001:4878:8220::,2001:4878:8220:7fff:ffff:ffff:ffff:ffff,SE
+2001:4878:8220:8000::,2001:4878:8224:ffff:ffff:ffff:ffff:ffff,US
 2001:4878:8225::,2001:4878:8225:7fff:ffff:ffff:ffff:ffff,PL
 2001:4878:8225:8000::,2001:4878:8227:ffff:ffff:ffff:ffff:ffff,US
 2001:4878:8228::,2001:4878:8228:7fff:ffff:ffff:ffff:ffff,IL
-2001:4878:8228:8000::,2001:4878:ffff:ffff:ffff:ffff:ffff:ffff,US
+2001:4878:8228:8000::,2001:4878:8233:ffff:ffff:ffff:ffff:ffff,US
+2001:4878:8234::,2001:4878:8234:7fff:ffff:ffff:ffff:ffff,GB
+2001:4878:8234:8000::,2001:4878:8304:ffff:ffff:ffff:ffff:ffff,US
+2001:4878:8305::,2001:4878:8305:7fff:ffff:ffff:ffff:ffff,IN
+2001:4878:8305:8000::,2001:4878:8321:ffff:ffff:ffff:ffff:ffff,US
+2001:4878:8322::,2001:4878:8322:7fff:ffff:ffff:ffff:ffff,JP
+2001:4878:8322:8000::,2001:4878:ffff:ffff:ffff:ffff:ffff:ffff,US
 2001:4888::,2001:4888:ffff:ffff:ffff:ffff:ffff:ffff,US
 2001:4890::,2001:4890:ffff:ffff:ffff:ffff:ffff:ffff,US
-2001:4898::,2001:489a:ffff:ffff:ffff:ffff:ffff:ffff,US
+2001:4898::,2001:4898:de07:ffff:ffff:ffff:ffff:ffff,US
+2001:4898:de08::,2001:4898:de08:7fff:ffff:ffff:ffff:ffff,BR
+2001:4898:de08:8000::,2001:489a:ffff:ffff:ffff:ffff:ffff:ffff,US
 2001:48a0::,2001:48a0:ffff:ffff:ffff:ffff:ffff:ffff,US
 2001:48a8::,2001:48a8:ffff:ffff:ffff:ffff:ffff:ffff,US
 2001:48b0::,2001:48b0:ffff:ffff:ffff:ffff:ffff:ffff,US
@@ -4398,7 +5318,13 @@
 2001:4970::,2001:4970:ffff:ffff:ffff:ffff:ffff:ffff,US
 2001:4978::,2001:4978:f:7fff:ffff:ffff:ffff:ffff,US
 2001:4978:f:8000::,2001:4978:f:ffff:ffff:ffff:ffff:ffff,CA
-2001:4978:10::,2001:4978:ffff:ffff:ffff:ffff:ffff:ffff,US
+2001:4978:10::,2001:4978:1e2:ffff:ffff:ffff:ffff:ffff,US
+2001:4978:1e3::,2001:4978:1e3:7fff:ffff:ffff:ffff:ffff,CA
+2001:4978:1e3:8000::,2001:4978:2d0:ffff:ffff:ffff:ffff:ffff,US
+2001:4978:2d1::,2001:4978:2d1:7fff:ffff:ffff:ffff:ffff,CA
+2001:4978:2d1:8000::,2001:4978:305:ffff:ffff:ffff:ffff:ffff,US
+2001:4978:306::,2001:4978:306:7fff:ffff:ffff:ffff:ffff,CA
+2001:4978:306:8000::,2001:4978:ffff:ffff:ffff:ffff:ffff:ffff,US
 2001:4980::,2001:4980:ffff:ffff:ffff:ffff:ffff:ffff,US
 2001:4988::,2001:4988:ffff:ffff:ffff:ffff:ffff:ffff,US
 2001:4990::,2001:4990:ffff:ffff:ffff:ffff:ffff:ffff,US
@@ -4449,10 +5375,18 @@
 2001:4bf0::,2001:4bf0:ffff:ffff:ffff:ffff:ffff:ffff,GB
 2001:4bf8::,2001:4bf8:ffff:ffff:ffff:ffff:ffff:ffff,CH
 2001:4c00::,2001:4c07:ffff:ffff:ffff:ffff:ffff:ffff,IT
-2001:4c08::,2001:4c08:ffff:ffff:ffff:ffff:ffff:ffff,GB
+2001:4c08::,2001:4c08:2000:ffff:ffff:ffff:ffff:ffff,GB
+2001:4c08:2001::,2001:4c08:2001:7fff:ffff:ffff:ffff:ffff,NL
+2001:4c08:2001:8000::,2001:4c08:200c:ffff:ffff:ffff:ffff:ffff,GB
+2001:4c08:200d::,2001:4c08:200d:7fff:ffff:ffff:ffff:ffff,DE
+2001:4c08:200d:8000::,2001:4c08:ffff:ffff:ffff:ffff:ffff:ffff,GB
 2001:4c10::,2001:4c10:ffff:ffff:ffff:ffff:ffff:ffff,NL
 2001:4c20::,2001:4c20:ffff:ffff:ffff:ffff:ffff:ffff,GB
-2001:4c28::,2001:4c28:ffff:ffff:ffff:ffff:ffff:ffff,NO
+2001:4c28::,2001:4c28::ffff:ffff:ffff:ffff:ffff,NO
+2001:4c28:1::,2001:4c28:1:7fff:ffff:ffff:ffff:ffff,RU
+2001:4c28:1:8000::,2001:4c28:2fff:ffff:ffff:ffff:ffff:ffff,NO
+2001:4c28:3000::,2001:4c28:3000:7fff:ffff:ffff:ffff:ffff,US
+2001:4c28:3000:8000::,2001:4c28:ffff:ffff:ffff:ffff:ffff:ffff,NO
 2001:4c30::,2001:4c30:ffff:ffff:ffff:ffff:ffff:ffff,PL
 2001:4c38::,2001:4c3f:ffff:ffff:ffff:ffff:ffff:ffff,NL
 2001:4c40::,2001:4c40:ffff:ffff:ffff:ffff:ffff:ffff,BE
@@ -4489,10 +5423,12 @@
 2001:4d58::,2001:4d58:ffff:ffff:ffff:ffff:ffff:ffff,CH
 2001:4d60::,2001:4d60:ffff:ffff:ffff:ffff:ffff:ffff,NL
 2001:4d68::,2001:4d68:ffff:ffff:ffff:ffff:ffff:ffff,IE
-2001:4d70::,2001:4d70:ffff:ffff:ffff:ffff:ffff:ffff,GR
+2001:4d70::,2001:4d70:ffff:ffff:ffff:ffff:ffff:ffff,BG
 2001:4d78::,2001:4d78:ffff:ffff:ffff:ffff:ffff:ffff,GB
 2001:4d80::,2001:4d80:ffff:ffff:ffff:ffff:ffff:ffff,RO
-2001:4d88::,2001:4d88:ffff:ffff:ffff:ffff:ffff:ffff,DE
+2001:4d88::,2001:4d88:1010:ffff:ffff:ffff:ffff:ffff,DE
+2001:4d88:1011::,2001:4d88:1011:7fff:ffff:ffff:ffff:ffff,ZA
+2001:4d88:1011:8000::,2001:4d88:ffff:ffff:ffff:ffff:ffff:ffff,DE
 2001:4d90::,2001:4d90:ffff:ffff:ffff:ffff:ffff:ffff,ES
 2001:4d98::,2001:4d98:ffff:ffff:ffff:ffff:ffff:ffff,CH
 2001:4da0::,2001:4da7:ffff:ffff:ffff:ffff:ffff:ffff,CH
@@ -4510,10 +5446,30 @@
 2001:4df0::,2001:4df0:ffff:ffff:ffff:ffff:ffff:ffff,IL
 2001:8000::,2001:8fff:ffff:ffff:ffff:ffff:ffff:ffff,AU
 2001:a000::,2001:a7ff:ffff:ffff:ffff:ffff:ffff:ffff,JP
-2001:b000::,2001:b7ff:ffff:ffff:ffff:ffff:ffff:ffff,TW
+2001:b000::,2001:b010:fc7f:ffff:ffff:ffff:ffff:ffff,TW
+2001:b010:fc80::,2001:b010:fc80:7fff:ffff:ffff:ffff:ffff,CN
+2001:b010:fc80:8000::,2001:b7ff:ffff:ffff:ffff:ffff:ffff:ffff,TW
 2003::,2003:45:2d04:7fff:ffff:ffff:ffff:ffff,DE
 2003:45:2d04:8000::,2003:45:2d04:ffff:ffff:ffff:ffff:ffff,TR
-2003:45:2d05::,2003:1fff:ffff:ffff:ffff:ffff:ffff:ffff,DE
+2003:45:2d05::,2003:45:2d35:7fff:ffff:ffff:ffff:ffff,DE
+2003:45:2d35:8000::,2003:45:2d35:ffff:ffff:ffff:ffff:ffff,TR
+2003:45:2d36::,2003:45:2d36:7fff:ffff:ffff:ffff:ffff,DE
+2003:45:2d36:8000::,2003:45:2d36:ffff:ffff:ffff:ffff:ffff,TR
+2003:45:2d37::,2003:4b:ae58:ffff:ffff:ffff:ffff:ffff,DE
+2003:4b:ae59::,2003:4b:ae59:7fff:ffff:ffff:ffff:ffff,PL
+2003:4b:ae59:8000::,2003:56:ae38:ffff:ffff:ffff:ffff:ffff,DE
+2003:56:ae39::,2003:56:ae39:7fff:ffff:ffff:ffff:ffff,PL
+2003:56:ae39:8000::,2003:61:ea1b:ffff:ffff:ffff:ffff:ffff,DE
+2003:61:ea1c::,2003:61:ea1c:7fff:ffff:ffff:ffff:ffff,GB
+2003:61:ea1c:8000::,2003:62:4e56:7fff:ffff:ffff:ffff:ffff,DE
+2003:62:4e56:8000::,2003:62:4e56:ffff:ffff:ffff:ffff:ffff,CH
+2003:62:4e57::,2003:6a:7f66:7fff:ffff:ffff:ffff:ffff,DE
+2003:6a:7f66:8000::,2003:6a:7f66:ffff:ffff:ffff:ffff:ffff,CH
+2003:6a:7f67::,2003:87:292f:ffff:ffff:ffff:ffff:ffff,DE
+2003:87:2930::,2003:87:2930:7fff:ffff:ffff:ffff:ffff,NZ
+2003:87:2930:8000::,2003:87:2968:7fff:ffff:ffff:ffff:ffff,DE
+2003:87:2968:8000::,2003:87:2968:ffff:ffff:ffff:ffff:ffff,NZ
+2003:87:2969::,2003:1fff:ffff:ffff:ffff:ffff:ffff:ffff,DE
 2067:8e00::,2067:8e00:ffff:ffff:ffff:ffff:ffff:ffff,US
 2160:150::,2160:150:7fff:ffff:ffff:ffff:ffff:ffff,US
 2400::,2400:fff:ffff:ffff:ffff:ffff:ffff:ffff,KR
@@ -4709,8 +5665,9 @@
 2400:8780::,2400:8780:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2400:8800::,2400:8800:ffff:ffff:ffff:ffff:ffff:ffff,HK
 2400:8880::,2400:8880:ffff:ffff:ffff:ffff:ffff:ffff,IN
-2400:8900::,2400:8900::7fff:ffff:ffff:ffff:ffff,JP
-2400:8900:0:8000::,2400:8901:ffff:ffff:ffff:ffff:ffff:ffff,SG
+2400:8900::,2400:8900::f03c:91ff:fe70:9ac8,SG
+2400:8900::f03c:91ff:fe70:9ac9,2400:8900::f03c:91ff:fe70:9ac9,JP
+2400:8900::f03c:91ff:fe70:9aca,2400:8901:ffff:ffff:ffff:ffff:ffff:ffff,SG
 2400:8980::,2400:8980:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2400:8a00::,2400:8a00:ffff:ffff:ffff:ffff:ffff:ffff,AU
 2400:8a80::,2400:8a80:ffff:ffff:ffff:ffff:ffff:ffff,PH
@@ -4737,7 +5694,6 @@
 2400:9500::,2400:9500:ffff:ffff:ffff:ffff:ffff:ffff,NP
 2400:9580::,2400:9580:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2400:9600::,2400:9600:ffff:ffff:ffff:ffff:ffff:ffff,CN
-2400:9680::,2400:9680:ffff:ffff:ffff:ffff:ffff:ffff,HK
 2400:9700::,2400:9700:ffff:ffff:ffff:ffff:ffff:ffff,NP
 2400:9780::,2400:9780:ffff:ffff:ffff:ffff:ffff:ffff,SG
 2400:9800::,2400:9800:ffff:ffff:ffff:ffff:ffff:ffff,ID
@@ -4821,7 +5777,6 @@
 2400:c380::,2400:c380:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2400:c400::,2400:c400:ffff:ffff:ffff:ffff:ffff:ffff,AU
 2400:c401::,2400:c401:ffff:ffff:ffff:ffff:ffff:ffff,US
-2400:c480::,2400:c480:ffff:ffff:ffff:ffff:ffff:ffff,HK
 2400:c500::,2400:c500:ffff:ffff:ffff:ffff:ffff:ffff,AU
 2400:c580::,2400:c580:ffff:ffff:ffff:ffff:ffff:ffff,NZ
 2400:c600::,2400:c600:ffff:ffff:ffff:ffff:ffff:ffff,BD
@@ -4833,11 +5788,78 @@
 2400:c900::,2400:c900:ffff:ffff:ffff:ffff:ffff:ffff,ID
 2400:c980::,2400:c980:ffff:ffff:ffff:ffff:ffff:ffff,SG
 2400:ca00::,2400:ca00:ffff:ffff:ffff:ffff:ffff:ffff,BD
-2400:cb00::,2400:cb00:24:ffff:ffff:ffff:ffff:ffff,HK
-2400:cb00:25::,2400:cb00:25:7fff:ffff:ffff:ffff:ffff,GB
-2400:cb00:25:8000::,2400:cb00:f00c:ffff:ffff:ffff:ffff:ffff,HK
-2400:cb00:f00d::,2400:cb00:f00d:7fff:ffff:ffff:ffff:ffff,US
-2400:cb00:f00d:8000::,2400:cb00:ffff:ffff:ffff:ffff:ffff:ffff,HK
+2400:cb00::,2400:cb00::ffff:ffff:ffff:ffff:ffff,US
+2400:cb00:1::,2400:cb00:3:ffff:ffff:ffff:ffff:ffff,HK
+2400:cb00:4::,2400:cb00:4:ffff:ffff:ffff:ffff:ffff,US
+2400:cb00:5::,2400:cb00:10:ffff:ffff:ffff:ffff:ffff,HK
+2400:cb00:11::,2400:cb00:12:ffff:ffff:ffff:ffff:ffff,US
+2400:cb00:13::,2400:cb00:13:ffff:ffff:ffff:ffff:ffff,HK
+2400:cb00:14::,2400:cb00:17:ffff:ffff:ffff:ffff:ffff,US
+2400:cb00:18::,2400:cb00:18:ffff:ffff:ffff:ffff:ffff,HK
+2400:cb00:19::,2400:cb00:19:ffff:ffff:ffff:ffff:ffff,FR
+2400:cb00:1a::,2400:cb00:1f:ffff:ffff:ffff:ffff:ffff,HK
+2400:cb00:20::,2400:cb00:20:ffff:ffff:ffff:ffff:ffff,NL
+2400:cb00:21::,2400:cb00:21:ffff:ffff:ffff:ffff:ffff,GB
+2400:cb00:22::,2400:cb00:22:ffff:ffff:ffff:ffff:ffff,JP
+2400:cb00:23::,2400:cb00:24:ffff:ffff:ffff:ffff:ffff,HK
+2400:cb00:25::,2400:cb00:25:ffff:ffff:ffff:ffff:ffff,US
+2400:cb00:26::,2400:cb00:26:ffff:ffff:ffff:ffff:ffff,AU
+2400:cb00:27::,2400:cb00:28:ffff:ffff:ffff:ffff:ffff,US
+2400:cb00:29::,2400:cb00:29:ffff:ffff:ffff:ffff:ffff,CA
+2400:cb00:2a::,2400:cb00:2f:ffff:ffff:ffff:ffff:ffff,HK
+2400:cb00:30::,2400:cb00:30:ffff:ffff:ffff:ffff:ffff,AT
+2400:cb00:31::,2400:cb00:31:ffff:ffff:ffff:ffff:ffff,CZ
+2400:cb00:32::,2400:cb00:32:ffff:ffff:ffff:ffff:ffff,SE
+2400:cb00:33::,2400:cb00:33:ffff:ffff:ffff:ffff:ffff,PL
+2400:cb00:34::,2400:cb00:34:ffff:ffff:ffff:ffff:ffff,KR
+2400:cb00:35::,2400:cb00:35:ffff:ffff:ffff:ffff:ffff,SG
+2400:cb00:36::,2400:cb00:36:ffff:ffff:ffff:ffff:ffff,HK
+2400:cb00:37::,2400:cb00:37:ffff:ffff:ffff:ffff:ffff,DE
+2400:cb00:38::,2400:cb00:38:ffff:ffff:ffff:ffff:ffff,CL
+2400:cb00:39::,2400:cb00:39:ffff:ffff:ffff:ffff:ffff,IT
+2400:cb00:3a::,2400:cb00:3f:ffff:ffff:ffff:ffff:ffff,HK
+2400:cb00:40::,2400:cb00:40:ffff:ffff:ffff:ffff:ffff,ES
+2400:cb00:41::,2400:cb00:41:ffff:ffff:ffff:ffff:ffff,CO
+2400:cb00:42::,2400:cb00:42:ffff:ffff:ffff:ffff:ffff,BR
+2400:cb00:43::,2400:cb00:43:ffff:ffff:ffff:ffff:ffff,PE
+2400:cb00:44::,2400:cb00:44:ffff:ffff:ffff:ffff:ffff,AR
+2400:cb00:45::,2400:cb00:45:ffff:ffff:ffff:ffff:ffff,ZA
+2400:cb00:46::,2400:cb00:46:ffff:ffff:ffff:ffff:ffff,NZ
+2400:cb00:47::,2400:cb00:47:ffff:ffff:ffff:ffff:ffff,AU
+2400:cb00:48::,2400:cb00:48:ffff:ffff:ffff:ffff:ffff,DE
+2400:cb00:49::,2400:cb00:49:ffff:ffff:ffff:ffff:ffff,FR
+2400:cb00:4a::,2400:cb00:4f:ffff:ffff:ffff:ffff:ffff,HK
+2400:cb00:50::,2400:cb00:50:ffff:ffff:ffff:ffff:ffff,RO
+2400:cb00:51::,2400:cb00:51:ffff:ffff:ffff:ffff:ffff,JP
+2400:cb00:52::,2400:cb00:52:ffff:ffff:ffff:ffff:ffff,IE
+2400:cb00:53::,2400:cb00:53:ffff:ffff:ffff:ffff:ffff,KW
+2400:cb00:54::,2400:cb00:54:ffff:ffff:ffff:ffff:ffff,QA
+2400:cb00:55::,2400:cb00:55:ffff:ffff:ffff:ffff:ffff,OM
+2400:cb00:56::,2400:cb00:56:ffff:ffff:ffff:ffff:ffff,MY
+2400:cb00:57::,2400:cb00:59:ffff:ffff:ffff:ffff:ffff,IN
+2400:cb00:5a::,2400:cb00:5f:ffff:ffff:ffff:ffff:ffff,HK
+2400:cb00:60::,2400:cb00:60:ffff:ffff:ffff:ffff:ffff,AE
+2400:cb00:61::,2400:cb00:61:ffff:ffff:ffff:ffff:ffff,KE
+2400:cb00:62::,2400:cb00:62:ffff:ffff:ffff:ffff:ffff,EG
+2400:cb00:63::,2400:cb00:63:ffff:ffff:ffff:ffff:ffff,GB
+2400:cb00:64::,2400:cb00:64:ffff:ffff:ffff:ffff:ffff,CH
+2400:cb00:65::,2400:cb00:65:ffff:ffff:ffff:ffff:ffff,DK
+2400:cb00:66::,2400:cb00:66:ffff:ffff:ffff:ffff:ffff,US
+2400:cb00:67::,2400:cb00:67:ffff:ffff:ffff:ffff:ffff,DE
+2400:cb00:68::,2400:cb00:68:ffff:ffff:ffff:ffff:ffff,HK
+2400:cb00:69::,2400:cb00:69:ffff:ffff:ffff:ffff:ffff,CA
+2400:cb00:6a::,2400:cb00:6f:ffff:ffff:ffff:ffff:ffff,HK
+2400:cb00:70::,2400:cb00:70:ffff:ffff:ffff:ffff:ffff,CA
+2400:cb00:71::,2400:cb00:71:ffff:ffff:ffff:ffff:ffff,DE
+2400:cb00:72::,2400:cb00:72:ffff:ffff:ffff:ffff:ffff,US
+2400:cb00:73::,2400:cb00:73:ffff:ffff:ffff:ffff:ffff,PL
+2400:cb00:74::,2400:cb00:74:ffff:ffff:ffff:ffff:ffff,BG
+2400:cb00:75::,2400:cb00:75:ffff:ffff:ffff:ffff:ffff,DE
+2400:cb00:76::,2400:cb00:77:ffff:ffff:ffff:ffff:ffff,HK
+2400:cb00:78::,2400:cb00:78:ffff:ffff:ffff:ffff:ffff,BE
+2400:cb00:79::,2400:cb00:82:ffff:ffff:ffff:ffff:ffff,HK
+2400:cb00:83::,2400:cb00:83:ffff:ffff:ffff:ffff:ffff,NO
+2400:cb00:84::,2400:cb00:ffff:ffff:ffff:ffff:ffff:ffff,HK
 2400:cb80::,2400:cb80:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2400:cc00::,2400:cc00:ffff:ffff:ffff:ffff:ffff:ffff,AU
 2400:cc80::,2400:cc80:ffff:ffff:ffff:ffff:ffff:ffff,CN
@@ -4979,7 +6001,9 @@
 2401:1680::,2401:1680:ffff:ffff:ffff:ffff:ffff:ffff,MY
 2401:1700::,2401:1700:ffff:ffff:ffff:ffff:ffff:ffff,ID
 2401:1780::,2401:1780:ffff:ffff:ffff:ffff:ffff:ffff,TW
-2401:1800::,2401:1801:ffff:ffff:ffff:ffff:ffff:ffff,HK
+2401:1800::,2401:1801:7800:ffff:ffff:ffff:ffff:ffff,HK
+2401:1801:7801::,2401:1801:7801:7fff:ffff:ffff:ffff:ffff,AU
+2401:1801:7801:8000::,2401:1801:ffff:ffff:ffff:ffff:ffff:ffff,HK
 2401:1880::,2401:1880:ffff:ffff:ffff:ffff:ffff:ffff,NZ
 2401:1900::,2401:1900:ffff:ffff:ffff:ffff:ffff:ffff,BD
 2401:1980::,2401:1980:ffff:ffff:ffff:ffff:ffff:ffff,BD
@@ -5056,7 +6080,9 @@
 2401:3d80::,2401:3d80:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2401:3e00::,2401:3e00:ffff:ffff:ffff:ffff:ffff:ffff,KH
 2401:3e80::,2401:3e80:ffff:ffff:ffff:ffff:ffff:ffff,CN
-2401:3f00::,2401:3f00:ffff:ffff:ffff:ffff:ffff:ffff,SG
+2401:3f00::,2401:3f00:10:ffff:ffff:ffff:ffff:ffff,SG
+2401:3f00:11::,2401:3f00:11:7fff:ffff:ffff:ffff:ffff,ID
+2401:3f00:11:8000::,2401:3f00:ffff:ffff:ffff:ffff:ffff:ffff,SG
 2401:3f80::,2401:3f80:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2401:4000::,2401:4000:ffff:ffff:ffff:ffff:ffff:ffff,KR
 2401:4080::,2401:4080:ffff:ffff:ffff:ffff:ffff:ffff,CN
@@ -5112,7 +6138,6 @@
 2401:5c00::,2401:5c00:ffff:ffff:ffff:ffff:ffff:ffff,AU
 2401:5c80::,2401:5c80:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2401:5d00::,2401:5d00:ffff:ffff:ffff:ffff:ffff:ffff,BD
-2401:5d80::,2401:5d80:ffff:ffff:ffff:ffff:ffff:ffff,HK
 2401:5e00::,2401:5e00:ffff:ffff:ffff:ffff:ffff:ffff,TW
 2401:5e80::,2401:5e80:ffff:ffff:ffff:ffff:ffff:ffff,AU
 2401:5f00::,2401:5f00:ffff:ffff:ffff:ffff:ffff:ffff,AU
@@ -5123,7 +6148,6 @@
 2401:7100::,2401:7100:ffff:ffff:ffff:ffff:ffff:ffff,AU
 2401:7180::,2401:7180:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2401:7200::,2401:7200:ffff:ffff:ffff:ffff:ffff:ffff,AU
-2401:7280::,2401:7280:ffff:ffff:ffff:ffff:ffff:ffff,HK
 2401:7300::,2401:7300:ffff:ffff:ffff:ffff:ffff:ffff,AU
 2401:7380::,2401:7380:ffff:ffff:ffff:ffff:ffff:ffff,AU
 2401:7400::,2401:7401:ffff:ffff:ffff:ffff:ffff:ffff,SG
@@ -5150,7 +6174,8 @@
 2401:7e80::,2401:7e80:ffff:ffff:ffff:ffff:ffff:ffff,AU
 2401:7f00::,2401:7f00:ffff:ffff:ffff:ffff:ffff:ffff,JP
 2401:7f80::,2401:7f80:ffff:ffff:ffff:ffff:ffff:ffff,CN
-2401:8000::,2401:803f:ffff:ffff:ffff:ffff:ffff:ffff,TW
+2401:8000::,2401:8000::7fff:ffff:ffff:ffff:ffff,CN
+2401:8000:0:8000::,2401:803f:ffff:ffff:ffff:ffff:ffff:ffff,TW
 2401:8080::,2401:8080:ffff:ffff:ffff:ffff:ffff:ffff,AF
 2401:8100::,2401:8100:ffff:ffff:ffff:ffff:ffff:ffff,AU
 2401:8180::,2401:8180:ffff:ffff:ffff:ffff:ffff:ffff,AU
@@ -5177,7 +6202,6 @@
 2401:8c00::,2401:8c01:ffff:ffff:ffff:ffff:ffff:ffff,AU
 2401:8c80::,2401:8c80:ffff:ffff:ffff:ffff:ffff:ffff,BD
 2401:8d00::,2401:8d00:ffff:ffff:ffff:ffff:ffff:ffff,CN
-2401:8d80::,2401:8d80:ffff:ffff:ffff:ffff:ffff:ffff,AU
 2401:8e00::,2401:8e00:ffff:ffff:ffff:ffff:ffff:ffff,PK
 2401:8e80::,2401:8e80:ffff:ffff:ffff:ffff:ffff:ffff,PH
 2401:8f00::,2401:8f00:ffff:ffff:ffff:ffff:ffff:ffff,ID
@@ -5201,7 +6225,6 @@
 2401:9880::,2401:9880:ffff:ffff:ffff:ffff:ffff:ffff,HK
 2401:9980::,2401:9980:ffff:ffff:ffff:ffff:ffff:ffff,MY
 2401:9a00::,2401:9a00:ffff:ffff:ffff:ffff:ffff:ffff,CN
-2401:9a80::,2401:9a80:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2401:9b00::,2401:9b00:ffff:ffff:ffff:ffff:ffff:ffff,ID
 2401:9b80::,2401:9b80:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2401:9c00::,2401:9c00:ffff:ffff:ffff:ffff:ffff:ffff,BD
@@ -5261,7 +6284,6 @@
 2401:b800::,2401:b800:ffff:ffff:ffff:ffff:ffff:ffff,VN
 2401:b880::,2401:b880:ffff:ffff:ffff:ffff:ffff:ffff,AU
 2401:b900::,2401:b900:ffff:ffff:ffff:ffff:ffff:ffff,PH
-2401:b980::,2401:b980:ffff:ffff:ffff:ffff:ffff:ffff,TH
 2401:ba00::,2401:ba00:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2401:ba80::,2401:ba80:ffff:ffff:ffff:ffff:ffff:ffff,PK
 2401:bb00::,2401:bb00:ffff:ffff:ffff:ffff:ffff:ffff,IN
@@ -5281,7 +6303,6 @@
 2401:c200::,2401:c200:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2401:c280::,2401:c280:ffff:ffff:ffff:ffff:ffff:ffff,IN
 2401:c300::,2401:c300:ffff:ffff:ffff:ffff:ffff:ffff,IN
-2401:c380::,2401:c380:ffff:ffff:ffff:ffff:ffff:ffff,IN
 2401:c400::,2401:c400:ffff:ffff:ffff:ffff:ffff:ffff,MY
 2401:c480::,2401:c480:ffff:ffff:ffff:ffff:ffff:ffff,HK
 2401:c500::,2401:c500:ffff:ffff:ffff:ffff:ffff:ffff,KR
@@ -5292,13 +6313,19 @@
 2401:c780::,2401:c780:ffff:ffff:ffff:ffff:ffff:ffff,AU
 2401:c800::,2401:c800:ffff:ffff:ffff:ffff:ffff:ffff,JP
 2401:c880::,2401:c880:ffff:ffff:ffff:ffff:ffff:ffff,IN
-2401:c900::,2401:c900:11ff:ffff:ffff:ffff:ffff:ffff,SG
+2401:c900::,2401:c900:1000:ffff:ffff:ffff:ffff:ffff,SG
+2401:c900:1001::,2401:c900:1001:ff:ffff:ffff:ffff:ffff,JP
+2401:c900:1001:100::,2401:c900:11ff:ffff:ffff:ffff:ffff:ffff,SG
 2401:c900:1200::,2401:c900:1201:175:ffff:ffff:ffff:ffff,US
 2401:c900:1201:176::,2401:c900:1201:176:ffff:ffff:ffff:ffff,HK
-2401:c900:1201:177::,2401:c900:12ff:ffff:ffff:ffff:ffff:ffff,US
+2401:c900:1201:177::,2401:c900:1201:1cb:ffff:ffff:ffff:ffff,US
+2401:c900:1201:1cc::,2401:c900:1201:1cc:ffff:ffff:ffff:ffff,HK
+2401:c900:1201:1cd::,2401:c900:12ff:ffff:ffff:ffff:ffff:ffff,US
 2401:c900:1300::,2401:c900:1300:ffff:ffff:ffff:ffff:ffff,SG
 2401:c900:1301::,2401:c900:1301:7fff:ffff:ffff:ffff:ffff,AU
-2401:c900:1301:8000::,2401:c901:ffff:ffff:ffff:ffff:ffff:ffff,SG
+2401:c900:1301:8000::,2401:c900:1400:ffff:ffff:ffff:ffff:ffff,SG
+2401:c900:1401::,2401:c900:1401:7fff:ffff:ffff:ffff:ffff,AU
+2401:c900:1401:8000::,2401:c901:ffff:ffff:ffff:ffff:ffff:ffff,SG
 2401:c980::,2401:c980:ffff:ffff:ffff:ffff:ffff:ffff,NZ
 2401:ca00::,2401:ca00:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2401:ca80::,2401:ca80:ffff:ffff:ffff:ffff:ffff:ffff,CN
@@ -5307,7 +6334,9 @@
 2401:cc00::,2401:cc00:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2401:cc80::,2401:cc80:ffff:ffff:ffff:ffff:ffff:ffff,AU
 2401:cd00::,2401:cd00:ffff:ffff:ffff:ffff:ffff:ffff,BD
-2401:cd80::,2401:cd81:ffff:ffff:ffff:ffff:ffff:ffff,AU
+2401:cd80::,2401:cd80:1:ffff:ffff:ffff:ffff:ffff,AU
+2401:cd80:2::,2401:cd80:2:ffff:ffff:ffff:ffff:ffff,NZ
+2401:cd80:3::,2401:cd81:ffff:ffff:ffff:ffff:ffff:ffff,AU
 2401:ce00::,2401:ce00:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2401:ce80::,2401:ce80:ffff:ffff:ffff:ffff:ffff:ffff,JP
 2401:cf00::,2401:cf00:ffff:ffff:ffff:ffff:ffff:ffff,AU
@@ -5395,25 +6424,35 @@
 2401:f880::,2401:f880:ffff:ffff:ffff:ffff:ffff:ffff,MY
 2401:f900::,2401:f900:ffff:ffff:ffff:ffff:ffff:ffff,SG
 2401:f980::,2401:f980:ffff:ffff:ffff:ffff:ffff:ffff,ID
-2401:fa00::,2401:fa00::7fff:ffff:ffff:ffff:ffff,AU
-2401:fa00:0:8000::,2401:fa00:3:ffff:ffff:ffff:ffff:ffff,IN
+2401:fa00::,2401:fa00::ffff:ffff:ffff:ffff:ffff,AU
+2401:fa00:1::,2401:fa00:1:ffff:ffff:ffff:ffff:ffff,TW
+2401:fa00:2::,2401:fa00:2:ffff:ffff:ffff:ffff:ffff,IN
+2401:fa00:3::,2401:fa00:3:ffff:ffff:ffff:ffff:ffff,SG
 2401:fa00:4::,2401:fa00:4:ffff:ffff:ffff:ffff:ffff,JP
-2401:fa00:5::,2401:fa00:8:ffff:ffff:ffff:ffff:ffff,IN
-2401:fa00:9::,2401:fa00:9:7fff:ffff:ffff:ffff:ffff,AU
-2401:fa00:9:8000::,2401:fa00:c:ffff:ffff:ffff:ffff:ffff,IN
-2401:fa00:d::,2401:fa00:d:7fff:ffff:ffff:ffff:ffff,KR
-2401:fa00:d:8000::,2401:fa00:e:ffff:ffff:ffff:ffff:ffff,IN
-2401:fa00:f::,2401:fa00:f:7fff:ffff:ffff:ffff:ffff,SG
-2401:fa00:f:8000::,2401:fa00:10:ffff:ffff:ffff:ffff:ffff,IN
-2401:fa00:11::,2401:fa00:11:7fff:ffff:ffff:ffff:ffff,AU
-2401:fa00:11:8000::,2401:fa00:12:ffff:ffff:ffff:ffff:ffff,IN
-2401:fa00:13::,2401:fa00:13:7fff:ffff:ffff:ffff:ffff,HK
-2401:fa00:13:8000::,2401:fa00:17:ffff:ffff:ffff:ffff:ffff,IN
+2401:fa00:5::,2401:fa00:6:ffff:ffff:ffff:ffff:ffff,IN
+2401:fa00:7::,2401:fa00:7:ffff:ffff:ffff:ffff:ffff,US
+2401:fa00:8::,2401:fa00:8:7fff:ffff:ffff:ffff:ffff,IN
+2401:fa00:8:8000::,2401:fa00:8:ffff:ffff:ffff:ffff:ffff,MY
+2401:fa00:9::,2401:fa00:9:ffff:ffff:ffff:ffff:ffff,AU
+2401:fa00:a::,2401:fa00:f:7fff:ffff:ffff:ffff:ffff,IN
+2401:fa00:f:8000::,2401:fa00:f:ffff:ffff:ffff:ffff:ffff,SG
+2401:fa00:10::,2401:fa00:10:ffff:ffff:ffff:ffff:ffff,IN
+2401:fa00:11::,2401:fa00:11:ffff:ffff:ffff:ffff:ffff,AU
+2401:fa00:12::,2401:fa00:12:ffff:ffff:ffff:ffff:ffff,NZ
+2401:fa00:13::,2401:fa00:13:ffff:ffff:ffff:ffff:ffff,HK
+2401:fa00:14::,2401:fa00:15:7fff:ffff:ffff:ffff:ffff,IN
+2401:fa00:15:8000::,2401:fa00:15:ffff:ffff:ffff:ffff:ffff,US
+2401:fa00:16::,2401:fa00:17:ffff:ffff:ffff:ffff:ffff,IN
 2401:fa00:18::,2401:fa00:18:7fff:ffff:ffff:ffff:ffff,PH
 2401:fa00:18:8000::,2401:fa00:18:ffff:ffff:ffff:ffff:ffff,US
-2401:fa00:19::,2401:fa00:23:ffff:ffff:ffff:ffff:ffff,IN
+2401:fa00:19::,2401:fa00:1e:ffff:ffff:ffff:ffff:ffff,IN
+2401:fa00:1f::,2401:fa00:1f:7fff:ffff:ffff:ffff:ffff,US
+2401:fa00:1f:8000::,2401:fa00:23:ffff:ffff:ffff:ffff:ffff,IN
 2401:fa00:24::,2401:fa00:24:7fff:ffff:ffff:ffff:ffff,US
-2401:fa00:24:8000::,2401:fa00:3f:ffff:ffff:ffff:ffff:ffff,IN
+2401:fa00:24:8000::,2401:fa00:24:ffff:ffff:ffff:ffff:ffff,MY
+2401:fa00:25::,2401:fa00:25:ffff:ffff:ffff:ffff:ffff,IN
+2401:fa00:26::,2401:fa00:26:ffff:ffff:ffff:ffff:ffff,US
+2401:fa00:27::,2401:fa00:3f:ffff:ffff:ffff:ffff:ffff,IN
 2401:fa00:40::,2401:fa00:40:7fff:ffff:ffff:ffff:ffff,CN
 2401:fa00:40:8000::,2401:fa00:40:ffff:ffff:ffff:ffff:ffff,IN
 2401:fa00:41::,2401:fa00:41:7fff:ffff:ffff:ffff:ffff,CN
@@ -5613,9 +6652,15 @@
 2402:5e80::,2402:5e80:ffff:ffff:ffff:ffff:ffff:ffff,BD
 2402:5f00::,2402:5f00:ffff:ffff:ffff:ffff:ffff:ffff,ID
 2402:5f80::,2402:5f80:ffff:ffff:ffff:ffff:ffff:ffff,SG
-2402:6000::,2402:6000:100:ffff:ffff:ffff:ffff:ffff,AU
+2402:6000::,2402:6000:ff:ffff:ffff:ffff:ffff:ffff,AU
+2402:6000:100::,2402:6000:100:7fff:ffff:ffff:ffff:ffff,NZ
+2402:6000:100:8000::,2402:6000:100:ffff:ffff:ffff:ffff:ffff,AU
 2402:6000:101::,2402:6000:101:7fff:ffff:ffff:ffff:ffff,NZ
-2402:6000:101:8000::,2402:6000:ffff:ffff:ffff:ffff:ffff:ffff,AU
+2402:6000:101:8000::,2402:6000:1ff:7fff:ffff:ffff:ffff:ffff,AU
+2402:6000:1ff:8000::,2402:6000:1ff:ffff:ffff:ffff:ffff:ffff,NZ
+2402:6000:200::,2402:6000:202:ffff:ffff:ffff:ffff:ffff,AU
+2402:6000:203::,2402:6000:203:7fff:ffff:ffff:ffff:ffff,NZ
+2402:6000:203:8000::,2402:6000:ffff:ffff:ffff:ffff:ffff:ffff,AU
 2402:6080::,2402:6080:ffff:ffff:ffff:ffff:ffff:ffff,HK
 2402:6100::,2402:6100:ffff:ffff:ffff:ffff:ffff:ffff,KR
 2402:6180::,2402:6180:ffff:ffff:ffff:ffff:ffff:ffff,HK
@@ -5635,7 +6680,9 @@
 2402:6980::,2402:6980:ffff:ffff:ffff:ffff:ffff:ffff,ID
 2402:6a00::,2402:6a00:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2402:6a80::,2402:6a80:ffff:ffff:ffff:ffff:ffff:ffff,HK
-2402:6b00::,2402:6b00:ffff:ffff:ffff:ffff:ffff:ffff,JP
+2402:6b00::,2402:6b00:4c64:ffff:ffff:ffff:ffff:ffff,JP
+2402:6b00:4c65::,2402:6b00:4c65:7fff:ffff:ffff:ffff:ffff,US
+2402:6b00:4c65:8000::,2402:6b00:ffff:ffff:ffff:ffff:ffff:ffff,JP
 2402:6b80::,2402:6b80:ffff:ffff:ffff:ffff:ffff:ffff,AU
 2402:6c00::,2402:6c00:ffff:ffff:ffff:ffff:ffff:ffff,MY
 2402:6c80::,2402:6c80:ffff:ffff:ffff:ffff:ffff:ffff,JP
@@ -5652,7 +6699,9 @@
 2402:7200::,2402:7200:ffff:ffff:ffff:ffff:ffff:ffff,TK
 2402:7280::,2402:7280:ffff:ffff:ffff:ffff:ffff:ffff,AU
 2402:7300::,2402:7300:ffff:ffff:ffff:ffff:ffff:ffff,HK
-2402:7380::,2402:7380:ffff:ffff:ffff:ffff:ffff:ffff,CN
+2402:7380::,2402:7380:7ff:ffff:ffff:ffff:ffff:ffff,JP
+2402:7380:800::,2402:7380:fff:ffff:ffff:ffff:ffff:ffff,HK
+2402:7380:1000::,2402:7380:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2402:7400::,2402:7400:ffff:ffff:ffff:ffff:ffff:ffff,AU
 2402:7480::,2402:7481:ffff:ffff:ffff:ffff:ffff:ffff,HK
 2402:7500::,2402:7500:ffff:ffff:ffff:ffff:ffff:ffff,TW
@@ -5842,7 +6891,8 @@
 2402:d380::,2402:d380:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2402:d400::,2402:d400:ffff:ffff:ffff:ffff:ffff:ffff,IN
 2402:d500::,2402:d500:ffff:ffff:ffff:ffff:ffff:ffff,IN
-2402:d580::,2402:d581:ffff:ffff:ffff:ffff:ffff:ffff,AU
+2402:d580::,2402:d580:ffff:ffff:ffff:ffff:ffff:ffff,US
+2402:d581::,2402:d581:ffff:ffff:ffff:ffff:ffff:ffff,AU
 2402:d600::,2402:d600:ffff:ffff:ffff:ffff:ffff:ffff,JP
 2402:d680::,2402:d680:ffff:ffff:ffff:ffff:ffff:ffff,ID
 2402:d700::,2402:d700:ffff:ffff:ffff:ffff:ffff:ffff,JP
@@ -5873,7 +6923,7 @@
 2402:e400::,2402:e400:ffff:ffff:ffff:ffff:ffff:ffff,AU
 2402:e480::,2402:e480:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2402:e500::,2402:e500:ffff:ffff:ffff:ffff:ffff:ffff,AU
-2402:e580::,2402:e580:ffff:ffff:ffff:ffff:ffff:ffff,HK
+2402:e580::,2402:e580:ffff:ffff:ffff:ffff:ffff:ffff,US
 2402:e600::,2402:e600:ffff:ffff:ffff:ffff:ffff:ffff,SG
 2402:e680::,2402:e680:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2402:e780::,2402:e780:ffff:ffff:ffff:ffff:ffff:ffff,CN
@@ -5925,251 +6975,513 @@
 2402:ff00::,2402:ff00:ffff:ffff:ffff:ffff:ffff:ffff,NZ
 2402:ff80::,2402:ff80:ffff:ffff:ffff:ffff:ffff:ffff,AU
 2403::,2403:1:ffff:ffff:ffff:ffff:ffff:ffff,IN
+2403:80::,2403:80:ffff:ffff:ffff:ffff:ffff:ffff,ID
 2403:100::,2403:100:ffff:ffff:ffff:ffff:ffff:ffff,SG
+2403:180::,2403:180:ffff:ffff:ffff:ffff:ffff:ffff,SG
 2403:200::,2403:200:ffff:ffff:ffff:ffff:ffff:ffff,NC
+2403:280::,2403:280:ffff:ffff:ffff:ffff:ffff:ffff,HK
 2403:300::,2403:300:ffff:ffff:ffff:ffff:ffff:ffff,SG
+2403:380::,2403:380:ffff:ffff:ffff:ffff:ffff:ffff,HK
 2403:400::,2403:400:ffff:ffff:ffff:ffff:ffff:ffff,JP
+2403:480::,2403:480:ffff:ffff:ffff:ffff:ffff:ffff,AU
 2403:500::,2403:500:ffff:ffff:ffff:ffff:ffff:ffff,LA
+2403:580::,2403:580:ffff:ffff:ffff:ffff:ffff:ffff,BT
 2403:600::,2403:600:ffff:ffff:ffff:ffff:ffff:ffff,CN
+2403:680::,2403:680:ffff:ffff:ffff:ffff:ffff:ffff,BD
 2403:700::,2403:700:ffff:ffff:ffff:ffff:ffff:ffff,CN
+2403:780::,2403:780:ffff:ffff:ffff:ffff:ffff:ffff,AU
 2403:800::,2403:801:ffff:ffff:ffff:ffff:ffff:ffff,CN
+2403:880::,2403:880:ffff:ffff:ffff:ffff:ffff:ffff,AU
 2403:900::,2403:900:ffff:ffff:ffff:ffff:ffff:ffff,AU
+2403:980::,2403:980:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:a00::,2403:a00:ffff:ffff:ffff:ffff:ffff:ffff,NZ
+2403:a80::,2403:a80:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:b00::,2403:b00:ffff:ffff:ffff:ffff:ffff:ffff,SG
+2403:b80::,2403:b80:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:c00::,2403:c00:ffff:ffff:ffff:ffff:ffff:ffff,IN
+2403:c80::,2403:c80:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:d00::,2403:d00:ffff:ffff:ffff:ffff:ffff:ffff,AU
+2403:d80::,2403:d80:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:e00::,2403:e00:ffff:ffff:ffff:ffff:ffff:ffff,NZ
+2403:e80::,2403:e80:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:f00::,2403:f00:ffff:ffff:ffff:ffff:ffff:ffff,CN
+2403:f80::,2403:f80:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:1000::,2403:1000:ffff:ffff:ffff:ffff:ffff:ffff,HK
+2403:1080::,2403:1080:ffff:ffff:ffff:ffff:ffff:ffff,IN
 2403:1100::,2403:1100:ffff:ffff:ffff:ffff:ffff:ffff,AU
+2403:1180::,2403:1180:ffff:ffff:ffff:ffff:ffff:ffff,CN
+2403:1280::,2403:1280:ffff:ffff:ffff:ffff:ffff:ffff,AU
 2403:1300::,2403:1300:ffff:ffff:ffff:ffff:ffff:ffff,MY
+2403:1380::,2403:1380:ffff:ffff:ffff:ffff:ffff:ffff,MY
 2403:1400::,2403:1400:ffff:ffff:ffff:ffff:ffff:ffff,AU
+2403:1480::,2403:1480:ffff:ffff:ffff:ffff:ffff:ffff,AU
 2403:1500::,2403:1500:ffff:ffff:ffff:ffff:ffff:ffff,NZ
+2403:1580::,2403:1580:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:1600::,2403:1600:ffff:ffff:ffff:ffff:ffff:ffff,KH
+2403:1680::,2403:1680:ffff:ffff:ffff:ffff:ffff:ffff,AU
 2403:1700::,2403:1700:ffff:ffff:ffff:ffff:ffff:ffff,AU
+2403:1780::,2403:1780:ffff:ffff:ffff:ffff:ffff:ffff,ID
 2403:1800::,2403:1800:ffff:ffff:ffff:ffff:ffff:ffff,JP
+2403:1880::,2403:1880:ffff:ffff:ffff:ffff:ffff:ffff,ID
 2403:1900::,2403:1900:ffff:ffff:ffff:ffff:ffff:ffff,AU
+2403:1980::,2403:1980:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:1a00::,2403:1a00:ffff:ffff:ffff:ffff:ffff:ffff,ID
+2403:1a80::,2403:1a80:ffff:ffff:ffff:ffff:ffff:ffff,SG
 2403:1b00::,2403:1b00:ffff:ffff:ffff:ffff:ffff:ffff,JP
+2403:1b80::,2403:1b80:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:1c00::,2403:1c00:ffff:ffff:ffff:ffff:ffff:ffff,HK
+2403:1c80::,2403:1c80:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:1d00::,2403:1d00:ffff:ffff:ffff:ffff:ffff:ffff,IN
+2403:1d80::,2403:1d80:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:1e00::,2403:1e00:ffff:ffff:ffff:ffff:ffff:ffff,AS
+2403:1e80::,2403:1e80:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:1f00::,2403:1f00:ffff:ffff:ffff:ffff:ffff:ffff,JP
+2403:1f80::,2403:1f80:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:2000::,2403:2000:ffff:ffff:ffff:ffff:ffff:ffff,JP
+2403:2080::,2403:2080:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:2100::,2403:2100:ffff:ffff:ffff:ffff:ffff:ffff,NZ
+2403:2180::,2403:2180:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:2200::,2403:2200:ffff:ffff:ffff:ffff:ffff:ffff,IN
+2403:2280::,2403:2280:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:2300::,2403:2300:ffff:ffff:ffff:ffff:ffff:ffff,TH
+2403:2380::,2403:2380:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:2400::,2403:2400:ffff:ffff:ffff:ffff:ffff:ffff,HK
+2403:2480::,2403:2480:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:2500::,2403:2500:ffff:ffff:ffff:ffff:ffff:ffff,IN
+2403:2580::,2403:2580:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:2600::,2403:2600:ffff:ffff:ffff:ffff:ffff:ffff,ID
+2403:2680::,2403:2680:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:2700::,2403:2700:ffff:ffff:ffff:ffff:ffff:ffff,ID
+2403:2780::,2403:2780:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:2800::,2403:2801:ffff:ffff:ffff:ffff:ffff:ffff,TH
+2403:2880::,2403:2880:ffff:ffff:ffff:ffff:ffff:ffff,JP
 2403:2900::,2403:2900:ffff:ffff:ffff:ffff:ffff:ffff,IN
+2403:2980::,2403:2980:ffff:ffff:ffff:ffff:ffff:ffff,IN
 2403:2a00::,2403:2a00:ffff:ffff:ffff:ffff:ffff:ffff,CN
+2403:2a80::,2403:2a80:ffff:ffff:ffff:ffff:ffff:ffff,AU
+2403:2b80::,2403:2b80:ffff:ffff:ffff:ffff:ffff:ffff,MY
 2403:2c00::,2403:2c00:ffff:ffff:ffff:ffff:ffff:ffff,HK
+2403:2c80::,2403:2c80::ffff:ffff:ffff:ffff:ffff,HK
+2403:2c80:1::,2403:2c80:1:ffff:ffff:ffff:ffff:ffff,JP
+2403:2c80:2::,2403:2c80:2:ffff:ffff:ffff:ffff:ffff,SG
+2403:2c80:3::,2403:2c80:ffff:ffff:ffff:ffff:ffff:ffff,HK
 2403:2d00::,2403:2d00:ffff:ffff:ffff:ffff:ffff:ffff,JP
+2403:2d80::,2403:2d80:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:2e00::,2403:2e00:ffff:ffff:ffff:ffff:ffff:ffff,ID
+2403:2e80::,2403:2e80:ffff:ffff:ffff:ffff:ffff:ffff,AU
 2403:2f00::,2403:2f00:ffff:ffff:ffff:ffff:ffff:ffff,NZ
+2403:2f80::,2403:2f80:ffff:ffff:ffff:ffff:ffff:ffff,AU
+2403:3080::,2403:3080:ffff:ffff:ffff:ffff:ffff:ffff,HK
 2403:3100::,2403:3100:ffff:ffff:ffff:ffff:ffff:ffff,SG
+2403:3180::,2403:3180:ffff:ffff:ffff:ffff:ffff:ffff,AU
 2403:3200::,2403:3200:ffff:ffff:ffff:ffff:ffff:ffff,JP
+2403:3280::,2403:3280:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:3300::,2403:3300:ffff:ffff:ffff:ffff:ffff:ffff,NL
+2403:3380::,2403:3380:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:3400::,2403:3400:ffff:ffff:ffff:ffff:ffff:ffff,AU
+2403:3480::,2403:3480:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:3500::,2403:3500:ffff:ffff:ffff:ffff:ffff:ffff,AU
+2403:3580::,2403:3580:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:3600::,2403:3600:ffff:ffff:ffff:ffff:ffff:ffff,AU
+2403:3680::,2403:3680:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:3700::,2403:3700:ffff:ffff:ffff:ffff:ffff:ffff,KR
+2403:3780::,2403:3780:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:3800::,2403:3800:ffff:ffff:ffff:ffff:ffff:ffff,NP
+2403:3880::,2403:3880:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:3900::,2403:3900:ffff:ffff:ffff:ffff:ffff:ffff,NZ
+2403:3980::,2403:3980:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:3a00::,2403:3a00:ffff:ffff:ffff:ffff:ffff:ffff,JP
+2403:3a80::,2403:3a80:ffff:ffff:ffff:ffff:ffff:ffff,MY
 2403:3b00::,2403:3b00:ffff:ffff:ffff:ffff:ffff:ffff,AU
+2403:3b80::,2403:3b80:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:3c00::,2403:3c00:ffff:ffff:ffff:ffff:ffff:ffff,AU
+2403:3c80::,2403:3c80:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:3d00::,2403:3d00:ffff:ffff:ffff:ffff:ffff:ffff,IN
+2403:3d80::,2403:3d80:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:3e00::,2403:3e00:ffff:ffff:ffff:ffff:ffff:ffff,KR
+2403:3e80::,2403:3e80:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:3f00::,2403:3f00:ffff:ffff:ffff:ffff:ffff:ffff,MY
+2403:3f80::,2403:3f80:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:4000::,2403:4000:ffff:ffff:ffff:ffff:ffff:ffff,BD
+2403:4080::,2403:4080:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:4100::,2403:4100:ffff:ffff:ffff:ffff:ffff:ffff,ID
+2403:4180::,2403:4180:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:4200::,2403:4200:ffff:ffff:ffff:ffff:ffff:ffff,AU
+2403:4280::,2403:4280:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:4300::,2403:4300:ffff:ffff:ffff:ffff:ffff:ffff,CN
+2403:4380::,2403:4380:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:4400::,2403:4400:ffff:ffff:ffff:ffff:ffff:ffff,JP
+2403:4480::,2403:4480:ffff:ffff:ffff:ffff:ffff:ffff,WS
 2403:4500::,2403:4500:ffff:ffff:ffff:ffff:ffff:ffff,ID
+2403:4580::,2403:4580:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:4600::,2403:4600:ffff:ffff:ffff:ffff:ffff:ffff,FJ
+2403:4680::,2403:4680:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:4700::,2403:4700:ffff:ffff:ffff:ffff:ffff:ffff,SG
+2403:4780::,2403:4780:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:4800::,2403:4800:ffff:ffff:ffff:ffff:ffff:ffff,AU
+2403:4880::,2403:4880:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:4900::,2403:4900:ffff:ffff:ffff:ffff:ffff:ffff,HK
+2403:4980::,2403:4980:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:4a00::,2403:4a00:ffff:ffff:ffff:ffff:ffff:ffff,HK
+2403:4a80::,2403:4a80:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:4b00::,2403:4b00:ffff:ffff:ffff:ffff:ffff:ffff,NL
+2403:4b80::,2403:4b80:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:4c00::,2403:4c00:ffff:ffff:ffff:ffff:ffff:ffff,TH
+2403:4c80::,2403:4c80:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:4d00::,2403:4d00:ffff:ffff:ffff:ffff:ffff:ffff,NZ
+2403:4d80::,2403:4d80:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:4e00::,2403:4e00:ffff:ffff:ffff:ffff:ffff:ffff,IN
+2403:4e80::,2403:4e80:ffff:ffff:ffff:ffff:ffff:ffff,AU
 2403:4f00::,2403:4f00:ffff:ffff:ffff:ffff:ffff:ffff,NZ
+2403:4f80::,2403:4f80:ffff:ffff:ffff:ffff:ffff:ffff,AU
 2403:5000::,2403:5000:ffff:ffff:ffff:ffff:ffff:ffff,HK
+2403:5080::,2403:5080:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:5100::,2403:5100:ffff:ffff:ffff:ffff:ffff:ffff,AU
+2403:5180::,2403:5180:ffff:ffff:ffff:ffff:ffff:ffff,HK
 2403:5200::,2403:5200:ffff:ffff:ffff:ffff:ffff:ffff,TW
+2403:5280::,2403:5280:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:5300::,2403:5300:ffff:ffff:ffff:ffff:ffff:ffff,IN
+2403:5380::,2403:5380:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:5400::,2403:5400:ffff:ffff:ffff:ffff:ffff:ffff,TH
+2403:5480::,2403:5480:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:5500::,2403:5500:ffff:ffff:ffff:ffff:ffff:ffff,HK
+2403:5580::,2403:5580:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:5600::,2403:5600:ffff:ffff:ffff:ffff:ffff:ffff,HK
+2403:5680::,2403:5680:ffff:ffff:ffff:ffff:ffff:ffff,AU
 2403:5700::,2403:5700:ffff:ffff:ffff:ffff:ffff:ffff,JP
+2403:5780::,2403:5780:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:5800::,2403:5800:ffff:ffff:ffff:ffff:ffff:ffff,AU
+2403:5880::,2403:5880:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:5900::,2403:5900:ffff:ffff:ffff:ffff:ffff:ffff,IN
+2403:5980::,2403:5980:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:5a00::,2403:5a00:ffff:ffff:ffff:ffff:ffff:ffff,JP
+2403:5a80::,2403:5a80:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:5b00::,2403:5b00:ffff:ffff:ffff:ffff:ffff:ffff,IN
+2403:5b80::,2403:5b80:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:5c00::,2403:5c00:ffff:ffff:ffff:ffff:ffff:ffff,AU
+2403:5c80::,2403:5c80:ffff:ffff:ffff:ffff:ffff:ffff,CN
+2403:5d80::,2403:5d80:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:5e00::,2403:5e00:ffff:ffff:ffff:ffff:ffff:ffff,PH
+2403:5e80::,2403:5e80:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:5f00::,2403:5f00:ffff:ffff:ffff:ffff:ffff:ffff,JP
+2403:5f80::,2403:5f80:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:6000::,2403:6000:ffff:ffff:ffff:ffff:ffff:ffff,VN
+2403:6080::,2403:6080:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:6100::,2403:6100:ffff:ffff:ffff:ffff:ffff:ffff,TH
+2403:6180::,2403:6180:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:6200::,2403:6200:ffff:ffff:ffff:ffff:ffff:ffff,TH
+2403:6280::,2403:6280:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:6300::,2403:6300:ffff:ffff:ffff:ffff:ffff:ffff,KR
+2403:6380::,2403:6380:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:6400::,2403:6400:ffff:ffff:ffff:ffff:ffff:ffff,AU
+2403:6480::,2403:6480:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:6500::,2403:6500:ffff:ffff:ffff:ffff:ffff:ffff,KR
+2403:6580::,2403:6580:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:6600::,2403:6600:ffff:ffff:ffff:ffff:ffff:ffff,KH
+2403:6680::,2403:6680:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:6700::,2403:6700:ffff:ffff:ffff:ffff:ffff:ffff,AU
+2403:6780::,2403:6780:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:6800::,2403:6800:ffff:ffff:ffff:ffff:ffff:ffff,NZ
+2403:6880::,2403:6880:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:6900::,2403:6900:ffff:ffff:ffff:ffff:ffff:ffff,AU
+2403:6980::,2403:6980:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:6a00::,2403:6a00:ffff:ffff:ffff:ffff:ffff:ffff,CN
+2403:6a80::,2403:6a80:ffff:ffff:ffff:ffff:ffff:ffff,MM
 2403:6b00::,2403:6b00:ffff:ffff:ffff:ffff:ffff:ffff,SG
+2403:6b80::,2403:6b80:ffff:ffff:ffff:ffff:ffff:ffff,AU
 2403:6c00::,2403:6c00:ffff:ffff:ffff:ffff:ffff:ffff,JP
+2403:6c80::,2403:6c80:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:6d00::,2403:6d00:ffff:ffff:ffff:ffff:ffff:ffff,SG
+2403:6d80::,2403:6d80:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:6e00::,2403:6e00:ffff:ffff:ffff:ffff:ffff:ffff,AU
+2403:6e80::,2403:6e80:ffff:ffff:ffff:ffff:ffff:ffff,CN
+2403:6f80::,2403:6f80:ffff:ffff:ffff:ffff:ffff:ffff,HK
 2403:7000::,2403:7000:ffff:ffff:ffff:ffff:ffff:ffff,NZ
+2403:7080::,2403:7080:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:7100::,2403:7100:ffff:ffff:ffff:ffff:ffff:ffff,IN
+2403:7180::,2403:7180:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:7200::,2403:7200:ffff:ffff:ffff:ffff:ffff:ffff,ID
+2403:7280::,2403:7280:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:7300::,2403:7300:ffff:ffff:ffff:ffff:ffff:ffff,JP
+2403:7380::,2403:7380:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:7400::,2403:7400:ffff:ffff:ffff:ffff:ffff:ffff,JP
+2403:7480::,2403:7480:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:7500::,2403:7500:ffff:ffff:ffff:ffff:ffff:ffff,KH
+2403:7580::,2403:7580:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:7600::,2403:7600:ffff:ffff:ffff:ffff:ffff:ffff,NZ
+2403:7680::,2403:7680:ffff:ffff:ffff:ffff:ffff:ffff,HK
 2403:7700::,2403:7700:ffff:ffff:ffff:ffff:ffff:ffff,CN
+2403:7780::,2403:7780:ffff:ffff:ffff:ffff:ffff:ffff,HK
 2403:7800::,2403:7800:ffff:ffff:ffff:ffff:ffff:ffff,JP
+2403:7880::,2403:7880:ffff:ffff:ffff:ffff:ffff:ffff,IN
 2403:7900::,2403:7900:ffff:ffff:ffff:ffff:ffff:ffff,AU
+2403:7980::,2403:7980:ffff:ffff:ffff:ffff:ffff:ffff,PK
 2403:7a00::,2403:7a00:ffff:ffff:ffff:ffff:ffff:ffff,JP
+2403:7a80::,2403:7a80:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:7b00::,2403:7b00:ffff:ffff:ffff:ffff:ffff:ffff,CN
+2403:7b80::,2403:7b80:ffff:ffff:ffff:ffff:ffff:ffff,ID
 2403:7c00::,2403:7c00:ffff:ffff:ffff:ffff:ffff:ffff,JP
+2403:7c80::,2403:7c80:ffff:ffff:ffff:ffff:ffff:ffff,SG
 2403:7d00::,2403:7d00:ffff:ffff:ffff:ffff:ffff:ffff,AU
+2403:7d80::,2403:7d80:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:7e00::,2403:7e00:ffff:ffff:ffff:ffff:ffff:ffff,AU
+2403:7e80::,2403:7e80:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:7f00::,2403:7f00:ffff:ffff:ffff:ffff:ffff:ffff,SG
+2403:7f80::,2403:7f80:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:8000::,2403:8000:ffff:ffff:ffff:ffff:ffff:ffff,ID
+2403:8080::,2403:8080:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:8100::,2403:8100:ffff:ffff:ffff:ffff:ffff:ffff,HK
+2403:8180::,2403:8180:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:8200::,2403:8200:ffff:ffff:ffff:ffff:ffff:ffff,AU
+2403:8280::,2403:8280:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:8300::,2403:8300:ffff:ffff:ffff:ffff:ffff:ffff,DE
+2403:8380::,2403:8380:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:8400::,2403:8400:ffff:ffff:ffff:ffff:ffff:ffff,IN
+2403:8480::,2403:8480:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:8500::,2403:8500:ffff:ffff:ffff:ffff:ffff:ffff,IN
+2403:8580::,2403:8580:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:8600::,2403:8600:ffff:ffff:ffff:ffff:ffff:ffff,IN
+2403:8680::,2403:8680:ffff:ffff:ffff:ffff:ffff:ffff,ID
 2403:8700::,2403:8700:ffff:ffff:ffff:ffff:ffff:ffff,BT
+2403:8780::,2403:8780:ffff:ffff:ffff:ffff:ffff:ffff,IN
 2403:8800::,2403:8800:ffff:ffff:ffff:ffff:ffff:ffff,AU
+2403:8880::,2403:8880:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:8900::,2403:8900:ffff:ffff:ffff:ffff:ffff:ffff,CN
+2403:8980::,2403:8980:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:8a00::,2403:8a00:ffff:ffff:ffff:ffff:ffff:ffff,JP
+2403:8a80::,2403:8a80:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:8b00::,2403:8b00:ffff:ffff:ffff:ffff:ffff:ffff,CN
+2403:8b80::,2403:8b80:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:8c00::,2403:8c00:ffff:ffff:ffff:ffff:ffff:ffff,CN
+2403:8c80::,2403:8c80:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:8d00::,2403:8d00:ffff:ffff:ffff:ffff:ffff:ffff,CN
+2403:8d80::,2403:8d80:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:8e00::,2403:8e00:ffff:ffff:ffff:ffff:ffff:ffff,JP
+2403:8e80::,2403:8e80:ffff:ffff:ffff:ffff:ffff:ffff,MM
 2403:8f00::,2403:8f00:ffff:ffff:ffff:ffff:ffff:ffff,JP
+2403:8f80::,2403:8f80:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:9000::,2403:9000:ffff:ffff:ffff:ffff:ffff:ffff,AU
+2403:9080::,2403:9080:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:9100::,2403:9100:ffff:ffff:ffff:ffff:ffff:ffff,ID
+2403:9180::,2403:9180:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:9200::,2403:9200:ffff:ffff:ffff:ffff:ffff:ffff,JP
+2403:9280::,2403:9280:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:9300::,2403:9300:ffff:ffff:ffff:ffff:ffff:ffff,BD
+2403:9380::,2403:9380:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:9400::,2403:9400:ffff:ffff:ffff:ffff:ffff:ffff,JP
+2403:9480::,2403:9480:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:9500::,2403:9500:ffff:ffff:ffff:ffff:ffff:ffff,ID
+2403:9580::,2403:9580:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:9600::,2403:9600:ffff:ffff:ffff:ffff:ffff:ffff,JP
+2403:9680::,2403:9680:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:9700::,2403:9700:ffff:ffff:ffff:ffff:ffff:ffff,MY
+2403:9780::,2403:9780:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:9800::,2403:9800:ffff:ffff:ffff:ffff:ffff:ffff,NZ
+2403:9880::,2403:9880:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:9900::,2403:9a00:ffff:ffff:ffff:ffff:ffff:ffff,JP
+2403:9a80::,2403:9a80:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:9b00::,2403:9b00:ffff:ffff:ffff:ffff:ffff:ffff,CN
+2403:9b80::,2403:9b80:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:9c00::,2403:9c00:ffff:ffff:ffff:ffff:ffff:ffff,JP
+2403:9c80::,2403:9c80:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:9d00::,2403:9d00:ffff:ffff:ffff:ffff:ffff:ffff,CN
+2403:9d80::,2403:9d80:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:9e00::,2403:9e00:ffff:ffff:ffff:ffff:ffff:ffff,AU
+2403:9e80::,2403:9e80:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:9f00::,2403:9f00:ffff:ffff:ffff:ffff:ffff:ffff,TW
+2403:9f80::,2403:9f80:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:a000::,2403:a000:ffff:ffff:ffff:ffff:ffff:ffff,PH
+2403:a080::,2403:a080:ffff:ffff:ffff:ffff:ffff:ffff,IN
 2403:a100::,2403:a100:ffff:ffff:ffff:ffff:ffff:ffff,CN
+2403:a180::,2403:a180:ffff:ffff:ffff:ffff:ffff:ffff,SG
 2403:a200::,2403:a200:ffff:ffff:ffff:ffff:ffff:ffff,CN
+2403:a280::,2403:a280:ffff:ffff:ffff:ffff:ffff:ffff,HK
 2403:a300::,2403:a300:ffff:ffff:ffff:ffff:ffff:ffff,CN
+2403:a380::,2403:a380:ffff:ffff:ffff:ffff:ffff:ffff,SG
 2403:a400::,2403:a400:ffff:ffff:ffff:ffff:ffff:ffff,AU
+2403:a480::,2403:a480:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:a500::,2403:a500:ffff:ffff:ffff:ffff:ffff:ffff,PK
+2403:a580::,2403:a580:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:a600::,2403:a600:ffff:ffff:ffff:ffff:ffff:ffff,ID
+2403:a680::,2403:a680:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:a700::,2403:a700:ffff:ffff:ffff:ffff:ffff:ffff,JP
+2403:a780::,2403:a780:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:a800::,2403:a800:ffff:ffff:ffff:ffff:ffff:ffff,AU
+2403:a880::,2403:a880:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:a900::,2403:a900:ffff:ffff:ffff:ffff:ffff:ffff,SG
+2403:a980::,2403:a980:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:aa00::,2403:aa00:ffff:ffff:ffff:ffff:ffff:ffff,ID
+2403:aa80::,2403:aa80:ffff:ffff:ffff:ffff:ffff:ffff,CN
+2403:ab80::,2403:ab80:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:ac00::,2403:ac00:ffff:ffff:ffff:ffff:ffff:ffff,CN
+2403:ac80::,2403:ac80:ffff:ffff:ffff:ffff:ffff:ffff,JP
 2403:ad00::,2403:ad00:ffff:ffff:ffff:ffff:ffff:ffff,IN
+2403:ad80::,2403:ad80:ffff:ffff:ffff:ffff:ffff:ffff,HK
 2403:ae00::,2403:ae00:ffff:ffff:ffff:ffff:ffff:ffff,ID
+2403:ae80::,2403:ae80:ffff:ffff:ffff:ffff:ffff:ffff,NR
 2403:af00::,2403:af00:ffff:ffff:ffff:ffff:ffff:ffff,ID
+2403:af80::,2403:af80:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:b000::,2403:b000:ffff:ffff:ffff:ffff:ffff:ffff,AU
+2403:b080::,2403:b080:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:b100::,2403:b100:ffff:ffff:ffff:ffff:ffff:ffff,SG
+2403:b180::,2403:b180:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:b200::,2403:b200:ffff:ffff:ffff:ffff:ffff:ffff,ID
+2403:b280::,2403:b280:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:b300::,2403:b300:ffff:ffff:ffff:ffff:ffff:ffff,AU
+2403:b380::,2403:b380:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:b400::,2403:b400:ffff:ffff:ffff:ffff:ffff:ffff,CN
+2403:b480::,2403:b480:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:b500::,2403:b500:ffff:ffff:ffff:ffff:ffff:ffff,IN
+2403:b580::,2403:b580:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:b600::,2403:b600:ffff:ffff:ffff:ffff:ffff:ffff,ID
+2403:b680::,2403:b680:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:b700::,2403:b700:ffff:ffff:ffff:ffff:ffff:ffff,NZ
+2403:b780::,2403:b780:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:b800::,2403:b800:ffff:ffff:ffff:ffff:ffff:ffff,AU
+2403:b880::,2403:b880:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:b900::,2403:b900:ffff:ffff:ffff:ffff:ffff:ffff,ID
+2403:b980::,2403:b980:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:ba00::,2403:ba00:ffff:ffff:ffff:ffff:ffff:ffff,ID
+2403:ba80::,2403:ba80:ffff:ffff:ffff:ffff:ffff:ffff,AU
 2403:bb00::,2403:bb00:ffff:ffff:ffff:ffff:ffff:ffff,ID
+2403:bb80::,2403:bb80:ffff:ffff:ffff:ffff:ffff:ffff,HK
 2403:bc00::,2403:bc00:ffff:ffff:ffff:ffff:ffff:ffff,MY
+2403:bc80::,2403:bc80:ffff:ffff:ffff:ffff:ffff:ffff,SG
 2403:bd00::,2403:bd00:ffff:ffff:ffff:ffff:ffff:ffff,IN
+2403:bd80::,2403:bd80:ffff:ffff:ffff:ffff:ffff:ffff,JP
 2403:be00::,2403:be00:ffff:ffff:ffff:ffff:ffff:ffff,ID
+2403:be80::,2403:be80:ffff:ffff:ffff:ffff:ffff:ffff,IN
 2403:bf00::,2403:bf00:ffff:ffff:ffff:ffff:ffff:ffff,TH
+2403:bf80::,2403:bf80:ffff:ffff:ffff:ffff:ffff:ffff,BD
 2403:c000::,2403:c000:ffff:ffff:ffff:ffff:ffff:ffff,TH
+2403:c080::,2403:c080:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:c100::,2403:c100:ffff:ffff:ffff:ffff:ffff:ffff,CN
+2403:c180::,2403:c180:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:c200::,2403:c200:ffff:ffff:ffff:ffff:ffff:ffff,NZ
+2403:c280::,2403:c280:ffff:ffff:ffff:ffff:ffff:ffff,MM
 2403:c300::,2403:c300:ffff:ffff:ffff:ffff:ffff:ffff,TW
+2403:c380::,2403:c380:ffff:ffff:ffff:ffff:ffff:ffff,IN
 2403:c400::,2403:c400:ffff:ffff:ffff:ffff:ffff:ffff,AU
+2403:c480::,2403:c480:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:c500::,2403:c500:ffff:ffff:ffff:ffff:ffff:ffff,SG
+2403:c580::,2403:c580:ffff:ffff:ffff:ffff:ffff:ffff,MY
 2403:c600::,2403:c600:ffff:ffff:ffff:ffff:ffff:ffff,ID
+2403:c680::,2403:c680:ffff:ffff:ffff:ffff:ffff:ffff,IN
+2403:c780::,2403:c780:ffff:ffff:ffff:ffff:ffff:ffff,JP
 2403:c800::,2403:c800:ffff:ffff:ffff:ffff:ffff:ffff,AU
+2403:c880::,2403:c881:ffff:ffff:ffff:ffff:ffff:ffff,HK
 2403:c900::,2403:c900:ffff:ffff:ffff:ffff:ffff:ffff,NZ
+2403:c980::,2403:c980:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:ca00::,2403:ca00:ffff:ffff:ffff:ffff:ffff:ffff,AU
+2403:ca80::,2403:ca80:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:cb00::,2403:cb00:ffff:ffff:ffff:ffff:ffff:ffff,SG
-2403:cc00::,2403:cc00:ffff:ffff:ffff:ffff:ffff:ffff,SG
+2403:cb80::,2403:cb80:ffff:ffff:ffff:ffff:ffff:ffff,ID
+2403:cc00::,2403:cc00:3fff:ffff:ffff:ffff:ffff:ffff,SG
+2403:cc00:4000::,2403:cc00:4000:7fff:ffff:ffff:ffff:ffff,AU
+2403:cc00:4000:8000::,2403:cc00:9fff:ffff:ffff:ffff:ffff:ffff,SG
+2403:cc00:a000::,2403:cc00:a000:7fff:ffff:ffff:ffff:ffff,ES
+2403:cc00:a000:8000::,2403:cc00:ffff:ffff:ffff:ffff:ffff:ffff,SG
+2403:cc80::,2403:cc80:ffff:ffff:ffff:ffff:ffff:ffff,BD
 2403:cd00::,2403:cd00:ffff:ffff:ffff:ffff:ffff:ffff,PH
+2403:cd80::,2403:cd80:ffff:ffff:ffff:ffff:ffff:ffff,PH
 2403:ce00::,2403:ce00:ffff:ffff:ffff:ffff:ffff:ffff,AU
+2403:ce80::,2403:ce80:ffff:ffff:ffff:ffff:ffff:ffff,JP
 2403:cf00::,2403:cf00:ffff:ffff:ffff:ffff:ffff:ffff,AU
+2403:cf80::,2403:cf80:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:d000::,2403:d000:ffff:ffff:ffff:ffff:ffff:ffff,JP
+2403:d080::,2403:d080:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:d100::,2403:d100:ffff:ffff:ffff:ffff:ffff:ffff,AU
+2403:d180::,2403:d180:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:d200::,2403:d200:ffff:ffff:ffff:ffff:ffff:ffff,NZ
+2403:d280::,2403:d280:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:d300::,2403:d300:ffff:ffff:ffff:ffff:ffff:ffff,HK
+2403:d380::,2403:d380:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:d400::,2403:d400:ffff:ffff:ffff:ffff:ffff:ffff,CN
+2403:d480::,2403:d480:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:d500::,2403:d500:ffff:ffff:ffff:ffff:ffff:ffff,AU
+2403:d580::,2403:d580:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:d600::,2403:d600:ffff:ffff:ffff:ffff:ffff:ffff,AU
+2403:d680::,2403:d680:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:d700::,2403:d700:ffff:ffff:ffff:ffff:ffff:ffff,MN
+2403:d780::,2403:d780:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:d800::,2403:d800:ffff:ffff:ffff:ffff:ffff:ffff,NZ
+2403:d880::,2403:d880:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:d900::,2403:d900:ffff:ffff:ffff:ffff:ffff:ffff,AU
+2403:d980::,2403:d980:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:da00::,2403:da00:ffff:ffff:ffff:ffff:ffff:ffff,ID
+2403:da80::,2403:da80:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:db00::,2403:db00:ffff:ffff:ffff:ffff:ffff:ffff,CN
+2403:db80::,2403:db80:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:dc00::,2403:dc00:ffff:ffff:ffff:ffff:ffff:ffff,AU
+2403:dc80::,2403:dc80:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:dd00::,2403:dd00:ffff:ffff:ffff:ffff:ffff:ffff,BD
+2403:dd80::,2403:dd80:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:de00::,2403:de00:ffff:ffff:ffff:ffff:ffff:ffff,NZ
+2403:de80::,2403:de80:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:df00::,2403:df00:ffff:ffff:ffff:ffff:ffff:ffff,SG
+2403:df80::,2403:df80:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:e000::,2403:e000:ffff:ffff:ffff:ffff:ffff:ffff,AU
+2403:e080::,2403:e080:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:e100::,2403:e100:ffff:ffff:ffff:ffff:ffff:ffff,BD
+2403:e180::,2403:e180:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:e200::,2403:e200:ffff:ffff:ffff:ffff:ffff:ffff,VN
+2403:e280::,2403:e280:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:e300::,2403:e300:ffff:ffff:ffff:ffff:ffff:ffff,CN
+2403:e380::,2403:e380:ffff:ffff:ffff:ffff:ffff:ffff,ID
 2403:e400::,2403:e400:ffff:ffff:ffff:ffff:ffff:ffff,HK
+2403:e480::,2403:e480:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:e500::,2403:e500:ffff:ffff:ffff:ffff:ffff:ffff,CN
+2403:e580::,2403:e580:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:e600::,2403:e600:ffff:ffff:ffff:ffff:ffff:ffff,ID
+2403:e680::,2403:e680:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:e700::,2403:e700:ffff:ffff:ffff:ffff:ffff:ffff,CN
+2403:e780::,2403:e780:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:e800::,2403:e800:ffff:ffff:ffff:ffff:ffff:ffff,HK
+2403:e880::,2403:e880:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:e900::,2403:e900:ffff:ffff:ffff:ffff:ffff:ffff,SG
+2403:e980::,2403:e980:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:ea00::,2403:ea00:ffff:ffff:ffff:ffff:ffff:ffff,HK
+2403:ea80::,2403:ea80:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:eb00::,2403:eb00:ffff:ffff:ffff:ffff:ffff:ffff,BD
+2403:eb80::,2403:eb80:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:ec00::,2403:ec00:ffff:ffff:ffff:ffff:ffff:ffff,BD
+2403:ec80::,2403:ec80:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:ed00::,2403:ed00:ffff:ffff:ffff:ffff:ffff:ffff,CN
+2403:ed80::,2403:ed80:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:ee00::,2403:ee00:ffff:ffff:ffff:ffff:ffff:ffff,TW
+2403:ee80::,2403:ee80:ffff:ffff:ffff:ffff:ffff:ffff,CN
+2403:ef80::,2403:ef80:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:f000::,2403:f000:ffff:ffff:ffff:ffff:ffff:ffff,AU
+2403:f080::,2403:f080:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:f100::,2403:f100:ffff:ffff:ffff:ffff:ffff:ffff,CN
+2403:f180::,2403:f180:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:f200::,2403:f200:ffff:ffff:ffff:ffff:ffff:ffff,JP
+2403:f280::,2403:f280:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:f300::,2403:f300:ffff:ffff:ffff:ffff:ffff:ffff,CN
+2403:f380::,2403:f380:ffff:ffff:ffff:ffff:ffff:ffff,CN
+2403:f480::,2403:f480:ffff:ffff:ffff:ffff:ffff:ffff,AU
 2403:f500::,2403:f500:ffff:ffff:ffff:ffff:ffff:ffff,HK
+2403:f580::,2403:f580:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:f600::,2403:f600:ffff:ffff:ffff:ffff:ffff:ffff,NR
+2403:f680::,2403:f680:ffff:ffff:ffff:ffff:ffff:ffff,IN
 2403:f700::,2403:f700:ffff:ffff:ffff:ffff:ffff:ffff,NZ
+2403:f780::,2403:f780:ffff:ffff:ffff:ffff:ffff:ffff,BD
 2403:f800::,2403:f800:ffff:ffff:ffff:ffff:ffff:ffff,CN
+2403:f880::,2403:f880:ffff:ffff:ffff:ffff:ffff:ffff,JP
 2403:f900::,2403:f900:ffff:ffff:ffff:ffff:ffff:ffff,CN
+2403:f980::,2403:f980:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:fa00::,2403:fa00:ffff:ffff:ffff:ffff:ffff:ffff,HK
+2403:fa80::,2403:fa80:ffff:ffff:ffff:ffff:ffff:ffff,SG
 2403:fb00::,2403:fb00:ffff:ffff:ffff:ffff:ffff:ffff,CN
+2403:fb80::,2403:fb80:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:fc00::,2403:fc00:ffff:ffff:ffff:ffff:ffff:ffff,AU
+2403:fc80::,2403:fc80:ffff:ffff:ffff:ffff:ffff:ffff,ID
 2403:fd00::,2403:fd00:ffff:ffff:ffff:ffff:ffff:ffff,AU
+2403:fd80::,2403:fd80:ffff:ffff:ffff:ffff:ffff:ffff,ID
 2403:fe00::,2403:fe00:ffff:ffff:ffff:ffff:ffff:ffff,IN
+2403:fe80::,2403:fe80:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2403:ff00::,2403:ff00:ffff:ffff:ffff:ffff:ffff:ffff,ID
+2403:ff80::,2403:ff80:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2404::,2404:3f:ffff:ffff:ffff:ffff:ffff:ffff,TW
 2404:80::,2404:8f:ffff:ffff:ffff:ffff:ffff:ffff,TW
 2404:a0::,2404:a0:ffff:ffff:ffff:ffff:ffff:ffff,NZ
@@ -6197,56 +7509,111 @@
 2404:1b0::,2404:1b0:ffff:ffff:ffff:ffff:ffff:ffff,ID
 2404:1b8::,2404:1b8:ffff:ffff:ffff:ffff:ffff:ffff,ID
 2404:200::,2404:200:ffff:ffff:ffff:ffff:ffff:ffff,JP
+2404:280::,2404:280:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2404:300::,2404:300:ffff:ffff:ffff:ffff:ffff:ffff,KH
+2404:380::,2404:380:ffff:ffff:ffff:ffff:ffff:ffff,GU
 2404:400::,2404:400:ffff:ffff:ffff:ffff:ffff:ffff,ID
+2404:480::,2404:480:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2404:500::,2404:500:ffff:ffff:ffff:ffff:ffff:ffff,ID
+2404:580::,2404:580:ffff:ffff:ffff:ffff:ffff:ffff,IN
 2404:600::,2404:600:ffff:ffff:ffff:ffff:ffff:ffff,ID
+2404:680::,2404:680:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2404:700::,2404:700:ffff:ffff:ffff:ffff:ffff:ffff,KH
+2404:780::,2404:780:ffff:ffff:ffff:ffff:ffff:ffff,AU
 2404:800::,2404:800:ffff:ffff:ffff:ffff:ffff:ffff,KR
+2404:880::,2404:880:ffff:ffff:ffff:ffff:ffff:ffff,ID
+2404:980::,2404:980:ffff:ffff:ffff:ffff:ffff:ffff,BD
 2404:a00::,2404:a00:ffff:ffff:ffff:ffff:ffff:ffff,JP
+2404:a80::,2404:a80:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2404:b00::,2404:b00:ffff:ffff:ffff:ffff:ffff:ffff,BD
+2404:b80::,2404:b80:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2404:c00::,2404:c00:ffff:ffff:ffff:ffff:ffff:ffff,IN
+2404:c80::,2404:c80:ffff:ffff:ffff:ffff:ffff:ffff,AU
 2404:d00::,2404:d00:ffff:ffff:ffff:ffff:ffff:ffff,BD
+2404:d80::,2404:d80:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2404:e00::,2404:e00:ffff:ffff:ffff:ffff:ffff:ffff,SG
+2404:e80::,2404:e80:ffff:ffff:ffff:ffff:ffff:ffff,AU
 2404:f00::,2404:f00:ffff:ffff:ffff:ffff:ffff:ffff,CN
+2404:f80::,2404:f80:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2404:1000::,2404:1000:ffff:ffff:ffff:ffff:ffff:ffff,JP
+2404:1080::,2404:1080:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2404:1100::,2404:1100:ffff:ffff:ffff:ffff:ffff:ffff,SG
+2404:1180::,2404:1180:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2404:1200::,2404:1200:ffff:ffff:ffff:ffff:ffff:ffff,SG
+2404:1280::,2404:1280:ffff:ffff:ffff:ffff:ffff:ffff,HK
 2404:1300::,2404:1300:ffff:ffff:ffff:ffff:ffff:ffff,JP
+2404:1380::,2404:1380:ffff:ffff:ffff:ffff:ffff:ffff,BD
 2404:1400::,2404:1400:ffff:ffff:ffff:ffff:ffff:ffff,ID
+2404:1480::,2404:1480:ffff:ffff:ffff:ffff:ffff:ffff,IN
 2404:1500::,2404:1500:ffff:ffff:ffff:ffff:ffff:ffff,IN
+2404:1580::,2404:1580:ffff:ffff:ffff:ffff:ffff:ffff,IN
 2404:1600::,2404:1601:ffff:ffff:ffff:ffff:ffff:ffff,AU
+2404:1680::,2404:1680:ffff:ffff:ffff:ffff:ffff:ffff,TH
 2404:1700::,2404:1700:ffff:ffff:ffff:ffff:ffff:ffff,JP
+2404:1780::,2404:1780:ffff:ffff:ffff:ffff:ffff:ffff,MM
 2404:1800::,2404:1800:ffff:ffff:ffff:ffff:ffff:ffff,NZ
+2404:1880::,2404:1880:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2404:1900::,2404:1900:ffff:ffff:ffff:ffff:ffff:ffff,JP
+2404:1980::,2404:1980:ffff:ffff:ffff:ffff:ffff:ffff,JP
 2404:1a00::,2404:1a00:ffff:ffff:ffff:ffff:ffff:ffff,TH
+2404:1a80::,2404:1a80:ffff:ffff:ffff:ffff:ffff:ffff,NZ
 2404:1b00::,2404:1b00:ffff:ffff:ffff:ffff:ffff:ffff,JP
+2404:1b80::,2404:1b80:ffff:ffff:ffff:ffff:ffff:ffff,IN
 2404:1c00::,2404:1c00:ffff:ffff:ffff:ffff:ffff:ffff,NZ
+2404:1c80::,2404:1c80:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2404:1d00::,2404:1d00:ffff:ffff:ffff:ffff:ffff:ffff,AU
+2404:1d80::,2404:1d80:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2404:1e00::,2404:1e00:ffff:ffff:ffff:ffff:ffff:ffff,NZ
+2404:1e80::,2404:1e80:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2404:1f00::,2404:1f00:ffff:ffff:ffff:ffff:ffff:ffff,IN
+2404:1f80::,2404:1f80:ffff:ffff:ffff:ffff:ffff:ffff,AU
 2404:2000::,2404:2000:ffff:ffff:ffff:ffff:ffff:ffff,NZ
+2404:2080::,2404:2080:ffff:ffff:ffff:ffff:ffff:ffff,AU
 2404:2100::,2404:2100:ffff:ffff:ffff:ffff:ffff:ffff,HK
+2404:2180::,2404:2180:ffff:ffff:ffff:ffff:ffff:ffff,SG
 2404:2200::,2404:2200:ffff:ffff:ffff:ffff:ffff:ffff,NC
+2404:2280::,2404:2280:ffff:ffff:ffff:ffff:ffff:ffff,SG
 2404:2300::,2404:2300:ffff:ffff:ffff:ffff:ffff:ffff,KR
+2404:2380::,2404:2380:ffff:ffff:ffff:ffff:ffff:ffff,PH
 2404:2400::,2404:2400:ffff:ffff:ffff:ffff:ffff:ffff,AU
+2404:2480::,2404:2480:ffff:ffff:ffff:ffff:ffff:ffff,HK
+2404:2580::,2404:2580:ffff:ffff:ffff:ffff:ffff:ffff,TH
 2404:2600::,2404:2600:ffff:ffff:ffff:ffff:ffff:ffff,TH
+2404:2680::,2404:2680:ffff:ffff:ffff:ffff:ffff:ffff,JP
 2404:2700::,2404:2700:ffff:ffff:ffff:ffff:ffff:ffff,MN
+2404:2780::,2404:2780:ffff:ffff:ffff:ffff:ffff:ffff,AU
 2404:2800::,2404:2800:ffff:ffff:ffff:ffff:ffff:ffff,AU
+2404:2880::,2404:2880:ffff:ffff:ffff:ffff:ffff:ffff,KR
 2404:2900::,2404:2900:ffff:ffff:ffff:ffff:ffff:ffff,AU
+2404:2980::,2404:2980:ffff:ffff:ffff:ffff:ffff:ffff,BD
 2404:2a00::,2404:2a00:ffff:ffff:ffff:ffff:ffff:ffff,NC
+2404:2a80::,2404:2a80:ffff:ffff:ffff:ffff:ffff:ffff,HK
 2404:2b00::,2404:2b00:ffff:ffff:ffff:ffff:ffff:ffff,AU
+2404:2b80::,2404:2b80:ffff:ffff:ffff:ffff:ffff:ffff,BD
 2404:2c00::,2404:2c00:ffff:ffff:ffff:ffff:ffff:ffff,NP
+2404:2c80::,2404:2c80:ffff:ffff:ffff:ffff:ffff:ffff,ID
 2404:2d00::,2404:2d00:ffff:ffff:ffff:ffff:ffff:ffff,JP
+2404:2d80::,2404:2d80:ffff:ffff:ffff:ffff:ffff:ffff,BD
 2404:2e00::,2404:2e00:ffff:ffff:ffff:ffff:ffff:ffff,LA
+2404:2e80::,2404:2e80:ffff:ffff:ffff:ffff:ffff:ffff,NP
 2404:2f00::,2404:2f00:ffff:ffff:ffff:ffff:ffff:ffff,NZ
+2404:2f80::,2404:2f80:ffff:ffff:ffff:ffff:ffff:ffff,ID
+2404:3080::,2404:3080:ffff:ffff:ffff:ffff:ffff:ffff,BD
 2404:3100::,2404:3100:ffff:ffff:ffff:ffff:ffff:ffff,PK
+2404:3180::,2404:3180:ffff:ffff:ffff:ffff:ffff:ffff,BD
 2404:3200::,2404:3200:ffff:ffff:ffff:ffff:ffff:ffff,JP
+2404:3280::,2404:3280:ffff:ffff:ffff:ffff:ffff:ffff,TH
 2404:3300::,2404:3300:ffff:ffff:ffff:ffff:ffff:ffff,CN
+2404:3380::,2404:3380:ffff:ffff:ffff:ffff:ffff:ffff,PH
+2404:3480::,2404:3480:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2404:3500::,2404:3500:ffff:ffff:ffff:ffff:ffff:ffff,HK
+2404:3580::,2404:3580:ffff:ffff:ffff:ffff:ffff:ffff,ID
 2404:3600::,2404:3601:ffff:ffff:ffff:ffff:ffff:ffff,NZ
+2404:3680::,2404:3680:ffff:ffff:ffff:ffff:ffff:ffff,ID
 2404:3700::,2404:3700:ffff:ffff:ffff:ffff:ffff:ffff,CN
+2404:3780::,2404:3780:ffff:ffff:ffff:ffff:ffff:ffff,NP
 2404:3800::,2404:3800:ffff:ffff:ffff:ffff:ffff:ffff,NZ
+2404:3880::,2404:3880:ffff:ffff:ffff:ffff:ffff:ffff,HK
 2404:3900::,2404:3900:ffff:ffff:ffff:ffff:ffff:ffff,ID
 2404:3a00::,2404:3a00:ffff:ffff:ffff:ffff:ffff:ffff,VN
 2404:3b00::,2404:3b00:ffff:ffff:ffff:ffff:ffff:ffff,CN
@@ -6331,7 +7698,7 @@
 2404:8a00::,2404:8a00:ffff:ffff:ffff:ffff:ffff:ffff,LK
 2404:8b00::,2404:8b00:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2404:8c00::,2404:8c00:ffff:ffff:ffff:ffff:ffff:ffff,GU
-2404:8d00::,2404:8d00:ffff:ffff:ffff:ffff:ffff:ffff,TH
+2404:8d00::,2404:8d07:ffff:ffff:ffff:ffff:ffff:ffff,TH
 2404:8e00::,2404:8e01:ffff:ffff:ffff:ffff:ffff:ffff,JP
 2404:8f00::,2404:8f00:ffff:ffff:ffff:ffff:ffff:ffff,AU
 2404:9000::,2404:9000:ffff:ffff:ffff:ffff:ffff:ffff,JP
@@ -6367,7 +7734,6 @@
 2404:b100::,2404:b100:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2404:b200::,2404:b200:ffff:ffff:ffff:ffff:ffff:ffff,IN
 2404:b300::,2404:b300:ffff:ffff:ffff:ffff:ffff:ffff,KH
-2404:b400::,2404:b400:ffff:ffff:ffff:ffff:ffff:ffff,AU
 2404:b500::,2404:b500:ffff:ffff:ffff:ffff:ffff:ffff,AU
 2404:b600::,2404:b600:ffff:ffff:ffff:ffff:ffff:ffff,JP
 2404:b700::,2404:b700:ffff:ffff:ffff:ffff:ffff:ffff,NZ
@@ -6419,7 +7785,9 @@
 2404:e500::,2404:e500:ffff:ffff:ffff:ffff:ffff:ffff,ID
 2404:e600::,2404:e600:ffff:ffff:ffff:ffff:ffff:ffff,SG
 2404:e700::,2404:e700:ffff:ffff:ffff:ffff:ffff:ffff,ID
-2404:e800::,2404:e801:ffff:ffff:ffff:ffff:ffff:ffff,SG
+2404:e800::,2404:e801:ca9c:7fff:ffff:ffff:ffff:ffff,SG
+2404:e801:ca9c:8000::,2404:e801:ca9c:ffff:ffff:ffff:ffff:ffff,US
+2404:e801:ca9d::,2404:e801:ffff:ffff:ffff:ffff:ffff:ffff,SG
 2404:e900::,2404:e900:ffff:ffff:ffff:ffff:ffff:ffff,ID
 2404:ea00::,2404:ea00:ffff:ffff:ffff:ffff:ffff:ffff,AU
 2404:eb00::,2404:eb00:ffff:ffff:ffff:ffff:ffff:ffff,ID
@@ -6437,11 +7805,15 @@
 2404:f700::,2404:f700:ffff:ffff:ffff:ffff:ffff:ffff,ID
 2404:f800::,2404:f800:ffff:ffff:ffff:ffff:ffff:ffff,JP
 2404:f801::,2404:f801::ffff:ffff:ffff:ffff:ffff,IN
-2404:f801:1::,2404:f801:7:ffff:ffff:ffff:ffff:ffff,SG
-2404:f801:8::,2404:f801:8:7fff:ffff:ffff:ffff:ffff,AU
-2404:f801:8:8000::,2404:f801:2f:ffff:ffff:ffff:ffff:ffff,SG
+2404:f801:1::,2404:f801:8:1010:ffff:ffff:ffff:ffff,SG
+2404:f801:8:1011::,2404:f801:8:1011::,AU
+2404:f801:8:1011::1,2404:f801:8:1013:ffff:ffff:ffff:ffff,SG
+2404:f801:8:1014::,2404:f801:8:1014::,AU
+2404:f801:8:1014::1,2404:f801:2f:ffff:ffff:ffff:ffff:ffff,SG
 2404:f801:30::,2404:f801:30::,AU
-2404:f801:30::1,2404:f801:8057:ffff:ffff:ffff:ffff:ffff,SG
+2404:f801:30::1,2404:f801:802f:ffff:ffff:ffff:ffff:ffff,SG
+2404:f801:8030::,2404:f801:8030:7fff:ffff:ffff:ffff:ffff,AU
+2404:f801:8030:8000::,2404:f801:8057:ffff:ffff:ffff:ffff:ffff,SG
 2404:f801:8058::,2404:f801:8058:ffff:ffff:ffff:ffff:ffff,IN
 2404:f801:8059::,2404:f801:ffff:ffff:ffff:ffff:ffff:ffff,SG
 2404:f900::,2404:f900:ffff:ffff:ffff:ffff:ffff:ffff,ID
@@ -6464,7 +7836,6 @@
 2405:c00::,2405:c00:ffff:ffff:ffff:ffff:ffff:ffff,PK
 2405:d00::,2405:d00:ffff:ffff:ffff:ffff:ffff:ffff,HK
 2405:e00::,2405:e00:ffff:ffff:ffff:ffff:ffff:ffff,JP
-2405:f00::,2405:f00:ffff:ffff:ffff:ffff:ffff:ffff,BD
 2405:1000::,2405:1000:ffff:ffff:ffff:ffff:ffff:ffff,AU
 2405:1200::,2405:1200:ffff:ffff:ffff:ffff:ffff:ffff,JP
 2405:1300::,2405:1300:ffff:ffff:ffff:ffff:ffff:ffff,AU
@@ -6497,7 +7868,9 @@
 2405:2000:e00::,2405:2000:e00:ff:ffff:ffff:ffff:ffff,AU
 2405:2000:e00:100::,2405:2000:eff:ffff:ffff:ffff:ffff:ffff,IN
 2405:2000:f00::,2405:2000:f00:1ff:ffff:ffff:ffff:ffff,JP
-2405:2000:f00:200::,2405:2000:ffc7:ffff:ffff:ffff:ffff:ffff,IN
+2405:2000:f00:200::,2405:2000:1fff:ffff:ffff:ffff:ffff:ffff,IN
+2405:2000:2000::,2405:2000:2000:ff:ffff:ffff:ffff:ffff,AU
+2405:2000:2000:100::,2405:2000:ffc7:ffff:ffff:ffff:ffff:ffff,IN
 2405:2000:ffc8::,2405:2000:ffc8:ffff:ffff:ffff:ffff:ffff,SG
 2405:2000:ffc9::,2405:2001:2ff:ffff:ffff:ffff:ffff:ffff,IN
 2405:2001:300::,2405:2001:300:ff:ffff:ffff:ffff:ffff,MY
@@ -6569,7 +7942,6 @@
 2405:6400::,2405:6400:ffff:ffff:ffff:ffff:ffff:ffff,MY
 2405:6500::,2405:6500:ffff:ffff:ffff:ffff:ffff:ffff,AU
 2405:6600::,2405:6600:ffff:ffff:ffff:ffff:ffff:ffff,NP
-2405:6700::,2405:6700:ffff:ffff:ffff:ffff:ffff:ffff,AU
 2405:6800::,2405:6800:ffff:ffff:ffff:ffff:ffff:ffff,IN
 2405:6900::,2405:6900:ffff:ffff:ffff:ffff:ffff:ffff,BD
 2405:6a00::,2405:6a00:ffff:ffff:ffff:ffff:ffff:ffff,AU
@@ -6587,7 +7959,6 @@
 2405:7700::,2405:7700:ffff:ffff:ffff:ffff:ffff:ffff,MY
 2405:7800::,2405:7800:ffff:ffff:ffff:ffff:ffff:ffff,JP
 2405:7900::,2405:7900:ffff:ffff:ffff:ffff:ffff:ffff,NZ
-2405:7a00::,2405:7a00:ffff:ffff:ffff:ffff:ffff:ffff,BD
 2405:7b00::,2405:7b00:ffff:ffff:ffff:ffff:ffff:ffff,KR
 2405:7c00::,2405:7c00:ffff:ffff:ffff:ffff:ffff:ffff,MY
 2405:7d00::,2405:7d00:ffff:ffff:ffff:ffff:ffff:ffff,JP
@@ -6631,7 +8002,6 @@
 2405:a300::,2405:a300:ffff:ffff:ffff:ffff:ffff:ffff,IN
 2405:a400::,2405:a400:ffff:ffff:ffff:ffff:ffff:ffff,NZ
 2405:a500::,2405:a500:ffff:ffff:ffff:ffff:ffff:ffff,CN
-2405:a600::,2405:a600:ffff:ffff:ffff:ffff:ffff:ffff,AU
 2405:a700::,2405:a700:ffff:ffff:ffff:ffff:ffff:ffff,IN
 2405:a900::,2405:a900:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2405:aa00::,2405:aa00:ffff:ffff:ffff:ffff:ffff:ffff,KH
@@ -6745,7 +8115,11 @@
 2406:1f00::,2406:1f00:ffff:ffff:ffff:ffff:ffff:ffff,AU
 2406:2000::,2406:2000:ef95:ffff:ffff:ffff:ffff:ffff,TW
 2406:2000:ef96::,2406:2000:ef96:7fff:ffff:ffff:ffff:ffff,HK
-2406:2000:ef96:8000::,2406:2000:ffff:ffff:ffff:ffff:ffff:ffff,TW
+2406:2000:ef96:8000::,2406:2000:efa5:ffff:ffff:ffff:ffff:ffff,TW
+2406:2000:efa6::,2406:2000:efa6:7fff:ffff:ffff:ffff:ffff,SG
+2406:2000:efa6:8000::,2406:2000:efb9:ffff:ffff:ffff:ffff:ffff,TW
+2406:2000:efba::,2406:2000:efba:7fff:ffff:ffff:ffff:ffff,HK
+2406:2000:efba:8000::,2406:2000:ffff:ffff:ffff:ffff:ffff:ffff,TW
 2406:2100::,2406:2100:ffff:ffff:ffff:ffff:ffff:ffff,IN
 2406:2200::,2406:2200:ffff:ffff:ffff:ffff:ffff:ffff,AU
 2406:2300::,2406:2300:ffff:ffff:ffff:ffff:ffff:ffff,NZ
@@ -6933,7 +8307,7 @@
 2406:e100::,2406:e100:ffff:ffff:ffff:ffff:ffff:ffff,PH
 2406:e200::,2406:e200:ffff:ffff:ffff:ffff:ffff:ffff,HK
 2406:e300::,2406:e300:ffff:ffff:ffff:ffff:ffff:ffff,HK
-2406:e400::,2406:e400:ffff:ffff:ffff:ffff:ffff:ffff,MV
+2406:e400::,2406:e401:ffff:ffff:ffff:ffff:ffff:ffff,MV
 2406:e500::,2406:e500:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2406:e600::,2406:e600:ffff:ffff:ffff:ffff:ffff:ffff,AU
 2406:e700::,2406:e700:ffff:ffff:ffff:ffff:ffff:ffff,JP
@@ -7001,7 +8375,6 @@
 2407:2900::,2407:2900:ffff:ffff:ffff:ffff:ffff:ffff,IN
 2407:2a00::,2407:2a00:ffff:ffff:ffff:ffff:ffff:ffff,IN
 2407:2b00::,2407:2b00:ffff:ffff:ffff:ffff:ffff:ffff,NZ
-2407:2c00::,2407:2c00:ffff:ffff:ffff:ffff:ffff:ffff,TH
 2407:2d00::,2407:2d00:ffff:ffff:ffff:ffff:ffff:ffff,SG
 2407:2e00::,2407:2e01:ffff:ffff:ffff:ffff:ffff:ffff,AU
 2407:2f00::,2407:2f00:ffff:ffff:ffff:ffff:ffff:ffff,SG
@@ -7193,7 +8566,6 @@
 2407:f200::,2407:f200:ffff:ffff:ffff:ffff:ffff:ffff,ID
 2407:f300::,2407:f300:ffff:ffff:ffff:ffff:ffff:ffff,MM
 2407:f400::,2407:f400:ffff:ffff:ffff:ffff:ffff:ffff,AU
-2407:f500::,2407:f500:ffff:ffff:ffff:ffff:ffff:ffff,HK
 2407:f600::,2407:f600:ffff:ffff:ffff:ffff:ffff:ffff,JP
 2407:f700::,2407:f700:ffff:ffff:ffff:ffff:ffff:ffff,IN
 2407:f800::,2407:f800:ffff:ffff:ffff:ffff:ffff:ffff,MY
@@ -7203,6 +8575,7 @@
 2407:fe00::,2407:fe00:ffff:ffff:ffff:ffff:ffff:ffff,AU
 2407:ff00::,2407:ff00:ffff:ffff:ffff:ffff:ffff:ffff,IN
 2408::,2408:3ff:ffff:ffff:ffff:ffff:ffff:ffff,JP
+2408:4000::,2408:43ff:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2408:8000::,2408:8fff:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2409:10::,2409:1f:ffff:ffff:ffff:ffff:ffff:ffff,JP
 2409:250::,2409:25f:ffff:ffff:ffff:ffff:ffff:ffff,JP
@@ -7217,9 +8590,13 @@
 240d::,240d:1f:ffff:ffff:ffff:ffff:ffff:ffff,JP
 240d:8000::,240d:80ff:ffff:ffff:ffff:ffff:ffff:ffff,CN
 240e::,240e:fff:ffff:ffff:ffff:ffff:ffff:ffff,CN
-240f::,240f:7c:4f20:ffff:ffff:ffff:ffff:ffff,JP
-240f:7c:4f21::,240f:7c:4f21:7fff:ffff:ffff:ffff:ffff,KR
-240f:7c:4f21:8000::,240f:ff:ffff:ffff:ffff:ffff:ffff:ffff,JP
+240f::,240f:74:c239:ffff:ffff:ffff:ffff:ffff,JP
+240f:74:c23a::,240f:74:c23a:7fff:ffff:ffff:ffff:ffff,US
+240f:74:c23a:8000::,240f:78:8491:ffff:ffff:ffff:ffff:ffff,JP
+240f:78:8492::,240f:78:8492:7fff:ffff:ffff:ffff:ffff,GB
+240f:78:8492:8000::,240f:93:b6d:ffff:ffff:ffff:ffff:ffff,JP
+240f:93:b6e::,240f:93:b6e:7fff:ffff:ffff:ffff:ffff,US
+240f:93:b6e:8000::,240f:ff:ffff:ffff:ffff:ffff:ffff:ffff,JP
 240f:8000::,240f:80ff:ffff:ffff:ffff:ffff:ffff:ffff,CN
 2600::,2600:7:ffff:ffff:ffff:ffff:ffff:ffff,US
 2600:100::,2600:10f:ffff:ffff:ffff:ffff:ffff:ffff,US
@@ -7249,6 +8626,8 @@
 2600:2300::,2600:230f:ffff:ffff:ffff:ffff:ffff:ffff,US
 2600:2400::,2600:2407:ffff:ffff:ffff:ffff:ffff:ffff,US
 2600:2500::,2600:250f:ffff:ffff:ffff:ffff:ffff:ffff,US
+2600:2600::,2600:260f:ffff:ffff:ffff:ffff:ffff:ffff,US
+2600:2700::,2600:270f:ffff:ffff:ffff:ffff:ffff:ffff,US
 2600:2800::,2600:2803:ffff:ffff:ffff:ffff:ffff:ffff,US
 2600:2c00::,2600:2c03:ffff:ffff:ffff:ffff:ffff:ffff,US
 2600:3000::,2600:3007:ffff:ffff:ffff:ffff:ffff:ffff,US
@@ -7277,12 +8656,15 @@
 2600:8c00::,2600:8c0f:ffff:ffff:ffff:ffff:ffff:ffff,US
 2600:9000::,2600:900f:ffff:ffff:ffff:ffff:ffff:ffff,US
 2600:a000::,2600:a00f:ffff:ffff:ffff:ffff:ffff:ffff,US
+2600:a400::,2600:a40f:ffff:ffff:ffff:ffff:ffff:ffff,US
 2600:e000::,2600:e00f:ffff:ffff:ffff:ffff:ffff:ffff,CA
 2601::,2601:6:117f:ffff:ffff:ffff:ffff:ffff,US
 2601:6:1180::,2601:6:1180:ffff:ffff:ffff:ffff:ffff,CA
 2601:6:1181::,2601:186:ffff:ffff:ffff:ffff:ffff:ffff,US
-2601:187::,2601:187::ffff:ffff:ffff:ffff:ffff,CA
-2601:187:1::,2601:fff:ffff:ffff:ffff:ffff:ffff:ffff,US
+2601:187::,2601:187:1:7fff:ffff:ffff:ffff:ffff,CA
+2601:187:1:8000::,2601:187:7f:ffff:ffff:ffff:ffff:ffff,US
+2601:187:80::,2601:187:80:7fff:ffff:ffff:ffff:ffff,CA
+2601:187:80:8000::,2601:fff:ffff:ffff:ffff:ffff:ffff:ffff,US
 2602::,2602:10f:ffff:ffff:ffff:ffff:ffff:ffff,US
 2602:200::,2602:200:ffff:ffff:ffff:ffff:ffff:ffff,CA
 2602:210::,2602:210:ffff:ffff:ffff:ffff:ffff:ffff,CA
@@ -7290,6 +8672,20 @@
 2602:230::,2602:231:ffff:ffff:ffff:ffff:ffff:ffff,US
 2602:240::,2602:25f:ffff:ffff:ffff:ffff:ffff:ffff,US
 2602:300::,2602:3ff:ffff:ffff:ffff:ffff:ffff:ffff,US
+2602:ff5b::,2602:ff5b:fff:ffff:ffff:ffff:ffff:ffff,US
+2602:ff5c::,2602:ff5c:fff:ffff:ffff:ffff:ffff:ffff,US
+2602:ff5d::,2602:ff5d:fff:ffff:ffff:ffff:ffff:ffff,US
+2602:ff5e::,2602:ff5e:fff:ffff:ffff:ffff:ffff:ffff,US
+2602:ff5f::,2602:ff5f:fff:ffff:ffff:ffff:ffff:ffff,US
+2602:ff60::,2602:ff60:fff:ffff:ffff:ffff:ffff:ffff,US
+2602:ff61::,2602:ff61:fff:ffff:ffff:ffff:ffff:ffff,US
+2602:ff62::,2602:ff62:fff:ffff:ffff:ffff:ffff:ffff,US
+2602:ff63::,2602:ff63:fff:ffff:ffff:ffff:ffff:ffff,US
+2602:ff64::,2602:ff64:fff:ffff:ffff:ffff:ffff:ffff,US
+2602:ff65::,2602:ff65:fff:ffff:ffff:ffff:ffff:ffff,US
+2602:ff66::,2602:ff66:fff:ffff:ffff:ffff:ffff:ffff,CA
+2602:ff67::,2602:ff67:fff:ffff:ffff:ffff:ffff:ffff,US
+2602:ff68::,2602:ff68:fff:ffff:ffff:ffff:ffff:ffff,US
 2602:ff69::,2602:ff69:fff:ffff:ffff:ffff:ffff:ffff,US
 2602:ff6a::,2602:ff6a:fff:ffff:ffff:ffff:ffff:ffff,US
 2602:ff6b::,2602:ff6b:fff:ffff:ffff:ffff:ffff:ffff,US
@@ -7307,8 +8703,7 @@
 2602:ff77::,2602:ff77:fff:ffff:ffff:ffff:ffff:ffff,US
 2602:ff78::,2602:ff78:fff:ffff:ffff:ffff:ffff:ffff,US
 2602:ff79::,2602:ff79:fff:ffff:ffff:ffff:ffff:ffff,US
-2602:ff7a::,2602:ff7a:fff:ffff:ffff:ffff:ffff:ffff,US
-2602:ff7b::,2602:ff7b:fff:ffff:ffff:ffff:ffff:ffff,US
+2602:ff7a::,2602:ff7b:fff:ffff:ffff:ffff:ffff:ffff,US
 2602:ff7c::,2602:ff7c:fff:ffff:ffff:ffff:ffff:ffff,US
 2602:ff7d::,2602:ff7d:fff:ffff:ffff:ffff:ffff:ffff,US
 2602:ff7e::,2602:ff7e:fff:ffff:ffff:ffff:ffff:ffff,US
@@ -7317,7 +8712,9 @@
 2602:ff81::,2602:ff81:fff:ffff:ffff:ffff:ffff:ffff,US
 2602:ff82::,2602:ff82:fff:ffff:ffff:ffff:ffff:ffff,US
 2602:ff83::,2602:ff83:fff:ffff:ffff:ffff:ffff:ffff,US
-2602:ff84::,2602:ff84:fff:ffff:ffff:ffff:ffff:ffff,US
+2602:ff84::,2602:ff84:2:ffff:ffff:ffff:ffff:ffff,US
+2602:ff84:3::,2602:ff84:3:ffff:ffff:ffff:ffff:ffff,DE
+2602:ff84:4::,2602:ff84:fff:ffff:ffff:ffff:ffff:ffff,US
 2602:ff85::,2602:ff85:fff:ffff:ffff:ffff:ffff:ffff,US
 2602:ff86::,2602:ff86:fff:ffff:ffff:ffff:ffff:ffff,US
 2602:ff87::,2602:ff87:fff:ffff:ffff:ffff:ffff:ffff,US
@@ -7404,7 +8801,9 @@
 2602:ffd7::,2602:ffd7:fff:ffff:ffff:ffff:ffff:ffff,US
 2602:ffd8::,2602:ffd8:fff:ffff:ffff:ffff:ffff:ffff,US
 2602:ffd9::,2602:ffd9:fff:ffff:ffff:ffff:ffff:ffff,US
-2602:ffda::,2602:ffda:fff:ffff:ffff:ffff:ffff:ffff,US
+2602:ffda::,2602:ffda:aa9:ffff:ffff:ffff:ffff:ffff,US
+2602:ffda:aaa::,2602:ffda:aaa:7fff:ffff:ffff:ffff:ffff,NL
+2602:ffda:aaa:8000::,2602:ffda:fff:ffff:ffff:ffff:ffff:ffff,US
 2602:ffdb::,2602:ffdb:fff:ffff:ffff:ffff:ffff:ffff,US
 2602:ffdc::,2602:ffdc:fff:ffff:ffff:ffff:ffff:ffff,US
 2602:ffdd::,2602:ffdd:fff:ffff:ffff:ffff:ffff:ffff,US
@@ -7420,7 +8819,7 @@
 2602:ffe7::,2602:ffe7:fff:ffff:ffff:ffff:ffff:ffff,PR
 2602:ffe8::,2602:ffe8:3ff:ffff:ffff:ffff:ffff:ffff,US
 2602:ffe8:400::,2602:ffe8:4ff:ffff:ffff:ffff:ffff:ffff,AU
-2602:ffe8:500::,2602:ffe9:fff:ffff:ffff:ffff:ffff:ffff,US
+2602:ffe8:500::,2602:ffe8:ffff:ffff:ffff:ffff:ffff:ffff,US
 2602:ffea::,2602:ffeb:fff:ffff:ffff:ffff:ffff:ffff,US
 2602:ffec::,2602:ffec:fff:ffff:ffff:ffff:ffff:ffff,CA
 2602:ffed::,2602:ffed:fff:ffff:ffff:ffff:ffff:ffff,US
@@ -7438,11 +8837,12 @@
 2602:fff9::,2602:fff9:fff:ffff:ffff:ffff:ffff:ffff,US
 2602:fffa::,2602:fffa:fff:ffff:ffff:ffff:ffff:ffff,US
 2602:fffb::,2602:fffb:fff:ffff:ffff:ffff:ffff:ffff,US
-2602:fffc::,2602:fffc:fff:ffff:ffff:ffff:ffff:ffff,US
+2602:fffc::,2602:fffc:ffff:ffff:ffff:ffff:ffff:ffff,US
 2602:fffd::,2602:fffd:fff:ffff:ffff:ffff:ffff:ffff,CA
 2602:ffff::,2602:ffff:fff:ffff:ffff:ffff:ffff:ffff,US
 2603::,2603:10ff:ffff:ffff:ffff:ffff:ffff:ffff,US
 2603:2000::,2603:30ff:ffff:ffff:ffff:ffff:ffff:ffff,US
+2603:4000::,2603:40ff:ffff:ffff:ffff:ffff:ffff:ffff,US
 2604::,2604::ffff:ffff:ffff:ffff:ffff:ffff,US
 2604:10::,2604:10:ffff:ffff:ffff:ffff:ffff:ffff,US
 2604:100::,2604:100:ffff:ffff:ffff:ffff:ffff:ffff,US
@@ -7465,7 +8865,6 @@
 2604:980::,2604:980:ffff:ffff:ffff:ffff:ffff:ffff,US
 2604:a00::,2604:a00:ffff:ffff:ffff:ffff:ffff:ffff,US
 2604:a80::,2604:a80:ffff:ffff:ffff:ffff:ffff:ffff,US
-2604:b00::,2604:b00:ffff:ffff:ffff:ffff:ffff:ffff,US
 2604:b80::,2604:b80:ffff:ffff:ffff:ffff:ffff:ffff,US
 2604:c00::,2604:c00:ffff:ffff:ffff:ffff:ffff:ffff,US
 2604:c80::,2604:c80:ffff:ffff:ffff:ffff:ffff:ffff,US
@@ -7475,7 +8874,6 @@
 2604:e80::,2604:e80:ffff:ffff:ffff:ffff:ffff:ffff,CA
 2604:f00::,2604:f00:ffff:ffff:ffff:ffff:ffff:ffff,US
 2604:f80::,2604:f80:ffff:ffff:ffff:ffff:ffff:ffff,US
-2604:1000::,2604:1000:ffff:ffff:ffff:ffff:ffff:ffff,US
 2604:1080::,2604:1080:ffff:ffff:ffff:ffff:ffff:ffff,US
 2604:1100::,2604:1100:ffff:ffff:ffff:ffff:ffff:ffff,US
 2604:1180::,2604:1180:ffff:ffff:ffff:ffff:ffff:ffff,US
@@ -7773,7 +9171,9 @@
 2604:a700::,2604:a700:ffff:ffff:ffff:ffff:ffff:ffff,US
 2604:a780::,2604:a780:ffff:ffff:ffff:ffff:ffff:ffff,US
 2604:a800::,2604:a800:ffff:ffff:ffff:ffff:ffff:ffff,US
-2604:a880::,2604:a880:ffff:ffff:ffff:ffff:ffff:ffff,US
+2604:a880::,2604:a880:cac:ffff:ffff:ffff:ffff:ffff,US
+2604:a880:cad::,2604:a880:cad:ffff:ffff:ffff:ffff:ffff,CA
+2604:a880:cae::,2604:a880:ffff:ffff:ffff:ffff:ffff:ffff,US
 2604:a900::,2604:a900:ffff:ffff:ffff:ffff:ffff:ffff,US
 2604:a980::,2604:a980:ffff:ffff:ffff:ffff:ffff:ffff,US
 2604:aa00::,2604:aa00:ffff:ffff:ffff:ffff:ffff:ffff,US
@@ -7824,11 +9224,9 @@
 2604:c100::,2604:c100:ffff:ffff:ffff:ffff:ffff:ffff,US
 2604:c180::,2604:c180:ffff:ffff:ffff:ffff:ffff:ffff,VI
 2604:c200::,2604:c200:ffff:ffff:ffff:ffff:ffff:ffff,US
-2604:c280::,2604:c280:ffff:ffff:ffff:ffff:ffff:ffff,US
 2604:c300::,2604:c300:ffff:ffff:ffff:ffff:ffff:ffff,US
 2604:c380::,2604:c380:ffff:ffff:ffff:ffff:ffff:ffff,US
 2604:c400::,2604:c400:ffff:ffff:ffff:ffff:ffff:ffff,US
-2604:c480::,2604:c480:ffff:ffff:ffff:ffff:ffff:ffff,US
 2604:c500::,2604:c500:ffff:ffff:ffff:ffff:ffff:ffff,US
 2604:c580::,2604:c580:ffff:ffff:ffff:ffff:ffff:ffff,US
 2604:c600::,2604:c600:ffff:ffff:ffff:ffff:ffff:ffff,US
@@ -7962,7 +9360,7 @@
 2605:900::,2605:900:ffff:ffff:ffff:ffff:ffff:ffff,US
 2605:980::,2605:980:ffff:ffff:ffff:ffff:ffff:ffff,US
 2605:a00::,2605:a00:ffff:ffff:ffff:ffff:ffff:ffff,US
-2605:a80::,2605:a80:ffff:ffff:ffff:ffff:ffff:ffff,CA
+2605:a80::,2605:a80:ffff:ffff:ffff:ffff:ffff:ffff,US
 2605:b00::,2605:b00:fff:ffff:ffff:ffff:ffff:ffff,US
 2605:b80::,2605:b80:ffff:ffff:ffff:ffff:ffff:ffff,US
 2605:c00::,2605:c00:ffff:ffff:ffff:ffff:ffff:ffff,CA
@@ -8348,7 +9746,7 @@
 2605:d180::,2605:d180:ffff:ffff:ffff:ffff:ffff:ffff,US
 2605:d280::,2605:d280:ffff:ffff:ffff:ffff:ffff:ffff,US
 2605:d300::,2605:d300:ffff:ffff:ffff:ffff:ffff:ffff,US
-2605:d380::,2605:d380:ffff:ffff:ffff:ffff:ffff:ffff,US
+2605:d380::,2605:d380:fff:ffff:ffff:ffff:ffff:ffff,US
 2605:d400::,2605:d400:ffff:ffff:ffff:ffff:ffff:ffff,US
 2605:d480::,2605:d480:ffff:ffff:ffff:ffff:ffff:ffff,US
 2605:d500::,2605:d500:ffff:ffff:ffff:ffff:ffff:ffff,CA
@@ -8388,7 +9786,6 @@
 2605:e680::,2605:e680:ffff:ffff:ffff:ffff:ffff:ffff,CA
 2605:e700::,2605:e700:ffff:ffff:ffff:ffff:ffff:ffff,US
 2605:e780::,2605:e780:ffff:ffff:ffff:ffff:ffff:ffff,US
-2605:e800::,2605:e800:ffff:ffff:ffff:ffff:ffff:ffff,US
 2605:e880::,2605:e880:ffff:ffff:ffff:ffff:ffff:ffff,US
 2605:e900::,2605:e900:ffff:ffff:ffff:ffff:ffff:ffff,US
 2605:e980::,2605:e980:ffff:ffff:ffff:ffff:ffff:ffff,US
@@ -8428,6 +9825,7 @@
 2605:fa80::,2605:fa80:fff:ffff:ffff:ffff:ffff:ffff,US
 2605:fb00::,2605:fb00:ffff:ffff:ffff:ffff:ffff:ffff,US
 2605:fb80::,2605:fb80:ffff:ffff:ffff:ffff:ffff:ffff,US
+2605:fc00:1::,2605:fc00:1:7fff:ffff:ffff:ffff:ffff,US
 2605:fc80::,2605:fc80:ffff:ffff:ffff:ffff:ffff:ffff,US
 2605:fd00::,2605:fd00:ffff:ffff:ffff:ffff:ffff:ffff,CA
 2605:fd80::,2605:fd80:ffff:ffff:ffff:ffff:ffff:ffff,US
@@ -8471,7 +9869,6 @@
 2606:1100::,2606:1100:ffff:ffff:ffff:ffff:ffff:ffff,US
 2606:1180::,2606:1180:ffff:ffff:ffff:ffff:ffff:ffff,US
 2606:1200::,2606:1200:ffff:ffff:ffff:ffff:ffff:ffff,US
-2606:1280::,2606:1280:ffff:ffff:ffff:ffff:ffff:ffff,US
 2606:1300::,2606:1300:ffff:ffff:ffff:ffff:ffff:ffff,US
 2606:1380::,2606:1380:ffff:ffff:ffff:ffff:ffff:ffff,US
 2606:1400::,2606:1400:ffff:ffff:ffff:ffff:ffff:ffff,US
@@ -8513,7 +9910,51 @@
 2606:2680::,2606:2680:ffff:ffff:ffff:ffff:ffff:ffff,US
 2606:2700::,2606:2700:ffff:ffff:ffff:ffff:ffff:ffff,CA
 2606:2780::,2606:2780:ffff:ffff:ffff:ffff:ffff:ffff,US
-2606:2800::,2606:2800:ffff:ffff:ffff:ffff:ffff:ffff,US
+2606:2800::,2606:2800:420a:ffff:ffff:ffff:ffff:ffff,US
+2606:2800:420b::,2606:2800:420b:ffff:ffff:ffff:ffff:ffff,BR
+2606:2800:420c::,2606:2800:420c:ffff:ffff:ffff:ffff:ffff,US
+2606:2800:420d::,2606:2800:420d:ffff:ffff:ffff:ffff:ffff,EC
+2606:2800:420e::,2606:2800:5000:ffff:ffff:ffff:ffff:ffff,US
+2606:2800:5001::,2606:2800:5001:ffff:ffff:ffff:ffff:ffff,ES
+2606:2800:5002::,2606:2800:500f:ffff:ffff:ffff:ffff:ffff,US
+2606:2800:5010::,2606:2800:5011:ffff:ffff:ffff:ffff:ffff,GB
+2606:2800:5012::,2606:2800:501f:ffff:ffff:ffff:ffff:ffff,US
+2606:2800:5020::,2606:2800:5021:ffff:ffff:ffff:ffff:ffff,DE
+2606:2800:5022::,2606:2800:5030:ffff:ffff:ffff:ffff:ffff,US
+2606:2800:5031::,2606:2800:5033:ffff:ffff:ffff:ffff:ffff,FR
+2606:2800:5034::,2606:2800:503f:ffff:ffff:ffff:ffff:ffff,US
+2606:2800:5040::,2606:2800:5041:ffff:ffff:ffff:ffff:ffff,NL
+2606:2800:5042::,2606:2800:504f:ffff:ffff:ffff:ffff:ffff,US
+2606:2800:5050::,2606:2800:5051:ffff:ffff:ffff:ffff:ffff,AT
+2606:2800:5052::,2606:2800:505f:ffff:ffff:ffff:ffff:ffff,US
+2606:2800:5060::,2606:2800:5061:ffff:ffff:ffff:ffff:ffff,SE
+2606:2800:5062::,2606:2800:506f:ffff:ffff:ffff:ffff:ffff,US
+2606:2800:5070::,2606:2800:5071:ffff:ffff:ffff:ffff:ffff,DE
+2606:2800:5072::,2606:2800:507f:ffff:ffff:ffff:ffff:ffff,US
+2606:2800:5080::,2606:2800:5080:ffff:ffff:ffff:ffff:ffff,IT
+2606:2800:5081::,2606:2800:508f:ffff:ffff:ffff:ffff:ffff,US
+2606:2800:5090::,2606:2800:5090:ffff:ffff:ffff:ffff:ffff,PL
+2606:2800:5091::,2606:2800:5fff:ffff:ffff:ffff:ffff:ffff,US
+2606:2800:6000::,2606:2800:6001:ffff:ffff:ffff:ffff:ffff,SG
+2606:2800:6002::,2606:2800:600f:ffff:ffff:ffff:ffff:ffff,US
+2606:2800:6010::,2606:2800:6011:ffff:ffff:ffff:ffff:ffff,HK
+2606:2800:6012::,2606:2800:601f:ffff:ffff:ffff:ffff:ffff,US
+2606:2800:6020::,2606:2800:6023:ffff:ffff:ffff:ffff:ffff,JP
+2606:2800:6024::,2606:2800:6027:ffff:ffff:ffff:ffff:ffff,US
+2606:2800:6028::,2606:2800:6029:ffff:ffff:ffff:ffff:ffff,JP
+2606:2800:602a::,2606:2800:602a:ffff:ffff:ffff:ffff:ffff,US
+2606:2800:602b::,2606:2800:602b:ffff:ffff:ffff:ffff:ffff,JP
+2606:2800:602c::,2606:2800:602f:ffff:ffff:ffff:ffff:ffff,US
+2606:2800:6030::,2606:2800:6031:ffff:ffff:ffff:ffff:ffff,AU
+2606:2800:6032::,2606:2800:6032:ffff:ffff:ffff:ffff:ffff,US
+2606:2800:6033::,2606:2800:6033:ffff:ffff:ffff:ffff:ffff,AU
+2606:2800:6034::,2606:2800:603f:ffff:ffff:ffff:ffff:ffff,US
+2606:2800:6040::,2606:2800:6041:ffff:ffff:ffff:ffff:ffff,HK
+2606:2800:6042::,2606:2800:60ef:ffff:ffff:ffff:ffff:ffff,US
+2606:2800:60f0::,2606:2800:60f3:ffff:ffff:ffff:ffff:ffff,IN
+2606:2800:60f4::,2606:2800:7000:ffff:ffff:ffff:ffff:ffff,US
+2606:2800:7001::,2606:2800:7001:ffff:ffff:ffff:ffff:ffff,CO
+2606:2800:7002::,2606:2800:ffff:ffff:ffff:ffff:ffff:ffff,US
 2606:2880::,2606:2880:ffff:ffff:ffff:ffff:ffff:ffff,US
 2606:2900::,2606:2900:ffff:ffff:ffff:ffff:ffff:ffff,US
 2606:2980::,2606:2980:ffff:ffff:ffff:ffff:ffff:ffff,US
@@ -8525,7 +9966,11 @@
 2606:2c80::,2606:2c80:ffff:ffff:ffff:ffff:ffff:ffff,US
 2606:2d00::,2606:2d00:fff:ffff:ffff:ffff:ffff:ffff,US
 2606:2d80::,2606:2d80:ffff:ffff:ffff:ffff:ffff:ffff,US
-2606:2e00::,2606:2e00:ffff:ffff:ffff:ffff:ffff:ffff,US
+2606:2e00::,2606:2e00:8001:ffff:ffff:ffff:ffff:ffff,US
+2606:2e00:8002::,2606:2e00:8002:7fff:ffff:ffff:ffff:ffff,JP
+2606:2e00:8002:8000::,2606:2e00:800a:2:ffff:ffff:ffff:ffff,US
+2606:2e00:800a:3::,2606:2e00:800a:3:ffff:ffff:ffff:ffff,HK
+2606:2e00:800a:4::,2606:2e00:ffff:ffff:ffff:ffff:ffff:ffff,US
 2606:2e80::,2606:2e80:ffff:ffff:ffff:ffff:ffff:ffff,US
 2606:2f00::,2606:2f00:ffff:ffff:ffff:ffff:ffff:ffff,US
 2606:2f80::,2606:2f80:ffff:ffff:ffff:ffff:ffff:ffff,CA
@@ -8575,7 +10020,9 @@
 2606:4580::,2606:4580:ffff:ffff:ffff:ffff:ffff:ffff,CA
 2606:4600::,2606:4600:ffff:ffff:ffff:ffff:ffff:ffff,US
 2606:4680::,2606:4680:ffff:ffff:ffff:ffff:ffff:ffff,US
-2606:4700::,2606:4700:ffff:ffff:ffff:ffff:ffff:ffff,US
+2606:4700::,2606:4700:1000:7fff:ffff:ffff:ffff:ffff,US
+2606:4700:1000:8000::,2606:4700:1000:ffff:ffff:ffff:ffff:ffff,DE
+2606:4700:1001::,2606:4700:ffff:ffff:ffff:ffff:ffff:ffff,US
 2606:4780::,2606:4780:ffff:ffff:ffff:ffff:ffff:ffff,US
 2606:4800::,2606:4800:ffff:ffff:ffff:ffff:ffff:ffff,US
 2606:4880::,2606:4880:ffff:ffff:ffff:ffff:ffff:ffff,US
@@ -8694,7 +10141,6 @@
 2606:8100::,2606:8100:ffff:ffff:ffff:ffff:ffff:ffff,US
 2606:8180::,2606:8180:ffff:ffff:ffff:ffff:ffff:ffff,US
 2606:8200::,2606:8200:ffff:ffff:ffff:ffff:ffff:ffff,US
-2606:8280::,2606:8280:ffff:ffff:ffff:ffff:ffff:ffff,US
 2606:8300::,2606:830f:ffff:ffff:ffff:ffff:ffff:ffff,CA
 2606:8380::,2606:8380:ffff:ffff:ffff:ffff:ffff:ffff,US
 2606:8400::,2606:8400:ffff:ffff:ffff:ffff:ffff:ffff,US
@@ -8728,99 +10174,195 @@
 2606:9200::,2606:9200:ffff:ffff:ffff:ffff:ffff:ffff,US
 2606:9280::,2606:9280:ffff:ffff:ffff:ffff:ffff:ffff,US
 2606:9300::,2606:9300:ffff:ffff:ffff:ffff:ffff:ffff,US
+2606:9380::,2606:9380:ffff:ffff:ffff:ffff:ffff:ffff,US
 2606:9400::,2606:9400:ffff:ffff:ffff:ffff:ffff:ffff,US
+2606:9480::,2606:9480:ffff:ffff:ffff:ffff:ffff:ffff,US
 2606:9500::,2606:9500:ffff:ffff:ffff:ffff:ffff:ffff,US
+2606:9580::,2606:9580:ffff:ffff:ffff:ffff:ffff:ffff,CA
 2606:9600::,2606:9600:ffff:ffff:ffff:ffff:ffff:ffff,US
+2606:9680::,2606:9680:ffff:ffff:ffff:ffff:ffff:ffff,US
 2606:9700::,2606:9700:ffff:ffff:ffff:ffff:ffff:ffff,US
+2606:9780::,2606:9780:ffff:ffff:ffff:ffff:ffff:ffff,US
 2606:9800::,2606:9800:ffff:ffff:ffff:ffff:ffff:ffff,US
+2606:9880::,2606:9880:ffff:ffff:ffff:ffff:ffff:ffff,US
 2606:9900::,2606:9900:ffff:ffff:ffff:ffff:ffff:ffff,US
+2606:9980::,2606:9980:ffff:ffff:ffff:ffff:ffff:ffff,US
 2606:9a00::,2606:9a00:ffff:ffff:ffff:ffff:ffff:ffff,US
+2606:9a80::,2606:9a80:ffff:ffff:ffff:ffff:ffff:ffff,US
 2606:9b00::,2606:9b00:ffff:ffff:ffff:ffff:ffff:ffff,US
+2606:9b80::,2606:9b80:ffff:ffff:ffff:ffff:ffff:ffff,US
 2606:9c00::,2606:9c00:ffff:ffff:ffff:ffff:ffff:ffff,US
+2606:9c80::,2606:9c80:ffff:ffff:ffff:ffff:ffff:ffff,US
 2606:9d00::,2606:9d00:ffff:ffff:ffff:ffff:ffff:ffff,US
+2606:9d80::,2606:9d80:ffff:ffff:ffff:ffff:ffff:ffff,US
 2606:9e00::,2606:9e00:ffff:ffff:ffff:ffff:ffff:ffff,BM
+2606:9e80::,2606:9e80:ffff:ffff:ffff:ffff:ffff:ffff,US
 2606:9f00::,2606:9f00:ffff:ffff:ffff:ffff:ffff:ffff,US
+2606:9f80::,2606:9f80:ffff:ffff:ffff:ffff:ffff:ffff,US
 2606:a000::,2606:a000:ffff:ffff:ffff:ffff:ffff:ffff,US
+2606:a080::,2606:a080:ffff:ffff:ffff:ffff:ffff:ffff,US
 2606:a100::,2606:a100:ffff:ffff:ffff:ffff:ffff:ffff,US
+2606:a180::,2606:a180:ffff:ffff:ffff:ffff:ffff:ffff,US
 2606:a200::,2606:a200:ffff:ffff:ffff:ffff:ffff:ffff,US
+2606:a280::,2606:a280:ffff:ffff:ffff:ffff:ffff:ffff,US
 2606:a300::,2606:a300:ffff:ffff:ffff:ffff:ffff:ffff,US
+2606:a380::,2606:a380:ffff:ffff:ffff:ffff:ffff:ffff,US
 2606:a400::,2606:a400:ffff:ffff:ffff:ffff:ffff:ffff,US
+2606:a480::,2606:a480:ffff:ffff:ffff:ffff:ffff:ffff,US
 2606:a500::,2606:a500:ffff:ffff:ffff:ffff:ffff:ffff,US
+2606:a580::,2606:a580:ffff:ffff:ffff:ffff:ffff:ffff,US
 2606:a600::,2606:a600:ffff:ffff:ffff:ffff:ffff:ffff,US
+2606:a680::,2606:a680:ffff:ffff:ffff:ffff:ffff:ffff,US
 2606:a700::,2606:a700:ffff:ffff:ffff:ffff:ffff:ffff,US
+2606:a780::,2606:a780:ffff:ffff:ffff:ffff:ffff:ffff,US
 2606:a800::,2606:a800:ffff:ffff:ffff:ffff:ffff:ffff,US
+2606:a880::,2606:a880:ffff:ffff:ffff:ffff:ffff:ffff,US
 2606:a900::,2606:a900:ffff:ffff:ffff:ffff:ffff:ffff,US
+2606:a980::,2606:a980:ffff:ffff:ffff:ffff:ffff:ffff,US
 2606:aa00::,2606:aa00:ffff:ffff:ffff:ffff:ffff:ffff,US
+2606:aa80::,2606:aa80:ffff:ffff:ffff:ffff:ffff:ffff,US
 2606:ab00::,2606:ab00:ffff:ffff:ffff:ffff:ffff:ffff,US
+2606:ab80::,2606:ab80:ffff:ffff:ffff:ffff:ffff:ffff,US
 2606:ac00::,2606:ac00:ffff:ffff:ffff:ffff:ffff:ffff,US
+2606:ac80::,2606:ac80:ffff:ffff:ffff:ffff:ffff:ffff,US
 2606:ad00::,2606:ad00:ffff:ffff:ffff:ffff:ffff:ffff,US
+2606:ad80::,2606:ad80:ffff:ffff:ffff:ffff:ffff:ffff,US
 2606:ae00::,2606:ae00:ffff:ffff:ffff:ffff:ffff:ffff,US
+2606:ae80::,2606:ae80:ffff:ffff:ffff:ffff:ffff:ffff,US
 2606:af00::,2606:af00:ffff:ffff:ffff:ffff:ffff:ffff,CA
+2606:af80::,2606:af80:ffff:ffff:ffff:ffff:ffff:ffff,US
 2606:b000::,2606:b000:ffff:ffff:ffff:ffff:ffff:ffff,US
+2606:b080::,2606:b080:ffff:ffff:ffff:ffff:ffff:ffff,US
 2606:b100::,2606:b100:ffff:ffff:ffff:ffff:ffff:ffff,US
+2606:b180::,2606:b180:ffff:ffff:ffff:ffff:ffff:ffff,US
 2606:b200::,2606:b200:ffff:ffff:ffff:ffff:ffff:ffff,KY
+2606:b280::,2606:b280:ffff:ffff:ffff:ffff:ffff:ffff,US
 2606:b300::,2606:b300:ffff:ffff:ffff:ffff:ffff:ffff,US
+2606:b380::,2606:b380:ffff:ffff:ffff:ffff:ffff:ffff,US
 2606:b400::,2606:b400:ffff:ffff:ffff:ffff:ffff:ffff,US
+2606:b480::,2606:b480:ffff:ffff:ffff:ffff:ffff:ffff,US
 2606:b500::,2606:b500:ffff:ffff:ffff:ffff:ffff:ffff,US
+2606:b580::,2606:b580:ffff:ffff:ffff:ffff:ffff:ffff,US
 2606:b600::,2606:b600:fff:ffff:ffff:ffff:ffff:ffff,US
+2606:b680::,2606:b680:ffff:ffff:ffff:ffff:ffff:ffff,US
 2606:b700::,2606:b700:ffff:ffff:ffff:ffff:ffff:ffff,US
+2606:b780::,2606:b780:ffff:ffff:ffff:ffff:ffff:ffff,US
 2606:b800::,2606:b800:ffff:ffff:ffff:ffff:ffff:ffff,CA
+2606:b880::,2606:b880:ffff:ffff:ffff:ffff:ffff:ffff,US
 2606:b900::,2606:b900:ffff:ffff:ffff:ffff:ffff:ffff,US
+2606:b980::,2606:b980:ffff:ffff:ffff:ffff:ffff:ffff,US
 2606:ba00::,2606:ba00:ffff:ffff:ffff:ffff:ffff:ffff,US
+2606:ba80::,2606:ba80:ffff:ffff:ffff:ffff:ffff:ffff,US
 2606:bb00::,2606:bb00:ffff:ffff:ffff:ffff:ffff:ffff,US
+2606:bb80::,2606:bb80:ffff:ffff:ffff:ffff:ffff:ffff,US
 2606:bc00::,2606:bc00:ffff:ffff:ffff:ffff:ffff:ffff,US
+2606:bc80::,2606:bc80:ffff:ffff:ffff:ffff:ffff:ffff,US
 2606:bd00::,2606:bd00:ffff:ffff:ffff:ffff:ffff:ffff,US
+2606:bd80::,2606:bd80:ffff:ffff:ffff:ffff:ffff:ffff,CA
 2606:be00::,2606:be00:ffff:ffff:ffff:ffff:ffff:ffff,US
+2606:be80::,2606:be80:ffff:ffff:ffff:ffff:ffff:ffff,CA
 2606:bf00::,2606:bf00:ffff:ffff:ffff:ffff:ffff:ffff,US
+2606:bf80::,2606:bf80:ffff:ffff:ffff:ffff:ffff:ffff,US
 2606:c000::,2606:c000:ffff:ffff:ffff:ffff:ffff:ffff,US
+2606:c080::,2606:c080:ffff:ffff:ffff:ffff:ffff:ffff,US
 2606:c100::,2606:c100:ffff:ffff:ffff:ffff:ffff:ffff,US
+2606:c180::,2606:c180:ffff:ffff:ffff:ffff:ffff:ffff,US
+2606:c280::,2606:c280:ffff:ffff:ffff:ffff:ffff:ffff,US
 2606:c300::,2606:c300:ffff:ffff:ffff:ffff:ffff:ffff,US
+2606:c380::,2606:c380:ffff:ffff:ffff:ffff:ffff:ffff,US
 2606:c400::,2606:c400:ffff:ffff:ffff:ffff:ffff:ffff,US
+2606:c480::,2606:c480:ffff:ffff:ffff:ffff:ffff:ffff,US
 2606:c500::,2606:c500:ffff:ffff:ffff:ffff:ffff:ffff,JM
+2606:c580::,2606:c580:ffff:ffff:ffff:ffff:ffff:ffff,US
+2606:c680::,2606:c680:ffff:ffff:ffff:ffff:ffff:ffff,US
 2606:c700::,2606:c700:ffff:ffff:ffff:ffff:ffff:ffff,US
+2606:c780::,2606:c780:ffff:ffff:ffff:ffff:ffff:ffff,US
 2606:c800::,2606:c800:ffff:ffff:ffff:ffff:ffff:ffff,US
+2606:c880::,2606:c880:ffff:ffff:ffff:ffff:ffff:ffff,CA
 2606:c900::,2606:c900:ffff:ffff:ffff:ffff:ffff:ffff,US
+2606:c980::,2606:c980:ffff:ffff:ffff:ffff:ffff:ffff,US
 2606:ca00::,2606:ca00:ffff:ffff:ffff:ffff:ffff:ffff,CA
+2606:ca80::,2606:ca80:ffff:ffff:ffff:ffff:ffff:ffff,US
 2606:cb00::,2606:cb00:ffff:ffff:ffff:ffff:ffff:ffff,US
+2606:cb80::,2606:cb80:ffff:ffff:ffff:ffff:ffff:ffff,US
 2606:cc00::,2606:cc00:ffff:ffff:ffff:ffff:ffff:ffff,US
+2606:cc80::,2606:cc80:ffff:ffff:ffff:ffff:ffff:ffff,US
 2606:cd00::,2606:cd00:ffff:ffff:ffff:ffff:ffff:ffff,US
+2606:cd80::,2606:cd80:ffff:ffff:ffff:ffff:ffff:ffff,US
 2606:ce00::,2606:ce00:ffff:ffff:ffff:ffff:ffff:ffff,US
+2606:ce80::,2606:ce80:ffff:ffff:ffff:ffff:ffff:ffff,US
 2606:cf00::,2606:cf00:ffff:ffff:ffff:ffff:ffff:ffff,US
+2606:cf80::,2606:cf80:ffff:ffff:ffff:ffff:ffff:ffff,US
 2606:d000::,2606:d000:ffff:ffff:ffff:ffff:ffff:ffff,US
+2606:d080::,2606:d080:ffff:ffff:ffff:ffff:ffff:ffff,US
 2606:d100::,2606:d100:ffff:ffff:ffff:ffff:ffff:ffff,US
+2606:d180::,2606:d180:ffff:ffff:ffff:ffff:ffff:ffff,CA
 2606:d200::,2606:d200:ffff:ffff:ffff:ffff:ffff:ffff,US
+2606:d280::,2606:d280:ffff:ffff:ffff:ffff:ffff:ffff,US
 2606:d300::,2606:d300:fff:ffff:ffff:ffff:ffff:ffff,US
+2606:d380::,2606:d380:ffff:ffff:ffff:ffff:ffff:ffff,US
 2606:d400::,2606:d400:ffff:ffff:ffff:ffff:ffff:ffff,US
+2606:d480::,2606:d480:ffff:ffff:ffff:ffff:ffff:ffff,US
 2606:d500::,2606:d500:ffff:ffff:ffff:ffff:ffff:ffff,US
+2606:d580::,2606:d580:ffff:ffff:ffff:ffff:ffff:ffff,US
 2606:d600::,2606:d600:ffff:ffff:ffff:ffff:ffff:ffff,US
+2606:d680::,2606:d680:ffff:ffff:ffff:ffff:ffff:ffff,CA
 2606:d700::,2606:d700:ffff:ffff:ffff:ffff:ffff:ffff,US
+2606:d780::,2606:d780:ffff:ffff:ffff:ffff:ffff:ffff,US
 2606:d800::,2606:d800:ffff:ffff:ffff:ffff:ffff:ffff,US
+2606:d880::,2606:d880:ffff:ffff:ffff:ffff:ffff:ffff,US
 2606:d900::,2606:d900:ffff:ffff:ffff:ffff:ffff:ffff,US
+2606:d980::,2606:d980:ffff:ffff:ffff:ffff:ffff:ffff,US
 2606:da00::,2606:da00:ffff:ffff:ffff:ffff:ffff:ffff,US
+2606:da80::,2606:da80:fff:ffff:ffff:ffff:ffff:ffff,US
 2606:db00::,2606:db00:ffff:ffff:ffff:ffff:ffff:ffff,US
+2606:db80::,2606:db80:ffff:ffff:ffff:ffff:ffff:ffff,US
 2606:dc00::,2606:dc00:ffff:ffff:ffff:ffff:ffff:ffff,US
+2606:dc80::,2606:dc80:ffff:ffff:ffff:ffff:ffff:ffff,US
 2606:dd00::,2606:dd00:fff:ffff:ffff:ffff:ffff:ffff,US
+2606:dd80::,2606:dd80:ffff:ffff:ffff:ffff:ffff:ffff,CA
 2606:de00::,2606:de00:ffff:ffff:ffff:ffff:ffff:ffff,CA
+2606:de80::,2606:de80:ffff:ffff:ffff:ffff:ffff:ffff,US
 2606:df00::,2606:df00:ffff:ffff:ffff:ffff:ffff:ffff,US
+2606:df80::,2606:df80:ffff:ffff:ffff:ffff:ffff:ffff,US
 2606:e000::,2606:e000:ffff:ffff:ffff:ffff:ffff:ffff,CA
+2606:e080::,2606:e080:ffff:ffff:ffff:ffff:ffff:ffff,US
 2606:e100::,2606:e100:ffff:ffff:ffff:ffff:ffff:ffff,US
+2606:e180::,2606:e180:ffff:ffff:ffff:ffff:ffff:ffff,US
 2606:e200::,2606:e200:ffff:ffff:ffff:ffff:ffff:ffff,US
+2606:e280::,2606:e280:ffff:ffff:ffff:ffff:ffff:ffff,US
 2606:e300::,2606:e300:ffff:ffff:ffff:ffff:ffff:ffff,US
+2606:e380::,2606:e380:ffff:ffff:ffff:ffff:ffff:ffff,CA
 2606:e400::,2606:e400:ffff:ffff:ffff:ffff:ffff:ffff,US
+2606:e480::,2606:e480:ffff:ffff:ffff:ffff:ffff:ffff,US
 2606:e500::,2606:e500:ffff:ffff:ffff:ffff:ffff:ffff,US
+2606:e580::,2606:e580:ffff:ffff:ffff:ffff:ffff:ffff,US
 2606:e600::,2606:e600:ffff:ffff:ffff:ffff:ffff:ffff,US
+2606:e680::,2606:e680:ffff:ffff:ffff:ffff:ffff:ffff,US
 2606:e700::,2606:e700:ffff:ffff:ffff:ffff:ffff:ffff,US
+2606:e780::,2606:e780:ffff:ffff:ffff:ffff:ffff:ffff,US
 2606:e800::,2606:e800:ffff:ffff:ffff:ffff:ffff:ffff,US
+2606:e880::,2606:e880:ffff:ffff:ffff:ffff:ffff:ffff,US
 2606:e900::,2606:e900:ffff:ffff:ffff:ffff:ffff:ffff,US
+2606:e980::,2606:e980:ffff:ffff:ffff:ffff:ffff:ffff,US
 2606:ea00::,2606:ea00:ffff:ffff:ffff:ffff:ffff:ffff,US
+2606:ea80::,2606:ea80:ffff:ffff:ffff:ffff:ffff:ffff,US
 2606:eb00::,2606:eb00:ffff:ffff:ffff:ffff:ffff:ffff,CA
+2606:eb80::,2606:eb80:ffff:ffff:ffff:ffff:ffff:ffff,US
 2606:ec00::,2606:ec00:ffff:ffff:ffff:ffff:ffff:ffff,US
+2606:ec80::,2606:ec80:ffff:ffff:ffff:ffff:ffff:ffff,CA
 2606:ed00::,2606:ed00:ffff:ffff:ffff:ffff:ffff:ffff,US
+2606:ed80::,2606:ed80:ffff:ffff:ffff:ffff:ffff:ffff,US
 2606:ee00::,2606:ee00:ffff:ffff:ffff:ffff:ffff:ffff,CA
+2606:ee80::,2606:ee80:ffff:ffff:ffff:ffff:ffff:ffff,US
 2606:ef00::,2606:ef00:ffff:ffff:ffff:ffff:ffff:ffff,US
+2606:ef80::,2606:ef80:ffff:ffff:ffff:ffff:ffff:ffff,US
 2606:f000::,2606:f000:ffff:ffff:ffff:ffff:ffff:ffff,US
+2606:f080::,2606:f080:ffff:ffff:ffff:ffff:ffff:ffff,CA
 2606:f100::,2606:f100:ffff:ffff:ffff:ffff:ffff:ffff,US
+2606:f180::,2606:f180:ffff:ffff:ffff:ffff:ffff:ffff,US
 2606:f200::,2606:f200:ffff:ffff:ffff:ffff:ffff:ffff,US
+2606:f280::,2606:f280:ffff:ffff:ffff:ffff:ffff:ffff,CA
 2606:f300::,2606:f300:ffff:ffff:ffff:ffff:ffff:ffff,US
 2606:f400::,2606:f40f:ffff:ffff:ffff:ffff:ffff:ffff,US
 2606:f500::,2606:f500:ffff:ffff:ffff:ffff:ffff:ffff,US
@@ -8918,7 +10460,7 @@
 2607:5200::,2607:5201:ffff:ffff:ffff:ffff:ffff:ffff,US
 2607:5300::,2607:5300:ffff:ffff:ffff:ffff:ffff:ffff,CA
 2607:5400::,2607:5400:ffff:ffff:ffff:ffff:ffff:ffff,US
-2607:5500::,2607:5500:ffff:ffff:ffff:ffff:ffff:ffff,US
+2607:5500::,2607:5501:ffff:ffff:ffff:ffff:ffff:ffff,US
 2607:5600::,2607:5600:ffff:ffff:ffff:ffff:ffff:ffff,US
 2607:5700::,2607:5700:ffff:ffff:ffff:ffff:ffff:ffff,US
 2607:5800::,2607:5800:ffff:ffff:ffff:ffff:ffff:ffff,US
@@ -8928,7 +10470,7 @@
 2607:5d00::,2607:5d00:ffff:ffff:ffff:ffff:ffff:ffff,US
 2607:5e00::,2607:5e00:ffff:ffff:ffff:ffff:ffff:ffff,CA
 2607:5f00::,2607:5f00:ffff:ffff:ffff:ffff:ffff:ffff,US
-2607:6000::,2607:6000:ffff:ffff:ffff:ffff:ffff:ffff,US
+2607:6000::,2607:600f:ffff:ffff:ffff:ffff:ffff:ffff,US
 2607:6100::,2607:6100:ffff:ffff:ffff:ffff:ffff:ffff,US
 2607:6200::,2607:6200:ffff:ffff:ffff:ffff:ffff:ffff,US
 2607:6300::,2607:6300:ffff:ffff:ffff:ffff:ffff:ffff,US
@@ -8982,7 +10524,6 @@
 2607:9000::,2607:9000:ffff:ffff:ffff:ffff:ffff:ffff,US
 2607:9100::,2607:9100:ffff:ffff:ffff:ffff:ffff:ffff,US
 2607:9200::,2607:9200:ffff:ffff:ffff:ffff:ffff:ffff,US
-2607:9300::,2607:9300:ffff:ffff:ffff:ffff:ffff:ffff,US
 2607:9400::,2607:9400:ffff:ffff:ffff:ffff:ffff:ffff,US
 2607:9500::,2607:9500:ffff:ffff:ffff:ffff:ffff:ffff,CA
 2607:9600::,2607:9600:ffff:ffff:ffff:ffff:ffff:ffff,US
@@ -9099,8 +10640,14 @@
 2607:f0b0::,2607:f0b0:ffff:ffff:ffff:ffff:ffff:ffff,CA
 2607:f0c0::,2607:f0c0:ffff:ffff:ffff:ffff:ffff:ffff,US
 2607:f0c8::,2607:f0c8:ffff:ffff:ffff:ffff:ffff:ffff,CA
-2607:f0d0::,2607:f0d1:ffff:ffff:ffff:ffff:ffff:ffff,US
-2607:f0d8::,2607:f0e0:ffff:ffff:ffff:ffff:ffff:ffff,US
+2607:f0d0::,2607:f0d0:1c00:ffff:ffff:ffff:ffff:ffff,US
+2607:f0d0:1c01::,2607:f0d0:1c01:7fff:ffff:ffff:ffff:ffff,MX
+2607:f0d0:1c01:8000::,2607:f0d0:3700:ffff:ffff:ffff:ffff:ffff,US
+2607:f0d0:3701::,2607:f0d0:3701:7fff:ffff:ffff:ffff:ffff,CA
+2607:f0d0:3701:8000::,2607:f0d1:ffff:ffff:ffff:ffff:ffff:ffff,US
+2607:f0d8::,2607:f0dc:5001:7fff:ffff:ffff:ffff:ffff,US
+2607:f0dc:5001:8000::,2607:f0dc:5001:ffff:ffff:ffff:ffff:ffff,TW
+2607:f0dc:5002::,2607:f0e0:ffff:ffff:ffff:ffff:ffff:ffff,US
 2607:f0e8::,2607:f0e8:ffff:ffff:ffff:ffff:ffff:ffff,US
 2607:f0f8::,2607:f0f8:ffff:ffff:ffff:ffff:ffff:ffff,US
 2607:f100::,2607:f100:ffff:ffff:ffff:ffff:ffff:ffff,US
@@ -9163,7 +10710,7 @@
 2607:f2e8::,2607:f2e8:ffff:ffff:ffff:ffff:ffff:ffff,US
 2607:f2f0::,2607:f2f0:ffff:ffff:ffff:ffff:ffff:ffff,US
 2607:f2f8::,2607:f2f8:ffff:ffff:ffff:ffff:ffff:ffff,US
-2607:f300::,2607:f300:ffff:ffff:ffff:ffff:ffff:ffff,US
+2607:f300::,2607:f300:fff:ffff:ffff:ffff:ffff:ffff,US
 2607:f308::,2607:f308:ffff:ffff:ffff:ffff:ffff:ffff,US
 2607:f310::,2607:f310:ffff:ffff:ffff:ffff:ffff:ffff,US
 2607:f318::,2607:f318:ffff:ffff:ffff:ffff:ffff:ffff,US
@@ -9289,7 +10836,9 @@
 2607:f720::,2607:f720:ffff:ffff:ffff:ffff:ffff:ffff,US
 2607:f728::,2607:f728:ffff:ffff:ffff:ffff:ffff:ffff,US
 2607:f738::,2607:f738:ffff:ffff:ffff:ffff:ffff:ffff,US
-2607:f740::,2607:f740:ffff:ffff:ffff:ffff:ffff:ffff,US
+2607:f740::,2607:f740:8f:ffff:ffff:ffff:ffff:ffff,US
+2607:f740:90::,2607:f740:90:7fff:ffff:ffff:ffff:ffff,HK
+2607:f740:90:8000::,2607:f740:ffff:ffff:ffff:ffff:ffff:ffff,US
 2607:f748::,2607:f748:ffff:ffff:ffff:ffff:ffff:ffff,CA
 2607:f750::,2607:f750:ffff:ffff:ffff:ffff:ffff:ffff,US
 2607:f758::,2607:f758:ffff:ffff:ffff:ffff:ffff:ffff,US
@@ -9642,7 +11191,6 @@
 2620:0:f0::,2620::f0:ffff:ffff:ffff:ffff:ffff,CA
 2620:0:100::,2620::100:ffff:ffff:ffff:ffff:ffff,US
 2620:0:110::,2620::110:ffff:ffff:ffff:ffff:ffff,US
-2620:0:120::,2620::120:ffff:ffff:ffff:ffff:ffff,US
 2620:0:140::,2620::140:ffff:ffff:ffff:ffff:ffff,US
 2620:0:150::,2620::150:ffff:ffff:ffff:ffff:ffff,US
 2620:0:160::,2620::160:ffff:ffff:ffff:ffff:ffff,CA
@@ -9661,7 +11209,6 @@
 2620:0:240::,2620::240:ffff:ffff:ffff:ffff:ffff,US
 2620:0:250::,2620::250:ffff:ffff:ffff:ffff:ffff,US
 2620:0:260::,2620::260:ffff:ffff:ffff:ffff:ffff,US
-2620:0:270::,2620::270:ffff:ffff:ffff:ffff:ffff,US
 2620:0:280::,2620::280:ffff:ffff:ffff:ffff:ffff,US
 2620:0:290::,2620::290:ffff:ffff:ffff:ffff:ffff,US
 2620:0:2b0::,2620::2b0:ffff:ffff:ffff:ffff:ffff,US
@@ -9778,33 +11325,80 @@
 2620:0:ee0::,2620::ee0:ffff:ffff:ffff:ffff:ffff,US
 2620:0:ef0::,2620::ef0:ffff:ffff:ffff:ffff:ffff,US
 2620:0:f00::,2620::f7f:ffff:ffff:ffff:ffff:ffff,US
-2620:0:1000::,2620::100c:ffff:ffff:ffff:ffff:ffff,US
-2620:0:100d::,2620::100d:ffff:ffff:ffff:ffff:ffff,CA
+2620:0:1000::,2620::100b:ffff:ffff:ffff:ffff:ffff,US
+2620:0:100c::,2620::100d:ffff:ffff:ffff:ffff:ffff,CA
 2620:0:100e::,2620::1010:ffff:ffff:ffff:ffff:ffff,US
 2620:0:1011::,2620::1011:7fff:ffff:ffff:ffff:ffff,AR
-2620:0:1011:8000::,2620::1024:ffff:ffff:ffff:ffff:ffff,US
+2620:0:1011:8000::,2620::1017:7fff:ffff:ffff:ffff:ffff,US
+2620:0:1017:8000::,2620::1017:ffff:ffff:ffff:ffff:ffff,CO
+2620:0:1018::,2620::1019:ffff:ffff:ffff:ffff:ffff,US
+2620:0:101a::,2620::101a:7fff:ffff:ffff:ffff:ffff,BR
+2620:0:101a:8000::,2620::101f:ffff:ffff:ffff:ffff:ffff,US
+2620:0:1020::,2620::1020:ffff:ffff:ffff:ffff:ffff,MX
+2620:0:1021::,2620::1024:ffff:ffff:ffff:ffff:ffff,US
 2620:0:1025::,2620::1025:7fff:ffff:ffff:ffff:ffff,BR
 2620:0:1025:8000::,2620::1034:ffff:ffff:ffff:ffff:ffff,US
-2620:0:1035::,2620::1035:7fff:ffff:ffff:ffff:ffff,CA
-2620:0:1035:8000::,2620::103f:ffff:ffff:ffff:ffff:ffff,US
+2620:0:1035::,2620::1035:ffff:ffff:ffff:ffff:ffff,CA
+2620:0:1036::,2620::103f:ffff:ffff:ffff:ffff:ffff,US
 2620:0:1040::,2620::1040:7fff:ffff:ffff:ffff:ffff,IE
 2620:0:1040:8000::,2620::1041:ffff:ffff:ffff:ffff:ffff,US
-2620:0:1042::,2620::1042:7fff:ffff:ffff:ffff:ffff,GB
-2620:0:1042:8000::,2620::1044:ffff:ffff:ffff:ffff:ffff,US
+2620:0:1042::,2620::1042:ffff:ffff:ffff:ffff:ffff,GB
+2620:0:1043::,2620::1043:7fff:ffff:ffff:ffff:ffff,SE
+2620:0:1043:8000::,2620::1044:ffff:ffff:ffff:ffff:ffff,US
 2620:0:1045::,2620::1045:7fff:ffff:ffff:ffff:ffff,IL
-2620:0:1045:8000::,2620::1048:ffff:ffff:ffff:ffff:ffff,US
+2620:0:1045:8000::,2620::1045:ffff:ffff:ffff:ffff:ffff,US
+2620:0:1046::,2620::1046:7fff:ffff:ffff:ffff:ffff,DE
+2620:0:1046:8000::,2620::1046:ffff:ffff:ffff:ffff:ffff,US
+2620:0:1047::,2620::1047:7fff:ffff:ffff:ffff:ffff,FR
+2620:0:1047:8000::,2620::1047:ffff:ffff:ffff:ffff:ffff,US
+2620:0:1048::,2620::1048:7fff:ffff:ffff:ffff:ffff,IL
+2620:0:1048:8000::,2620::1048:ffff:ffff:ffff:ffff:ffff,US
 2620:0:1049::,2620::1049:7fff:ffff:ffff:ffff:ffff,DE
-2620:0:1049:8000::,2620::104f:ffff:ffff:ffff:ffff:ffff,US
-2620:0:1050::,2620::1050:7fff:ffff:ffff:ffff:ffff,GB
-2620:0:1050:8000::,2620::1050:ffff:ffff:ffff:ffff:ffff,US
+2620:0:1049:8000::,2620::1049:ffff:ffff:ffff:ffff:ffff,US
+2620:0:104a::,2620::104a:7fff:ffff:ffff:ffff:ffff,AE
+2620:0:104a:8000::,2620::104a:ffff:ffff:ffff:ffff:ffff,US
+2620:0:104b::,2620::104b:7fff:ffff:ffff:ffff:ffff,NL
+2620:0:104b:8000::,2620::104b:ffff:ffff:ffff:ffff:ffff,US
+2620:0:104c::,2620::104c:7fff:ffff:ffff:ffff:ffff,CH
+2620:0:104c:8000::,2620::104f:ffff:ffff:ffff:ffff:ffff,US
+2620:0:1050::,2620::1050:ffff:ffff:ffff:ffff:ffff,GB
 2620:0:1051::,2620::1051:7fff:ffff:ffff:ffff:ffff,ES
 2620:0:1051:8000::,2620::1051:ffff:ffff:ffff:ffff:ffff,US
 2620:0:1052::,2620::1052:7fff:ffff:ffff:ffff:ffff,IE
-2620:0:1052:8000::,2620::105e:ffff:ffff:ffff:ffff:ffff,US
+2620:0:1052:8000::,2620::1052:ffff:ffff:ffff:ffff:ffff,US
+2620:0:1053::,2620::1053:7fff:ffff:ffff:ffff:ffff,FR
+2620:0:1053:8000::,2620::1055:ffff:ffff:ffff:ffff:ffff,US
+2620:0:1056::,2620::1056:7fff:ffff:ffff:ffff:ffff,FR
+2620:0:1056:8000::,2620::1056:ffff:ffff:ffff:ffff:ffff,US
+2620:0:1057::,2620::1057:7fff:ffff:ffff:ffff:ffff,DE
+2620:0:1057:8000::,2620::1059:ffff:ffff:ffff:ffff:ffff,US
+2620:0:105a::,2620::105a:ffff:ffff:ffff:ffff:ffff,UG
+2620:0:105b::,2620::105e:ffff:ffff:ffff:ffff:ffff,US
 2620:0:105f::,2620::105f:ffff:ffff:ffff:ffff:ffff,CH
-2620:0:1060::,2620::1072:ffff:ffff:ffff:ffff:ffff,US
-2620:0:1073::,2620::1073:7fff:ffff:ffff:ffff:ffff,GB
-2620:0:1073:8000::,2620::10ff:ffff:ffff:ffff:ffff:ffff,US
+2620:0:1060::,2620::1060:ffff:ffff:ffff:ffff:ffff,US
+2620:0:1061::,2620::1061:7fff:ffff:ffff:ffff:ffff,CH
+2620:0:1061:8000::,2620::1068:ffff:ffff:ffff:ffff:ffff,US
+2620:0:1069::,2620::1069:7fff:ffff:ffff:ffff:ffff,PL
+2620:0:1069:8000::,2620::106a:ffff:ffff:ffff:ffff:ffff,US
+2620:0:106b::,2620::106b:7fff:ffff:ffff:ffff:ffff,RU
+2620:0:106b:8000::,2620::106d:ffff:ffff:ffff:ffff:ffff,US
+2620:0:106e::,2620::106e:7fff:ffff:ffff:ffff:ffff,ZA
+2620:0:106e:8000::,2620::1072:ffff:ffff:ffff:ffff:ffff,US
+2620:0:1073::,2620::1073:ffff:ffff:ffff:ffff:ffff,GB
+2620:0:1074::,2620::1074:7fff:ffff:ffff:ffff:ffff,IE
+2620:0:1074:8000::,2620::1076:ffff:ffff:ffff:ffff:ffff,US
+2620:0:1077::,2620::1077:7fff:ffff:ffff:ffff:ffff,DE
+2620:0:1077:8000::,2620::1078:ffff:ffff:ffff:ffff:ffff,US
+2620:0:1079::,2620::1079:7fff:ffff:ffff:ffff:ffff,DK
+2620:0:1079:8000::,2620::107a:7fff:ffff:ffff:ffff:ffff,US
+2620:0:107a:8000::,2620::107a:ffff:ffff:ffff:ffff:ffff,IE
+2620:0:107b::,2620::107b:ffff:ffff:ffff:ffff:ffff,US
+2620:0:107c::,2620::107c:7fff:ffff:ffff:ffff:ffff,GR
+2620:0:107c:8000::,2620::107e:ffff:ffff:ffff:ffff:ffff,US
+2620:0:107f::,2620::107f:7fff:ffff:ffff:ffff:ffff,BE
+2620:0:107f:8000::,2620::10e7:ffff:ffff:ffff:ffff:ffff,US
+2620:0:10e8::,2620::10e8:7fff:ffff:ffff:ffff:ffff,AR
+2620:0:10e8:8000::,2620::10ff:ffff:ffff:ffff:ffff:ffff,US
 2620:0:1400::,2620::143f:ffff:ffff:ffff:ffff:ffff,US
 2620:0:1500::,2620::157f:ffff:ffff:ffff:ffff:ffff,US
 2620:0:1600::,2620::167f:ffff:ffff:ffff:ffff:ffff,US
@@ -9851,15 +11445,13 @@
 2620:0:2860::,2620::2860:ffff:ffff:ffff:ffff:ffff,US
 2620:0:2870::,2620::2870:ffff:ffff:ffff:ffff:ffff,US
 2620:0:2880::,2620::2880:ffff:ffff:ffff:ffff:ffff,US
-2620:0:28a0::,2620::28a0:ffff:ffff:ffff:ffff:ffff,US
-2620:0:28b0::,2620::28b0:ffff:ffff:ffff:ffff:ffff,US
+2620:0:28a0::,2620::28b0:ffff:ffff:ffff:ffff:ffff,US
 2620:0:28d0::,2620::28d0:ffff:ffff:ffff:ffff:ffff,US
 2620:0:28f0::,2620::28f0:ffff:ffff:ffff:ffff:ffff,US
 2620:0:2900::,2620::290f:ffff:ffff:ffff:ffff:ffff,US
 2620:0:2a00::,2620::2a1f:ffff:ffff:ffff:ffff:ffff,US
 2620:0:2b00::,2620::2b00:ffff:ffff:ffff:ffff:ffff,US
-2620:0:2b10::,2620::2b10:ffff:ffff:ffff:ffff:ffff,US
-2620:0:2b20::,2620::2b20:ffff:ffff:ffff:ffff:ffff,US
+2620:0:2b10::,2620::2b20:ffff:ffff:ffff:ffff:ffff,US
 2620:0:2b30::,2620::2b40:ffff:ffff:ffff:ffff:ffff,US
 2620:0:2b50::,2620::2b50:ffff:ffff:ffff:ffff:ffff,US
 2620:0:2b60::,2620::2b60:ffff:ffff:ffff:ffff:ffff,US
@@ -10073,7 +11665,7 @@
 2620:2f:4000::,2620:2f:4000:ffff:ffff:ffff:ffff:ffff,US
 2620:2f:8000::,2620:2f:8000:ffff:ffff:ffff:ffff:ffff,US
 2620:2f:c000::,2620:2f:c000:ffff:ffff:ffff:ffff:ffff,US
-2620:30::,2620:30::ffff:ffff:ffff:ffff:ffff,US
+2620:30::,2620:30:f:ffff:ffff:ffff:ffff:ffff,US
 2620:30:4000::,2620:30:4000:ffff:ffff:ffff:ffff:ffff,US
 2620:30:8000::,2620:30:8000:ffff:ffff:ffff:ffff:ffff,US
 2620:30:c000::,2620:30:c00f:ffff:ffff:ffff:ffff:ffff,US
@@ -10093,7 +11685,6 @@
 2620:34:4000::,2620:34:4000:ffff:ffff:ffff:ffff:ffff,US
 2620:34:8000::,2620:34:8000:ffff:ffff:ffff:ffff:ffff,US
 2620:34:c000::,2620:34:c000:ffff:ffff:ffff:ffff:ffff,US
-2620:35::,2620:35::ffff:ffff:ffff:ffff:ffff,US
 2620:35:4000::,2620:35:400f:ffff:ffff:ffff:ffff:ffff,CA
 2620:35:8000::,2620:35:8000:ffff:ffff:ffff:ffff:ffff,CA
 2620:35:c000::,2620:35:c00f:ffff:ffff:ffff:ffff:ffff,US
@@ -10201,7 +11792,7 @@
 2620:51:c000::,2620:51:c000:ffff:ffff:ffff:ffff:ffff,US
 2620:52::,2620:52:3:ffff:ffff:ffff:ffff:ffff,US
 2620:52:4000::,2620:52:4000:ffff:ffff:ffff:ffff:ffff,US
-2620:52:8000::,2620:52:8000:ffff:ffff:ffff:ffff:ffff,US
+2620:52:8000::,2620:52:800f:ffff:ffff:ffff:ffff:ffff,US
 2620:52:c000::,2620:52:c000:ffff:ffff:ffff:ffff:ffff,US
 2620:53::,2620:53::ffff:ffff:ffff:ffff:ffff,US
 2620:53:4000::,2620:53:400f:ffff:ffff:ffff:ffff:ffff,US
@@ -10269,7 +11860,6 @@
 2620:63:c000::,2620:63:c000:ffff:ffff:ffff:ffff:ffff,US
 2620:64::,2620:64::ffff:ffff:ffff:ffff:ffff,US
 2620:64:4000::,2620:64:4000:ffff:ffff:ffff:ffff:ffff,US
-2620:64:8000::,2620:64:8000:ffff:ffff:ffff:ffff:ffff,TW
 2620:64:c000::,2620:64:c00f:ffff:ffff:ffff:ffff:ffff,US
 2620:65::,2620:65:ff:ffff:ffff:ffff:ffff:ffff,US
 2620:65:8000::,2620:65:800f:ffff:ffff:ffff:ffff:ffff,US
@@ -10364,7 +11954,6 @@
 2620:7e::,2620:7e:f:ffff:ffff:ffff:ffff:ffff,US
 2620:7e:60c0::,2620:7e:60c0:ffff:ffff:ffff:ffff:ffff,US
 2620:7e:c080::,2620:7e:c080:ffff:ffff:ffff:ffff:ffff,US
-2620:7f:2040::,2620:7f:2040:ffff:ffff:ffff:ffff:ffff,US
 2620:7f:8000::,2620:7f:8000:ffff:ffff:ffff:ffff:ffff,CA
 2620:7f:c000::,2620:7f:c000:ffff:ffff:ffff:ffff:ffff,US
 2620:80:4000::,2620:80:4000:ffff:ffff:ffff:ffff:ffff,US
@@ -10466,7 +12055,6 @@
 2620:98:8000::,2620:98:8000:ffff:ffff:ffff:ffff:ffff,US
 2620:98:c000::,2620:98:c000:ffff:ffff:ffff:ffff:ffff,US
 2620:99::,2620:99::ffff:ffff:ffff:ffff:ffff,US
-2620:99:4000::,2620:99:4000:ffff:ffff:ffff:ffff:ffff,CA
 2620:99:8000::,2620:99:8000:ffff:ffff:ffff:ffff:ffff,US
 2620:99:c000::,2620:99:c000:ffff:ffff:ffff:ffff:ffff,US
 2620:9a::,2620:9a::ffff:ffff:ffff:ffff:ffff,CA
@@ -10475,8 +12063,8 @@
 2620:9a:c000::,2620:9a:c000:ffff:ffff:ffff:ffff:ffff,US
 2620:9b::,2620:9b::ffff:ffff:ffff:ffff:ffff,US
 2620:9b:4000::,2620:9b:4000:ffff:ffff:ffff:ffff:ffff,US
-2620:9b:8000::,2620:9b:8000:ffff:ffff:ffff:ffff:ffff,US
-2620:9b:c000::,2620:9b:c000:ffff:ffff:ffff:ffff:ffff,US
+2620:9b:8000::,2620:9b:80ff:ffff:ffff:ffff:ffff:ffff,US
+2620:9b:c000::,2620:9b:c00f:ffff:ffff:ffff:ffff:ffff,US
 2620:9c::,2620:9c::ffff:ffff:ffff:ffff:ffff,US
 2620:9c:4000::,2620:9c:400f:ffff:ffff:ffff:ffff:ffff,US
 2620:9c:8000::,2620:9c:8000:ffff:ffff:ffff:ffff:ffff,US
@@ -10521,7 +12109,7 @@
 2620:a7::,2620:a7::ffff:ffff:ffff:ffff:ffff,US
 2620:a7:4000::,2620:a7:4000:ffff:ffff:ffff:ffff:ffff,US
 2620:a7:8000::,2620:a7:8000:ffff:ffff:ffff:ffff:ffff,US
-2620:a7:c000::,2620:a7:c000:ffff:ffff:ffff:ffff:ffff,US
+2620:a7:c000::,2620:a7:c00f:ffff:ffff:ffff:ffff:ffff,US
 2620:a8::,2620:a8::ffff:ffff:ffff:ffff:ffff,US
 2620:a8:4000::,2620:a8:4000:ffff:ffff:ffff:ffff:ffff,US
 2620:a8:8000::,2620:a8:8000:ffff:ffff:ffff:ffff:ffff,US
@@ -10543,7 +12131,7 @@
 2620:ac:c000::,2620:ac:c000:ffff:ffff:ffff:ffff:ffff,US
 2620:ad::,2620:ad::ffff:ffff:ffff:ffff:ffff,US
 2620:ad:4000::,2620:ad:4000:ffff:ffff:ffff:ffff:ffff,US
-2620:ad:8000::,2620:ad:8000:ffff:ffff:ffff:ffff:ffff,US
+2620:ad:8000::,2620:ad:80ff:ffff:ffff:ffff:ffff:ffff,US
 2620:ad:c000::,2620:ad:c000:ffff:ffff:ffff:ffff:ffff,CA
 2620:ae::,2620:ae::ffff:ffff:ffff:ffff:ffff,CA
 2620:ae:4000::,2620:ae:4000:ffff:ffff:ffff:ffff:ffff,US
@@ -10592,7 +12180,7 @@
 2620:b9:4000::,2620:b9:4000:ffff:ffff:ffff:ffff:ffff,US
 2620:b9:8000::,2620:b9:8000:ffff:ffff:ffff:ffff:ffff,US
 2620:b9:c000::,2620:b9:c000:ffff:ffff:ffff:ffff:ffff,US
-2620:ba::,2620:ba::ffff:ffff:ffff:ffff:ffff,US
+2620:ba::,2620:ba:ff:ffff:ffff:ffff:ffff:ffff,US
 2620:ba:4000::,2620:ba:4000:ffff:ffff:ffff:ffff:ffff,US
 2620:ba:8000::,2620:ba:8000:ffff:ffff:ffff:ffff:ffff,US
 2620:ba:c000::,2620:ba:c000:ffff:ffff:ffff:ffff:ffff,US
@@ -10659,7 +12247,7 @@
 2620:ca:4000::,2620:ca:4000:ffff:ffff:ffff:ffff:ffff,US
 2620:ca:8000::,2620:ca:8000:ffff:ffff:ffff:ffff:ffff,US
 2620:ca:c000::,2620:ca:c000:ffff:ffff:ffff:ffff:ffff,US
-2620:cb::,2620:cb::ffff:ffff:ffff:ffff:ffff,US
+2620:cb::,2620:cb:f:ffff:ffff:ffff:ffff:ffff,US
 2620:cb:4000::,2620:cb:4000:ffff:ffff:ffff:ffff:ffff,US
 2620:cb:8000::,2620:cb:8000:ffff:ffff:ffff:ffff:ffff,CA
 2620:cb:c000::,2620:cb:c000:ffff:ffff:ffff:ffff:ffff,US
@@ -10697,7 +12285,7 @@
 2620:d4::,2620:d4::ffff:ffff:ffff:ffff:ffff,US
 2620:d4:4000::,2620:d4:4000:ffff:ffff:ffff:ffff:ffff,US
 2620:d4:8000::,2620:d4:8000:ffff:ffff:ffff:ffff:ffff,US
-2620:d4:c000::,2620:d4:c000:ffff:ffff:ffff:ffff:ffff,US
+2620:d4:c000::,2620:d4:c00f:ffff:ffff:ffff:ffff:ffff,US
 2620:d5::,2620:d5::ffff:ffff:ffff:ffff:ffff,US
 2620:d5:4000::,2620:d5:4000:ffff:ffff:ffff:ffff:ffff,US
 2620:d5:8000::,2620:d5:8000:ffff:ffff:ffff:ffff:ffff,US
@@ -10720,7 +12308,6 @@
 2620:d9:c000::,2620:d9:c000:ffff:ffff:ffff:ffff:ffff,US
 2620:da::,2620:da::ffff:ffff:ffff:ffff:ffff,US
 2620:da:4000::,2620:da:4000:ffff:ffff:ffff:ffff:ffff,US
-2620:da:8000::,2620:da:8000:ffff:ffff:ffff:ffff:ffff,US
 2620:da:c000::,2620:da:c000:ffff:ffff:ffff:ffff:ffff,US
 2620:db::,2620:db::ffff:ffff:ffff:ffff:ffff,US
 2620:db:4000::,2620:db:4000:ffff:ffff:ffff:ffff:ffff,CA
@@ -10736,53 +12323,101 @@
 2620:dd:8000::,2620:dd:8000:ffff:ffff:ffff:ffff:ffff,US
 2620:dd:c000::,2620:dd:c000:ffff:ffff:ffff:ffff:ffff,US
 2620:de::,2620:de::ffff:ffff:ffff:ffff:ffff,US
+2620:de:4000::,2620:de:4000:ffff:ffff:ffff:ffff:ffff,US
 2620:de:8000::,2620:de:8000:ffff:ffff:ffff:ffff:ffff,US
+2620:de:c000::,2620:de:c000:ffff:ffff:ffff:ffff:ffff,US
 2620:df::,2620:df::ffff:ffff:ffff:ffff:ffff,US
+2620:df:4000::,2620:df:400f:ffff:ffff:ffff:ffff:ffff,US
 2620:df:8000::,2620:df:8000:ffff:ffff:ffff:ffff:ffff,US
+2620:df:c000::,2620:df:c000:ffff:ffff:ffff:ffff:ffff,US
 2620:e0::,2620:e0::ffff:ffff:ffff:ffff:ffff,US
+2620:e0:4000::,2620:e0:4000:ffff:ffff:ffff:ffff:ffff,US
 2620:e0:8000::,2620:e0:8000:ffff:ffff:ffff:ffff:ffff,US
+2620:e0:c000::,2620:e0:c000:ffff:ffff:ffff:ffff:ffff,US
 2620:e1::,2620:e1::ffff:ffff:ffff:ffff:ffff,US
+2620:e1:4000::,2620:e1:4000:ffff:ffff:ffff:ffff:ffff,US
 2620:e1:8000::,2620:e1:8000:ffff:ffff:ffff:ffff:ffff,US
+2620:e1:c000::,2620:e1:c000:ffff:ffff:ffff:ffff:ffff,VG
 2620:e2::,2620:e2::ffff:ffff:ffff:ffff:ffff,US
+2620:e2:4000::,2620:e2:4000:ffff:ffff:ffff:ffff:ffff,US
 2620:e2:8000::,2620:e2:8000:ffff:ffff:ffff:ffff:ffff,US
+2620:e2:c000::,2620:e2:c000:ffff:ffff:ffff:ffff:ffff,US
 2620:e3::,2620:e3::ffff:ffff:ffff:ffff:ffff,US
+2620:e3:4000::,2620:e3:4000:ffff:ffff:ffff:ffff:ffff,US
 2620:e3:8000::,2620:e3:8000:ffff:ffff:ffff:ffff:ffff,US
+2620:e3:c000::,2620:e3:c000:ffff:ffff:ffff:ffff:ffff,US
 2620:e4::,2620:e4::ffff:ffff:ffff:ffff:ffff,US
+2620:e4:4000::,2620:e4:4000:ffff:ffff:ffff:ffff:ffff,US
 2620:e4:8000::,2620:e4:8000:ffff:ffff:ffff:ffff:ffff,US
+2620:e4:c000::,2620:e4:c000:ffff:ffff:ffff:ffff:ffff,US
 2620:e5::,2620:e5::ffff:ffff:ffff:ffff:ffff,US
+2620:e5:4000::,2620:e5:4000:ffff:ffff:ffff:ffff:ffff,US
 2620:e5:8000::,2620:e5:8000:ffff:ffff:ffff:ffff:ffff,US
+2620:e5:c000::,2620:e5:c000:ffff:ffff:ffff:ffff:ffff,US
 2620:e6::,2620:e6::ffff:ffff:ffff:ffff:ffff,US
+2620:e6:4000::,2620:e6:4000:ffff:ffff:ffff:ffff:ffff,US
 2620:e6:8000::,2620:e6:8000:ffff:ffff:ffff:ffff:ffff,US
+2620:e6:c000::,2620:e6:c000:ffff:ffff:ffff:ffff:ffff,US
 2620:e7::,2620:e7::ffff:ffff:ffff:ffff:ffff,US
+2620:e7:4000::,2620:e7:4000:ffff:ffff:ffff:ffff:ffff,US
 2620:e7:8000::,2620:e7:8000:ffff:ffff:ffff:ffff:ffff,CA
+2620:e7:c000::,2620:e7:c000:ffff:ffff:ffff:ffff:ffff,US
 2620:e8::,2620:e8::ffff:ffff:ffff:ffff:ffff,US
+2620:e8:4000::,2620:e8:4000:ffff:ffff:ffff:ffff:ffff,US
 2620:e8:8000::,2620:e8:8000:ffff:ffff:ffff:ffff:ffff,US
+2620:e8:c000::,2620:e8:c000:ffff:ffff:ffff:ffff:ffff,US
 2620:e9::,2620:e9::ffff:ffff:ffff:ffff:ffff,US
+2620:e9:4000::,2620:e9:4000:ffff:ffff:ffff:ffff:ffff,US
 2620:e9:8000::,2620:e9:8000:ffff:ffff:ffff:ffff:ffff,US
+2620:e9:c000::,2620:e9:c000:ffff:ffff:ffff:ffff:ffff,US
 2620:ea::,2620:ea:f:ffff:ffff:ffff:ffff:ffff,US
+2620:ea:4000::,2620:ea:4000:ffff:ffff:ffff:ffff:ffff,US
 2620:ea:8000::,2620:ea:8000:ffff:ffff:ffff:ffff:ffff,US
+2620:ea:c000::,2620:ea:c000:ffff:ffff:ffff:ffff:ffff,US
 2620:eb::,2620:eb::ffff:ffff:ffff:ffff:ffff,US
+2620:eb:4000::,2620:eb:4000:ffff:ffff:ffff:ffff:ffff,US
 2620:eb:8000::,2620:eb:8000:ffff:ffff:ffff:ffff:ffff,US
+2620:eb:c000::,2620:eb:c000:ffff:ffff:ffff:ffff:ffff,US
 2620:ec::,2620:ec::ffff:ffff:ffff:ffff:ffff,US
+2620:ec:4000::,2620:ec:4000:ffff:ffff:ffff:ffff:ffff,US
 2620:ec:8000::,2620:ec:8000:ffff:ffff:ffff:ffff:ffff,US
+2620:ec:c000::,2620:ec:c000:ffff:ffff:ffff:ffff:ffff,US
 2620:ed::,2620:ed::ffff:ffff:ffff:ffff:ffff,US
+2620:ed:4000::,2620:ed:4000:ffff:ffff:ffff:ffff:ffff,CA
 2620:ed:8000::,2620:ed:8000:ffff:ffff:ffff:ffff:ffff,US
+2620:ed:c000::,2620:ed:c000:ffff:ffff:ffff:ffff:ffff,US
 2620:ee::,2620:ee::ffff:ffff:ffff:ffff:ffff,US
+2620:ee:4000::,2620:ee:4000:ffff:ffff:ffff:ffff:ffff,US
 2620:ee:8000::,2620:ee:8000:ffff:ffff:ffff:ffff:ffff,US
+2620:ee:c000::,2620:ee:c000:ffff:ffff:ffff:ffff:ffff,US
 2620:ef::,2620:ef::ffff:ffff:ffff:ffff:ffff,US
+2620:ef:4000::,2620:ef:4000:ffff:ffff:ffff:ffff:ffff,US
 2620:ef:8000::,2620:ef:8000:ffff:ffff:ffff:ffff:ffff,US
+2620:ef:c000::,2620:ef:c000:ffff:ffff:ffff:ffff:ffff,US
 2620:f0::,2620:f0::ffff:ffff:ffff:ffff:ffff,US
+2620:f0:4000::,2620:f0:400f:ffff:ffff:ffff:ffff:ffff,US
 2620:f0:8000::,2620:f0:8000:ffff:ffff:ffff:ffff:ffff,US
+2620:f0:c000::,2620:f0:c00f:ffff:ffff:ffff:ffff:ffff,US
 2620:f1::,2620:f1::ffff:ffff:ffff:ffff:ffff,US
+2620:f1:4000::,2620:f1:4000:ffff:ffff:ffff:ffff:ffff,CA
 2620:f1:8000::,2620:f1:8000:ffff:ffff:ffff:ffff:ffff,US
+2620:f1:c000::,2620:f1:c000:ffff:ffff:ffff:ffff:ffff,US
 2620:f2::,2620:f2::ffff:ffff:ffff:ffff:ffff,CA
+2620:f2:4000::,2620:f2:4000:ffff:ffff:ffff:ffff:ffff,US
 2620:f2:8000::,2620:f2:8000:ffff:ffff:ffff:ffff:ffff,US
+2620:f2:c000::,2620:f2:c000:ffff:ffff:ffff:ffff:ffff,US
 2620:f3::,2620:f3::ffff:ffff:ffff:ffff:ffff,US
+2620:f3:4000::,2620:f3:4000:ffff:ffff:ffff:ffff:ffff,US
 2620:f3:8000::,2620:f3:8000:ffff:ffff:ffff:ffff:ffff,US
+2620:f3:c000::,2620:f3:c000:ffff:ffff:ffff:ffff:ffff,US
 2620:f4::,2620:f4::ffff:ffff:ffff:ffff:ffff,US
+2620:f4:4000::,2620:f4:40ff:ffff:ffff:ffff:ffff:ffff,US
 2620:f4:8000::,2620:f4:8000:ffff:ffff:ffff:ffff:ffff,CA
+2620:f4:c000::,2620:f4:c000:ffff:ffff:ffff:ffff:ffff,US
 2620:f5::,2620:f5::ffff:ffff:ffff:ffff:ffff,US
+2620:f5:4000::,2620:f5:4000:ffff:ffff:ffff:ffff:ffff,US
 2620:f5:8000::,2620:f5:8000:ffff:ffff:ffff:ffff:ffff,US
+2620:f5:c000::,2620:f5:c000:ffff:ffff:ffff:ffff:ffff,US
 2620:f6:8000::,2620:f6:8000:ffff:ffff:ffff:ffff:ffff,US
 2620:f7::,2620:f7::ffff:ffff:ffff:ffff:ffff,US
 2620:f7:8000::,2620:f7:8000:ffff:ffff:ffff:ffff:ffff,US
@@ -10964,7 +12599,9 @@
 2620:10a:3000::,2620:10a:30ff:ffff:ffff:ffff:ffff:ffff,US
 2620:10a:4000::,2620:10a:40ff:ffff:ffff:ffff:ffff:ffff,US
 2620:10a:5000::,2620:10a:50ff:ffff:ffff:ffff:ffff:ffff,US
-2620:10a:6000::,2620:10a:600f:ffff:ffff:ffff:ffff:ffff,US
+2620:10a:6000::,2620:10a:6000:3fff:ffff:ffff:ffff:ffff,US
+2620:10a:6000:4000::,2620:10a:6000:7fff:ffff:ffff:ffff:ffff,CA
+2620:10a:6000:8000::,2620:10a:600f:ffff:ffff:ffff:ffff:ffff,US
 2620:10a:8000::,2620:10a:80ff:ffff:ffff:ffff:ffff:ffff,CA
 2620:10a:9000::,2620:10a:90ff:ffff:ffff:ffff:ffff:ffff,US
 2620:10a:a000::,2620:10a:a0ff:ffff:ffff:ffff:ffff:ffff,US
@@ -11018,11 +12655,9 @@
 2620:10d:b000::,2620:10d:b00f:ffff:ffff:ffff:ffff:ffff,US
 2620:10d:c000::,2620:10d:c091:ffff:ffff:ffff:ffff:ffff,US
 2620:10d:c092::,2620:10d:c092:7fff:ffff:ffff:ffff:ffff,GB
-2620:10d:c092:8000::,2620:10d:c0c0:ffff:ffff:ffff:ffff:ffff,US
-2620:10d:c0c1::,2620:10d:c0c1:7fff:ffff:ffff:ffff:ffff,IE
-2620:10d:c0c1:8000::,2620:10d:c0e0:ffff:ffff:ffff:ffff:ffff,US
-2620:10d:c0e1::,2620:10d:c0e1:7fff:ffff:ffff:ffff:ffff,AU
-2620:10d:c0e1:8000::,2620:10d:c0ff:ffff:ffff:ffff:ffff:ffff,US
+2620:10d:c092:8000::,2620:10d:c0f0:ffff:ffff:ffff:ffff:ffff,US
+2620:10d:c0f1::,2620:10d:c0f1:7fff:ffff:ffff:ffff:ffff,KR
+2620:10d:c0f1:8000::,2620:10d:c0ff:ffff:ffff:ffff:ffff:ffff,US
 2620:10d:d000::,2620:10d:d00f:ffff:ffff:ffff:ffff:ffff,CA
 2620:10d:e000::,2620:10d:e00f:ffff:ffff:ffff:ffff:ffff,CA
 2620:10d:f000::,2620:10d:f00f:ffff:ffff:ffff:ffff:ffff,US
@@ -11069,7 +12704,6 @@
 2620:110:8000::,2620:110:80ff:ffff:ffff:ffff:ffff:ffff,US
 2620:110:9000::,2620:110:900f:ffff:ffff:ffff:ffff:ffff,US
 2620:110:a000::,2620:110:a00f:ffff:ffff:ffff:ffff:ffff,US
-2620:110:b000::,2620:110:b00f:ffff:ffff:ffff:ffff:ffff,US
 2620:110:d000::,2620:110:d00f:ffff:ffff:ffff:ffff:ffff,US
 2620:110:e000::,2620:110:e00f:ffff:ffff:ffff:ffff:ffff,US
 2620:110:f000::,2620:110:f00f:ffff:ffff:ffff:ffff:ffff,US
@@ -11111,7 +12745,9 @@
 2620:113:5000::,2620:113:500f:ffff:ffff:ffff:ffff:ffff,US
 2620:113:6000::,2620:113:600f:ffff:ffff:ffff:ffff:ffff,US
 2620:113:7000::,2620:113:700f:ffff:ffff:ffff:ffff:ffff,US
-2620:113:8000::,2620:113:80ff:ffff:ffff:ffff:ffff:ffff,US
+2620:113:8000::,2620:113:80bf:ffff:ffff:ffff:ffff:ffff,US
+2620:113:80c0::,2620:113:80c0:7fff:ffff:ffff:ffff:ffff,DE
+2620:113:80c0:8000::,2620:113:80ff:ffff:ffff:ffff:ffff:ffff,US
 2620:113:9000::,2620:113:900f:ffff:ffff:ffff:ffff:ffff,US
 2620:113:a000::,2620:113:a00f:ffff:ffff:ffff:ffff:ffff,US
 2620:113:b000::,2620:113:b00f:ffff:ffff:ffff:ffff:ffff,US
@@ -11145,6 +12781,7 @@
 2620:115:8000::,2620:115:800f:ffff:ffff:ffff:ffff:ffff,US
 2620:115:9000::,2620:115:900f:ffff:ffff:ffff:ffff:ffff,US
 2620:115:a000::,2620:115:a00f:ffff:ffff:ffff:ffff:ffff,US
+2620:115:a096::,2620:115:a096:7fff:ffff:ffff:ffff:ffff,US
 2620:115:b000::,2620:115:b00f:ffff:ffff:ffff:ffff:ffff,US
 2620:115:c000::,2620:115:c00f:ffff:ffff:ffff:ffff:ffff,US
 2620:115:d000::,2620:115:d0ff:ffff:ffff:ffff:ffff:ffff,US
@@ -11218,7 +12855,6 @@
 2620:119:f000::,2620:119:f00f:ffff:ffff:ffff:ffff:ffff,US
 2620:11a::,2620:11a:ff:ffff:ffff:ffff:ffff:ffff,US
 2620:11a:1000::,2620:11a:100f:ffff:ffff:ffff:ffff:ffff,CA
-2620:11a:2000::,2620:11a:20ff:ffff:ffff:ffff:ffff:ffff,US
 2620:11a:3000::,2620:11a:30ff:ffff:ffff:ffff:ffff:ffff,US
 2620:11a:4000::,2620:11a:40ff:ffff:ffff:ffff:ffff:ffff,US
 2620:11a:5000::,2620:11a:500f:ffff:ffff:ffff:ffff:ffff,US
@@ -11357,6 +12993,47 @@
 2620:122:a000::,2620:122:a0ff:ffff:ffff:ffff:ffff:ffff,BL
 2620:122:b000::,2620:122:b00f:ffff:ffff:ffff:ffff:ffff,US
 2620:122:c000::,2620:122:c0ff:ffff:ffff:ffff:ffff:ffff,US
+2620:122:d000::,2620:122:d0ff:ffff:ffff:ffff:ffff:ffff,US
+2620:122:e000::,2620:122:e00f:ffff:ffff:ffff:ffff:ffff,US
+2620:122:f000::,2620:122:f00f:ffff:ffff:ffff:ffff:ffff,US
+2620:123::,2620:123:f:ffff:ffff:ffff:ffff:ffff,US
+2620:123:1000::,2620:123:10ff:ffff:ffff:ffff:ffff:ffff,US
+2620:123:2000::,2620:123:200f:ffff:ffff:ffff:ffff:ffff,US
+2620:123:3000::,2620:123:30ff:ffff:ffff:ffff:ffff:ffff,US
+2620:123:4000::,2620:123:40ff:ffff:ffff:ffff:ffff:ffff,US
+2620:123:5000::,2620:123:50ff:ffff:ffff:ffff:ffff:ffff,US
+2620:123:6000::,2620:123:600f:ffff:ffff:ffff:ffff:ffff,CA
+2620:123:7000::,2620:123:700f:ffff:ffff:ffff:ffff:ffff,CA
+2620:123:8000::,2620:123:800f:ffff:ffff:ffff:ffff:ffff,US
+2620:123:9000::,2620:123:900f:ffff:ffff:ffff:ffff:ffff,US
+2620:123:a000::,2620:123:a00f:ffff:ffff:ffff:ffff:ffff,US
+2620:123:b000::,2620:123:b00f:ffff:ffff:ffff:ffff:ffff,US
+2620:123:c000::,2620:123:c0ff:ffff:ffff:ffff:ffff:ffff,US
+2620:123:d000::,2620:123:d0ff:ffff:ffff:ffff:ffff:ffff,US
+2620:123:e000::,2620:123:e0ff:ffff:ffff:ffff:ffff:ffff,US
+2620:123:f000::,2620:123:f00f:ffff:ffff:ffff:ffff:ffff,US
+2620:124::,2620:124:f:ffff:ffff:ffff:ffff:ffff,US
+2620:124:1000::,2620:124:100f:ffff:ffff:ffff:ffff:ffff,US
+2620:124:2000::,2620:124:200f:ffff:ffff:ffff:ffff:ffff,US
+2620:124:3000::,2620:124:30ff:ffff:ffff:ffff:ffff:ffff,US
+2620:124:4000::,2620:124:400f:ffff:ffff:ffff:ffff:ffff,US
+2620:124:5000::,2620:124:50ff:ffff:ffff:ffff:ffff:ffff,CA
+2620:124:6000::,2620:124:60ff:ffff:ffff:ffff:ffff:ffff,US
+2620:124:7000::,2620:124:700f:ffff:ffff:ffff:ffff:ffff,US
+2620:124:8000::,2620:124:800f:ffff:ffff:ffff:ffff:ffff,US
+2620:124:9000::,2620:124:900f:ffff:ffff:ffff:ffff:ffff,US
+2620:124:a000::,2620:124:a00f:ffff:ffff:ffff:ffff:ffff,US
+2620:124:b000::,2620:124:b0ff:ffff:ffff:ffff:ffff:ffff,CA
+2620:124:c000::,2620:124:c00f:ffff:ffff:ffff:ffff:ffff,US
+2620:124:d000::,2620:124:d0ff:ffff:ffff:ffff:ffff:ffff,US
+2620:124:e000::,2620:124:e0ff:ffff:ffff:ffff:ffff:ffff,US
+2620:124:f000::,2620:124:f00f:ffff:ffff:ffff:ffff:ffff,US
+2620:125::,2620:125:ff:ffff:ffff:ffff:ffff:ffff,US
+2620:125:1000::,2620:125:100f:ffff:ffff:ffff:ffff:ffff,US
+2620:125:2000::,2620:125:200f:ffff:ffff:ffff:ffff:ffff,US
+2620:125:3000::,2620:125:30ff:ffff:ffff:ffff:ffff:ffff,US
+2620:125:4000::,2620:125:400f:ffff:ffff:ffff:ffff:ffff,US
+2620:125:5000::,2620:125:500f:ffff:ffff:ffff:ffff:ffff,CA
 2620:140::,2620:140:3ff:ffff:ffff:ffff:ffff:ffff,US
 2620:141::,2620:141:fff:ffff:ffff:ffff:ffff:ffff,US
 2620:143::,2620:143:7ff:ffff:ffff:ffff:ffff:ffff,US
@@ -11383,9 +13060,12 @@
 2620:159::,2620:159:fff:ffff:ffff:ffff:ffff:ffff,US
 2620:15a::,2620:15a:fff:ffff:ffff:ffff:ffff:ffff,US
 2620:15b::,2620:15b:fff:ffff:ffff:ffff:ffff:ffff,US
-2620:15c::,2620:15c:4:ffff:ffff:ffff:ffff:ffff,US
+2620:15c::,2620:15c::7fff:ffff:ffff:ffff:ffff,CA
+2620:15c:0:8000::,2620:15c:4:ffff:ffff:ffff:ffff:ffff,US
 2620:15c:5::,2620:15c:5:ffff:ffff:ffff:ffff:ffff,BR
-2620:15c:6::,2620:15c:fff:ffff:ffff:ffff:ffff:ffff,US
+2620:15c:6::,2620:15c:d:ffff:ffff:ffff:ffff:ffff,US
+2620:15c:e::,2620:15c:e:7fff:ffff:ffff:ffff:ffff,MX
+2620:15c:e:8000::,2620:15c:fff:ffff:ffff:ffff:ffff:ffff,US
 2620:15d::,2620:15e:fff:ffff:ffff:ffff:ffff:ffff,US
 2620:15f::,2620:15f:fff:ffff:ffff:ffff:ffff:ffff,US
 2620:160::,2620:160:ffff:ffff:ffff:ffff:ffff:ffff,US
@@ -11419,6 +13099,7 @@
 2620:1c0::,2620:1c0:ffff:ffff:ffff:ffff:ffff:ffff,US
 2620:1d0::,2620:1d1:ffff:ffff:ffff:ffff:ffff:ffff,US
 2620:1d2::,2620:1d2:ffff:ffff:ffff:ffff:ffff:ffff,CA
+2620:1d3::,2620:1d5:fff:ffff:ffff:ffff:ffff:ffff,US
 2620:1e0::,2620:1e1:fff:ffff:ffff:ffff:ffff:ffff,US
 2620:1e2::,2620:1e2:fff:ffff:ffff:ffff:ffff:ffff,US
 2620:1e3::,2620:1e3:fff:ffff:ffff:ffff:ffff:ffff,US
@@ -11431,7 +13112,6 @@
 2620:1ea::,2620:1ea:fff:ffff:ffff:ffff:ffff:ffff,US
 2620:1eb::,2620:1eb:fff:ffff:ffff:ffff:ffff:ffff,US
 2620:1ec::,2620:1ec:fff:ffff:ffff:ffff:ffff:ffff,US
-2620:1ed::,2620:1ed:fff:ffff:ffff:ffff:ffff:ffff,CA
 2620:1ee::,2620:1ee:fff:ffff:ffff:ffff:ffff:ffff,US
 2620:1ef::,2620:1ef:fff:ffff:ffff:ffff:ffff:ffff,US
 2620:1f0::,2620:1f1:fff:ffff:ffff:ffff:ffff:ffff,US
@@ -11726,10 +13406,12 @@
 2801:10:4000::,2801:10:4000:ffff:ffff:ffff:ffff:ffff,AR
 2801:10:6000::,2801:10:6000:ffff:ffff:ffff:ffff:ffff,HN
 2801:10:8000::,2801:10:8000:ffff:ffff:ffff:ffff:ffff,AR
+2801:10:9000::,2801:10:9000:ffff:ffff:ffff:ffff:ffff,PY
 2801:10:a000::,2801:10:a000:ffff:ffff:ffff:ffff:ffff,AR
 2801:10:c000::,2801:10:c000:ffff:ffff:ffff:ffff:ffff,CO
 2801:10:e000::,2801:10:e000:ffff:ffff:ffff:ffff:ffff,AR
 2801:11::,2801:11::ffff:ffff:ffff:ffff:ffff,AR
+2801:11:1000::,2801:11:1000:ffff:ffff:ffff:ffff:ffff,PY
 2801:11:2000::,2801:11:2000:ffff:ffff:ffff:ffff:ffff,AR
 2801:11:4000::,2801:11:4000:ffff:ffff:ffff:ffff:ffff,CO
 2801:11:6000::,2801:11:6000:ffff:ffff:ffff:ffff:ffff,AR
@@ -11738,14 +13420,15 @@
 2801:11:c000::,2801:11:c000:ffff:ffff:ffff:ffff:ffff,AR
 2801:11:e000::,2801:11:e000:ffff:ffff:ffff:ffff:ffff,CO
 2801:12::,2801:12::ffff:ffff:ffff:ffff:ffff,PY
+2801:12:1000::,2801:12:1000:ffff:ffff:ffff:ffff:ffff,BO
 2801:12:2000::,2801:12:2000:ffff:ffff:ffff:ffff:ffff,HN
 2801:12:4000::,2801:12:4000:ffff:ffff:ffff:ffff:ffff,CO
 2801:12:6000::,2801:12:6000:ffff:ffff:ffff:ffff:ffff,SV
 2801:12:8000::,2801:12:8000:ffff:ffff:ffff:ffff:ffff,AR
-2801:12:a000::,2801:12:a00f:ffff:ffff:ffff:ffff:ffff,CL
 2801:12:c000::,2801:12:c000:ffff:ffff:ffff:ffff:ffff,AR
 2801:12:e000::,2801:12:e000:ffff:ffff:ffff:ffff:ffff,PA
 2801:13::,2801:13::ffff:ffff:ffff:ffff:ffff,VE
+2801:13:1000::,2801:13:1000:ffff:ffff:ffff:ffff:ffff,AR
 2801:13:2000::,2801:13:2000:ffff:ffff:ffff:ffff:ffff,AR
 2801:13:4000::,2801:13:4000:ffff:ffff:ffff:ffff:ffff,CL
 2801:13:6000::,2801:13:6000:ffff:ffff:ffff:ffff:ffff,GT
@@ -11763,6 +13446,7 @@
 2801:14:c000::,2801:14:c000:ffff:ffff:ffff:ffff:ffff,BO
 2801:14:e000::,2801:14:e000:ffff:ffff:ffff:ffff:ffff,PY
 2801:15::,2801:15::ffff:ffff:ffff:ffff:ffff,EC
+2801:15:1000::,2801:15:1000:ffff:ffff:ffff:ffff:ffff,SV
 2801:15:2000::,2801:15:2000:ffff:ffff:ffff:ffff:ffff,CR
 2801:15:4000::,2801:15:4000:ffff:ffff:ffff:ffff:ffff,CO
 2801:15:6000::,2801:15:6000:ffff:ffff:ffff:ffff:ffff,SV
@@ -11772,6 +13456,7 @@
 2801:15:e000::,2801:15:e000:ffff:ffff:ffff:ffff:ffff,DO
 2801:16::,2801:16::ffff:ffff:ffff:ffff:ffff,CW
 2801:16:e0::,2801:16:e0:ffff:ffff:ffff:ffff:ffff,GY
+2801:16:1000::,2801:16:1000:ffff:ffff:ffff:ffff:ffff,AR
 2801:16:2000::,2801:16:2000:ffff:ffff:ffff:ffff:ffff,HN
 2801:16:4000::,2801:16:4000:ffff:ffff:ffff:ffff:ffff,AR
 2801:16:6000::,2801:16:6000:ffff:ffff:ffff:ffff:ffff,AR
@@ -11779,6 +13464,7 @@
 2801:16:a000::,2801:16:a000:ffff:ffff:ffff:ffff:ffff,CR
 2801:16:c000::,2801:16:c000:ffff:ffff:ffff:ffff:ffff,AR
 2801:17::,2801:17::ffff:ffff:ffff:ffff:ffff,CL
+2801:17:1000::,2801:17:1000:ffff:ffff:ffff:ffff:ffff,HN
 2801:17:2000::,2801:17:2000:ffff:ffff:ffff:ffff:ffff,PY
 2801:17:4000::,2801:17:4000:ffff:ffff:ffff:ffff:ffff,CO
 2801:17:6000::,2801:17:6000:ffff:ffff:ffff:ffff:ffff,AR
@@ -11789,13 +13475,13 @@
 2801:18::,2801:18::ffff:ffff:ffff:ffff:ffff,CR
 2801:18:1000::,2801:18:1000:ffff:ffff:ffff:ffff:ffff,PA
 2801:18:2000::,2801:18:2000:ffff:ffff:ffff:ffff:ffff,CO
-2801:18:4000::,2801:18:4000:ffff:ffff:ffff:ffff:ffff,CO
 2801:18:6000::,2801:18:6000:ffff:ffff:ffff:ffff:ffff,AR
 2801:18:8000::,2801:18:8000:ffff:ffff:ffff:ffff:ffff,AR
 2801:18:a000::,2801:18:a000:ffff:ffff:ffff:ffff:ffff,BO
 2801:18:c000::,2801:18:c000:ffff:ffff:ffff:ffff:ffff,AR
 2801:18:e000::,2801:18:e000:ffff:ffff:ffff:ffff:ffff,DO
 2801:19::,2801:19::ffff:ffff:ffff:ffff:ffff,AR
+2801:19:1000::,2801:19:1000:ffff:ffff:ffff:ffff:ffff,PA
 2801:19:2000::,2801:19:2000:ffff:ffff:ffff:ffff:ffff,CL
 2801:19:4000::,2801:19:4000:ffff:ffff:ffff:ffff:ffff,PY
 2801:19:6000::,2801:19:6000:ffff:ffff:ffff:ffff:ffff,CW
@@ -11804,6 +13490,7 @@
 2801:19:c000::,2801:19:c000:ffff:ffff:ffff:ffff:ffff,AR
 2801:19:e000::,2801:19:e000:ffff:ffff:ffff:ffff:ffff,CO
 2801:1a::,2801:1a::ffff:ffff:ffff:ffff:ffff,CO
+2801:1a:1000::,2801:1a:1000:ffff:ffff:ffff:ffff:ffff,CL
 2801:1a:2000::,2801:1a:2000:ffff:ffff:ffff:ffff:ffff,SR
 2801:1a:4000::,2801:1a:4000:ffff:ffff:ffff:ffff:ffff,CO
 2801:1a:6000::,2801:1a:6000:ffff:ffff:ffff:ffff:ffff,CR
@@ -11812,6 +13499,7 @@
 2801:1a:c000::,2801:1a:c000:ffff:ffff:ffff:ffff:ffff,CO
 2801:1a:e000::,2801:1a:e000:ffff:ffff:ffff:ffff:ffff,DO
 2801:1b::,2801:1b::ffff:ffff:ffff:ffff:ffff,CR
+2801:1b:1000::,2801:1b:1000:ffff:ffff:ffff:ffff:ffff,CL
 2801:1b:2000::,2801:1b:2000:ffff:ffff:ffff:ffff:ffff,UY
 2801:1b:4000::,2801:1b:4000:ffff:ffff:ffff:ffff:ffff,CL
 2801:1b:6000::,2801:1b:6000:ffff:ffff:ffff:ffff:ffff,CL
@@ -11829,6 +13517,7 @@
 2801:1c:c000::,2801:1c:c000:ffff:ffff:ffff:ffff:ffff,HN
 2801:1c:e000::,2801:1c:e000:ffff:ffff:ffff:ffff:ffff,CO
 2801:1d::,2801:1d::ffff:ffff:ffff:ffff:ffff,PY
+2801:1d:1000::,2801:1d:1000:ffff:ffff:ffff:ffff:ffff,AR
 2801:1d:2000::,2801:1d:2000:ffff:ffff:ffff:ffff:ffff,GT
 2801:1d:4000::,2801:1d:4000:ffff:ffff:ffff:ffff:ffff,TT
 2801:1d:6000::,2801:1d:6000:ffff:ffff:ffff:ffff:ffff,NI
@@ -11837,6 +13526,7 @@
 2801:1d:c000::,2801:1d:c000:ffff:ffff:ffff:ffff:ffff,AR
 2801:1d:e000::,2801:1d:e000:ffff:ffff:ffff:ffff:ffff,CO
 2801:1e::,2801:1e::ffff:ffff:ffff:ffff:ffff,EC
+2801:1e:1000::,2801:1e:1000:ffff:ffff:ffff:ffff:ffff,AR
 2801:1e:2000::,2801:1e:2000:ffff:ffff:ffff:ffff:ffff,AR
 2801:1e:4000::,2801:1e:4007:ffff:ffff:ffff:ffff:ffff,AR
 2801:1e:6000::,2801:1e:6000:ffff:ffff:ffff:ffff:ffff,CO
@@ -11844,6 +13534,7 @@
 2801:1e:a000::,2801:1e:a000:ffff:ffff:ffff:ffff:ffff,AR
 2801:1e:e000::,2801:1e:e000:ffff:ffff:ffff:ffff:ffff,SV
 2801:1f::,2801:1f::ffff:ffff:ffff:ffff:ffff,AR
+2801:1f:1000::,2801:1f:1000:ffff:ffff:ffff:ffff:ffff,HN
 2801:1f:2000::,2801:1f:2000:ffff:ffff:ffff:ffff:ffff,CR
 2801:1f:4000::,2801:1f:4000:ffff:ffff:ffff:ffff:ffff,CR
 2801:1f:6000::,2801:1f:6000:ffff:ffff:ffff:ffff:ffff,AR
@@ -11937,7 +13628,7 @@
 2801:80:550::,2801:80:550:ffff:ffff:ffff:ffff:ffff,BR
 2801:80:560::,2801:80:560:ffff:ffff:ffff:ffff:ffff,BR
 2801:80:570::,2801:80:570:ffff:ffff:ffff:ffff:ffff,BR
-2801:80:580::,2801:80:580:ffff:ffff:ffff:ffff:ffff,BR
+2801:80:580::,2801:80:581:ffff:ffff:ffff:ffff:ffff,BR
 2801:80:590::,2801:80:590:ffff:ffff:ffff:ffff:ffff,BR
 2801:80:5a0::,2801:80:5a0:ffff:ffff:ffff:ffff:ffff,BR
 2801:80:5b0::,2801:80:5b0:ffff:ffff:ffff:ffff:ffff,BR
@@ -11950,7 +13641,7 @@
 2801:80:620::,2801:80:620:ffff:ffff:ffff:ffff:ffff,BR
 2801:80:630::,2801:80:630:ffff:ffff:ffff:ffff:ffff,BR
 2801:80:640::,2801:80:640:ffff:ffff:ffff:ffff:ffff,BR
-2801:80:650::,2801:80:650:ffff:ffff:ffff:ffff:ffff,BR
+2801:80:650::,2801:80:651:ffff:ffff:ffff:ffff:ffff,BR
 2801:80:660::,2801:80:660:ffff:ffff:ffff:ffff:ffff,BR
 2801:80:670::,2801:80:670:ffff:ffff:ffff:ffff:ffff,BR
 2801:80:680::,2801:80:680:ffff:ffff:ffff:ffff:ffff,BR
@@ -12118,7 +13809,22 @@
 2801:80:1370::,2801:80:1370:ffff:ffff:ffff:ffff:ffff,BR
 2801:80:1380::,2801:80:1380:ffff:ffff:ffff:ffff:ffff,BR
 2801:80:1390::,2801:80:1390:ffff:ffff:ffff:ffff:ffff,BR
+2801:80:13a0::,2801:80:13a0:ffff:ffff:ffff:ffff:ffff,BR
+2801:80:13b0::,2801:80:13b0:ffff:ffff:ffff:ffff:ffff,BR
+2801:80:13c0::,2801:80:13c0:ffff:ffff:ffff:ffff:ffff,BR
+2801:80:13d0::,2801:80:13d0:ffff:ffff:ffff:ffff:ffff,BR
+2801:80:13e0::,2801:80:13e0:ffff:ffff:ffff:ffff:ffff,BR
+2801:80:13f0::,2801:80:13f0:ffff:ffff:ffff:ffff:ffff,BR
 2801:80:1400::,2801:80:14ff:ffff:ffff:ffff:ffff:ffff,BR
+2801:80:1600::,2801:80:1600:ffff:ffff:ffff:ffff:ffff,BR
+2801:80:1610::,2801:80:1610:ffff:ffff:ffff:ffff:ffff,BR
+2801:80:1620::,2801:80:162f:ffff:ffff:ffff:ffff:ffff,BR
+2801:80:1640::,2801:80:1640:ffff:ffff:ffff:ffff:ffff,BR
+2801:80:1650::,2801:80:1650:ffff:ffff:ffff:ffff:ffff,BR
+2801:80:1660::,2801:80:1660:ffff:ffff:ffff:ffff:ffff,BR
+2801:80:1670::,2801:80:1670:ffff:ffff:ffff:ffff:ffff,BR
+2801:80:1680::,2801:80:1680:ffff:ffff:ffff:ffff:ffff,BR
+2801:80:1690::,2801:80:1690:ffff:ffff:ffff:ffff:ffff,BR
 2801:82::,2801:82:ffff:ffff:ffff:ffff:ffff:ffff,BR
 2801:84::,2801:84:ffff:ffff:ffff:ffff:ffff:ffff,BR
 2801:86::,2801:86:ffff:ffff:ffff:ffff:ffff:ffff,BR
@@ -12153,6 +13859,7 @@
 2801:c0::,2801:c0:ffff:ffff:ffff:ffff:ffff:ffff,MX
 2801:c4::,2801:c4::ffff:ffff:ffff:ffff:ffff,MX
 2801:c4:10::,2801:c4:10:ffff:ffff:ffff:ffff:ffff,MX
+2801:c4:12::,2801:c4:12:ffff:ffff:ffff:ffff:ffff,MX
 2801:c4:20::,2801:c4:20:ffff:ffff:ffff:ffff:ffff,MX
 2801:c4:30::,2801:c4:30:ffff:ffff:ffff:ffff:ffff,MX
 2801:c4:40::,2801:c4:40:ffff:ffff:ffff:ffff:ffff,MX
@@ -12171,18 +13878,21 @@
 2801:100::,2801:100:ff:ffff:ffff:ffff:ffff:ffff,AR
 2801:108::,2801:108:f:ffff:ffff:ffff:ffff:ffff,CO
 2801:110::,2801:110:1fff:ffff:ffff:ffff:ffff:ffff,CO
+2801:118::,2801:118:ff:ffff:ffff:ffff:ffff:ffff,AR
 2801:120::,2801:120:ffff:ffff:ffff:ffff:ffff:ffff,AR
 2801:128::,2801:128:fff:ffff:ffff:ffff:ffff:ffff,UY
 2801:130::,2801:130:fff:ffff:ffff:ffff:ffff:ffff,CO
 2801:140::,2801:140:ffff:ffff:ffff:ffff:ffff:ffff,AR
 2801:148::,2801:148:ff:ffff:ffff:ffff:ffff:ffff,AR
 2801:150::,2801:150:ffff:ffff:ffff:ffff:ffff:ffff,PE
+2801:158::,2801:158:fff:ffff:ffff:ffff:ffff:ffff,PA
 2801:160::,2801:160:ff:ffff:ffff:ffff:ffff:ffff,CO
 2801:168::,2801:168:ff:ffff:ffff:ffff:ffff:ffff,AR
 2801:170::,2801:170:fff:ffff:ffff:ffff:ffff:ffff,CO
 2801:180::,2801:180:f:ffff:ffff:ffff:ffff:ffff,PA
 2801:188::,2801:188:ff:ffff:ffff:ffff:ffff:ffff,AR
 2801:190::,2801:190:fff:ffff:ffff:ffff:ffff:ffff,CO
+2801:198::,2801:198:ffff:ffff:ffff:ffff:ffff:ffff,CL
 2801:1a0::,2801:1a0:3f:ffff:ffff:ffff:ffff:ffff,CO
 2801:1a8::,2801:1a8:ff:ffff:ffff:ffff:ffff:ffff,AR
 2801:1b0::,2801:1b0:ff:ffff:ffff:ffff:ffff:ffff,CO
@@ -12197,6 +13907,7 @@
 2803:80::,2803:80:ffff:ffff:ffff:ffff:ffff:ffff,CL
 2803:b4::,2803:b4:ffff:ffff:ffff:ffff:ffff:ffff,BZ
 2803:100::,2803:100:ffff:ffff:ffff:ffff:ffff:ffff,HN
+2803:140::,2803:140:ffff:ffff:ffff:ffff:ffff:ffff,AR
 2803:180::,2803:180:ffff:ffff:ffff:ffff:ffff:ffff,NI
 2803:200::,2803:200:ffff:ffff:ffff:ffff:ffff:ffff,PA
 2803:240::,2803:240:ffff:ffff:ffff:ffff:ffff:ffff,CO
@@ -12207,6 +13918,7 @@
 2803:440::,2803:440:ffff:ffff:ffff:ffff:ffff:ffff,AR
 2803:480::,2803:480:ffff:ffff:ffff:ffff:ffff:ffff,EC
 2803:500::,2803:500:ffff:ffff:ffff:ffff:ffff:ffff,PE
+2803:540::,2803:540:ffff:ffff:ffff:ffff:ffff:ffff,CR
 2803:580::,2803:580:ffff:ffff:ffff:ffff:ffff:ffff,AR
 2803:600::,2803:600:ffff:ffff:ffff:ffff:ffff:ffff,PA
 2803:640::,2803:640:ffff:ffff:ffff:ffff:ffff:ffff,AR
@@ -12217,6 +13929,7 @@
 2803:840::,2803:840:ffff:ffff:ffff:ffff:ffff:ffff,AR
 2803:880::,2803:880:ffff:ffff:ffff:ffff:ffff:ffff,AR
 2803:900::,2803:900:ffff:ffff:ffff:ffff:ffff:ffff,AR
+2803:940::,2803:940:ffff:ffff:ffff:ffff:ffff:ffff,CL
 2803:980::,2803:980:ffff:ffff:ffff:ffff:ffff:ffff,CR
 2803:a00::,2803:a00:ffff:ffff:ffff:ffff:ffff:ffff,AR
 2803:a40::,2803:a40:ffff:ffff:ffff:ffff:ffff:ffff,NI
@@ -12233,14 +13946,19 @@
 2803:e80::,2803:e80:ffff:ffff:ffff:ffff:ffff:ffff,CO
 2803:f00::,2803:f00:48a:ffff:ffff:ffff:ffff:ffff,PE
 2803:f00:48b::,2803:f00:48e:ffff:ffff:ffff:ffff:ffff,CO
-2803:f00:48f::,2803:f00:4a9:ffff:ffff:ffff:ffff:ffff,PE
-2803:f00:4aa::,2803:f00:4aa:7fff:ffff:ffff:ffff:ffff,CL
-2803:f00:4aa:8000::,2803:f00:ffff:ffff:ffff:ffff:ffff:ffff,PE
+2803:f00:48f::,2803:f00:4a6:ffff:ffff:ffff:ffff:ffff,PE
+2803:f00:4a7::,2803:f00:4a9:bfff:ffff:ffff:ffff:ffff,CL
+2803:f00:4a9:c000::,2803:f00:4a9:ffff:ffff:ffff:ffff:ffff,PE
+2803:f00:4aa::,2803:f00:4aa:ffff:ffff:ffff:ffff:ffff,CL
+2803:f00:4ab::,2803:f00:68d:7fff:ffff:ffff:ffff:ffff,PE
+2803:f00:68d:8000::,2803:f00:68d:ffff:ffff:ffff:ffff:ffff,CO
+2803:f00:68e::,2803:f00:ffff:ffff:ffff:ffff:ffff:ffff,PE
 2803:f80::,2803:f80:ffff:ffff:ffff:ffff:ffff:ffff,AR
 2803:1000::,2803:1000:ffff:ffff:ffff:ffff:ffff:ffff,SV
 2803:1040::,2803:1040:ffff:ffff:ffff:ffff:ffff:ffff,NI
 2803:1080::,2803:1080:ffff:ffff:ffff:ffff:ffff:ffff,AR
 2803:1100::,2803:1100:ffff:ffff:ffff:ffff:ffff:ffff,CW
+2803:1140::,2803:1140:ffff:ffff:ffff:ffff:ffff:ffff,DO
 2803:1180::,2803:1180:ffff:ffff:ffff:ffff:ffff:ffff,BO
 2803:1200::,2803:1200:ffff:ffff:ffff:ffff:ffff:ffff,CL
 2803:1240::,2803:1240:ffff:ffff:ffff:ffff:ffff:ffff,CO
@@ -12250,6 +13968,7 @@
 2803:1400::,2803:1400:ffff:ffff:ffff:ffff:ffff:ffff,DO
 2803:1440::,2803:1440:ffff:ffff:ffff:ffff:ffff:ffff,GT
 2803:1500::,2803:1500:ffff:ffff:ffff:ffff:ffff:ffff,TT
+2803:1540::,2803:1540:ffff:ffff:ffff:ffff:ffff:ffff,PE
 2803:1580::,2803:1580:ffff:ffff:ffff:ffff:ffff:ffff,CO
 2803:1600::,2803:1600:ffff:ffff:ffff:ffff:ffff:ffff,BQ
 2803:1640::,2803:1640:ffff:ffff:ffff:ffff:ffff:ffff,NI
@@ -12260,6 +13979,7 @@
 2803:1840::,2803:1840:ffff:ffff:ffff:ffff:ffff:ffff,CO
 2803:1880::,2803:1880:ffff:ffff:ffff:ffff:ffff:ffff,PE
 2803:1900::,2803:1900:ffff:ffff:ffff:ffff:ffff:ffff,AR
+2803:1940::,2803:1940:ffff:ffff:ffff:ffff:ffff:ffff,AR
 2803:1980::,2803:1980:ffff:ffff:ffff:ffff:ffff:ffff,CO
 2803:1a00::,2803:1a00:ffff:ffff:ffff:ffff:ffff:ffff,CO
 2803:1a40::,2803:1a40:ffff:ffff:ffff:ffff:ffff:ffff,AR
@@ -12271,6 +13991,7 @@
 2803:1d00::,2803:1d00:ffff:ffff:ffff:ffff:ffff:ffff,AR
 2803:1d80::,2803:1d80:ffff:ffff:ffff:ffff:ffff:ffff,AR
 2803:1e00::,2803:1e00:ffff:ffff:ffff:ffff:ffff:ffff,NI
+2803:1e40::,2803:1e40:ffff:ffff:ffff:ffff:ffff:ffff,AR
 2803:1e80::,2803:1e80:ffff:ffff:ffff:ffff:ffff:ffff,AR
 2803:1f00::,2803:1f00:ffff:ffff:ffff:ffff:ffff:ffff,AR
 2803:1f80::,2803:1f80:ffff:ffff:ffff:ffff:ffff:ffff,VE
@@ -12278,6 +13999,7 @@
 2803:2040::,2803:2040:ffff:ffff:ffff:ffff:ffff:ffff,CR
 2803:2080::,2803:2080:ffff:ffff:ffff:ffff:ffff:ffff,HN
 2803:2100::,2803:2100:ffff:ffff:ffff:ffff:ffff:ffff,PE
+2803:2140::,2803:2140:ffff:ffff:ffff:ffff:ffff:ffff,AR
 2803:2180::,2803:2180:ffff:ffff:ffff:ffff:ffff:ffff,CO
 2803:2200::,2803:2200:ffff:ffff:ffff:ffff:ffff:ffff,EC
 2803:2240::,2803:2240:ffff:ffff:ffff:ffff:ffff:ffff,AR
@@ -12288,6 +14010,7 @@
 2803:2440::,2803:2440:ffff:ffff:ffff:ffff:ffff:ffff,AR
 2803:2480::,2803:2480:ffff:ffff:ffff:ffff:ffff:ffff,PE
 2803:2500::,2803:2500:ffff:ffff:ffff:ffff:ffff:ffff,PE
+2803:2540::,2803:2540:ffff:ffff:ffff:ffff:ffff:ffff,EC
 2803:2580::,2803:2580:ffff:ffff:ffff:ffff:ffff:ffff,HN
 2803:2600::,2803:2600:ffff:ffff:ffff:ffff:ffff:ffff,AR
 2803:2640::,2803:2640:ffff:ffff:ffff:ffff:ffff:ffff,CO
@@ -12298,6 +14021,7 @@
 2803:2840::,2803:2840:ffff:ffff:ffff:ffff:ffff:ffff,BZ
 2803:2880::,2803:2880:ffff:ffff:ffff:ffff:ffff:ffff,BO
 2803:2900::,2803:2900:ffff:ffff:ffff:ffff:ffff:ffff,PA
+2803:2940::,2803:2940:ffff:ffff:ffff:ffff:ffff:ffff,PA
 2803:2980::,2803:2980:ffff:ffff:ffff:ffff:ffff:ffff,AR
 2803:2a00::,2803:2a00:ffff:ffff:ffff:ffff:ffff:ffff,PY
 2803:2a40::,2803:2a40:ffff:ffff:ffff:ffff:ffff:ffff,AR
@@ -12310,12 +14034,14 @@
 2803:2d00::,2803:2d00:ffff:ffff:ffff:ffff:ffff:ffff,AR
 2803:2d80::,2803:2d80:ffff:ffff:ffff:ffff:ffff:ffff,PA
 2803:2e00::,2803:2e00:ffff:ffff:ffff:ffff:ffff:ffff,EC
+2803:2e40::,2803:2e40:ffff:ffff:ffff:ffff:ffff:ffff,PA
 2803:2e80::,2803:2e80:ffff:ffff:ffff:ffff:ffff:ffff,AR
 2803:2f00::,2803:2f00:ffff:ffff:ffff:ffff:ffff:ffff,AR
 2803:2f80::,2803:2f80:ffff:ffff:ffff:ffff:ffff:ffff,CL
 2803:3000::,2803:3000:ffff:ffff:ffff:ffff:ffff:ffff,PA
 2803:3040::,2803:3040:ffff:ffff:ffff:ffff:ffff:ffff,CW
 2803:3100::,2803:3100:ffff:ffff:ffff:ffff:ffff:ffff,CR
+2803:3140::,2803:3140:ffff:ffff:ffff:ffff:ffff:ffff,PE
 2803:3180::,2803:3180:ffff:ffff:ffff:ffff:ffff:ffff,AR
 2803:3200::,2803:3200:ffff:ffff:ffff:ffff:ffff:ffff,CR
 2803:3240::,2803:3240:ffff:ffff:ffff:ffff:ffff:ffff,BZ
@@ -12326,6 +14052,7 @@
 2803:3440::,2803:3440:ffff:ffff:ffff:ffff:ffff:ffff,CL
 2803:3480::,2803:3480:ffff:ffff:ffff:ffff:ffff:ffff,AR
 2803:3500::,2803:3500:ffff:ffff:ffff:ffff:ffff:ffff,AR
+2803:3540::,2803:3540:ffff:ffff:ffff:ffff:ffff:ffff,AR
 2803:3580::,2803:3580:ffff:ffff:ffff:ffff:ffff:ffff,PE
 2803:3600::,2803:3600:ffff:ffff:ffff:ffff:ffff:ffff,CR
 2803:3640::,2803:3640:ffff:ffff:ffff:ffff:ffff:ffff,DO
@@ -12336,6 +14063,7 @@
 2803:3840::,2803:3840:ffff:ffff:ffff:ffff:ffff:ffff,AR
 2803:3880::,2803:3880:ffff:ffff:ffff:ffff:ffff:ffff,AR
 2803:3900::,2803:3900:ffff:ffff:ffff:ffff:ffff:ffff,VE
+2803:3940::,2803:3940:ffff:ffff:ffff:ffff:ffff:ffff,AR
 2803:3980::,2803:3980:ffff:ffff:ffff:ffff:ffff:ffff,VE
 2803:3a00::,2803:3a00:ffff:ffff:ffff:ffff:ffff:ffff,GT
 2803:3a40::,2803:3a40:ffff:ffff:ffff:ffff:ffff:ffff,CL
@@ -12348,6 +14076,7 @@
 2803:3d00::,2803:3d00:ffff:ffff:ffff:ffff:ffff:ffff,BZ
 2803:3d80::,2803:3d80:ffff:ffff:ffff:ffff:ffff:ffff,AR
 2803:3e00::,2803:3e00:ffff:ffff:ffff:ffff:ffff:ffff,AR
+2803:3e40::,2803:3e40:ffff:ffff:ffff:ffff:ffff:ffff,AR
 2803:3e80::,2803:3e80:ffff:ffff:ffff:ffff:ffff:ffff,CO
 2803:3f00::,2803:3f00:ffff:ffff:ffff:ffff:ffff:ffff,HN
 2803:3f80::,2803:3f80:ffff:ffff:ffff:ffff:ffff:ffff,AR
@@ -12355,6 +14084,7 @@
 2803:4040::,2803:4040:ffff:ffff:ffff:ffff:ffff:ffff,AR
 2803:4080::,2803:4080:ffff:ffff:ffff:ffff:ffff:ffff,AR
 2803:4100::,2803:4100:ffff:ffff:ffff:ffff:ffff:ffff,AR
+2803:4140::,2803:4140:ffff:ffff:ffff:ffff:ffff:ffff,AR
 2803:4180::,2803:4180:ffff:ffff:ffff:ffff:ffff:ffff,EC
 2803:4200::,2803:4200:ffff:ffff:ffff:ffff:ffff:ffff,CL
 2803:4240::,2803:4240:ffff:ffff:ffff:ffff:ffff:ffff,PY
@@ -12365,6 +14095,7 @@
 2803:4440::,2803:4440:ffff:ffff:ffff:ffff:ffff:ffff,AR
 2803:4480::,2803:4480:ffff:ffff:ffff:ffff:ffff:ffff,PE
 2803:4500::,2803:4500:ffff:ffff:ffff:ffff:ffff:ffff,CW
+2803:4540::,2803:4540:ffff:ffff:ffff:ffff:ffff:ffff,HN
 2803:4580::,2803:4580:ffff:ffff:ffff:ffff:ffff:ffff,CR
 2803:4600::,2803:4600:ffff:ffff:ffff:ffff:ffff:ffff,HN
 2803:4640::,2803:4640:ffff:ffff:ffff:ffff:ffff:ffff,CL
@@ -12375,6 +14106,7 @@
 2803:4840::,2803:4840:ffff:ffff:ffff:ffff:ffff:ffff,AR
 2803:4880::,2803:4880:ffff:ffff:ffff:ffff:ffff:ffff,AR
 2803:4900::,2803:4900:ffff:ffff:ffff:ffff:ffff:ffff,BQ
+2803:4940::,2803:4940:ffff:ffff:ffff:ffff:ffff:ffff,AR
 2803:4980::,2803:4980:ffff:ffff:ffff:ffff:ffff:ffff,AR
 2803:4a40::,2803:4a40:ffff:ffff:ffff:ffff:ffff:ffff,CL
 2803:4a80::,2803:4a80:ffff:ffff:ffff:ffff:ffff:ffff,AR
@@ -12394,6 +14126,7 @@
 2803:5040::,2803:5040:ffff:ffff:ffff:ffff:ffff:ffff,SV
 2803:5080::,2803:5080:ffff:ffff:ffff:ffff:ffff:ffff,AR
 2803:5100::,2803:5100:ffff:ffff:ffff:ffff:ffff:ffff,GT
+2803:5140::,2803:5140:ffff:ffff:ffff:ffff:ffff:ffff,AR
 2803:5180::,2803:5180:ffff:ffff:ffff:ffff:ffff:ffff,CR
 2803:5200::,2803:5200:ffff:ffff:ffff:ffff:ffff:ffff,CL
 2803:5240::,2803:5240:ffff:ffff:ffff:ffff:ffff:ffff,AR
@@ -12404,6 +14137,7 @@
 2803:5440::,2803:5440:ffff:ffff:ffff:ffff:ffff:ffff,AR
 2803:5480::,2803:5480:ffff:ffff:ffff:ffff:ffff:ffff,AR
 2803:5500::,2803:5500:ffff:ffff:ffff:ffff:ffff:ffff,AR
+2803:5540::,2803:5540:ffff:ffff:ffff:ffff:ffff:ffff,AR
 2803:5580::,2803:5580:ffff:ffff:ffff:ffff:ffff:ffff,CR
 2803:5600::,2803:5600:ffff:ffff:ffff:ffff:ffff:ffff,HN
 2803:5640::,2803:5640:ffff:ffff:ffff:ffff:ffff:ffff,CO
@@ -12413,6 +14147,7 @@
 2803:5840::,2803:5840:ffff:ffff:ffff:ffff:ffff:ffff,CR
 2803:5880::,2803:5880:ffff:ffff:ffff:ffff:ffff:ffff,AR
 2803:5900::,2803:5900:ffff:ffff:ffff:ffff:ffff:ffff,GF
+2803:5940::,2803:5940:ffff:ffff:ffff:ffff:ffff:ffff,PE
 2803:5980::,2803:5980:ffff:ffff:ffff:ffff:ffff:ffff,AR
 2803:5a00::,2803:5a00:ffff:ffff:ffff:ffff:ffff:ffff,AR
 2803:5a40::,2803:5a40:ffff:ffff:ffff:ffff:ffff:ffff,PY
@@ -12425,12 +14160,14 @@
 2803:5d00::,2803:5d00:ffff:ffff:ffff:ffff:ffff:ffff,SV
 2803:5d80::,2803:5d80:ffff:ffff:ffff:ffff:ffff:ffff,BZ
 2803:5e00::,2803:5e00:ffff:ffff:ffff:ffff:ffff:ffff,BO
+2803:5e40::,2803:5e40:ffff:ffff:ffff:ffff:ffff:ffff,CL
 2803:5e80::,2803:5e80:ffff:ffff:ffff:ffff:ffff:ffff,AR
 2803:5f80::,2803:5f80:ffff:ffff:ffff:ffff:ffff:ffff,EC
 2803:6000::,2803:6000:ffff:ffff:ffff:ffff:ffff:ffff,CR
 2803:6040::,2803:6040:ffff:ffff:ffff:ffff:ffff:ffff,AR
-2803:6080::,2803:6080:ffff:ffff:ffff:ffff:ffff:ffff,US
+2803:6080::,2803:6087:ffff:ffff:ffff:ffff:ffff:ffff,US
 2803:6100::,2803:6100:ffff:ffff:ffff:ffff:ffff:ffff,AR
+2803:6140::,2803:6140:ffff:ffff:ffff:ffff:ffff:ffff,AR
 2803:6180::,2803:6180:ffff:ffff:ffff:ffff:ffff:ffff,HN
 2803:6200::,2803:6200:ffff:ffff:ffff:ffff:ffff:ffff,CL
 2803:6240::,2803:6240:ffff:ffff:ffff:ffff:ffff:ffff,VE
@@ -12441,6 +14178,7 @@
 2803:6440::,2803:6440:ffff:ffff:ffff:ffff:ffff:ffff,AR
 2803:6480::,2803:6480:ffff:ffff:ffff:ffff:ffff:ffff,BZ
 2803:6500::,2803:6500:ffff:ffff:ffff:ffff:ffff:ffff,PE
+2803:6540::,2803:6540:ffff:ffff:ffff:ffff:ffff:ffff,AR
 2803:6580::,2803:6580:ffff:ffff:ffff:ffff:ffff:ffff,CL
 2803:6600::,2803:6600:ffff:ffff:ffff:ffff:ffff:ffff,AR
 2803:6640::,2803:6640:ffff:ffff:ffff:ffff:ffff:ffff,DO
@@ -12451,6 +14189,7 @@
 2803:6840::,2803:6840:ffff:ffff:ffff:ffff:ffff:ffff,AR
 2803:6880::,2803:6880:ffff:ffff:ffff:ffff:ffff:ffff,AR
 2803:6900::,2803:6900:ffff:ffff:ffff:ffff:ffff:ffff,CR
+2803:6940::,2803:6940:ffff:ffff:ffff:ffff:ffff:ffff,PY
 2803:6980::,2803:6980:ffff:ffff:ffff:ffff:ffff:ffff,AR
 2803:6a00::,2803:6a00:ffff:ffff:ffff:ffff:ffff:ffff,EC
 2803:6a40::,2803:6a40:ffff:ffff:ffff:ffff:ffff:ffff,AR
@@ -12463,6 +14202,7 @@
 2803:6d00::,2803:6d00:ffff:ffff:ffff:ffff:ffff:ffff,AR
 2803:6d80::,2803:6d80:ffff:ffff:ffff:ffff:ffff:ffff,CL
 2803:6e00::,2803:6e00:ffff:ffff:ffff:ffff:ffff:ffff,SR
+2803:6e40::,2803:6e40:ffff:ffff:ffff:ffff:ffff:ffff,AR
 2803:6e80::,2803:6e80:ffff:ffff:ffff:ffff:ffff:ffff,HN
 2803:6f00::,2803:6f00:ffff:ffff:ffff:ffff:ffff:ffff,CL
 2803:6f80::,2803:6f80:ffff:ffff:ffff:ffff:ffff:ffff,CO
@@ -12470,6 +14210,7 @@
 2803:7040::,2803:7040:ffff:ffff:ffff:ffff:ffff:ffff,AR
 2803:7080::,2803:7080:ffff:ffff:ffff:ffff:ffff:ffff,AR
 2803:7100::,2803:7100:ffff:ffff:ffff:ffff:ffff:ffff,AR
+2803:7140::,2803:7140:ffff:ffff:ffff:ffff:ffff:ffff,GT
 2803:7180::,2803:7180:ffff:ffff:ffff:ffff:ffff:ffff,PE
 2803:7200::,2803:7200:ffff:ffff:ffff:ffff:ffff:ffff,HN
 2803:7240::,2803:7240:ffff:ffff:ffff:ffff:ffff:ffff,AR
@@ -12490,6 +14231,7 @@
 2803:7840::,2803:7840:ffff:ffff:ffff:ffff:ffff:ffff,AR
 2803:7880::,2803:7880:ffff:ffff:ffff:ffff:ffff:ffff,AR
 2803:7900::,2803:7900:ffff:ffff:ffff:ffff:ffff:ffff,BZ
+2803:7940::,2803:7940:ffff:ffff:ffff:ffff:ffff:ffff,AR
 2803:7980::,2803:7980:ffff:ffff:ffff:ffff:ffff:ffff,VE
 2803:7a00::,2803:7a00:ffff:ffff:ffff:ffff:ffff:ffff,CR
 2803:7a40::,2803:7a40:ffff:ffff:ffff:ffff:ffff:ffff,AR
@@ -12502,6 +14244,7 @@
 2803:7d00::,2803:7d00:ffff:ffff:ffff:ffff:ffff:ffff,AR
 2803:7d80::,2803:7d80:ffff:ffff:ffff:ffff:ffff:ffff,PY
 2803:7e00::,2803:7e00:ffff:ffff:ffff:ffff:ffff:ffff,AR
+2803:7e40::,2803:7e40:ffff:ffff:ffff:ffff:ffff:ffff,AR
 2803:7e80::,2803:7e80:ffff:ffff:ffff:ffff:ffff:ffff,AR
 2803:7f00::,2803:7f00:ffff:ffff:ffff:ffff:ffff:ffff,CO
 2803:7f80::,2803:7f80:ffff:ffff:ffff:ffff:ffff:ffff,AR
@@ -12509,6 +14252,7 @@
 2803:8040::,2803:8040:ffff:ffff:ffff:ffff:ffff:ffff,CR
 2803:8080::,2803:8080:ffff:ffff:ffff:ffff:ffff:ffff,AR
 2803:8100::,2803:8100:ffff:ffff:ffff:ffff:ffff:ffff,VE
+2803:8140::,2803:8140:ffff:ffff:ffff:ffff:ffff:ffff,CL
 2803:8180::,2803:8180:ffff:ffff:ffff:ffff:ffff:ffff,CL
 2803:8200::,2803:8200:ffff:ffff:ffff:ffff:ffff:ffff,HN
 2803:8240::,2803:8240:ffff:ffff:ffff:ffff:ffff:ffff,CL
@@ -12519,6 +14263,7 @@
 2803:8440::,2803:8440:ffff:ffff:ffff:ffff:ffff:ffff,AR
 2803:8480::,2803:8480:ffff:ffff:ffff:ffff:ffff:ffff,AR
 2803:8500::,2803:8500:ffff:ffff:ffff:ffff:ffff:ffff,AR
+2803:8540::,2803:8540:ffff:ffff:ffff:ffff:ffff:ffff,CL
 2803:8580::,2803:8580:ffff:ffff:ffff:ffff:ffff:ffff,CO
 2803:8600::,2803:8600:ffff:ffff:ffff:ffff:ffff:ffff,HT
 2803:8640::,2803:8640:ffff:ffff:ffff:ffff:ffff:ffff,AR
@@ -12529,6 +14274,7 @@
 2803:8840::,2803:8840:ffff:ffff:ffff:ffff:ffff:ffff,SV
 2803:8880::,2803:8880:ffff:ffff:ffff:ffff:ffff:ffff,NI
 2803:8900::,2803:8900:ffff:ffff:ffff:ffff:ffff:ffff,AR
+2803:8940::,2803:8940:ffff:ffff:ffff:ffff:ffff:ffff,CL
 2803:8980::,2803:8980:ffff:ffff:ffff:ffff:ffff:ffff,CO
 2803:8a40::,2803:8a40:ffff:ffff:ffff:ffff:ffff:ffff,AR
 2803:8a80::,2803:8a80:ffff:ffff:ffff:ffff:ffff:ffff,AR
@@ -12548,6 +14294,7 @@
 2803:9040::,2803:9040:ffff:ffff:ffff:ffff:ffff:ffff,DO
 2803:9080::,2803:9080:ffff:ffff:ffff:ffff:ffff:ffff,HN
 2803:9100::,2803:9100:ffff:ffff:ffff:ffff:ffff:ffff,AR
+2803:9140::,2803:9140:ffff:ffff:ffff:ffff:ffff:ffff,NI
 2803:9180::,2803:9180:ffff:ffff:ffff:ffff:ffff:ffff,CR
 2803:9200::,2803:9200:ffff:ffff:ffff:ffff:ffff:ffff,SV
 2803:9240::,2803:9240:ffff:ffff:ffff:ffff:ffff:ffff,AR
@@ -12558,6 +14305,7 @@
 2803:9440::,2803:9440:ffff:ffff:ffff:ffff:ffff:ffff,AR
 2803:9480::,2803:9480:ffff:ffff:ffff:ffff:ffff:ffff,AR
 2803:9500::,2803:9500:ffff:ffff:ffff:ffff:ffff:ffff,AR
+2803:9540::,2803:9540:ffff:ffff:ffff:ffff:ffff:ffff,PE
 2803:9580::,2803:9580:ffff:ffff:ffff:ffff:ffff:ffff,AR
 2803:9600::,2803:9600:ffff:ffff:ffff:ffff:ffff:ffff,CW
 2803:9640::,2803:9640:ffff:ffff:ffff:ffff:ffff:ffff,DO
@@ -12568,6 +14316,7 @@
 2803:9840::,2803:9840:ffff:ffff:ffff:ffff:ffff:ffff,NI
 2803:9880::,2803:9880:ffff:ffff:ffff:ffff:ffff:ffff,BZ
 2803:9900::,2803:9900:ffff:ffff:ffff:ffff:ffff:ffff,CL
+2803:9940::,2803:9940:ffff:ffff:ffff:ffff:ffff:ffff,AR
 2803:9980::,2803:9980:ffff:ffff:ffff:ffff:ffff:ffff,CO
 2803:9a00::,2803:9a00:ffff:ffff:ffff:ffff:ffff:ffff,BZ
 2803:9a40::,2803:9a40:ffff:ffff:ffff:ffff:ffff:ffff,BZ
@@ -12580,6 +14329,7 @@
 2803:9d00::,2803:9d00:ffff:ffff:ffff:ffff:ffff:ffff,SV
 2803:9d80::,2803:9d80:ffff:ffff:ffff:ffff:ffff:ffff,SV
 2803:9e00::,2803:9e00:ffff:ffff:ffff:ffff:ffff:ffff,AR
+2803:9e40::,2803:9e40:ffff:ffff:ffff:ffff:ffff:ffff,PA
 2803:9e80::,2803:9e80:ffff:ffff:ffff:ffff:ffff:ffff,CL
 2803:9f00::,2803:9f00:ffff:ffff:ffff:ffff:ffff:ffff,AR
 2803:9f80::,2803:9f80:ffff:ffff:ffff:ffff:ffff:ffff,HN
@@ -12587,6 +14337,7 @@
 2803:a040::,2803:a040:ffff:ffff:ffff:ffff:ffff:ffff,PY
 2803:a080::,2803:a080:ffff:ffff:ffff:ffff:ffff:ffff,AR
 2803:a100::,2803:a100:ffff:ffff:ffff:ffff:ffff:ffff,CL
+2803:a140::,2803:a140:ffff:ffff:ffff:ffff:ffff:ffff,CO
 2803:a180::,2803:a180:ffff:ffff:ffff:ffff:ffff:ffff,DO
 2803:a200::,2803:a200:ffff:ffff:ffff:ffff:ffff:ffff,SR
 2803:a240::,2803:a240:ffff:ffff:ffff:ffff:ffff:ffff,EC
@@ -12596,6 +14347,7 @@
 2803:a440::,2803:a440:ffff:ffff:ffff:ffff:ffff:ffff,AR
 2803:a480::,2803:a480:ffff:ffff:ffff:ffff:ffff:ffff,AR
 2803:a500::,2803:a500:ffff:ffff:ffff:ffff:ffff:ffff,AR
+2803:a540::,2803:a540:ffff:ffff:ffff:ffff:ffff:ffff,AR
 2803:a580::,2803:a580:ffff:ffff:ffff:ffff:ffff:ffff,HT
 2803:a600::,2803:a600:ffff:ffff:ffff:ffff:ffff:ffff,AR
 2803:a640::,2803:a640:ffff:ffff:ffff:ffff:ffff:ffff,DO
@@ -12606,6 +14358,7 @@
 2803:a840::,2803:a840:ffff:ffff:ffff:ffff:ffff:ffff,VE
 2803:a880::,2803:a880:ffff:ffff:ffff:ffff:ffff:ffff,AR
 2803:a900::,2803:a900:ffff:ffff:ffff:ffff:ffff:ffff,AR
+2803:a940::,2803:a940:ffff:ffff:ffff:ffff:ffff:ffff,PE
 2803:a980::,2803:a980:ffff:ffff:ffff:ffff:ffff:ffff,CL
 2803:aa00::,2803:aa00:ffff:ffff:ffff:ffff:ffff:ffff,CL
 2803:aa40::,2803:aa40:ffff:ffff:ffff:ffff:ffff:ffff,AR
@@ -12618,12 +14371,14 @@
 2803:ad00::,2803:ad00:ffff:ffff:ffff:ffff:ffff:ffff,AR
 2803:ad80::,2803:ad80:ffff:ffff:ffff:ffff:ffff:ffff,PA
 2803:ae00::,2803:ae00:ffff:ffff:ffff:ffff:ffff:ffff,AR
+2803:ae40::,2803:ae40:ffff:ffff:ffff:ffff:ffff:ffff,PA
 2803:ae80::,2803:ae80:ffff:ffff:ffff:ffff:ffff:ffff,AR
 2803:af00::,2803:af00:ffff:ffff:ffff:ffff:ffff:ffff,AR
 2803:af80::,2803:af80:ffff:ffff:ffff:ffff:ffff:ffff,PY
 2803:b000::,2803:b000:ffff:ffff:ffff:ffff:ffff:ffff,CO
 2803:b080::,2803:b080:ffff:ffff:ffff:ffff:ffff:ffff,BZ
 2803:b100::,2803:b100:ffff:ffff:ffff:ffff:ffff:ffff,CR
+2803:b140::,2803:b140:ffff:ffff:ffff:ffff:ffff:ffff,CR
 2803:b180::,2803:b180:ffff:ffff:ffff:ffff:ffff:ffff,CL
 2803:b200::,2803:b200:ffff:ffff:ffff:ffff:ffff:ffff,UY
 2803:b240::,2803:b240:ffff:ffff:ffff:ffff:ffff:ffff,PY
@@ -12644,6 +14399,7 @@
 2803:b840::,2803:b840:ffff:ffff:ffff:ffff:ffff:ffff,PA
 2803:b880::,2803:b880:ffff:ffff:ffff:ffff:ffff:ffff,AR
 2803:b900::,2803:b900:ffff:ffff:ffff:ffff:ffff:ffff,AR
+2803:b940::,2803:b940:ffff:ffff:ffff:ffff:ffff:ffff,PE
 2803:ba00::,2803:ba00:ffff:ffff:ffff:ffff:ffff:ffff,GT
 2803:ba40::,2803:ba40:ffff:ffff:ffff:ffff:ffff:ffff,AR
 2803:ba80::,2803:ba80:ffff:ffff:ffff:ffff:ffff:ffff,AR
@@ -12655,6 +14411,7 @@
 2803:bd00::,2803:bd00:ffff:ffff:ffff:ffff:ffff:ffff,AR
 2803:bd80::,2803:bd80:ffff:ffff:ffff:ffff:ffff:ffff,PA
 2803:be00::,2803:be00:ffff:ffff:ffff:ffff:ffff:ffff,AR
+2803:be40::,2803:be40:ffff:ffff:ffff:ffff:ffff:ffff,AR
 2803:be80::,2803:be80:ffff:ffff:ffff:ffff:ffff:ffff,CO
 2803:bf00::,2803:bf00:ffff:ffff:ffff:ffff:ffff:ffff,AR
 2803:bf80::,2803:bf80:ffff:ffff:ffff:ffff:ffff:ffff,PA
@@ -12662,6 +14419,7 @@
 2803:c040::,2803:c040:ffff:ffff:ffff:ffff:ffff:ffff,VE
 2803:c080::,2803:c080:ffff:ffff:ffff:ffff:ffff:ffff,AR
 2803:c100::,2803:c100:ffff:ffff:ffff:ffff:ffff:ffff,PY
+2803:c140::,2803:c140:ffff:ffff:ffff:ffff:ffff:ffff,AR
 2803:c180::,2803:c180:ffff:ffff:ffff:ffff:ffff:ffff,CL
 2803:c200::,2803:c200:ffff:ffff:ffff:ffff:ffff:ffff,PE
 2803:c240::,2803:c240:ffff:ffff:ffff:ffff:ffff:ffff,BZ
@@ -12672,6 +14430,7 @@
 2803:c440::,2803:c440:ffff:ffff:ffff:ffff:ffff:ffff,AR
 2803:c480::,2803:c480:ffff:ffff:ffff:ffff:ffff:ffff,AR
 2803:c500::,2803:c500:ffff:ffff:ffff:ffff:ffff:ffff,AR
+2803:c540::,2803:c540:ffff:ffff:ffff:ffff:ffff:ffff,GT
 2803:c580::,2803:c580:ffff:ffff:ffff:ffff:ffff:ffff,AR
 2803:c600::,2803:c600:ffff:ffff:ffff:ffff:ffff:ffff,CL
 2803:c640::,2803:c640:ffff:ffff:ffff:ffff:ffff:ffff,AR
@@ -12682,6 +14441,7 @@
 2803:c840::,2803:c840:ffff:ffff:ffff:ffff:ffff:ffff,GT
 2803:c880::,2803:c880:ffff:ffff:ffff:ffff:ffff:ffff,HN
 2803:c900::,2803:c900:ffff:ffff:ffff:ffff:ffff:ffff,AR
+2803:c940::,2803:c940:ffff:ffff:ffff:ffff:ffff:ffff,CR
 2803:c980::,2803:c980:ffff:ffff:ffff:ffff:ffff:ffff,CL
 2803:ca00::,2803:ca00:ffff:ffff:ffff:ffff:ffff:ffff,AR
 2803:ca40::,2803:ca40:ffff:ffff:ffff:ffff:ffff:ffff,AR
@@ -12694,6 +14454,7 @@
 2803:cd00::,2803:cd00:ffff:ffff:ffff:ffff:ffff:ffff,AR
 2803:cd80::,2803:cd80:ffff:ffff:ffff:ffff:ffff:ffff,TT
 2803:ce00::,2803:ce00:ffff:ffff:ffff:ffff:ffff:ffff,HN
+2803:ce40::,2803:ce40:ffff:ffff:ffff:ffff:ffff:ffff,AR
 2803:ce80::,2803:ce80:ffff:ffff:ffff:ffff:ffff:ffff,AR
 2803:cf00::,2803:cf00:ffff:ffff:ffff:ffff:ffff:ffff,AR
 2803:cf80::,2803:cf80:ffff:ffff:ffff:ffff:ffff:ffff,AR
@@ -12703,16 +14464,17 @@
 2803:d040::,2803:d040:ffff:ffff:ffff:ffff:ffff:ffff,PA
 2803:d080::,2803:d080:ffff:ffff:ffff:ffff:ffff:ffff,AR
 2803:d100::,2803:d100:ffff:ffff:ffff:ffff:ffff:ffff,GT
+2803:d140::,2803:d140:ffff:ffff:ffff:ffff:ffff:ffff,CL
 2803:d180::,2803:d180:ffff:ffff:ffff:ffff:ffff:ffff,EC
 2803:d200::,2803:d200:ffff:ffff:ffff:ffff:ffff:ffff,CR
 2803:d240::,2803:d240:ffff:ffff:ffff:ffff:ffff:ffff,AR
 2803:d280::,2803:d280:ffff:ffff:ffff:ffff:ffff:ffff,PY
-2803:d300::,2803:d300:ffff:ffff:ffff:ffff:ffff:ffff,PA
 2803:d380::,2803:d380:ffff:ffff:ffff:ffff:ffff:ffff,CL
 2803:d400::,2803:d400:ffff:ffff:ffff:ffff:ffff:ffff,AR
 2803:d440::,2803:d440:ffff:ffff:ffff:ffff:ffff:ffff,VE
 2803:d480::,2803:d480:ffff:ffff:ffff:ffff:ffff:ffff,VE
 2803:d500::,2803:d500:ffff:ffff:ffff:ffff:ffff:ffff,BZ
+2803:d540::,2803:d540:ffff:ffff:ffff:ffff:ffff:ffff,VE
 2803:d580::,2803:d580:ffff:ffff:ffff:ffff:ffff:ffff,CL
 2803:d600::,2803:d600:ffff:ffff:ffff:ffff:ffff:ffff,UY
 2803:d640::,2803:d640:ffff:ffff:ffff:ffff:ffff:ffff,SV
@@ -12723,6 +14485,7 @@
 2803:d840::,2803:d840:ffff:ffff:ffff:ffff:ffff:ffff,PA
 2803:d880::,2803:d880:ffff:ffff:ffff:ffff:ffff:ffff,CR
 2803:d900::,2803:d900:ffff:ffff:ffff:ffff:ffff:ffff,CR
+2803:d940::,2803:d940:ffff:ffff:ffff:ffff:ffff:ffff,VE
 2803:d980::,2803:d980:ffff:ffff:ffff:ffff:ffff:ffff,PA
 2803:da00::,2803:da00:ffff:ffff:ffff:ffff:ffff:ffff,GY
 2803:da40::,2803:da40:ffff:ffff:ffff:ffff:ffff:ffff,AR
@@ -12735,6 +14498,7 @@
 2803:dd00::,2803:dd00:ffff:ffff:ffff:ffff:ffff:ffff,PA
 2803:dd80::,2803:dd80:ffff:ffff:ffff:ffff:ffff:ffff,VE
 2803:de00::,2803:de00:ffff:ffff:ffff:ffff:ffff:ffff,AR
+2803:de40::,2803:de40:ffff:ffff:ffff:ffff:ffff:ffff,AR
 2803:de80::,2803:de80:ffff:ffff:ffff:ffff:ffff:ffff,CO
 2803:df00::,2803:df00:ffff:ffff:ffff:ffff:ffff:ffff,SV
 2803:df80::,2803:df80:ffff:ffff:ffff:ffff:ffff:ffff,AR
@@ -12742,6 +14506,7 @@
 2803:e040::,2803:e040:ffff:ffff:ffff:ffff:ffff:ffff,AR
 2803:e080::,2803:e080:ffff:ffff:ffff:ffff:ffff:ffff,AR
 2803:e100::,2803:e100:ffff:ffff:ffff:ffff:ffff:ffff,AR
+2803:e140::,2803:e140:ffff:ffff:ffff:ffff:ffff:ffff,PY
 2803:e180::,2803:e180:ffff:ffff:ffff:ffff:ffff:ffff,CL
 2803:e200::,2803:e200:ffff:ffff:ffff:ffff:ffff:ffff,AR
 2803:e240::,2803:e240:ffff:ffff:ffff:ffff:ffff:ffff,PA
@@ -12752,6 +14517,7 @@
 2803:e440::,2803:e440:ffff:ffff:ffff:ffff:ffff:ffff,AR
 2803:e480::,2803:e480:ffff:ffff:ffff:ffff:ffff:ffff,AR
 2803:e500::,2803:e500:ffff:ffff:ffff:ffff:ffff:ffff,PE
+2803:e540::,2803:e540:ffff:ffff:ffff:ffff:ffff:ffff,AR
 2803:e580::,2803:e580:ffff:ffff:ffff:ffff:ffff:ffff,CO
 2803:e600::,2803:e600:ffff:ffff:ffff:ffff:ffff:ffff,PA
 2803:e640::,2803:e640:ffff:ffff:ffff:ffff:ffff:ffff,CL
@@ -12762,6 +14528,7 @@
 2803:e840::,2803:e840:ffff:ffff:ffff:ffff:ffff:ffff,CO
 2803:e880::,2803:e880:ffff:ffff:ffff:ffff:ffff:ffff,GT
 2803:e900::,2803:e900:ffff:ffff:ffff:ffff:ffff:ffff,AR
+2803:e940::,2803:e940:ffff:ffff:ffff:ffff:ffff:ffff,AR
 2803:e980::,2803:e980:ffff:ffff:ffff:ffff:ffff:ffff,AR
 2803:ea00::,2803:ea00:ffff:ffff:ffff:ffff:ffff:ffff,AR
 2803:ea40::,2803:ea40:ffff:ffff:ffff:ffff:ffff:ffff,AR
@@ -12774,6 +14541,7 @@
 2803:ed00::,2803:ed00:ffff:ffff:ffff:ffff:ffff:ffff,PE
 2803:ed80::,2803:ed80:ffff:ffff:ffff:ffff:ffff:ffff,CL
 2803:ee00::,2803:ee00:ffff:ffff:ffff:ffff:ffff:ffff,AR
+2803:ee40::,2803:ee40:ffff:ffff:ffff:ffff:ffff:ffff,CR
 2803:ee80::,2803:ee80:ffff:ffff:ffff:ffff:ffff:ffff,AR
 2803:ef00::,2803:ef00:ffff:ffff:ffff:ffff:ffff:ffff,PA
 2803:ef80::,2803:ef80:ffff:ffff:ffff:ffff:ffff:ffff,CL
@@ -12781,6 +14549,7 @@
 2803:f040::,2803:f040:ffff:ffff:ffff:ffff:ffff:ffff,AR
 2803:f080::,2803:f080:ffff:ffff:ffff:ffff:ffff:ffff,PE
 2803:f100::,2803:f100:ffff:ffff:ffff:ffff:ffff:ffff,AR
+2803:f140::,2803:f140:ffff:ffff:ffff:ffff:ffff:ffff,AR
 2803:f180::,2803:f180:ffff:ffff:ffff:ffff:ffff:ffff,HN
 2803:f200::,2803:f200:ffff:ffff:ffff:ffff:ffff:ffff,AR
 2803:f240::,2803:f240:ffff:ffff:ffff:ffff:ffff:ffff,AR
@@ -12800,6 +14569,7 @@
 2803:f800::,2803:f800:ffff:ffff:ffff:ffff:ffff:ffff,CR
 2803:f840::,2803:f840:ffff:ffff:ffff:ffff:ffff:ffff,CO
 2803:f900::,2803:f900:ffff:ffff:ffff:ffff:ffff:ffff,BZ
+2803:f940::,2803:f940:ffff:ffff:ffff:ffff:ffff:ffff,SX
 2803:f980::,2803:f980:ffff:ffff:ffff:ffff:ffff:ffff,CL
 2803:fa00::,2803:fa00:ffff:ffff:ffff:ffff:ffff:ffff,BO
 2803:fa40::,2803:fa40:ffff:ffff:ffff:ffff:ffff:ffff,SV
@@ -12812,6 +14582,7 @@
 2803:fd00::,2803:fd00:ffff:ffff:ffff:ffff:ffff:ffff,CO
 2803:fd80::,2803:fd80:ffff:ffff:ffff:ffff:ffff:ffff,CL
 2803:fe00::,2803:fe00:ffff:ffff:ffff:ffff:ffff:ffff,CO
+2803:fe40::,2803:fe40:ffff:ffff:ffff:ffff:ffff:ffff,CR
 2803:fe80::,2803:fe80:ffff:ffff:ffff:ffff:ffff:ffff,PE
 2803:ff80::,2803:ff80:ffff:ffff:ffff:ffff:ffff:ffff,CO
 2804::,2804::ffff:ffff:ffff:ffff:ffff:ffff,BR
@@ -13619,7 +15390,9 @@
 2804:d34::,2804:d34:ffff:ffff:ffff:ffff:ffff:ffff,BR
 2804:d38::,2804:d38:ffff:ffff:ffff:ffff:ffff:ffff,BR
 2804:d3c::,2804:d3c:ffff:ffff:ffff:ffff:ffff:ffff,BR
-2804:d40::,2804:d60:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:d40::,2804:d41:514:7fff:ffff:ffff:ffff:ffff,BR
+2804:d41:514:8000::,2804:d41:514:ffff:ffff:ffff:ffff:ffff,US
+2804:d41:515::,2804:d60:ffff:ffff:ffff:ffff:ffff:ffff,BR
 2804:d64::,2804:d64:ffff:ffff:ffff:ffff:ffff:ffff,BR
 2804:d68::,2804:d68:ffff:ffff:ffff:ffff:ffff:ffff,BR
 2804:d6c::,2804:d6c:ffff:ffff:ffff:ffff:ffff:ffff,BR
@@ -14752,6 +16525,14 @@
 2804:1f0a::,2804:1f0a:ffff:ffff:ffff:ffff:ffff:ffff,BR
 2804:1f0c::,2804:1f0c:ffff:ffff:ffff:ffff:ffff:ffff,BR
 2804:1f0e::,2804:1f0e:1fff:ffff:ffff:ffff:ffff:ffff,BR
+2804:1f10::,2804:1f10:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:1f12::,2804:1f12:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:1f14::,2804:1f14:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:1f16::,2804:1f16:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:1f18::,2804:1f18:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:1f1a::,2804:1f1a:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:1f1c::,2804:1f1c:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:1f1e::,2804:1f1e:ffff:ffff:ffff:ffff:ffff:ffff,BR
 2804:2000::,2804:2000:ffff:ffff:ffff:ffff:ffff:ffff,BR
 2804:2004::,2804:2004:ffff:ffff:ffff:ffff:ffff:ffff,BR
 2804:2008::,2804:2008:ffff:ffff:ffff:ffff:ffff:ffff,BR
@@ -15402,11 +17183,246 @@
 2804:2a20::,2804:2a20:ffff:ffff:ffff:ffff:ffff:ffff,BR
 2804:2a24::,2804:2a24:ffff:ffff:ffff:ffff:ffff:ffff,BR
 2804:2a28::,2804:2a28:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2a2c::,2804:2a2c:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2a30::,2804:2a30:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2a34::,2804:2a34:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2a38::,2804:2a38:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2a3c::,2804:2a3c:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2a40::,2804:2a40:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2a44::,2804:2a44:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2a48::,2804:2a48:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2a4c::,2804:2a4c:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2a50::,2804:2a50:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2a54::,2804:2a54:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2a58::,2804:2a58:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2a5c::,2804:2a5c:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2a60::,2804:2a60:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2a64::,2804:2a64:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2a68::,2804:2a68:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2a6c::,2804:2a6c:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2a70::,2804:2a70:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2a74::,2804:2a74:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2a78::,2804:2a78:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2a7c::,2804:2a7c:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2a80::,2804:2a80:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2a84::,2804:2a84:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2a88::,2804:2a88:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2a8c::,2804:2a8c:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2a90::,2804:2a90:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2a94::,2804:2a94:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2a98::,2804:2a98:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2a9c::,2804:2a9c:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2aa0::,2804:2aa0:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2aa4::,2804:2aa4:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2aa8::,2804:2aa8:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2aac::,2804:2aac:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2ab0::,2804:2ab0:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2ab4::,2804:2ab4:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2ab8::,2804:2ab8:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2abc::,2804:2abc:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2ac0::,2804:2ac0:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2ac4::,2804:2ac4:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2ac8::,2804:2ac8:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2acc::,2804:2acc:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2ad0::,2804:2ad0:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2ad4::,2804:2ad4:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2ad8::,2804:2ad8:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2adc::,2804:2adc:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2ae0::,2804:2ae0:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2ae4::,2804:2ae4:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2ae8::,2804:2ae8:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2aec::,2804:2aec:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2af0::,2804:2af0:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2af4::,2804:2af4:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2af8::,2804:2af8:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2afc::,2804:2afc:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2b00::,2804:2b00:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2b04::,2804:2b04:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2b08::,2804:2b08:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2b0c::,2804:2b0c:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2b10::,2804:2b10:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2b14::,2804:2b14:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2b18::,2804:2b18:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2b1c::,2804:2b1c:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2b20::,2804:2b20:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2b24::,2804:2b24:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2b28::,2804:2b28:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2b2c::,2804:2b2c:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2b30::,2804:2b30:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2b34::,2804:2b34:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2b38::,2804:2b38:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2b3c::,2804:2b3c:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2b40::,2804:2b40:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2b44::,2804:2b44:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2b48::,2804:2b48:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2b4c::,2804:2b4c:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2b50::,2804:2b50:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2b54::,2804:2b54:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2b58::,2804:2b58:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2b5c::,2804:2b5c:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2b60::,2804:2b60:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2b64::,2804:2b64:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2b68::,2804:2b68:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2b6c::,2804:2b6c:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2b70::,2804:2b70:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2b74::,2804:2b74:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2b78::,2804:2b78:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2b7c::,2804:2b7c:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2b80::,2804:2b80:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2b84::,2804:2b84:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2b88::,2804:2b88:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2b8c::,2804:2b8c:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2b90::,2804:2b90:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2b94::,2804:2b94:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2b98::,2804:2b98:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2b9c::,2804:2b9c:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2ba0::,2804:2ba0:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2ba4::,2804:2ba4:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2ba8::,2804:2ba8:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2bac::,2804:2bac:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2bb0::,2804:2bb0:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2bb4::,2804:2bb4:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2bb8::,2804:2bb8:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2bbc::,2804:2bbc:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2bc0::,2804:2bc0:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2bc4::,2804:2bc4:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2bc8::,2804:2bc8:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2bcc::,2804:2bcc:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2bd0::,2804:2bd0:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2bd4::,2804:2bd4:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2bd8::,2804:2bd8:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2bdc::,2804:2bdc:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2be0::,2804:2be0:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2be4::,2804:2be4:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2be8::,2804:2be8:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2bec::,2804:2bec:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2bf0::,2804:2bf0:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2bf4::,2804:2bf4:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2bf8::,2804:2bf8:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2bfc::,2804:2bfc:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2c00::,2804:2c00:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2c04::,2804:2c04:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2c08::,2804:2c08:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2c0c::,2804:2c0c:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2c10::,2804:2c10:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2c14::,2804:2c14:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2c18::,2804:2c18:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2c1c::,2804:2c1c:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2c20::,2804:2c20:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2c24::,2804:2c24:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2c28::,2804:2c28:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2c2c::,2804:2c2c:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2c30::,2804:2c30:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2c34::,2804:2c34:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2c38::,2804:2c38:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2c3c::,2804:2c3c:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2c40::,2804:2c40:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2c44::,2804:2c44:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2c48::,2804:2c48:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2c4c::,2804:2c4c:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2c50::,2804:2c50:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2c54::,2804:2c54:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2c58::,2804:2c58:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2c5c::,2804:2c5c:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2c60::,2804:2c60:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2c64::,2804:2c64:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2c68::,2804:2c68:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2c6c::,2804:2c6c:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2c70::,2804:2c70:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2c74::,2804:2c74:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2c78::,2804:2c78:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2c7c::,2804:2c7c:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2c80::,2804:2c80:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2c84::,2804:2c84:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2c88::,2804:2c88:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2c8c::,2804:2c8c:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2c90::,2804:2c90:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2c94::,2804:2c94:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2c98::,2804:2c98:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2c9c::,2804:2c9c:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2ca0::,2804:2ca0:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2ca4::,2804:2ca4:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2ca8::,2804:2ca8:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2cac::,2804:2cac:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2cb0::,2804:2cb0:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2cb4::,2804:2cb4:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2cb8::,2804:2cb8:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2cbc::,2804:2cbc:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2cc0::,2804:2cc0:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2cc4::,2804:2cc4:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2cc8::,2804:2cc8:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2ccc::,2804:2ccc:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2cd0::,2804:2cd0:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2cd4::,2804:2cd4:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2cd8::,2804:2cd8:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2cdc::,2804:2cdc:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2ce0::,2804:2ce0:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2ce4::,2804:2ce4:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2ce8::,2804:2ce8:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2cec::,2804:2cec:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2cf0::,2804:2cf0:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2cf4::,2804:2cf4:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2cf8::,2804:2cf8:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2cfc::,2804:2cfc:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2d00::,2804:2d00:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2d04::,2804:2d04:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2d08::,2804:2d08:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2d0c::,2804:2d0c:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2d10::,2804:2d10:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2d14::,2804:2d14:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2d18::,2804:2d18:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2d1c::,2804:2d1c:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2d20::,2804:2d20:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2d24::,2804:2d24:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2d28::,2804:2d28:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2d2c::,2804:2d2c:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2d30::,2804:2d30:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2d34::,2804:2d34:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2d38::,2804:2d38:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2d3c::,2804:2d3c:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2d40::,2804:2d40:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2d44::,2804:2d44:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2d48::,2804:2d48:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2d4c::,2804:2d4c:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2d50::,2804:2d50:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2d54::,2804:2d54:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2d58::,2804:2d58:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2d5c::,2804:2d5c:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2d60::,2804:2d60:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2d64::,2804:2d64:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2d68::,2804:2d68:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2d6c::,2804:2d6c:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2d70::,2804:2d70:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2d74::,2804:2d74:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2d78::,2804:2d78:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2d7c::,2804:2d7c:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2d80::,2804:2d80:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2d84::,2804:2d84:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2d88::,2804:2d88:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2d8c::,2804:2d8c:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2d90::,2804:2d90:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2d94::,2804:2d94:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2d98::,2804:2d98:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2d9c::,2804:2d9c:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2da0::,2804:2da0:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2da4::,2804:2da4:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2da8::,2804:2da8:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2dac::,2804:2dac:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2db0::,2804:2db0:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2db4::,2804:2db4:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2db8::,2804:2db8:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2dbc::,2804:2dbc:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2dc0::,2804:2dc0:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2dc4::,2804:2dc4:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2dc8::,2804:2dc8:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2dcc::,2804:2dcc:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2dd0::,2804:2dd0:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2dd4::,2804:2dd4:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2dd8::,2804:2dd8:ffff:ffff:ffff:ffff:ffff:ffff,BR
+2804:2ddc::,2804:2ddc:ffff:ffff:ffff:ffff:ffff:ffff,BR
 2806::,2806:f:ffff:ffff:ffff:ffff:ffff:ffff,MX
-2806:200::,2806:20a:ffff:ffff:ffff:ffff:ffff:ffff,MX
-2806:210::,2806:216::ffff:ffff:ffff:ffff:ffff,MX
-2806:217::,2806:21d:ffff:ffff:ffff:ffff:ffff:ffff,MX
-2806:220::,2806:220:ffff:ffff:ffff:ffff:ffff:ffff,MX
+2806:200::,2806:216::ffff:ffff:ffff:ffff:ffff,MX
+2806:217::,2806:220:ffff:ffff:ffff:ffff:ffff:ffff,MX
 2806:230::,2806:230:ffff:ffff:ffff:ffff:ffff:ffff,MX
 2806:238::,2806:238::ffff:ffff:ffff:ffff:ffff,MX
 2806:238:10::,2806:238:10:ffff:ffff:ffff:ffff:ffff,MX
@@ -15479,7 +17495,7 @@
 2a00:d70::,2a00:d70:ffff:ffff:ffff:ffff:ffff:ffff,CH
 2a00:d78::,2a00:d78:ffff:ffff:ffff:ffff:ffff:ffff,NL
 2a00:d80::,2a00:d80:ffff:ffff:ffff:ffff:ffff:ffff,CH
-2a00:d88::,2a00:d88:ffff:ffff:ffff:ffff:ffff:ffff,AT
+2a00:d88::,2a00:d8f:ffff:ffff:ffff:ffff:ffff:ffff,AT
 2a00:d90::,2a00:d90:ffff:ffff:ffff:ffff:ffff:ffff,SE
 2a00:d98::,2a00:d98:ffff:ffff:ffff:ffff:ffff:ffff,RU
 2a00:da8::,2a00:da9:ffff:ffff:ffff:ffff:ffff:ffff,DE
@@ -15521,9 +17537,10 @@
 2a00:ee8::,2a00:ee8:ffff:ffff:ffff:ffff:ffff:ffff,DE
 2a00:ef0::,2a00:ef0:ffff:ffff:ffff:ffff:ffff:ffff,DK
 2a00:ef8::,2a00:ef8:ffff:ffff:ffff:ffff:ffff:ffff,NO
-2a00:f00::,2a00:f00:ffff:ffff:ffff:ffff:ffff:ffff,RU
-2a00:f08::,2a00:f08:ffff:ffff:ffff:ffff:ffff:ffff,RU
-2a00:f10::,2a00:f17:ffff:ffff:ffff:ffff:ffff:ffff,NL
+2a00:f00::,2a00:f08:ffff:ffff:ffff:ffff:ffff:ffff,RU
+2a00:f10::,2a00:f10:120:ffff:ffff:ffff:ffff:ffff,NL
+2a00:f10:121::,2a00:f10:121:7fff:ffff:ffff:ffff:ffff,FR
+2a00:f10:121:8000::,2a00:f17:ffff:ffff:ffff:ffff:ffff:ffff,NL
 2a00:f18::,2a00:f18:ffff:ffff:ffff:ffff:ffff:ffff,GB
 2a00:f20::,2a00:f20:ffff:ffff:ffff:ffff:ffff:ffff,IT
 2a00:f28::,2a00:f2f:ffff:ffff:ffff:ffff:ffff:ffff,AE
@@ -15562,7 +17579,9 @@
 2a00:1040::,2a00:1040:ffff:ffff:ffff:ffff:ffff:ffff,DK
 2a00:1048::,2a00:1048:ffff:ffff:ffff:ffff:ffff:ffff,NL
 2a00:1050::,2a00:1050:ffff:ffff:ffff:ffff:ffff:ffff,DE
-2a00:1058::,2a00:1058:ffff:ffff:ffff:ffff:ffff:ffff,FR
+2a00:1058::,2a00:1058:111:ffff:ffff:ffff:ffff:ffff,FR
+2a00:1058:112::,2a00:1058:112:7fff:ffff:ffff:ffff:ffff,GB
+2a00:1058:112:8000::,2a00:1058:ffff:ffff:ffff:ffff:ffff:ffff,FR
 2a00:1060::,2a00:1060:ffff:ffff:ffff:ffff:ffff:ffff,MT
 2a00:1068::,2a00:1068:ffff:ffff:ffff:ffff:ffff:ffff,GB
 2a00:1070::,2a00:1070:ffff:ffff:ffff:ffff:ffff:ffff,GB
@@ -15596,7 +17615,9 @@
 2a00:1160::,2a00:1167:ffff:ffff:ffff:ffff:ffff:ffff,GB
 2a00:1168::,2a00:116f:ffff:ffff:ffff:ffff:ffff:ffff,NL
 2a00:1170::,2a00:1170:ffff:ffff:ffff:ffff:ffff:ffff,IE
-2a00:1178::,2a00:1178:ffff:ffff:ffff:ffff:ffff:ffff,NL
+2a00:1178::,2a00:1178::ffff:ffff:ffff:ffff:ffff,NL
+2a00:1178:1::,2a00:1178:1:7fff:ffff:ffff:ffff:ffff,US
+2a00:1178:1:8000::,2a00:1178:ffff:ffff:ffff:ffff:ffff:ffff,NL
 2a00:1180::,2a00:1180:ffff:ffff:ffff:ffff:ffff:ffff,DE
 2a00:1188::,2a00:1188:ffff:ffff:ffff:ffff:ffff:ffff,NL
 2a00:1190::,2a00:1190:ffff:ffff:ffff:ffff:ffff:ffff,FI
@@ -15604,7 +17625,15 @@
 2a00:11a8::,2a00:11a8:ffff:ffff:ffff:ffff:ffff:ffff,OM
 2a00:11b0::,2a00:11b0:ffff:ffff:ffff:ffff:ffff:ffff,CZ
 2a00:11b8::,2a00:11b8:ffff:ffff:ffff:ffff:ffff:ffff,GB
-2a00:11c0::,2a00:11c0:ffff:ffff:ffff:ffff:ffff:ffff,AT
+2a00:11c0::,2a00:11c0:4:ffff:ffff:ffff:ffff:ffff,AT
+2a00:11c0:5::,2a00:11c0:5:7fff:ffff:ffff:ffff:ffff,CH
+2a00:11c0:5:8000::,2a00:11c0:7:ffff:ffff:ffff:ffff:ffff,AT
+2a00:11c0:8::,2a00:11c0:8:ffff:ffff:ffff:ffff:ffff,GB
+2a00:11c0:9::,2a00:11c0:a:ffff:ffff:ffff:ffff:ffff,AT
+2a00:11c0:b::,2a00:11c0:b:ffff:ffff:ffff:ffff:ffff,IT
+2a00:11c0:c::,2a00:11c0:62:ffff:ffff:ffff:ffff:ffff,AT
+2a00:11c0:63::,2a00:11c0:63:ffff:ffff:ffff:ffff:ffff,NL
+2a00:11c0:64::,2a00:11c0:ffff:ffff:ffff:ffff:ffff:ffff,AT
 2a00:11c8::,2a00:11c8:ffff:ffff:ffff:ffff:ffff:ffff,GB
 2a00:11d0::,2a00:11d0:ffff:ffff:ffff:ffff:ffff:ffff,AT
 2a00:11d8::,2a00:11d8:ffff:ffff:ffff:ffff:ffff:ffff,RU
@@ -15635,7 +17664,7 @@
 2a00:12b0::,2a00:12b0:ffff:ffff:ffff:ffff:ffff:ffff,FR
 2a00:12c0::,2a00:12c7:ffff:ffff:ffff:ffff:ffff:ffff,DE
 2a00:12c8::,2a00:12c8:ffff:ffff:ffff:ffff:ffff:ffff,RU
-2a00:12d0::,2a00:12d8:ffff:ffff:ffff:ffff:ffff:ffff,DE
+2a00:12d0::,2a00:12df:ffff:ffff:ffff:ffff:ffff:ffff,DE
 2a00:12e0::,2a00:12e0:ffff:ffff:ffff:ffff:ffff:ffff,AT
 2a00:12e8::,2a00:12e8:ffff:ffff:ffff:ffff:ffff:ffff,DE
 2a00:12f0::,2a00:12f0:ffff:ffff:ffff:ffff:ffff:ffff,NL
@@ -15669,7 +17698,7 @@
 2a00:13e0::,2a00:13e0:ffff:ffff:ffff:ffff:ffff:ffff,NO
 2a00:13e8::,2a00:13e8:ffff:ffff:ffff:ffff:ffff:ffff,SE
 2a00:13f0::,2a00:13f0:ffff:ffff:ffff:ffff:ffff:ffff,FI
-2a00:13f8::,2a00:13f8:ffff:ffff:ffff:ffff:ffff:ffff,RU
+2a00:13f8::,2a00:13ff:ffff:ffff:ffff:ffff:ffff:ffff,RU
 2a00:1400::,2a00:1400:ffff:ffff:ffff:ffff:ffff:ffff,NO
 2a00:1408::,2a00:1408:ffff:ffff:ffff:ffff:ffff:ffff,DE
 2a00:1410::,2a00:1410:ffff:ffff:ffff:ffff:ffff:ffff,RU
@@ -15702,7 +17731,7 @@
 2a00:14c0::,2a00:14c0:ffff:ffff:ffff:ffff:ffff:ffff,FI
 2a00:14c8::,2a00:14c8:ffff:ffff:ffff:ffff:ffff:ffff,GB
 2a00:14d0::,2a00:14d0:ffff:ffff:ffff:ffff:ffff:ffff,RU
-2a00:14d8::,2a00:14d8:ffff:ffff:ffff:ffff:ffff:ffff,NO
+2a00:14d8::,2a00:14df:ffff:ffff:ffff:ffff:ffff:ffff,NO
 2a00:14e0::,2a00:14e0:ffff:ffff:ffff:ffff:ffff:ffff,DE
 2a00:14e8::,2a00:14ef:ffff:ffff:ffff:ffff:ffff:ffff,FR
 2a00:14f0::,2a00:14f0:ffff:ffff:ffff:ffff:ffff:ffff,GB
@@ -15713,7 +17742,6 @@
 2a00:1518::,2a00:1518:ffff:ffff:ffff:ffff:ffff:ffff,RU
 2a00:1520::,2a00:1520:ffff:ffff:ffff:ffff:ffff:ffff,SE
 2a00:1528::,2a00:1528:ffff:ffff:ffff:ffff:ffff:ffff,BE
-2a00:1530::,2a00:1531:ffff:ffff:ffff:ffff:ffff:ffff,HU
 2a00:1538::,2a00:1538:ffff:ffff:ffff:ffff:ffff:ffff,GB
 2a00:1540::,2a00:1540:ffff:ffff:ffff:ffff:ffff:ffff,GB
 2a00:1548::,2a00:1548:ffff:ffff:ffff:ffff:ffff:ffff,NO
@@ -15794,6 +17822,7 @@
 2a00:17f8::,2a00:17f8:ffff:ffff:ffff:ffff:ffff:ffff,GB
 2a00:1800::,2a00:1800:ffff:ffff:ffff:ffff:ffff:ffff,CZ
 2a00:1808::,2a00:1808:ffff:ffff:ffff:ffff:ffff:ffff,CZ
+2a00:1810::,2a00:1810:ffff:ffff:ffff:ffff:ffff:ffff,LV
 2a00:1818::,2a00:1818:ffff:ffff:ffff:ffff:ffff:ffff,RU
 2a00:1828::,2a00:1828:ffff:ffff:ffff:ffff:ffff:ffff,DE
 2a00:1830::,2a00:1830:ffff:ffff:ffff:ffff:ffff:ffff,DE
@@ -15808,7 +17837,7 @@
 2a00:1880::,2a00:1880:ffff:ffff:ffff:ffff:ffff:ffff,TR
 2a00:1888::,2a00:1888:ffff:ffff:ffff:ffff:ffff:ffff,FR
 2a00:1890::,2a00:1897:ffff:ffff:ffff:ffff:ffff:ffff,DE
-2a00:1898::,2a00:1898:ffff:ffff:ffff:ffff:ffff:ffff,RU
+2a00:1898::,2a00:189f:ffff:ffff:ffff:ffff:ffff:ffff,RU
 2a00:18a0::,2a00:18a0:ffff:ffff:ffff:ffff:ffff:ffff,NL
 2a00:18a8::,2a00:18a8:ffff:ffff:ffff:ffff:ffff:ffff,FR
 2a00:18b0::,2a00:18b0:ffff:ffff:ffff:ffff:ffff:ffff,NL
@@ -15847,7 +17876,7 @@
 2a00:19b8::,2a00:19b8:ffff:ffff:ffff:ffff:ffff:ffff,GB
 2a00:19c0::,2a00:19c0:ffff:ffff:ffff:ffff:ffff:ffff,NL
 2a00:19c8::,2a00:19c8:ffff:ffff:ffff:ffff:ffff:ffff,DE
-2a00:19d0::,2a00:19d0:ffff:ffff:ffff:ffff:ffff:ffff,DE
+2a00:19d0::,2a00:19d7:ffff:ffff:ffff:ffff:ffff:ffff,DE
 2a00:19d8::,2a00:19d8:ffff:ffff:ffff:ffff:ffff:ffff,GB
 2a00:19e0::,2a00:19e7:ffff:ffff:ffff:ffff:ffff:ffff,DE
 2a00:19e8::,2a00:19e8:ffff:ffff:ffff:ffff:ffff:ffff,GB
@@ -15858,7 +17887,9 @@
 2a00:1a10::,2a00:1a10:ffff:ffff:ffff:ffff:ffff:ffff,GB
 2a00:1a18::,2a00:1a18:ffff:ffff:ffff:ffff:ffff:ffff,DE
 2a00:1a20::,2a00:1a20:ffff:ffff:ffff:ffff:ffff:ffff,SI
-2a00:1a28::,2a00:1a28:ffff:ffff:ffff:ffff:ffff:ffff,SE
+2a00:1a28::,2a00:1a28:1162:ffff:ffff:ffff:ffff:ffff,SE
+2a00:1a28:1163::,2a00:1a28:1163:7fff:ffff:ffff:ffff:ffff,GB
+2a00:1a28:1163:8000::,2a00:1a28:ffff:ffff:ffff:ffff:ffff:ffff,SE
 2a00:1a30::,2a00:1a30:ffff:ffff:ffff:ffff:ffff:ffff,GB
 2a00:1a38::,2a00:1a38:ffff:ffff:ffff:ffff:ffff:ffff,RU
 2a00:1a40::,2a00:1a40:ffff:ffff:ffff:ffff:ffff:ffff,PL
@@ -15957,7 +17988,7 @@
 2a00:1d18::,2a00:1d18:ffff:ffff:ffff:ffff:ffff:ffff,PL
 2a00:1d20::,2a00:1d27:ffff:ffff:ffff:ffff:ffff:ffff,NL
 2a00:1d28::,2a00:1d28:ffff:ffff:ffff:ffff:ffff:ffff,SE
-2a00:1d30::,2a00:1d30:ffff:ffff:ffff:ffff:ffff:ffff,TR
+2a00:1d30::,2a00:1d37:ffff:ffff:ffff:ffff:ffff:ffff,TR
 2a00:1d38::,2a00:1d38:ffff:ffff:ffff:ffff:ffff:ffff,NL
 2a00:1d40::,2a00:1d40:ffff:ffff:ffff:ffff:ffff:ffff,GB
 2a00:1d48::,2a00:1d48:ffff:ffff:ffff:ffff:ffff:ffff,DE
@@ -16012,7 +18043,6 @@
 2a00:1ed8::,2a00:1edf:ffff:ffff:ffff:ffff:ffff:ffff,IE
 2a00:1ee0::,2a00:1ee0:ffff:ffff:ffff:ffff:ffff:ffff,GB
 2a00:1ee8::,2a00:1ee8:ffff:ffff:ffff:ffff:ffff:ffff,SY
-2a00:1ef0::,2a00:1ef0:ffff:ffff:ffff:ffff:ffff:ffff,BG
 2a00:1ef8::,2a00:1eff:ffff:ffff:ffff:ffff:ffff:ffff,SA
 2a00:1f00::,2a00:1f00:ffff:ffff:ffff:ffff:ffff:ffff,NL
 2a00:1f08::,2a00:1f08:ffff:ffff:ffff:ffff:ffff:ffff,DE
@@ -16025,7 +18055,7 @@
 2a00:1f40::,2a00:1f47:ffff:ffff:ffff:ffff:ffff:ffff,HU
 2a00:1f48::,2a00:1f48:ffff:ffff:ffff:ffff:ffff:ffff,IT
 2a00:1f50::,2a00:1f50:ffff:ffff:ffff:ffff:ffff:ffff,FI
-2a00:1f58::,2a00:1f58:ffff:ffff:ffff:ffff:ffff:ffff,AT
+2a00:1f58::,2a00:1f5f:ffff:ffff:ffff:ffff:ffff:ffff,AT
 2a00:1f60::,2a00:1f60:ffff:ffff:ffff:ffff:ffff:ffff,FR
 2a00:1f68::,2a00:1f68:ffff:ffff:ffff:ffff:ffff:ffff,GR
 2a00:1f70::,2a00:1f70:ffff:ffff:ffff:ffff:ffff:ffff,RU
@@ -16034,11 +18064,11 @@
 2a00:1f88::,2a00:1f88:ffff:ffff:ffff:ffff:ffff:ffff,AT
 2a00:1f90::,2a00:1f90:ffff:ffff:ffff:ffff:ffff:ffff,TR
 2a00:1f98::,2a00:1f98:ffff:ffff:ffff:ffff:ffff:ffff,DK
-2a00:1fa0::,2a00:1fa0:ffff:ffff:ffff:ffff:ffff:ffff,RU
+2a00:1fa0::,2a00:1fa7:ffff:ffff:ffff:ffff:ffff:ffff,RU
 2a00:1fa8::,2a00:1fa8:ffff:ffff:ffff:ffff:ffff:ffff,GL
 2a00:1fb0::,2a00:1fb0:ffff:ffff:ffff:ffff:ffff:ffff,GB
 2a00:1fb8::,2a00:1fb8:ffff:ffff:ffff:ffff:ffff:ffff,NL
-2a00:1fc0::,2a00:1fc0:ffff:ffff:ffff:ffff:ffff:ffff,RU
+2a00:1fc0::,2a00:1fc7:ffff:ffff:ffff:ffff:ffff:ffff,RU
 2a00:1fd0::,2a00:1fd0:ffff:ffff:ffff:ffff:ffff:ffff,GB
 2a00:1fd8::,2a00:1fd8:ffff:ffff:ffff:ffff:ffff:ffff,DE
 2a00:1fe0::,2a00:1fe0:ffff:ffff:ffff:ffff:ffff:ffff,IR
@@ -16069,6 +18099,7 @@
 2a00:4280::,2a00:4280:ffff:ffff:ffff:ffff:ffff:ffff,FR
 2a00:42a0::,2a00:42a0:ffff:ffff:ffff:ffff:ffff:ffff,GB
 2a00:42c0::,2a00:42c0:ffff:ffff:ffff:ffff:ffff:ffff,FR
+2a00:42e0::,2a00:42e0:ffff:ffff:ffff:ffff:ffff:ffff,DE
 2a00:4300::,2a00:4300:ffff:ffff:ffff:ffff:ffff:ffff,GB
 2a00:4320::,2a00:4320:ffff:ffff:ffff:ffff:ffff:ffff,DE
 2a00:4340::,2a00:4340:ffff:ffff:ffff:ffff:ffff:ffff,GB
@@ -16108,6 +18139,7 @@
 2a00:4780::,2a00:4780:ffff:ffff:ffff:ffff:ffff:ffff,FR
 2a00:47a0::,2a00:47a0:ffff:ffff:ffff:ffff:ffff:ffff,KG
 2a00:47c0::,2a00:47c0:ffff:ffff:ffff:ffff:ffff:ffff,GB
+2a00:47e0::,2a00:47e0:ffff:ffff:ffff:ffff:ffff:ffff,DK
 2a00:4800::,2a00:4807:ffff:ffff:ffff:ffff:ffff:ffff,BG
 2a00:4820::,2a00:4820:ffff:ffff:ffff:ffff:ffff:ffff,DK
 2a00:4840::,2a00:4847:ffff:ffff:ffff:ffff:ffff:ffff,DE
@@ -16206,12 +18238,14 @@
 2a00:5400::,2a00:5400:ffff:ffff:ffff:ffff:ffff:ffff,SA
 2a00:5420::,2a00:5420:ffff:ffff:ffff:ffff:ffff:ffff,GB
 2a00:5440::,2a00:5440:ffff:ffff:ffff:ffff:ffff:ffff,US
-2a00:5460::,2a00:5460:ffff:ffff:ffff:ffff:ffff:ffff,NL
 2a00:5480::,2a00:5487:ffff:ffff:ffff:ffff:ffff:ffff,CH
 2a00:54a0::,2a00:54a0:ffff:ffff:ffff:ffff:ffff:ffff,TR
 2a00:54c0::,2a00:54c0:ffff:ffff:ffff:ffff:ffff:ffff,PL
 2a00:54e0::,2a00:54e0:ffff:ffff:ffff:ffff:ffff:ffff,IT
-2a00:5500::,2a00:5500:ffff:ffff:ffff:ffff:ffff:ffff,FI
+2a00:5500::,2a00:5500::7fff:ffff:ffff:ffff:ffff,AX
+2a00:5500:0:8000::,2a00:5500:1:ffff:ffff:ffff:ffff:ffff,FI
+2a00:5500:2::,2a00:5500:2:7fff:ffff:ffff:ffff:ffff,AX
+2a00:5500:2:8000::,2a00:5500:ffff:ffff:ffff:ffff:ffff:ffff,FI
 2a00:5520::,2a00:5520:ffff:ffff:ffff:ffff:ffff:ffff,FR
 2a00:5540::,2a00:5540:385:ffff:ffff:ffff:ffff:ffff,GB
 2a00:5540:386::,2a00:5540:387:ffff:ffff:ffff:ffff:ffff,SI
@@ -16328,7 +18362,7 @@
 2a00:6360::,2a00:6360:ffff:ffff:ffff:ffff:ffff:ffff,DE
 2a00:6380::,2a00:6380:ffff:ffff:ffff:ffff:ffff:ffff,IR
 2a00:63a0::,2a00:63a0:ffff:ffff:ffff:ffff:ffff:ffff,IR
-2a00:63c0::,2a00:63c0:ffff:ffff:ffff:ffff:ffff:ffff,AT
+2a00:63c0::,2a00:63c7:ffff:ffff:ffff:ffff:ffff:ffff,AT
 2a00:63e0::,2a00:63e0:ffff:ffff:ffff:ffff:ffff:ffff,FR
 2a00:6400::,2a00:6400:ffff:ffff:ffff:ffff:ffff:ffff,DE
 2a00:6420::,2a00:6420:ffff:ffff:ffff:ffff:ffff:ffff,FR
@@ -16350,9 +18384,11 @@
 2a00:6620::,2a00:6620:ffff:ffff:ffff:ffff:ffff:ffff,GR
 2a00:6640::,2a00:6647:ffff:ffff:ffff:ffff:ffff:ffff,ES
 2a00:6660::,2a00:6660:ffff:ffff:ffff:ffff:ffff:ffff,SE
+2a00:6680::,2a00:6680:ffff:ffff:ffff:ffff:ffff:ffff,DE
 2a00:66a0::,2a00:66a0:ffff:ffff:ffff:ffff:ffff:ffff,IL
 2a00:66c0::,2a00:66c0:ffff:ffff:ffff:ffff:ffff:ffff,SE
 2a00:66e0::,2a00:66e0:ffff:ffff:ffff:ffff:ffff:ffff,TR
+2a00:6700::,2a00:6700:ffff:ffff:ffff:ffff:ffff:ffff,DE
 2a00:6720::,2a00:6720:ffff:ffff:ffff:ffff:ffff:ffff,DE
 2a00:6740::,2a00:6740:ffff:ffff:ffff:ffff:ffff:ffff,UA
 2a00:6760::,2a00:6760:ffff:ffff:ffff:ffff:ffff:ffff,FR
@@ -16367,6 +18403,7 @@
 2a00:6880::,2a00:6880:ffff:ffff:ffff:ffff:ffff:ffff,LT
 2a00:68a0::,2a00:68a0:ffff:ffff:ffff:ffff:ffff:ffff,AE
 2a00:68c0::,2a00:68c0:ffff:ffff:ffff:ffff:ffff:ffff,FR
+2a00:68e0::,2a00:68e0:ffff:ffff:ffff:ffff:ffff:ffff,RU
 2a00:6900::,2a00:6900:ffff:ffff:ffff:ffff:ffff:ffff,FR
 2a00:6920::,2a00:6920:ffff:ffff:ffff:ffff:ffff:ffff,LB
 2a00:6940::,2a00:6940:ffff:ffff:ffff:ffff:ffff:ffff,ES
@@ -16501,10 +18538,30 @@
 2a00:7980::,2a00:7980:ffff:ffff:ffff:ffff:ffff:ffff,RU
 2a00:79a0::,2a00:79a0:ffff:ffff:ffff:ffff:ffff:ffff,RU
 2a00:79c0::,2a00:79c0:ffff:ffff:ffff:ffff:ffff:ffff,DE
-2a00:79e0::,2a00:79e0:13:ffff:ffff:ffff:ffff:ffff,CH
+2a00:79e0::,2a00:79e0::ffff:ffff:ffff:ffff:ffff,CH
+2a00:79e0:1::,2a00:79e0:1:7fff:ffff:ffff:ffff:ffff,CZ
+2a00:79e0:1:8000::,2a00:79e0:1:ffff:ffff:ffff:ffff:ffff,CH
+2a00:79e0:2::,2a00:79e0:2:7fff:ffff:ffff:ffff:ffff,PL
+2a00:79e0:2:8000::,2a00:79e0:2:ffff:ffff:ffff:ffff:ffff,CH
+2a00:79e0:3::,2a00:79e0:3:7fff:ffff:ffff:ffff:ffff,IE
+2a00:79e0:3:8000::,2a00:79e0:4:7fff:ffff:ffff:ffff:ffff,CH
+2a00:79e0:4:8000::,2a00:79e0:4:ffff:ffff:ffff:ffff:ffff,FI
+2a00:79e0:5::,2a00:79e0:5:ffff:ffff:ffff:ffff:ffff,CH
+2a00:79e0:6::,2a00:79e0:6:ffff:ffff:ffff:ffff:ffff,GB
+2a00:79e0:7::,2a00:79e0:a:7fff:ffff:ffff:ffff:ffff,CH
+2a00:79e0:a:8000::,2a00:79e0:a:ffff:ffff:ffff:ffff:ffff,GB
+2a00:79e0:b::,2a00:79e0:b:ffff:ffff:ffff:ffff:ffff,IT
+2a00:79e0:c::,2a00:79e0:c:ffff:ffff:ffff:ffff:ffff,GB
+2a00:79e0:d::,2a00:79e0:13:ffff:ffff:ffff:ffff:ffff,CH
 2a00:79e0:14::,2a00:79e0:14:ffff:ffff:ffff:ffff:ffff,ZA
 2a00:79e0:15::,2a00:79e0:15:ffff:ffff:ffff:ffff:ffff,DE
-2a00:79e0:16::,2a00:79e0:ffff:ffff:ffff:ffff:ffff:ffff,CH
+2a00:79e0:16::,2a00:79e0:1b:ffff:ffff:ffff:ffff:ffff,CH
+2a00:79e0:1c::,2a00:79e0:1c:ffff:ffff:ffff:ffff:ffff,GH
+2a00:79e0:1d::,2a00:79e0:1e:ffff:ffff:ffff:ffff:ffff,CH
+2a00:79e0:1f::,2a00:79e0:1f:ffff:ffff:ffff:ffff:ffff,LT
+2a00:79e0:20::,2a00:79e0:22:ffff:ffff:ffff:ffff:ffff,CH
+2a00:79e0:23::,2a00:79e0:23:ffff:ffff:ffff:ffff:ffff,GB
+2a00:79e0:24::,2a00:79e1:ffff:ffff:ffff:ffff:ffff:ffff,CH
 2a00:7a00::,2a00:7a00:ffff:ffff:ffff:ffff:ffff:ffff,NO
 2a00:7a20::,2a00:7a20:ffff:ffff:ffff:ffff:ffff:ffff,FI
 2a00:7a40::,2a00:7a40:ffff:ffff:ffff:ffff:ffff:ffff,GB
@@ -16522,7 +18579,6 @@
 2a00:7be0::,2a00:7be0:ffff:ffff:ffff:ffff:ffff:ffff,QA
 2a00:7c00::,2a00:7c00:ffff:ffff:ffff:ffff:ffff:ffff,RU
 2a00:7c20::,2a00:7c20:ffff:ffff:ffff:ffff:ffff:ffff,DE
-2a00:7c40::,2a00:7c40:ffff:ffff:ffff:ffff:ffff:ffff,GB
 2a00:7c60::,2a00:7c60:ffff:ffff:ffff:ffff:ffff:ffff,NL
 2a00:7c80::,2a00:7c87:ffff:ffff:ffff:ffff:ffff:ffff,NL
 2a00:7ca0::,2a00:7ca0:ffff:ffff:ffff:ffff:ffff:ffff,IT
@@ -16618,6 +18674,8 @@
 2a00:8800::,2a00:8800:ffff:ffff:ffff:ffff:ffff:ffff,DE
 2a00:8820::,2a00:8820:ffff:ffff:ffff:ffff:ffff:ffff,SA
 2a00:8840::,2a00:8840:ffff:ffff:ffff:ffff:ffff:ffff,UZ
+2a00:8860:8001::,2a00:8860:8001:7fff:ffff:ffff:ffff:ffff,US
+2a00:8860:8007::,2a00:8860:8007:7fff:ffff:ffff:ffff:ffff,US
 2a00:8880::,2a00:8880:ffff:ffff:ffff:ffff:ffff:ffff,FR
 2a00:88a0::,2a00:88a0:ffff:ffff:ffff:ffff:ffff:ffff,FR
 2a00:88c0::,2a00:88c0:ffff:ffff:ffff:ffff:ffff:ffff,RU
@@ -16648,7 +18706,6 @@
 2a00:8be0::,2a00:8be7:ffff:ffff:ffff:ffff:ffff:ffff,NO
 2a00:8c00::,2a00:8c00:ffff:ffff:ffff:ffff:ffff:ffff,LT
 2a00:8c20::,2a00:8c20:ffff:ffff:ffff:ffff:ffff:ffff,DE
-2a00:8c40::,2a00:8c40:ffff:ffff:ffff:ffff:ffff:ffff,NL
 2a00:8c60::,2a00:8c60:ffff:ffff:ffff:ffff:ffff:ffff,IT
 2a00:8c80::,2a00:8c80:ffff:ffff:ffff:ffff:ffff:ffff,IE
 2a00:8ca0::,2a00:8ca0:ffff:ffff:ffff:ffff:ffff:ffff,BA
@@ -16722,7 +18779,7 @@
 2a00:9560::,2a00:9560:ffff:ffff:ffff:ffff:ffff:ffff,FI
 2a00:9580::,2a00:9580:ffff:ffff:ffff:ffff:ffff:ffff,GB
 2a00:95a0::,2a00:95a0:ffff:ffff:ffff:ffff:ffff:ffff,RU
-2a00:95c0::,2a00:95c0:ffff:ffff:ffff:ffff:ffff:ffff,GB
+2a00:95c0::,2a00:95c0:ffff:ffff:ffff:ffff:ffff:ffff,US
 2a00:95e0::,2a00:95e0:ffff:ffff:ffff:ffff:ffff:ffff,GB
 2a00:9600::,2a00:9600:83ff:ffff:ffff:ffff:ffff:ffff,GB
 2a00:9600:8400::,2a00:9600:8400:ffff:ffff:ffff:ffff:ffff,US
@@ -16771,7 +18828,6 @@
 2a00:9ae0::,2a00:9ae0:ffff:ffff:ffff:ffff:ffff:ffff,DE
 2a00:9b00::,2a00:9b00:ffff:ffff:ffff:ffff:ffff:ffff,FI
 2a00:9b20::,2a00:9b20:ffff:ffff:ffff:ffff:ffff:ffff,IR
-2a00:9b40::,2a00:9b40:ffff:ffff:ffff:ffff:ffff:ffff,KZ
 2a00:9b60::,2a00:9b60:ffff:ffff:ffff:ffff:ffff:ffff,NL
 2a00:9b80::,2a00:9b80:ffff:ffff:ffff:ffff:ffff:ffff,BE
 2a00:9ba0::,2a00:9ba0:ffff:ffff:ffff:ffff:ffff:ffff,GB
@@ -16853,7 +18909,9 @@
 2a00:a520::,2a00:a520:ffff:ffff:ffff:ffff:ffff:ffff,DE
 2a00:a540::,2a00:a540:ffff:ffff:ffff:ffff:ffff:ffff,NO
 2a00:a560::,2a00:a560:ffff:ffff:ffff:ffff:ffff:ffff,PL
-2a00:a580::,2a00:a580:ffff:ffff:ffff:ffff:ffff:ffff,FR
+2a00:a580::,2a00:a580:10a4:ffff:ffff:ffff:ffff:ffff,FR
+2a00:a580:10a5::,2a00:a580:10a5:7fff:ffff:ffff:ffff:ffff,DE
+2a00:a580:10a5:8000::,2a00:a580:ffff:ffff:ffff:ffff:ffff:ffff,FR
 2a00:a5a0::,2a00:a5a0:ffff:ffff:ffff:ffff:ffff:ffff,CZ
 2a00:a5c0::,2a00:a5c0:ffff:ffff:ffff:ffff:ffff:ffff,NL
 2a00:a5e0::,2a00:a5e0:ffff:ffff:ffff:ffff:ffff:ffff,RU
@@ -16941,6 +18999,7 @@
 2a00:b040::,2a00:b040:ffff:ffff:ffff:ffff:ffff:ffff,GB
 2a00:b060::,2a00:b060:ffff:ffff:ffff:ffff:ffff:ffff,BE
 2a00:b080::,2a00:b080:ffff:ffff:ffff:ffff:ffff:ffff,ES
+2a00:b0a0::,2a00:b0a0:ffff:ffff:ffff:ffff:ffff:ffff,CH
 2a00:b0c0::,2a00:b0c0:ffff:ffff:ffff:ffff:ffff:ffff,HU
 2a00:b0e0::,2a00:b0e0:ffff:ffff:ffff:ffff:ffff:ffff,GB
 2a00:b100::,2a00:b100:ffff:ffff:ffff:ffff:ffff:ffff,RU
@@ -17009,7 +19068,7 @@
 2a00:b920::,2a00:b920:ffff:ffff:ffff:ffff:ffff:ffff,DK
 2a00:b940::,2a00:b940:ffff:ffff:ffff:ffff:ffff:ffff,RU
 2a00:b960::,2a00:b960:ffff:ffff:ffff:ffff:ffff:ffff,PL
-2a00:b980::,2a00:b981:ffff:ffff:ffff:ffff:ffff:ffff,GB
+2a00:b980::,2a00:b987:ffff:ffff:ffff:ffff:ffff:ffff,GB
 2a00:b9a0::,2a00:b9a0:ffff:ffff:ffff:ffff:ffff:ffff,FI
 2a00:b9c0::,2a00:b9c0:ffff:ffff:ffff:ffff:ffff:ffff,DE
 2a00:b9e0::,2a00:b9e0:ffff:ffff:ffff:ffff:ffff:ffff,EE
@@ -17035,7 +19094,6 @@
 2a00:bc60::,2a00:bc60:ffff:ffff:ffff:ffff:ffff:ffff,IR
 2a00:bc80::,2a00:bc80:ffff:ffff:ffff:ffff:ffff:ffff,FR
 2a00:bca0::,2a00:bca0:ffff:ffff:ffff:ffff:ffff:ffff,NL
-2a00:bcc0::,2a00:bcc0:ffff:ffff:ffff:ffff:ffff:ffff,NL
 2a00:bce0::,2a00:bce0:ffff:ffff:ffff:ffff:ffff:ffff,SE
 2a00:bd00::,2a00:bd00:ffff:ffff:ffff:ffff:ffff:ffff,CH
 2a00:bd20::,2a00:bd20:ffff:ffff:ffff:ffff:ffff:ffff,NL
@@ -17084,7 +19142,7 @@
 2a00:c2a0::,2a00:c2a0:ffff:ffff:ffff:ffff:ffff:ffff,GB
 2a00:c2c0::,2a00:c2c0:ffff:ffff:ffff:ffff:ffff:ffff,NL
 2a00:c2e0::,2a00:c2e0:ffff:ffff:ffff:ffff:ffff:ffff,FR
-2a00:c300::,2a00:c300:ffff:ffff:ffff:ffff:ffff:ffff,RU
+2a00:c300::,2a00:c307:ffff:ffff:ffff:ffff:ffff:ffff,RU
 2a00:c320::,2a00:c320:ffff:ffff:ffff:ffff:ffff:ffff,DE
 2a00:c340::,2a00:c340:ffff:ffff:ffff:ffff:ffff:ffff,FR
 2a00:c360::,2a00:c360:ffff:ffff:ffff:ffff:ffff:ffff,RU
@@ -17143,7 +19201,9 @@
 2a00:ca00::,2a00:ca07:ffff:ffff:ffff:ffff:ffff:ffff,DE
 2a00:ca20::,2a00:ca20:ffff:ffff:ffff:ffff:ffff:ffff,IE
 2a00:ca40::,2a00:ca40:ffff:ffff:ffff:ffff:ffff:ffff,DK
-2a00:ca60::,2a00:ca67:ffff:ffff:ffff:ffff:ffff:ffff,LU
+2a00:ca60::,2a00:ca60:16:7fff:ffff:ffff:ffff:ffff,LU
+2a00:ca60:16:8000::,2a00:ca60:16:ffff:ffff:ffff:ffff:ffff,GB
+2a00:ca60:17::,2a00:ca67:ffff:ffff:ffff:ffff:ffff:ffff,LU
 2a00:ca80::,2a00:ca80:ffff:ffff:ffff:ffff:ffff:ffff,CZ
 2a00:caa0::,2a00:caa0:ffff:ffff:ffff:ffff:ffff:ffff,JO
 2a00:cac0::,2a00:cac0:ffff:ffff:ffff:ffff:ffff:ffff,AT
@@ -17203,7 +19263,9 @@
 2a00:d140::,2a00:d140:ffff:ffff:ffff:ffff:ffff:ffff,RS
 2a00:d160::,2a00:d160:ffff:ffff:ffff:ffff:ffff:ffff,RU
 2a00:d180::,2a00:d180:ffff:ffff:ffff:ffff:ffff:ffff,PT
-2a00:d1a0::,2a00:d1a0:ffff:ffff:ffff:ffff:ffff:ffff,DE
+2a00:d1a0::,2a00:d1a0:f:ffff:ffff:ffff:ffff:ffff,DE
+2a00:d1a0:10::,2a00:d1a0:1f:ffff:ffff:ffff:ffff:ffff,GB
+2a00:d1a0:20::,2a00:d1a0:ffff:ffff:ffff:ffff:ffff:ffff,DE
 2a00:d1c0::,2a00:d1c0:ffff:ffff:ffff:ffff:ffff:ffff,NL
 2a00:d1e0::,2a00:d1e0:ffff:ffff:ffff:ffff:ffff:ffff,DE
 2a00:d200::,2a00:d200:ffff:ffff:ffff:ffff:ffff:ffff,GB
@@ -17325,7 +19387,9 @@
 2a00:e120::,2a00:e120:ffff:ffff:ffff:ffff:ffff:ffff,GB
 2a00:e140::,2a00:e140:ffff:ffff:ffff:ffff:ffff:ffff,CZ
 2a00:e160::,2a00:e160:ffff:ffff:ffff:ffff:ffff:ffff,ES
-2a00:e180::,2a00:e180:ffff:ffff:ffff:ffff:ffff:ffff,DE
+2a00:e180::,2a00:e180:12ca:ffff:ffff:ffff:ffff:ffff,DE
+2a00:e180:12cb::,2a00:e180:12cb:7fff:ffff:ffff:ffff:ffff,US
+2a00:e180:12cb:8000::,2a00:e180:ffff:ffff:ffff:ffff:ffff:ffff,DE
 2a00:e1a0::,2a00:e1a0:ffff:ffff:ffff:ffff:ffff:ffff,GB
 2a00:e1c0::,2a00:e1c0:ffff:ffff:ffff:ffff:ffff:ffff,GB
 2a00:e1e0::,2a00:e1e0:ffff:ffff:ffff:ffff:ffff:ffff,ES
@@ -17374,7 +19438,8 @@
 2a00:e760::,2a00:e760:ffff:ffff:ffff:ffff:ffff:ffff,BE
 2a00:e780::,2a00:e780:ffff:ffff:ffff:ffff:ffff:ffff,UA
 2a00:e7a0::,2a00:e7a0:ffff:ffff:ffff:ffff:ffff:ffff,GB
-2a00:e7c0::,2a00:e7c0:ffff:ffff:ffff:ffff:ffff:ffff,DK
+2a00:e7c0::,2a00:e7c0::7fff:ffff:ffff:ffff:ffff,LT
+2a00:e7c0:0:8000::,2a00:e7c0:ffff:ffff:ffff:ffff:ffff:ffff,DK
 2a00:e7e0::,2a00:e7e0:ffff:ffff:ffff:ffff:ffff:ffff,CH
 2a00:e800::,2a00:e807:ffff:ffff:ffff:ffff:ffff:ffff,PL
 2a00:e840::,2a00:e840:ffff:ffff:ffff:ffff:ffff:ffff,FR
@@ -17391,7 +19456,7 @@
 2a00:e9c0::,2a00:e9c0:ffff:ffff:ffff:ffff:ffff:ffff,ES
 2a00:e9e0::,2a00:e9e0:ffff:ffff:ffff:ffff:ffff:ffff,RU
 2a00:ea00::,2a00:ea00:ffff:ffff:ffff:ffff:ffff:ffff,PL
-2a00:ea20::,2a00:ea20:ffff:ffff:ffff:ffff:ffff:ffff,RU
+2a00:ea20::,2a00:ea27:ffff:ffff:ffff:ffff:ffff:ffff,RU
 2a00:ea40::,2a00:ea40:ffff:ffff:ffff:ffff:ffff:ffff,GB
 2a00:ea60::,2a00:ea60:ff:ffff:ffff:ffff:ffff:ffff,LT
 2a00:ea60:100::,2a00:ea60:1ff:ffff:ffff:ffff:ffff:ffff,GB
@@ -17411,9 +19476,10 @@
 2a00:ec20::,2a00:ec23:ffff:ffff:ffff:ffff:ffff:ffff,FR
 2a00:ec40::,2a00:ec47:ffff:ffff:ffff:ffff:ffff:ffff,DE
 2a00:ec80::,2a00:ec80:ffff:ffff:ffff:ffff:ffff:ffff,FR
-2a00:eca0::,2a00:eca0:ffff:ffff:ffff:ffff:ffff:ffff,FI
+2a00:eca0::,2a00:eca0::7fff:ffff:ffff:ffff:ffff,AX
+2a00:eca0:0:8000::,2a00:eca0:ffff:ffff:ffff:ffff:ffff:ffff,FI
 2a00:ecc0::,2a00:ecc0:ffff:ffff:ffff:ffff:ffff:ffff,DE
-2a00:ece0::,2a00:ece0:ffff:ffff:ffff:ffff:ffff:ffff,RO
+2a00:ece0::,2a00:ece7:ffff:ffff:ffff:ffff:ffff:ffff,RO
 2a00:ed00::,2a00:ed00:ffff:ffff:ffff:ffff:ffff:ffff,GB
 2a00:ed20::,2a00:ed20:ffff:ffff:ffff:ffff:ffff:ffff,GB
 2a00:ed40::,2a00:ed40:ffff:ffff:ffff:ffff:ffff:ffff,GB
@@ -17430,6 +19496,7 @@
 2a00:eea0::,2a00:eea0:ffff:ffff:ffff:ffff:ffff:ffff,IT
 2a00:eec0::,2a00:eec0:ffff:ffff:ffff:ffff:ffff:ffff,DK
 2a00:eee0::,2a00:eee0:ffff:ffff:ffff:ffff:ffff:ffff,TR
+2a00:ef00::,2a00:ef00:ffff:ffff:ffff:ffff:ffff:ffff,GB
 2a00:ef20::,2a00:ef20:ffff:ffff:ffff:ffff:ffff:ffff,NL
 2a00:ef40::,2a00:ef40:ffff:ffff:ffff:ffff:ffff:ffff,PL
 2a00:ef60::,2a00:ef67:ffff:ffff:ffff:ffff:ffff:ffff,FR
@@ -17452,7 +19519,6 @@
 2a00:f180::,2a00:f180:ffff:ffff:ffff:ffff:ffff:ffff,GB
 2a00:f1a0::,2a00:f1a0:ffff:ffff:ffff:ffff:ffff:ffff,BE
 2a00:f1c0::,2a00:f1c0:ffff:ffff:ffff:ffff:ffff:ffff,GB
-2a00:f1e0::,2a00:f1e0:ffff:ffff:ffff:ffff:ffff:ffff,SE
 2a00:f200::,2a00:f200:ffff:ffff:ffff:ffff:ffff:ffff,IT
 2a00:f220::,2a00:f220:ffff:ffff:ffff:ffff:ffff:ffff,ME
 2a00:f240::,2a00:f240:ffff:ffff:ffff:ffff:ffff:ffff,PL
@@ -17508,7 +19574,7 @@
 2a00:f8a0::,2a00:f8a0:ffff:ffff:ffff:ffff:ffff:ffff,GB
 2a00:f8c0::,2a00:f8c0:ffff:ffff:ffff:ffff:ffff:ffff,LI
 2a00:f8e0::,2a00:f8e0:ffff:ffff:ffff:ffff:ffff:ffff,DE
-2a00:f900::,2a00:f900:ffff:ffff:ffff:ffff:ffff:ffff,MD
+2a00:f900::,2a00:f907:ffff:ffff:ffff:ffff:ffff:ffff,MD
 2a00:f920::,2a00:f920:ffff:ffff:ffff:ffff:ffff:ffff,RU
 2a00:f940::,2a00:f940:ffff:ffff:ffff:ffff:ffff:ffff,RU
 2a00:f960::,2a00:f960:ffff:ffff:ffff:ffff:ffff:ffff,IS
@@ -17552,8 +19618,8 @@
 2a00:fe20::,2a00:fe20:ffff:ffff:ffff:ffff:ffff:ffff,DE
 2a00:fe40::,2a00:fe40:ffff:ffff:ffff:ffff:ffff:ffff,ES
 2a00:fe60::,2a00:fe60:ffff:ffff:ffff:ffff:ffff:ffff,FI
-2a00:fe80::,2a00:fe80:ffff:ffff:ffff:ffff:ffff:ffff,ME
-2a00:fea0::,2a00:fea0:ffff:ffff:ffff:ffff:ffff:ffff,CZ
+2a00:fe80::,2a00:fe87:ffff:ffff:ffff:ffff:ffff:ffff,ME
+2a00:fea0::,2a00:fea7:ffff:ffff:ffff:ffff:ffff:ffff,CZ
 2a00:fec0::,2a00:fec0:ffff:ffff:ffff:ffff:ffff:ffff,TR
 2a00:fee0::,2a00:fee0:ffff:ffff:ffff:ffff:ffff:ffff,RU
 2a00:ff00::,2a00:ff00:ffff:ffff:ffff:ffff:ffff:ffff,CH
@@ -17579,7 +19645,7 @@
 2a01:68::,2a01:68:ffff:ffff:ffff:ffff:ffff:ffff,FR
 2a01:70::,2a01:70:fffe:ffff:ffff:ffff:ffff:ffff,GB
 2a01:70:ffff::,2a01:70:ffff:ffff:ffff:ffff:ffff:ffff,BE
-2a01:78::,2a01:78:ffff:ffff:ffff:ffff:ffff:ffff,DE
+2a01:78::,2a01:7f:ffff:ffff:ffff:ffff:ffff:ffff,DE
 2a01:80::,2a01:80:ffff:ffff:ffff:ffff:ffff:ffff,EE
 2a01:88::,2a01:88:ffff:ffff:ffff:ffff:ffff:ffff,IE
 2a01:90::,2a01:90:ffff:ffff:ffff:ffff:ffff:ffff,GB
@@ -17590,7 +19656,23 @@
 2a01:b8::,2a01:b8:ffff:ffff:ffff:ffff:ffff:ffff,VA
 2a01:c0::,2a01:c0:ffff:ffff:ffff:ffff:ffff:ffff,GB
 2a01:c8::,2a01:c8:ffff:ffff:ffff:ffff:ffff:ffff,FR
-2a01:d0::,2a01:d0:bfcf:ffff:ffff:ffff:ffff:ffff,UA
+2a01:d0::,2a01:d0:896c:7fff:ffff:ffff:ffff:ffff,UA
+2a01:d0:896c:8000::,2a01:d0:896c:ffff:ffff:ffff:ffff:ffff,RU
+2a01:d0:896d::,2a01:d0:8de4:ffff:ffff:ffff:ffff:ffff,UA
+2a01:d0:8de5::,2a01:d0:8de5:7fff:ffff:ffff:ffff:ffff,RU
+2a01:d0:8de5:8000::,2a01:d0:9008:ffff:ffff:ffff:ffff:ffff,UA
+2a01:d0:9009::,2a01:d0:9009:7fff:ffff:ffff:ffff:ffff,RU
+2a01:d0:9009:8000::,2a01:d0:92ea:ffff:ffff:ffff:ffff:ffff,UA
+2a01:d0:92eb::,2a01:d0:92eb:7fff:ffff:ffff:ffff:ffff,RU
+2a01:d0:92eb:8000::,2a01:d0:93ff:ffff:ffff:ffff:ffff:ffff,UA
+2a01:d0:9400::,2a01:d0:9400:7fff:ffff:ffff:ffff:ffff,RU
+2a01:d0:9400:8000::,2a01:d0:95d7:ffff:ffff:ffff:ffff:ffff,UA
+2a01:d0:95d8::,2a01:d0:95d8:7fff:ffff:ffff:ffff:ffff,RU
+2a01:d0:95d8:8000::,2a01:d0:b2f5:ffff:ffff:ffff:ffff:ffff,UA
+2a01:d0:b2f6::,2a01:d0:b2f6:7fff:ffff:ffff:ffff:ffff,RU
+2a01:d0:b2f6:8000::,2a01:d0:bf61:ffff:ffff:ffff:ffff:ffff,UA
+2a01:d0:bf62::,2a01:d0:bf62:7fff:ffff:ffff:ffff:ffff,RU
+2a01:d0:bf62:8000::,2a01:d0:bfcf:ffff:ffff:ffff:ffff:ffff,UA
 2a01:d0:bfd0::,2a01:d0:bfd0:7fff:ffff:ffff:ffff:ffff,RU
 2a01:d0:bfd0:8000::,2a01:d0:ffff:ffff:ffff:ffff:ffff:ffff,UA
 2a01:d8::,2a01:d8:ffff:ffff:ffff:ffff:ffff:ffff,RU
@@ -17636,11 +19718,13 @@
 2a01:228::,2a01:228:ffff:ffff:ffff:ffff:ffff:ffff,CH
 2a01:230::,2a01:230:ffff:ffff:ffff:ffff:ffff:ffff,RU
 2a01:238::,2a01:238:ffff:ffff:ffff:ffff:ffff:ffff,DE
-2a01:240::,2a01:240:ffff:ffff:ffff:ffff:ffff:ffff,FR
+2a01:240::,2a01:240:feda:ffff:ffff:ffff:ffff:ffff,FR
+2a01:240:fedb::,2a01:240:fedb:7fff:ffff:ffff:ffff:ffff,PT
+2a01:240:fedb:8000::,2a01:240:ffff:ffff:ffff:ffff:ffff:ffff,FR
 2a01:248::,2a01:248:ffff:ffff:ffff:ffff:ffff:ffff,GB
 2a01:250::,2a01:250:ffff:ffff:ffff:ffff:ffff:ffff,ES
 2a01:258::,2a01:258:ffff:ffff:ffff:ffff:ffff:ffff,IE
-2a01:260::,2a01:260:ffff:ffff:ffff:ffff:ffff:ffff,SI
+2a01:260::,2a01:267:ffff:ffff:ffff:ffff:ffff:ffff,SI
 2a01:268::,2a01:268:ffff:ffff:ffff:ffff:ffff:ffff,IE
 2a01:270::,2a01:270:ffff:ffff:ffff:ffff:ffff:ffff,HU
 2a01:278::,2a01:27f:ffff:ffff:ffff:ffff:ffff:ffff,CH
@@ -17650,7 +19734,9 @@
 2a01:298::,2a01:29f:ffff:ffff:ffff:ffff:ffff:ffff,SE
 2a01:2a0::,2a01:2a0:ffff:ffff:ffff:ffff:ffff:ffff,FR
 2a01:2a8::,2a01:2af:ffff:ffff:ffff:ffff:ffff:ffff,CH
-2a01:2b0::,2a01:2b7:ffff:ffff:ffff:ffff:ffff:ffff,SE
+2a01:2b0::,2a01:2b0:2000:112:ffff:ffff:ffff:ffff,SE
+2a01:2b0:2000:113::,2a01:2b0:2000:113:ffff:ffff:ffff:ffff,FI
+2a01:2b0:2000:114::,2a01:2b7:ffff:ffff:ffff:ffff:ffff:ffff,SE
 2a01:2b8::,2a01:2b8:ffff:ffff:ffff:ffff:ffff:ffff,GR
 2a01:2c0::,2a01:2c0:ffff:ffff:ffff:ffff:ffff:ffff,GB
 2a01:2c8::,2a01:2c8:ffff:ffff:ffff:ffff:ffff:ffff,RU
@@ -17663,20 +19749,24 @@
 2a01:328::,2a01:328:ffff:ffff:ffff:ffff:ffff:ffff,SK
 2a01:330::,2a01:330:ffff:ffff:ffff:ffff:ffff:ffff,CH
 2a01:338::,2a01:338:ffff:ffff:ffff:ffff:ffff:ffff,PL
-2a01:348::,2a01:348:ffff:ffff:ffff:ffff:ffff:ffff,GB
+2a01:348::,2a01:348:338:ffff:ffff:ffff:ffff:ffff,GB
+2a01:348:339::,2a01:348:339:7fff:ffff:ffff:ffff:ffff,NL
+2a01:348:339:8000::,2a01:348:ffff:ffff:ffff:ffff:ffff:ffff,GB
 2a01:350::,2a01:350:ffff:ffff:ffff:ffff:ffff:ffff,NL
 2a01:358::,2a01:35f:ffff:ffff:ffff:ffff:ffff:ffff,TR
 2a01:360::,2a01:367:ffff:ffff:ffff:ffff:ffff:ffff,DE
 2a01:368::,2a01:36f:ffff:ffff:ffff:ffff:ffff:ffff,HU
 2a01:378::,2a01:378:ffff:ffff:ffff:ffff:ffff:ffff,FR
 2a01:380::,2a01:380:ffff:ffff:ffff:ffff:ffff:ffff,NL
-2a01:388::,2a01:388:250:ffff:ffff:ffff:ffff:ffff,GB
-2a01:388:251::,2a01:388:251:7fff:ffff:ffff:ffff:ffff,NL
-2a01:388:251:8000::,2a01:38f:ffff:ffff:ffff:ffff:ffff:ffff,GB
+2a01:388::,2a01:388:24e:ffff:ffff:ffff:ffff:ffff,GB
+2a01:388:24f::,2a01:388:24f:7fff:ffff:ffff:ffff:ffff,NL
+2a01:388:24f:8000::,2a01:38f:ffff:ffff:ffff:ffff:ffff:ffff,GB
 2a01:390::,2a01:390:ffff:ffff:ffff:ffff:ffff:ffff,SK
 2a01:398::,2a01:398:ffff:ffff:ffff:ffff:ffff:ffff,GB
 2a01:3a0::,2a01:3a7:ffff:ffff:ffff:ffff:ffff:ffff,DK
 2a01:3a8::,2a01:3a8:ffff:ffff:ffff:ffff:ffff:ffff,NL
+2a01:3b0:1::,2a01:3b0:1:7fff:ffff:ffff:ffff:ffff,DE
+2a01:3b0:c08::,2a01:3b0:c08:7fff:ffff:ffff:ffff:ffff,DE
 2a01:3b8::,2a01:3b8:ffff:ffff:ffff:ffff:ffff:ffff,SE
 2a01:3c8::,2a01:3c8:ffff:ffff:ffff:ffff:ffff:ffff,IR
 2a01:3d8::,2a01:3d8:ffff:ffff:ffff:ffff:ffff:ffff,DE
@@ -17691,9 +19781,10 @@
 2a01:3e0:1601::,2a01:3e0:1601:ffff:ffff:ffff:ffff:ffff,FI
 2a01:3e0:1700::,2a01:3e0:1701:ff:ffff:ffff:ffff:ffff,GB
 2a01:3e0:1b00::,2a01:3e0:1b00:ffff:ffff:ffff:ffff:ffff,FI
+2a01:3e0:1d00::,2a01:3e0:1d00:ff:ffff:ffff:ffff:ffff,CH
 2a01:3e0:ff24::,2a01:3e0:ff24:ffff:ffff:ffff:ffff:ffff,DE
 2a01:3e8::,2a01:3e8:ffff:ffff:ffff:ffff:ffff:ffff,IT
-2a01:3f0::,2a01:3f0:ffff:ffff:ffff:ffff:ffff:ffff,SE
+2a01:3f0::,2a01:3f7:ffff:ffff:ffff:ffff:ffff:ffff,SE
 2a01:3f8::,2a01:3f8:ffff:ffff:ffff:ffff:ffff:ffff,GB
 2a01:400::,2a01:400:ffff:ffff:ffff:ffff:ffff:ffff,IE
 2a01:408::,2a01:408:ffff:ffff:ffff:ffff:ffff:ffff,DE
@@ -17724,7 +19815,9 @@
 2a01:4e0::,2a01:4e7:ffff:ffff:ffff:ffff:ffff:ffff,LV
 2a01:4e8::,2a01:4e8:ffff:ffff:ffff:ffff:ffff:ffff,GB
 2a01:4f0::,2a01:4f0:ffff:ffff:ffff:ffff:ffff:ffff,DK
-2a01:4f8::,2a01:4ff:ffff:ffff:ffff:ffff:ffff:ffff,DE
+2a01:4f8::,2a01:4f8:201:7fff:ffff:ffff:ffff:ffff,DE
+2a01:4f8:201:8000::,2a01:4f8:201:ffff:ffff:ffff:ffff:ffff,RU
+2a01:4f8:202::,2a01:4ff:ffff:ffff:ffff:ffff:ffff:ffff,DE
 2a01:500::,2a01:500:ffff:ffff:ffff:ffff:ffff:ffff,GB
 2a01:508::,2a01:508:ffff:ffff:ffff:ffff:ffff:ffff,RU
 2a01:510::,2a01:510:ffff:ffff:ffff:ffff:ffff:ffff,CZ
@@ -17739,7 +19832,7 @@
 2a01:558::,2a01:558:ffff:ffff:ffff:ffff:ffff:ffff,DK
 2a01:560::,2a01:567:ffff:ffff:ffff:ffff:ffff:ffff,NO
 2a01:568::,2a01:570:ffff:ffff:ffff:ffff:ffff:ffff,GB
-2a01:578::,2a01:578:ffff:ffff:ffff:ffff:ffff:ffff,IE
+2a01:578::,2a01:578:ffff:ffff:ffff:ffff:ffff:ffff,US
 2a01:580::,2a01:580:ffff:ffff:ffff:ffff:ffff:ffff,DE
 2a01:590::,2a01:590:ffff:ffff:ffff:ffff:ffff:ffff,RU
 2a01:598::,2a01:59f:ffff:ffff:ffff:ffff:ffff:ffff,DE
@@ -17792,7 +19885,6 @@
 2a01:730::,2a01:730:ffff:ffff:ffff:ffff:ffff:ffff,TR
 2a01:738::,2a01:738:ffff:ffff:ffff:ffff:ffff:ffff,GB
 2a01:740::,2a01:740:ffff:ffff:ffff:ffff:ffff:ffff,DE
-2a01:748::,2a01:748:ffff:ffff:ffff:ffff:ffff:ffff,TR
 2a01:750::,2a01:750:ffff:ffff:ffff:ffff:ffff:ffff,UA
 2a01:758::,2a01:758:ffff:ffff:ffff:ffff:ffff:ffff,UA
 2a01:760::,2a01:760:ffff:ffff:ffff:ffff:ffff:ffff,CH
@@ -17815,7 +19907,9 @@
 2a01:7e8::,2a01:7e8:ffff:ffff:ffff:ffff:ffff:ffff,DK
 2a01:7f0::,2a01:7f0:ffff:ffff:ffff:ffff:ffff:ffff,DE
 2a01:7f8::,2a01:7f8:ffff:ffff:ffff:ffff:ffff:ffff,DE
-2a01:800::,2a01:8ff:ffff:ffff:ffff:ffff:ffff:ffff,DE
+2a01:800::,2a01:838:fffe:ffff:ffff:ffff:ffff:ffff,DE
+2a01:838:ffff::,2a01:838:ffff:7fff:ffff:ffff:ffff:ffff,MT
+2a01:838:ffff:8000::,2a01:8ff:ffff:ffff:ffff:ffff:ffff:ffff,DE
 2a01:c00::,2a01:c3f:ffff:ffff:ffff:ffff:ffff:ffff,DE
 2a01:e00::,2a01:e3f:ffff:ffff:ffff:ffff:ffff:ffff,FR
 2a01:1000::,2a01:17ff:ffff:ffff:ffff:ffff:ffff:ffff,PL
@@ -17909,7 +20003,7 @@
 2a01:4b40::,2a01:4b40:ffff:ffff:ffff:ffff:ffff:ffff,KZ
 2a01:4b60::,2a01:4b60:ffff:ffff:ffff:ffff:ffff:ffff,RU
 2a01:4b80::,2a01:4b80:ffff:ffff:ffff:ffff:ffff:ffff,ES
-2a01:4ba0::,2a01:4ba0:ffff:ffff:ffff:ffff:ffff:ffff,AZ
+2a01:4ba0::,2a01:4ba7:ffff:ffff:ffff:ffff:ffff:ffff,AZ
 2a01:4bc0::,2a01:4bc0:ffff:ffff:ffff:ffff:ffff:ffff,DE
 2a01:4be0::,2a01:4be0:ffff:ffff:ffff:ffff:ffff:ffff,HU
 2a01:4c00::,2a01:4c00:ffff:ffff:ffff:ffff:ffff:ffff,NL
@@ -18004,6 +20098,7 @@
 2a01:5780::,2a01:5780:ffff:ffff:ffff:ffff:ffff:ffff,ES
 2a01:57a0::,2a01:57a0:ffff:ffff:ffff:ffff:ffff:ffff,ES
 2a01:57c0::,2a01:57c0:ffff:ffff:ffff:ffff:ffff:ffff,RU
+2a01:57e0::,2a01:57e0:ffff:ffff:ffff:ffff:ffff:ffff,IT
 2a01:5800::,2a01:5800:ffff:ffff:ffff:ffff:ffff:ffff,UA
 2a01:5820::,2a01:5820:ffff:ffff:ffff:ffff:ffff:ffff,GB
 2a01:5840::,2a01:5840:ffff:ffff:ffff:ffff:ffff:ffff,IR
@@ -18178,7 +20273,6 @@
 2a01:6ce0::,2a01:6ce0:ffff:ffff:ffff:ffff:ffff:ffff,IE
 2a01:6d00::,2a01:6d00:ffff:ffff:ffff:ffff:ffff:ffff,SE
 2a01:6d20::,2a01:6d20:ffff:ffff:ffff:ffff:ffff:ffff,FI
-2a01:6d40::,2a01:6d40:ffff:ffff:ffff:ffff:ffff:ffff,ES
 2a01:6d60::,2a01:6d60:ffff:ffff:ffff:ffff:ffff:ffff,IT
 2a01:6d80::,2a01:6d80:ffff:ffff:ffff:ffff:ffff:ffff,UA
 2a01:6da0::,2a01:6da0:ffff:ffff:ffff:ffff:ffff:ffff,EE
@@ -18243,7 +20337,6 @@
 2a01:7500::,2a01:7500:ffff:ffff:ffff:ffff:ffff:ffff,BE
 2a01:7520::,2a01:7520:ffff:ffff:ffff:ffff:ffff:ffff,NL
 2a01:7540::,2a01:7540:ffff:ffff:ffff:ffff:ffff:ffff,IT
-2a01:7560::,2a01:7560:ffff:ffff:ffff:ffff:ffff:ffff,BG
 2a01:7580::,2a01:7580:ffff:ffff:ffff:ffff:ffff:ffff,ES
 2a01:75a0::,2a01:75a0:ffff:ffff:ffff:ffff:ffff:ffff,AE
 2a01:75c0::,2a01:75c7:ffff:ffff:ffff:ffff:ffff:ffff,DE
@@ -18303,6 +20396,7 @@
 2a01:7cc0::,2a01:7cc0:ffff:ffff:ffff:ffff:ffff:ffff,DK
 2a01:7ce0::,2a01:7ce0:ffff:ffff:ffff:ffff:ffff:ffff,CZ
 2a01:7d00::,2a01:7d00:ffff:ffff:ffff:ffff:ffff:ffff,ES
+2a01:7d20::,2a01:7d20:ffff:ffff:ffff:ffff:ffff:ffff,CZ
 2a01:7d40::,2a01:7d40:ffff:ffff:ffff:ffff:ffff:ffff,SK
 2a01:7d60::,2a01:7d60:ffff:ffff:ffff:ffff:ffff:ffff,HU
 2a01:7d80::,2a01:7d80:ffff:ffff:ffff:ffff:ffff:ffff,HU
@@ -18328,7 +20422,7 @@
 2a01:7fe0::,2a01:7fe0:ffff:ffff:ffff:ffff:ffff:ffff,CZ
 2a01:8000::,2a01:8000:ffff:ffff:ffff:ffff:ffff:ffff,GB
 2a01:8020::,2a01:8020:ffff:ffff:ffff:ffff:ffff:ffff,EE
-2a01:8040::,2a01:8040:ffff:ffff:ffff:ffff:ffff:ffff,RU
+2a01:8040::,2a01:8047:ffff:ffff:ffff:ffff:ffff:ffff,RU
 2a01:8060::,2a01:8060:ffff:ffff:ffff:ffff:ffff:ffff,AE
 2a01:8080::,2a01:8080:ffff:ffff:ffff:ffff:ffff:ffff,RO
 2a01:80a0::,2a01:80a0:ffff:ffff:ffff:ffff:ffff:ffff,AT
@@ -18410,7 +20504,7 @@
 2a01:8a40::,2a01:8a40:ffff:ffff:ffff:ffff:ffff:ffff,DE
 2a01:8a60::,2a01:8a60:ffff:ffff:ffff:ffff:ffff:ffff,PL
 2a01:8a80::,2a01:8a80:ffff:ffff:ffff:ffff:ffff:ffff,SK
-2a01:8aa0::,2a01:8aa0:ffff:ffff:ffff:ffff:ffff:ffff,GB
+2a01:8aa0::,2a01:8aa0:ffff:ffff:ffff:ffff:ffff:ffff,IE
 2a01:8ac0::,2a01:8ac0:ffff:ffff:ffff:ffff:ffff:ffff,FR
 2a01:8ae0::,2a01:8ae0:ffff:ffff:ffff:ffff:ffff:ffff,NL
 2a01:8b00::,2a01:8b00:ffff:ffff:ffff:ffff:ffff:ffff,CH
@@ -18421,7 +20515,9 @@
 2a01:8ba0::,2a01:8ba7:ffff:ffff:ffff:ffff:ffff:ffff,PL
 2a01:8bc0::,2a01:8bc0:ffff:ffff:ffff:ffff:ffff:ffff,GB
 2a01:8be0::,2a01:8be0:ffff:ffff:ffff:ffff:ffff:ffff,NL
-2a01:8c00::,2a01:8c00:ff00:82b0:ffff:ffff:ffff:ffff,CZ
+2a01:8c00::,2a01:8c00:feff:ffff:ffff:ffff:ffff:ffff,CZ
+2a01:8c00:ff00::,2a01:8c00:ff00:7fff:ffff:ffff:ffff:ffff,SK
+2a01:8c00:ff00:8000::,2a01:8c00:ff00:82b0:ffff:ffff:ffff:ffff,CZ
 2a01:8c00:ff00:82b1::,2a01:8c00:ff00:82b1:ffff:ffff:ffff:ffff,US
 2a01:8c00:ff00:82b2::,2a01:8c00:ffff:ffff:ffff:ffff:ffff:ffff,CZ
 2a01:8c20::,2a01:8c20:ffff:ffff:ffff:ffff:ffff:ffff,NL
@@ -18623,6 +20719,7 @@
 2a01:a500::,2a01:a500:ffff:ffff:ffff:ffff:ffff:ffff,GB
 2a01:a520::,2a01:a520:ffff:ffff:ffff:ffff:ffff:ffff,NO
 2a01:a540::,2a01:a540:ffff:ffff:ffff:ffff:ffff:ffff,IR
+2a01:a560::,2a01:a560:ffff:ffff:ffff:ffff:ffff:ffff,SE
 2a01:a580::,2a01:a580:ffff:ffff:ffff:ffff:ffff:ffff,FR
 2a01:a5a0::,2a01:a5a0:ffff:ffff:ffff:ffff:ffff:ffff,GB
 2a01:a5c0::,2a01:a5c0:ffff:ffff:ffff:ffff:ffff:ffff,GB
@@ -18631,7 +20728,7 @@
 2a01:a620::,2a01:a620:ffff:ffff:ffff:ffff:ffff:ffff,IT
 2a01:a640::,2a01:a640:ffff:ffff:ffff:ffff:ffff:ffff,NL
 2a01:a660::,2a01:a660:ffff:ffff:ffff:ffff:ffff:ffff,DK
-2a01:a680::,2a01:a680:ffff:ffff:ffff:ffff:ffff:ffff,NL
+2a01:a680::,2a01:a687:ffff:ffff:ffff:ffff:ffff:ffff,NL
 2a01:a6a0::,2a01:a6a0:ffff:ffff:ffff:ffff:ffff:ffff,FR
 2a01:a6c0::,2a01:a6c0:ffff:ffff:ffff:ffff:ffff:ffff,RU
 2a01:a6e0::,2a01:a6e0:ffff:ffff:ffff:ffff:ffff:ffff,BA
@@ -18667,6 +20764,7 @@
 2a01:aac0::,2a01:aac0:ffff:ffff:ffff:ffff:ffff:ffff,TR
 2a01:aae0::,2a01:aae0:ffff:ffff:ffff:ffff:ffff:ffff,NL
 2a01:ab00::,2a01:ab00:ffff:ffff:ffff:ffff:ffff:ffff,IT
+2a01:ab20::,2a01:ab20:ffff:ffff:ffff:ffff:ffff:ffff,CH
 2a01:ab40::,2a01:ab40:ffff:ffff:ffff:ffff:ffff:ffff,DE
 2a01:ab60::,2a01:ab60:ffff:ffff:ffff:ffff:ffff:ffff,FR
 2a01:ab80::,2a01:ab80:ffff:ffff:ffff:ffff:ffff:ffff,DE
@@ -18762,7 +20860,6 @@
 2a01:b740::,2a01:b740:ffff:ffff:ffff:ffff:ffff:ffff,IE
 2a01:b760::,2a01:b760:ffff:ffff:ffff:ffff:ffff:ffff,BG
 2a01:b780::,2a01:b780:ffff:ffff:ffff:ffff:ffff:ffff,MK
-2a01:b7a0::,2a01:b7a0:ffff:ffff:ffff:ffff:ffff:ffff,IT
 2a01:b7c0::,2a01:b7c0:ffff:ffff:ffff:ffff:ffff:ffff,CH
 2a01:b7e0::,2a01:b7e0:ffff:ffff:ffff:ffff:ffff:ffff,FR
 2a01:b800::,2a01:b800:ffff:ffff:ffff:ffff:ffff:ffff,RS
@@ -18832,7 +20929,7 @@
 2a02:10::,2a02:17:ffff:ffff:ffff:ffff:ffff:ffff,NL
 2a02:18::,2a02:18:ffff:ffff:ffff:ffff:ffff:ffff,DE
 2a02:20::,2a02:20:ffff:ffff:ffff:ffff:ffff:ffff,IT
-2a02:28::,2a02:28:ffff:ffff:ffff:ffff:ffff:ffff,RU
+2a02:28::,2a02:2f:ffff:ffff:ffff:ffff:ffff:ffff,RU
 2a02:30::,2a02:30:ffff:ffff:ffff:ffff:ffff:ffff,SE
 2a02:38::,2a02:38:ffff:ffff:ffff:ffff:ffff:ffff,CZ
 2a02:40::,2a02:40:ffff:ffff:ffff:ffff:ffff:ffff,GB
@@ -18850,7 +20947,9 @@
 2a02:a0::,2a02:a0:ffff:ffff:ffff:ffff:ffff:ffff,ES
 2a02:a8::,2a02:a8:ffff:ffff:ffff:ffff:ffff:ffff,DE
 2a02:b0::,2a02:b0:ffff:ffff:ffff:ffff:ffff:ffff,GB
-2a02:b8::,2a02:b8:ffff:ffff:ffff:ffff:ffff:ffff,LU
+2a02:b8::,2a02:b8::ffff:ffff:ffff:ffff:ffff,LU
+2a02:b8:1::,2a02:b8:1:7fff:ffff:ffff:ffff:ffff,FR
+2a02:b8:1:8000::,2a02:b8:ffff:ffff:ffff:ffff:ffff:ffff,LU
 2a02:c0::,2a02:c0:ffff:ffff:ffff:ffff:ffff:ffff,NO
 2a02:c8::,2a02:c8:ffff:ffff:ffff:ffff:ffff:ffff,BE
 2a02:d0::,2a02:d0:ffff:ffff:ffff:ffff:ffff:ffff,RU
@@ -18868,7 +20967,9 @@
 2a02:128:4::,2a02:128:4:ffff:ffff:ffff:ffff:ffff,NL
 2a02:128:5::,2a02:128:5:ffff:ffff:ffff:ffff:ffff,CZ
 2a02:128:6::,2a02:128:6:ffff:ffff:ffff:ffff:ffff,RU
-2a02:128:7::,2a02:128:ffff:ffff:ffff:ffff:ffff:ffff,CZ
+2a02:128:7::,2a02:128:7:ffff:ffff:ffff:ffff:ffff,CZ
+2a02:128:8::,2a02:128:8:7fff:ffff:ffff:ffff:ffff,RU
+2a02:128:8:8000::,2a02:128:ffff:ffff:ffff:ffff:ffff:ffff,CZ
 2a02:130::,2a02:130:ffff:ffff:ffff:ffff:ffff:ffff,SK
 2a02:138::,2a02:138:ffff:ffff:ffff:ffff:ffff:ffff,PT
 2a02:140::,2a02:140:ffff:ffff:ffff:ffff:ffff:ffff,FI
@@ -18918,7 +21019,8 @@
 2a02:2b8::,2a02:2b8:ffff:ffff:ffff:ffff:ffff:ffff,FR
 2a02:2c0::,2a02:2c0:ffff:ffff:ffff:ffff:ffff:ffff,DE
 2a02:2c8::,2a02:2c8:ffff:ffff:ffff:ffff:ffff:ffff,NO
-2a02:2d8::,2a02:2d8:ffff:ffff:ffff:ffff:ffff:ffff,GB
+2a02:2d8::,2a02:2d8::7fff:ffff:ffff:ffff:ffff,RU
+2a02:2d8:0:8000::,2a02:2d8:ffff:ffff:ffff:ffff:ffff:ffff,GB
 2a02:2e0::,2a02:2e7:ffff:ffff:ffff:ffff:ffff:ffff,DE
 2a02:2e8::,2a02:2e8:ffff:ffff:ffff:ffff:ffff:ffff,IT
 2a02:2f0::,2a02:2f7:ffff:ffff:ffff:ffff:ffff:ffff,DE
@@ -19000,11 +21102,17 @@
 2a02:570::,2a02:570:ffff:ffff:ffff:ffff:ffff:ffff,CZ
 2a02:578::,2a02:578:5002:7fff:ffff:ffff:ffff:ffff,BE
 2a02:578:5002:8000::,2a02:578:5002:ffff:ffff:ffff:ffff:ffff,RU
-2a02:578:5003::,2a02:578:ffff:ffff:ffff:ffff:ffff:ffff,BE
-2a02:580::,2a02:587:ffff:ffff:ffff:ffff:ffff:ffff,GR
+2a02:578:5003::,2a02:578:5411:ffff:ffff:ffff:ffff:ffff,BE
+2a02:578:5412::,2a02:578:5412:7fff:ffff:ffff:ffff:ffff,RU
+2a02:578:5412:8000::,2a02:578:ffff:ffff:ffff:ffff:ffff:ffff,BE
+2a02:580::,2a02:580:d3ab:ffff:ffff:ffff:ffff:ffff,GR
+2a02:580:d3ac::,2a02:580:d3ac:7fff:ffff:ffff:ffff:ffff,FR
+2a02:580:d3ac:8000::,2a02:587:ffff:ffff:ffff:ffff:ffff:ffff,GR
 2a02:588::,2a02:588:ffff:ffff:ffff:ffff:ffff:ffff,DE
 2a02:590::,2a02:597:ffff:ffff:ffff:ffff:ffff:ffff,DE
-2a02:598::,2a02:598:ffff:ffff:ffff:ffff:ffff:ffff,CZ
+2a02:598::,2a02:598:1:ffff:ffff:ffff:ffff:ffff,CZ
+2a02:598:2::,2a02:598:2:7fff:ffff:ffff:ffff:ffff,GB
+2a02:598:2:8000::,2a02:598:ffff:ffff:ffff:ffff:ffff:ffff,CZ
 2a02:5a0::,2a02:5a0:ffff:ffff:ffff:ffff:ffff:ffff,DE
 2a02:5b0::,2a02:5b0:ffff:ffff:ffff:ffff:ffff:ffff,NL
 2a02:5b8::,2a02:5b8:ffff:ffff:ffff:ffff:ffff:ffff,GB
@@ -19012,7 +21120,7 @@
 2a02:5c8::,2a02:5c8:ffff:ffff:ffff:ffff:ffff:ffff,GR
 2a02:5d0::,2a02:5d0:ffff:ffff:ffff:ffff:ffff:ffff,DE
 2a02:5d8::,2a02:5d8:ffff:ffff:ffff:ffff:ffff:ffff,AT
-2a02:5e0::,2a02:5e0:ffff:ffff:ffff:ffff:ffff:ffff,AT
+2a02:5e0::,2a02:5e7:ffff:ffff:ffff:ffff:ffff:ffff,AT
 2a02:5f0::,2a02:5f0:ffff:ffff:ffff:ffff:ffff:ffff,UA
 2a02:600::,2a02:600:ffff:ffff:ffff:ffff:ffff:ffff,IT
 2a02:608::,2a02:608:ffff:ffff:ffff:ffff:ffff:ffff,DE
@@ -19036,7 +21144,8 @@
 2a02:6a0::,2a02:6a0:ffff:ffff:ffff:ffff:ffff:ffff,CH
 2a02:6a8::,2a02:6a8:ffff:ffff:ffff:ffff:ffff:ffff,DE
 2a02:6b0::,2a02:6b0:ffff:ffff:ffff:ffff:ffff:ffff,RU
-2a02:6b8::,2a02:6b8::2bff:ffff:ffff:ffff:ffff,RU
+2a02:6b8::,2a02:6b8::29ff:ffff:ffff:ffff:ffff,RU
+2a02:6b8:0:2a00::,2a02:6b8::2bff:ffff:ffff:ffff:ffff,TR
 2a02:6b8:0:2c00::,2a02:6b8::2fff:ffff:ffff:ffff:ffff,UA
 2a02:6b8:0:3000::,2a02:6b8:ffff:ffff:ffff:ffff:ffff:ffff,RU
 2a02:6c0::,2a02:6c0:ffff:ffff:ffff:ffff:ffff:ffff,DK
@@ -19079,7 +21188,6 @@
 2a02:7e0::,2a02:7e0:ffff:ffff:ffff:ffff:ffff:ffff,NO
 2a02:7e8::,2a02:7e8:ffff:ffff:ffff:ffff:ffff:ffff,UA
 2a02:7f0::,2a02:7f0:ffff:ffff:ffff:ffff:ffff:ffff,PL
-2a02:7f8::,2a02:7f8:ffff:ffff:ffff:ffff:ffff:ffff,BG
 2a02:800::,2a02:807:ffff:ffff:ffff:ffff:ffff:ffff,SI
 2a02:808::,2a02:808:ffff:ffff:ffff:ffff:ffff:ffff,HU
 2a02:810::,2a02:810:ffff:ffff:ffff:ffff:ffff:ffff,CH
@@ -19120,14 +21228,14 @@
 2a02:928::,2a02:928:ffff:ffff:ffff:ffff:ffff:ffff,NL
 2a02:930::,2a02:930:ffff:ffff:ffff:ffff:ffff:ffff,RU
 2a02:938::,2a02:93f:ffff:ffff:ffff:ffff:ffff:ffff,NL
-2a02:940::,2a02:940:ffff:ffff:ffff:ffff:ffff:ffff,AT
+2a02:940::,2a02:947:ffff:ffff:ffff:ffff:ffff:ffff,AT
 2a02:950::,2a02:957:ffff:ffff:ffff:ffff:ffff:ffff,PL
 2a02:958::,2a02:958:ffff:ffff:ffff:ffff:ffff:ffff,DE
 2a02:960::,2a02:960:ffff:ffff:ffff:ffff:ffff:ffff,RU
 2a02:968::,2a02:968:ffff:ffff:ffff:ffff:ffff:ffff,NL
 2a02:970::,2a02:970:ffff:ffff:ffff:ffff:ffff:ffff,CZ
 2a02:978::,2a02:978:ffff:ffff:ffff:ffff:ffff:ffff,RU
-2a02:980::,2a02:980:ffff:ffff:ffff:ffff:ffff:ffff,DK
+2a02:980::,2a02:987:ffff:ffff:ffff:ffff:ffff:ffff,DK
 2a02:988::,2a02:988:ffff:ffff:ffff:ffff:ffff:ffff,NL
 2a02:990::,2a02:990:ffff:ffff:ffff:ffff:ffff:ffff,NL
 2a02:998::,2a02:998:ffff:ffff:ffff:ffff:ffff:ffff,DE
@@ -19174,7 +21282,9 @@
 2a02:ae0::,2a02:ae0:ffff:ffff:ffff:ffff:ffff:ffff,DE
 2a02:ae8::,2a02:aef:ffff:ffff:ffff:ffff:ffff:ffff,SE
 2a02:af0::,2a02:af0:ffff:ffff:ffff:ffff:ffff:ffff,AT
-2a02:af8::,2a02:af8:ffff:ffff:ffff:ffff:ffff:ffff,GB
+2a02:af8::,2a02:af8:dad9:ffff:ffff:ffff:ffff:ffff,GB
+2a02:af8:dada::,2a02:af8:dada:7fff:ffff:ffff:ffff:ffff,IT
+2a02:af8:dada:8000::,2a02:af8:ffff:ffff:ffff:ffff:ffff:ffff,GB
 2a02:b00::,2a02:b00:ffff:ffff:ffff:ffff:ffff:ffff,GB
 2a02:b08::,2a02:b0f:ffff:ffff:ffff:ffff:ffff:ffff,DE
 2a02:b10::,2a02:b10:ffff:ffff:ffff:ffff:ffff:ffff,GB
@@ -19183,11 +21293,7 @@
 2a02:b28::,2a02:b28:ffff:ffff:ffff:ffff:ffff:ffff,DE
 2a02:b30::,2a02:b30:ffff:ffff:ffff:ffff:ffff:ffff,DE
 2a02:b48::,2a02:b48:ff:ffff:ffff:ffff:ffff:ffff,US
-2a02:b48:100::,2a02:b48:3fff:ffff:ffff:ffff:ffff:ffff,UA
-2a02:b48:4000::,2a02:b48:40ff:ffff:ffff:ffff:ffff:ffff,NL
-2a02:b48:4100::,2a02:b48:ffff:ffff:ffff:ffff:ffff:ffff,UA
-2a02:b49::,2a02:b49:ff:ffff:ffff:ffff:ffff:ffff,NL
-2a02:b49:100::,2a02:b4f:ffff:ffff:ffff:ffff:ffff:ffff,UA
+2a02:b48:100::,2a02:b4f:ffff:ffff:ffff:ffff:ffff:ffff,NL
 2a02:b50::,2a02:b50:ffff:ffff:ffff:ffff:ffff:ffff,GB
 2a02:b58::,2a02:b58:ffff:ffff:ffff:ffff:ffff:ffff,RS
 2a02:b60::,2a02:b60:ffff:ffff:ffff:ffff:ffff:ffff,IQ
@@ -19223,7 +21329,9 @@
 2a02:c60::,2a02:c60:ffff:ffff:ffff:ffff:ffff:ffff,CZ
 2a02:c68::,2a02:c68:ffff:ffff:ffff:ffff:ffff:ffff,RU
 2a02:c70::,2a02:c70:ffff:ffff:ffff:ffff:ffff:ffff,FR
-2a02:c78::,2a02:c7f:ffff:ffff:ffff:ffff:ffff:ffff,GB
+2a02:c78::,2a02:c7d:424:5fff:ffff:ffff:ffff:ffff,GB
+2a02:c7d:424:6000::,2a02:c7d:424:6fff:ffff:ffff:ffff:ffff,US
+2a02:c7d:424:7000::,2a02:c7f:ffff:ffff:ffff:ffff:ffff:ffff,GB
 2a02:c80::,2a02:c80:ffff:ffff:ffff:ffff:ffff:ffff,SK
 2a02:c88::,2a02:c88:ffff:ffff:ffff:ffff:ffff:ffff,FR
 2a02:c90::,2a02:c90:ffff:ffff:ffff:ffff:ffff:ffff,RU
@@ -19231,8 +21339,7 @@
 2a02:ca0::,2a02:ca0:ffff:ffff:ffff:ffff:ffff:ffff,NL
 2a02:ca8::,2a02:ca8:ffff:ffff:ffff:ffff:ffff:ffff,GB
 2a02:cb0::,2a02:cb0:ffff:ffff:ffff:ffff:ffff:ffff,GB
-2a02:cc0::,2a02:cc0:ffff:ffff:ffff:ffff:ffff:ffff,NL
-2a02:cc8::,2a02:cc9:ffff:ffff:ffff:ffff:ffff:ffff,NL
+2a02:cc0::,2a02:cc9:ffff:ffff:ffff:ffff:ffff:ffff,NL
 2a02:cd0::,2a02:cd0:ffff:ffff:ffff:ffff:ffff:ffff,DE
 2a02:cd8::,2a02:cd8:ffff:ffff:ffff:ffff:ffff:ffff,CH
 2a02:ce0::,2a02:ce0:ffff:ffff:ffff:ffff:ffff:ffff,SA
@@ -19240,7 +21347,7 @@
 2a02:cf0::,2a02:cf0:ffff:ffff:ffff:ffff:ffff:ffff,UA
 2a02:d00::,2a02:d00:ffff:ffff:ffff:ffff:ffff:ffff,CZ
 2a02:d08::,2a02:d0f:ffff:ffff:ffff:ffff:ffff:ffff,BE
-2a02:d10::,2a02:d10:ffff:ffff:ffff:ffff:ffff:ffff,RO
+2a02:d10::,2a02:d17:ffff:ffff:ffff:ffff:ffff:ffff,RO
 2a02:d18::,2a02:d18:ffff:ffff:ffff:ffff:ffff:ffff,AM
 2a02:d20::,2a02:d20:ffff:ffff:ffff:ffff:ffff:ffff,DE
 2a02:d28::,2a02:d28:ffff:ffff:ffff:ffff:ffff:ffff,NL
@@ -19409,9 +21516,10 @@
 2a02:1770::,2a02:1770:ffff:ffff:ffff:ffff:ffff:ffff,PL
 2a02:1778::,2a02:1778:ffff:ffff:ffff:ffff:ffff:ffff,PL
 2a02:1780::,2a02:1780:ffff:ffff:ffff:ffff:ffff:ffff,SE
-2a02:1788::,2a02:1788:4ff:83ff:ffff:ffff:ffff:ffff,GB
-2a02:1788:4ff:8400::,2a02:1788:4ff:84ff:ffff:ffff:ffff:ffff,US
-2a02:1788:4ff:8500::,2a02:1788:ffff:ffff:ffff:ffff:ffff:ffff,GB
+2a02:1788::,2a02:1788:4fe:ffff:ffff:ffff:ffff:ffff,GB
+2a02:1788:4ff::,2a02:1788:4ff:7fff:ffff:ffff:ffff:ffff,RO
+2a02:1788:4ff:8000::,2a02:1788:4ff:ffff:ffff:ffff:ffff:ffff,US
+2a02:1788:500::,2a02:1788:ffff:ffff:ffff:ffff:ffff:ffff,GB
 2a02:1790::,2a02:1790:ffff:ffff:ffff:ffff:ffff:ffff,FI
 2a02:1798::,2a02:179f:ffff:ffff:ffff:ffff:ffff:ffff,DE
 2a02:17a0::,2a02:17a0:ffff:ffff:ffff:ffff:ffff:ffff,CZ
@@ -19426,10 +21534,12 @@
 2a02:17e8::,2a02:17e8:ffff:ffff:ffff:ffff:ffff:ffff,RU
 2a02:17f0::,2a02:17f0:ffff:ffff:ffff:ffff:ffff:ffff,GB
 2a02:17f8::,2a02:17f8:ffff:ffff:ffff:ffff:ffff:ffff,DE
-2a02:1800::,2a02:18ff:ffff:ffff:ffff:ffff:ffff:ffff,BE
+2a02:1800::,2a02:1811:8511:ffff:ffff:ffff:ffff:ffff,BE
+2a02:1811:8512::,2a02:1811:8512:7fff:ffff:ffff:ffff:ffff,NL
+2a02:1811:8512:8000::,2a02:18ff:ffff:ffff:ffff:ffff:ffff:ffff,BE
 2a02:2000::,2a02:2000:ffff:ffff:ffff:ffff:ffff:ffff,UA
 2a02:2008::,2a02:2008:ffff:ffff:ffff:ffff:ffff:ffff,GB
-2a02:2010::,2a02:2010:ffff:ffff:ffff:ffff:ffff:ffff,TR
+2a02:2010::,2a02:2017:ffff:ffff:ffff:ffff:ffff:ffff,TR
 2a02:2018::,2a02:2018:ffff:ffff:ffff:ffff:ffff:ffff,RU
 2a02:2020::,2a02:2020:ffff:ffff:ffff:ffff:ffff:ffff,TR
 2a02:2028::,2a02:2028:ffff:ffff:ffff:ffff:ffff:ffff,DE
@@ -19477,7 +21587,7 @@
 2a02:2198::,2a02:2198:ffff:ffff:ffff:ffff:ffff:ffff,DE
 2a02:21a0::,2a02:21a0:ffff:ffff:ffff:ffff:ffff:ffff,PL
 2a02:21a8::,2a02:21a8:ffff:ffff:ffff:ffff:ffff:ffff,GB
-2a02:21b0::,2a02:21b0:ffff:ffff:ffff:ffff:ffff:ffff,CH
+2a02:21b0::,2a02:21b7:ffff:ffff:ffff:ffff:ffff:ffff,CH
 2a02:21b8::,2a02:21b8:ffff:ffff:ffff:ffff:ffff:ffff,NL
 2a02:21c0::,2a02:21c0:ffff:ffff:ffff:ffff:ffff:ffff,BA
 2a02:21c8::,2a02:21c8:ffff:ffff:ffff:ffff:ffff:ffff,FR
@@ -19672,7 +21782,9 @@
 2a02:2800::,2a02:2800:ffff:ffff:ffff:ffff:ffff:ffff,DE
 2a02:2808::,2a02:2808:1005:ffff:ffff:ffff:ffff:ffff,CZ
 2a02:2808:1006::,2a02:2808:1006:ffff:ffff:ffff:ffff:ffff,RU
-2a02:2808:1007::,2a02:2808:3000:ffff:ffff:ffff:ffff:ffff,CZ
+2a02:2808:1007::,2a02:2808:2800:ffff:ffff:ffff:ffff:ffff,CZ
+2a02:2808:2801::,2a02:2808:2801:7fff:ffff:ffff:ffff:ffff,RU
+2a02:2808:2801:8000::,2a02:2808:3000:ffff:ffff:ffff:ffff:ffff,CZ
 2a02:2808:3001::,2a02:2808:3001:ffff:ffff:ffff:ffff:ffff,RU
 2a02:2808:3002::,2a02:2808:5300:ffff:ffff:ffff:ffff:ffff,CZ
 2a02:2808:5301::,2a02:2808:5301:ffff:ffff:ffff:ffff:ffff,RU
@@ -19807,7 +21919,9 @@
 2a02:2dc0::,2a02:2dc0:ffff:ffff:ffff:ffff:ffff:ffff,DE
 2a02:2de0::,2a02:2de0:ffff:ffff:ffff:ffff:ffff:ffff,PL
 2a02:2e00::,2a02:2e1f:ffff:ffff:ffff:ffff:ffff:ffff,ES
-2a02:2f00::,2a02:2f0f:ffff:ffff:ffff:ffff:ffff:ffff,RO
+2a02:2f00::,2a02:2f0b:804c:ffff:ffff:ffff:ffff:ffff,RO
+2a02:2f0b:804d::,2a02:2f0b:804d:7fff:ffff:ffff:ffff:ffff,FR
+2a02:2f0b:804d:8000::,2a02:2f0f:ffff:ffff:ffff:ffff:ffff:ffff,RO
 2a02:2f80::,2a02:2f80:ffff:ffff:ffff:ffff:ffff:ffff,ES
 2a02:2fc0::,2a02:2fc7:ffff:ffff:ffff:ffff:ffff:ffff,DE
 2a02:2fe0::,2a02:2fe0:ffff:ffff:ffff:ffff:ffff:ffff,IT
@@ -19842,6 +21956,7 @@
 2a02:4360::,2a02:4360:ffff:ffff:ffff:ffff:ffff:ffff,PL
 2a02:4380::,2a02:4380:ffff:ffff:ffff:ffff:ffff:ffff,AZ
 2a02:43a0::,2a02:43a0:ffff:ffff:ffff:ffff:ffff:ffff,IQ
+2a02:43c0::,2a02:43c0:ffff:ffff:ffff:ffff:ffff:ffff,RU
 2a02:43e0::,2a02:43e0:ffff:ffff:ffff:ffff:ffff:ffff,GB
 2a02:4400::,2a02:4400:ffff:ffff:ffff:ffff:ffff:ffff,KZ
 2a02:4420::,2a02:4420:ffff:ffff:ffff:ffff:ffff:ffff,ES
@@ -19931,6 +22046,7 @@
 2a02:4f20::,2a02:4f20:ffff:ffff:ffff:ffff:ffff:ffff,GB
 2a02:4f40::,2a02:4f40:ffff:ffff:ffff:ffff:ffff:ffff,RU
 2a02:4f60::,2a02:4f67:ffff:ffff:ffff:ffff:ffff:ffff,GB
+2a02:4f80::,2a02:4f80:ffff:ffff:ffff:ffff:ffff:ffff,NL
 2a02:4fa0::,2a02:4fa0:ffff:ffff:ffff:ffff:ffff:ffff,IS
 2a02:4fc0::,2a02:4fc0:ffff:ffff:ffff:ffff:ffff:ffff,GR
 2a02:4fe0::,2a02:4fe0:ffff:ffff:ffff:ffff:ffff:ffff,CH
@@ -19974,7 +22090,7 @@
 2a02:54a0::,2a02:54a0:ffff:ffff:ffff:ffff:ffff:ffff,IT
 2a02:54c0::,2a02:54c0:ffff:ffff:ffff:ffff:ffff:ffff,AT
 2a02:54e0::,2a02:54e0:ffff:ffff:ffff:ffff:ffff:ffff,PL
-2a02:5500::,2a02:5500:ffff:ffff:ffff:ffff:ffff:ffff,RU
+2a02:5500::,2a02:5507:ffff:ffff:ffff:ffff:ffff:ffff,RU
 2a02:5520::,2a02:5520:ffff:ffff:ffff:ffff:ffff:ffff,FR
 2a02:5540::,2a02:5540:ffff:ffff:ffff:ffff:ffff:ffff,ES
 2a02:5560::,2a02:5560:ffff:ffff:ffff:ffff:ffff:ffff,NO
@@ -19993,7 +22109,7 @@
 2a02:5700::,2a02:5700:ffff:ffff:ffff:ffff:ffff:ffff,LB
 2a02:5720::,2a02:5720:ffff:ffff:ffff:ffff:ffff:ffff,MK
 2a02:5740::,2a02:5740:ffff:ffff:ffff:ffff:ffff:ffff,EE
-2a02:5760::,2a02:5760:ffff:ffff:ffff:ffff:ffff:ffff,NL
+2a02:5760::,2a02:5767:ffff:ffff:ffff:ffff:ffff:ffff,NL
 2a02:5780::,2a02:5780:ffff:ffff:ffff:ffff:ffff:ffff,GB
 2a02:57a0::,2a02:57a0:ffff:ffff:ffff:ffff:ffff:ffff,FR
 2a02:57c0::,2a02:57c0:ffff:ffff:ffff:ffff:ffff:ffff,TR
@@ -20031,7 +22147,7 @@
 2a02:5bc0::,2a02:5bc0:ffff:ffff:ffff:ffff:ffff:ffff,ES
 2a02:5be0::,2a02:5be0:ffff:ffff:ffff:ffff:ffff:ffff,GB
 2a02:5c00::,2a02:5c00:ffff:ffff:ffff:ffff:ffff:ffff,PL
-2a02:5c20::,2a02:5c20:ffff:ffff:ffff:ffff:ffff:ffff,DK
+2a02:5c20::,2a02:5c27:ffff:ffff:ffff:ffff:ffff:ffff,DK
 2a02:5c40::,2a02:5c40:ffff:ffff:ffff:ffff:ffff:ffff,RU
 2a02:5c60::,2a02:5c60:ffff:ffff:ffff:ffff:ffff:ffff,NL
 2a02:5c80::,2a02:5c80:ffff:ffff:ffff:ffff:ffff:ffff,IT
@@ -20058,7 +22174,7 @@
 2a02:5f20::,2a02:5f20:ffff:ffff:ffff:ffff:ffff:ffff,TR
 2a02:5f40::,2a02:5f40:ffff:ffff:ffff:ffff:ffff:ffff,HR
 2a02:5f60::,2a02:5f60:ffff:ffff:ffff:ffff:ffff:ffff,DE
-2a02:5f80::,2a02:5f80:ffff:ffff:ffff:ffff:ffff:ffff,RU
+2a02:5f80::,2a02:5f87:ffff:ffff:ffff:ffff:ffff:ffff,RU
 2a02:5fa0::,2a02:5fa0:ffff:ffff:ffff:ffff:ffff:ffff,FR
 2a02:5fc0::,2a02:5fc0:ffff:ffff:ffff:ffff:ffff:ffff,ES
 2a02:5fe0::,2a02:5fe0:ffff:ffff:ffff:ffff:ffff:ffff,RU
@@ -20173,6 +22289,7 @@
 2a02:6da0::,2a02:6da0:ffff:ffff:ffff:ffff:ffff:ffff,GB
 2a02:6dc0::,2a02:6dc0:ffff:ffff:ffff:ffff:ffff:ffff,PL
 2a02:6de0::,2a02:6de0:ffff:ffff:ffff:ffff:ffff:ffff,DE
+2a02:6e00:1::,2a02:6e00:1:7fff:ffff:ffff:ffff:ffff,RO
 2a02:6e20::,2a02:6e20:ffff:ffff:ffff:ffff:ffff:ffff,DE
 2a02:6e40::,2a02:6e40:ffff:ffff:ffff:ffff:ffff:ffff,GB
 2a02:6e60::,2a02:6e60:ffff:ffff:ffff:ffff:ffff:ffff,RU
@@ -20303,7 +22420,6 @@
 2a02:7e60::,2a02:7e60:ffff:ffff:ffff:ffff:ffff:ffff,CH
 2a02:7e80::,2a02:7e80:ffff:ffff:ffff:ffff:ffff:ffff,RU
 2a02:7ea0::,2a02:7ea0:ffff:ffff:ffff:ffff:ffff:ffff,SE
-2a02:7ec0::,2a02:7ec0:ffff:ffff:ffff:ffff:ffff:ffff,IR
 2a02:7ee0::,2a02:7ee0:ffff:ffff:ffff:ffff:ffff:ffff,DE
 2a02:7f00::,2a02:7f00:ffff:ffff:ffff:ffff:ffff:ffff,GB
 2a02:7f20::,2a02:7f20:ffff:ffff:ffff:ffff:ffff:ffff,DK
@@ -20326,7 +22442,9 @@
 2a02:8200::,2a02:821f:ffff:ffff:ffff:ffff:ffff:ffff,DE
 2a02:8300::,2a02:830f:ffff:ffff:ffff:ffff:ffff:ffff,CZ
 2a02:8380::,2a02:838f:ffff:ffff:ffff:ffff:ffff:ffff,AT
-2a02:8400::,2a02:847f:ffff:ffff:ffff:ffff:ffff:ffff,FR
+2a02:8400::,2a02:8434:2543:ffff:ffff:ffff:ffff:ffff,FR
+2a02:8434:2544::,2a02:8434:2544:7fff:ffff:ffff:ffff:ffff,ES
+2a02:8434:2544:8000::,2a02:847f:ffff:ffff:ffff:ffff:ffff:ffff,FR
 2a02:8800::,2a02:88ff:ffff:ffff:ffff:ffff:ffff:ffff,GB
 2a02:9000::,2a02:91ff:ffff:ffff:ffff:ffff:ffff:ffff,ES
 2a02:a000::,2a02:a03f:ffff:ffff:ffff:ffff:ffff:ffff,BE
@@ -20380,7 +22498,11 @@
 2a02:c540::,2a02:c547:ffff:ffff:ffff:ffff:ffff:ffff,IT
 2a02:c580::,2a02:c587:ffff:ffff:ffff:ffff:ffff:ffff,IR
 2a02:c5c0::,2a02:c5c7:ffff:ffff:ffff:ffff:ffff:ffff,FI
-2a02:c600::,2a02:c607:ffff:ffff:ffff:ffff:ffff:ffff,CH
+2a02:c600::,2a02:c600:ff:ffff:ffff:ffff:ffff:ffff,CH
+2a02:c600:100::,2a02:c600:100:7fff:ffff:ffff:ffff:ffff,CZ
+2a02:c600:100:8000::,2a02:c600:100:ffff:ffff:ffff:ffff:ffff,CH
+2a02:c600:101::,2a02:c600:101:7fff:ffff:ffff:ffff:ffff,CZ
+2a02:c600:101:8000::,2a02:c607:ffff:ffff:ffff:ffff:ffff:ffff,CH
 2a02:c640::,2a02:c647:ffff:ffff:ffff:ffff:ffff:ffff,HU
 2a02:c680::,2a02:c681:ffff:ffff:ffff:ffff:ffff:ffff,IT
 2a02:c690::,2a02:c691:ffff:ffff:ffff:ffff:ffff:ffff,AD
@@ -20591,6 +22713,7 @@
 2a02:f700::,2a02:f707:ffff:ffff:ffff:ffff:ffff:ffff,LB
 2a02:f740::,2a02:f747:ffff:ffff:ffff:ffff:ffff:ffff,PL
 2a02:f780::,2a02:f787:ffff:ffff:ffff:ffff:ffff:ffff,SE
+2a02:f7c0::,2a02:f7c7:ffff:ffff:ffff:ffff:ffff:ffff,UZ
 2a02:f800::,2a02:f807:ffff:ffff:ffff:ffff:ffff:ffff,RU
 2a02:f840::,2a02:f847:ffff:ffff:ffff:ffff:ffff:ffff,NL
 2a02:f880::,2a02:f887:ffff:ffff:ffff:ffff:ffff:ffff,DE
@@ -20601,7 +22724,8 @@
 2a02:f9c0::,2a02:f9c7:ffff:ffff:ffff:ffff:ffff:ffff,GB
 2a02:fa00::,2a02:fa07:ffff:ffff:ffff:ffff:ffff:ffff,SA
 2a02:fa40::,2a02:fa47:ffff:ffff:ffff:ffff:ffff:ffff,TR
-2a02:fac0::,2a02:fac7:ffff:ffff:ffff:ffff:ffff:ffff,PL
+2a02:fa80::,2a02:fa80:ffff:ffff:ffff:ffff:ffff:ffff,GR
+2a02:faa0::,2a02:faa0:ffff:ffff:ffff:ffff:ffff:ffff,DE
 2a02:fb00::,2a02:fb07:ffff:ffff:ffff:ffff:ffff:ffff,DE
 2a02:fb40::,2a02:fb47:ffff:ffff:ffff:ffff:ffff:ffff,GB
 2a02:fb80::,2a02:fb87:ffff:ffff:ffff:ffff:ffff:ffff,IT
@@ -20645,7 +22769,6 @@
 2a03:2a0::,2a03:2a0:ffff:ffff:ffff:ffff:ffff:ffff,CH
 2a03:2c0::,2a03:2c0:ffff:ffff:ffff:ffff:ffff:ffff,BG
 2a03:2e0::,2a03:2e0:ffff:ffff:ffff:ffff:ffff:ffff,CZ
-2a03:300::,2a03:300:ffff:ffff:ffff:ffff:ffff:ffff,GB
 2a03:320::,2a03:320:ffff:ffff:ffff:ffff:ffff:ffff,IL
 2a03:340::,2a03:340:ffff:ffff:ffff:ffff:ffff:ffff,RU
 2a03:360::,2a03:360:ffff:ffff:ffff:ffff:ffff:ffff,FR
@@ -20744,11 +22867,15 @@
 2a03:f60::,2a03:f60:ffff:ffff:ffff:ffff:ffff:ffff,NO
 2a03:f80::,2a03:f80:43:ffff:ffff:ffff:ffff:ffff,AT
 2a03:f80:44::,2a03:f80:44:ffff:ffff:ffff:ffff:ffff,IM
-2a03:f80:45::,2a03:f80:55:ffff:ffff:ffff:ffff:ffff,AT
+2a03:f80:45::,2a03:f80:47:ffff:ffff:ffff:ffff:ffff,AT
+2a03:f80:48::,2a03:f80:48:7fff:ffff:ffff:ffff:ffff,PL
+2a03:f80:48:8000::,2a03:f80:55:ffff:ffff:ffff:ffff:ffff,AT
 2a03:f80:56::,2a03:f80:56:ffff:ffff:ffff:ffff:ffff,CL
 2a03:f80:57::,2a03:f80:353:ffff:ffff:ffff:ffff:ffff,AT
 2a03:f80:354::,2a03:f80:354:ffff:ffff:ffff:ffff:ffff,IS
-2a03:f80:355::,2a03:f87:7:ffff:ffff:ffff:ffff:ffff,AT
+2a03:f80:355::,2a03:f80:851:ffff:ffff:ffff:ffff:ffff,AT
+2a03:f80:852::,2a03:f80:852:7fff:ffff:ffff:ffff:ffff,HK
+2a03:f80:852:8000::,2a03:f87:7:ffff:ffff:ffff:ffff:ffff,AT
 2a03:f87:8::,2a03:f87:8:7fff:ffff:ffff:ffff:ffff,SG
 2a03:f87:8:8000::,2a03:f87:ffff:ffff:ffff:ffff:ffff:ffff,AT
 2a03:fc0::,2a03:fc0:ffff:ffff:ffff:ffff:ffff:ffff,DE
@@ -20886,7 +23013,6 @@
 2a03:2060::,2a03:2060:ffff:ffff:ffff:ffff:ffff:ffff,CH
 2a03:2080::,2a03:2080:ffff:ffff:ffff:ffff:ffff:ffff,NL
 2a03:20a0::,2a03:20a0:ffff:ffff:ffff:ffff:ffff:ffff,GB
-2a03:20c0::,2a03:20c0:ffff:ffff:ffff:ffff:ffff:ffff,GB
 2a03:20e0::,2a03:20e0:ffff:ffff:ffff:ffff:ffff:ffff,NO
 2a03:2100::,2a03:2100:ffff:ffff:ffff:ffff:ffff:ffff,TR
 2a03:2120::,2a03:2120:ffff:ffff:ffff:ffff:ffff:ffff,CH
@@ -20926,6 +23052,7 @@
 2a03:2560::,2a03:2560:ffff:ffff:ffff:ffff:ffff:ffff,MK
 2a03:2580::,2a03:2580:ffff:ffff:ffff:ffff:ffff:ffff,GB
 2a03:25a0::,2a03:25a0:ffff:ffff:ffff:ffff:ffff:ffff,NO
+2a03:25c0::,2a03:25c0:ffff:ffff:ffff:ffff:ffff:ffff,FR
 2a03:25e0::,2a03:25e0:ffff:ffff:ffff:ffff:ffff:ffff,GB
 2a03:2600::,2a03:2600:ffff:ffff:ffff:ffff:ffff:ffff,CH
 2a03:2620::,2a03:2620:ffff:ffff:ffff:ffff:ffff:ffff,TR
@@ -20933,6 +23060,7 @@
 2a03:2660::,2a03:2660:ffff:ffff:ffff:ffff:ffff:ffff,RS
 2a03:2680::,2a03:2680:ffff:ffff:ffff:ffff:ffff:ffff,FR
 2a03:26a0::,2a03:26a0:ffff:ffff:ffff:ffff:ffff:ffff,ES
+2a03:26c0::,2a03:26c0:ffff:ffff:ffff:ffff:ffff:ffff,RU
 2a03:26e0::,2a03:26e0:ffff:ffff:ffff:ffff:ffff:ffff,RU
 2a03:2700::,2a03:2700:ffff:ffff:ffff:ffff:ffff:ffff,IT
 2a03:2720::,2a03:2720:ffff:ffff:ffff:ffff:ffff:ffff,DE
@@ -20947,14 +23075,24 @@
 2a03:2840::,2a03:2840:ffff:ffff:ffff:ffff:ffff:ffff,US
 2a03:2860::,2a03:2860:ffff:ffff:ffff:ffff:ffff:ffff,RU
 2a03:2880::,2a03:2880:10:ffff:ffff:ffff:ffff:ffff,IE
-2a03:2880:11::,2a03:2880:11:7fff:ffff:ffff:ffff:ffff,US
-2a03:2880:11:8000::,2a03:2880:1f:ffff:ffff:ffff:ffff:ffff,IE
-2a03:2880:20::,2a03:2880:20:7fff:ffff:ffff:ffff:ffff,US
-2a03:2880:20:8000::,2a03:2887:ffff:ffff:ffff:ffff:ffff:ffff,IE
+2a03:2880:11::,2a03:2880:11:ffff:ffff:ffff:ffff:ffff,US
+2a03:2880:12::,2a03:2880:1f:ffff:ffff:ffff:ffff:ffff,IE
+2a03:2880:20::,2a03:2880:20:ffff:ffff:ffff:ffff:ffff,US
+2a03:2880:21::,2a03:2880:100f:ffff:ffff:ffff:ffff:ffff,IE
+2a03:2880:1010::,2a03:2880:1010:7fff:ffff:ffff:ffff:ffff,US
+2a03:2880:1010:8000::,2a03:2880:201f:ffff:ffff:ffff:ffff:ffff,IE
+2a03:2880:2020::,2a03:2880:2020:ffff:ffff:ffff:ffff:ffff,US
+2a03:2880:2021::,2a03:2880:202f:ffff:ffff:ffff:ffff:ffff,IE
+2a03:2880:2030::,2a03:2880:2030:7fff:ffff:ffff:ffff:ffff,US
+2a03:2880:2030:8000::,2a03:2880:204f:ffff:ffff:ffff:ffff:ffff,IE
+2a03:2880:2050::,2a03:2880:2050:7fff:ffff:ffff:ffff:ffff,GB
+2a03:2880:2050:8000::,2a03:2880:300f:ffff:ffff:ffff:ffff:ffff,IE
+2a03:2880:3010::,2a03:2880:3010:ffff:ffff:ffff:ffff:ffff,GB
+2a03:2880:3011::,2a03:2887:ffff:ffff:ffff:ffff:ffff:ffff,IE
 2a03:28a0::,2a03:28a0:ffff:ffff:ffff:ffff:ffff:ffff,NL
 2a03:28c0::,2a03:28c0:ffff:ffff:ffff:ffff:ffff:ffff,TR
 2a03:28e0::,2a03:28e0:ffff:ffff:ffff:ffff:ffff:ffff,SE
-2a03:2900::,2a03:2900:ffff:ffff:ffff:ffff:ffff:ffff,DE
+2a03:2900::,2a03:2907:ffff:ffff:ffff:ffff:ffff:ffff,DE
 2a03:2920::,2a03:2920:ffff:ffff:ffff:ffff:ffff:ffff,ME
 2a03:2940::,2a03:2940:ffff:ffff:ffff:ffff:ffff:ffff,PS
 2a03:2960::,2a03:2960:ffff:ffff:ffff:ffff:ffff:ffff,CH
@@ -20969,6 +23107,7 @@
 2a03:2a80::,2a03:2a80:ffff:ffff:ffff:ffff:ffff:ffff,CZ
 2a03:2aa0::,2a03:2aa0:ffff:ffff:ffff:ffff:ffff:ffff,AE
 2a03:2ac0::,2a03:2ac0:ffff:ffff:ffff:ffff:ffff:ffff,GB
+2a03:2ae0::,2a03:2ae0:ffff:ffff:ffff:ffff:ffff:ffff,BE
 2a03:2b00::,2a03:2b00:ffff:ffff:ffff:ffff:ffff:ffff,IT
 2a03:2b20::,2a03:2b20:ffff:ffff:ffff:ffff:ffff:ffff,DE
 2a03:2b40::,2a03:2b40:ffff:ffff:ffff:ffff:ffff:ffff,RU
@@ -21201,7 +23340,9 @@
 2a03:48a0::,2a03:48a0:ffff:ffff:ffff:ffff:ffff:ffff,FR
 2a03:48c0::,2a03:48c0:ffff:ffff:ffff:ffff:ffff:ffff,TR
 2a03:48e0::,2a03:48e0:ffff:ffff:ffff:ffff:ffff:ffff,GB
-2a03:4900::,2a03:4900:ffff:ffff:ffff:ffff:ffff:ffff,RU
+2a03:4900::,2a03:4900::ffff:ffff:ffff:ffff:ffff,RU
+2a03:4900:1::,2a03:4900:1:7fff:ffff:ffff:ffff:ffff,UA
+2a03:4900:1:8000::,2a03:4900:ffff:ffff:ffff:ffff:ffff:ffff,RU
 2a03:4920::,2a03:4920:ffff:ffff:ffff:ffff:ffff:ffff,DE
 2a03:4940::,2a03:4940:ffff:ffff:ffff:ffff:ffff:ffff,DK
 2a03:4960::,2a03:4960:ffff:ffff:ffff:ffff:ffff:ffff,RS
@@ -21213,7 +23354,33 @@
 2a03:4a20::,2a03:4a20:ffff:ffff:ffff:ffff:ffff:ffff,DE
 2a03:4a40::,2a03:4a40:ffff:ffff:ffff:ffff:ffff:ffff,IT
 2a03:4a60::,2a03:4a60:ffff:ffff:ffff:ffff:ffff:ffff,SA
-2a03:4a80::,2a03:4a80:ffff:ffff:ffff:ffff:ffff:ffff,NL
+2a03:4a80::,2a03:4a80::ffff:ffff:ffff:ffff,NL
+2a03:4a80:0:1::,2a03:4a80::1:ffff:ffff:ffff:ffff,GB
+2a03:4a80:0:2::,2a03:4a80::2:ffff:ffff:ffff:ffff,CA
+2a03:4a80:0:3::,2a03:4a80::3:ffff:ffff:ffff:ffff,CZ
+2a03:4a80:0:4::,2a03:4a80::4:ffff:ffff:ffff:ffff,NL
+2a03:4a80:0:5::,2a03:4a80::5:ffff:ffff:ffff:ffff,FR
+2a03:4a80:0:6::,2a03:4a80::6:ffff:ffff:ffff:ffff,DK
+2a03:4a80:0:7::,2a03:4a80::7:ffff:ffff:ffff:ffff,RU
+2a03:4a80:0:8::,2a03:4a80::8:ffff:ffff:ffff:ffff,TR
+2a03:4a80:0:9::,2a03:4a80::9:ffff:ffff:ffff:ffff,UA
+2a03:4a80:0:a::,2a03:4a80::a:ffff:ffff:ffff:ffff,MX
+2a03:4a80:0:b::,2a03:4a80::b:ffff:ffff:ffff:ffff,AE
+2a03:4a80:0:c::,2a03:4a80::ffff:ffff:ffff:ffff:ffff,NL
+2a03:4a80:1::,2a03:4a80:1:ffff:ffff:ffff:ffff:ffff,GB
+2a03:4a80:2::,2a03:4a80:2:ffff:ffff:ffff:ffff:ffff,CA
+2a03:4a80:3::,2a03:4a80:3:ffff:ffff:ffff:ffff:ffff,CZ
+2a03:4a80:4::,2a03:4a80:4:ffff:ffff:ffff:ffff:ffff,DE
+2a03:4a80:5::,2a03:4a80:5:ffff:ffff:ffff:ffff:ffff,FR
+2a03:4a80:6::,2a03:4a80:6:ffff:ffff:ffff:ffff:ffff,DK
+2a03:4a80:7::,2a03:4a80:7:ffff:ffff:ffff:ffff:ffff,RU
+2a03:4a80:8::,2a03:4a80:8:ffff:ffff:ffff:ffff:ffff,TR
+2a03:4a80:9::,2a03:4a80:9:ffff:ffff:ffff:ffff:ffff,UA
+2a03:4a80:a::,2a03:4a80:a:ffff:ffff:ffff:ffff:ffff,MX
+2a03:4a80:b::,2a03:4a80:b:ffff:ffff:ffff:ffff:ffff,AE
+2a03:4a80:c::,2a03:4a80:fffe:ffff:ffff:ffff:ffff:ffff,NL
+2a03:4a80:ffff::,2a03:4a80:ffff:7fff:ffff:ffff:ffff:ffff,US
+2a03:4a80:ffff:8000::,2a03:4a80:ffff:ffff:ffff:ffff:ffff:ffff,NL
 2a03:4aa0::,2a03:4aa0:ffff:ffff:ffff:ffff:ffff:ffff,NL
 2a03:4ac0::,2a03:4ac0:ffff:ffff:ffff:ffff:ffff:ffff,KZ
 2a03:4ae0::,2a03:4ae0:ffff:ffff:ffff:ffff:ffff:ffff,CH
@@ -21340,7 +23507,6 @@
 2a03:5aa0::,2a03:5aa0:ffff:ffff:ffff:ffff:ffff:ffff,ES
 2a03:5ac0::,2a03:5ac0:ffff:ffff:ffff:ffff:ffff:ffff,CH
 2a03:5ae0::,2a03:5ae0:ffff:ffff:ffff:ffff:ffff:ffff,HU
-2a03:5b00::,2a03:5b00:ffff:ffff:ffff:ffff:ffff:ffff,TR
 2a03:5b20::,2a03:5b20:ffff:ffff:ffff:ffff:ffff:ffff,RE
 2a03:5b40::,2a03:5b40:ffff:ffff:ffff:ffff:ffff:ffff,GB
 2a03:5b60::,2a03:5b60:ffff:ffff:ffff:ffff:ffff:ffff,NL
@@ -21390,7 +23556,6 @@
 2a03:6140::,2a03:6140:ffff:ffff:ffff:ffff:ffff:ffff,RU
 2a03:6160::,2a03:6160:ffff:ffff:ffff:ffff:ffff:ffff,AZ
 2a03:6180::,2a03:6180:ffff:ffff:ffff:ffff:ffff:ffff,NO
-2a03:61a0::,2a03:61a0:ffff:ffff:ffff:ffff:ffff:ffff,RU
 2a03:61c0::,2a03:61c0:ffff:ffff:ffff:ffff:ffff:ffff,GB
 2a03:61e0::,2a03:61e0:ffff:ffff:ffff:ffff:ffff:ffff,ES
 2a03:6200::,2a03:6200:ffff:ffff:ffff:ffff:ffff:ffff,RU
@@ -21398,7 +23563,9 @@
 2a03:6240::,2a03:6240:ffff:ffff:ffff:ffff:ffff:ffff,NO
 2a03:6260::,2a03:6260:ffff:ffff:ffff:ffff:ffff:ffff,FR
 2a03:6280::,2a03:6280:ffff:ffff:ffff:ffff:ffff:ffff,ES
-2a03:62a0::,2a03:62a0:ffff:ffff:ffff:ffff:ffff:ffff,AU
+2a03:62a0::,2a03:62a0:3500:ffff:ffff:ffff:ffff:ffff,AU
+2a03:62a0:3501::,2a03:62a0:3501:7fff:ffff:ffff:ffff:ffff,FI
+2a03:62a0:3501:8000::,2a03:62a0:ffff:ffff:ffff:ffff:ffff:ffff,AU
 2a03:62c0::,2a03:62c0:ffff:ffff:ffff:ffff:ffff:ffff,ES
 2a03:62e0::,2a03:62e0:ffff:ffff:ffff:ffff:ffff:ffff,DE
 2a03:6300::,2a03:6300:ffff:ffff:ffff:ffff:ffff:ffff,UA
@@ -21417,7 +23584,7 @@
 2a03:64a0::,2a03:64a0:ffff:ffff:ffff:ffff:ffff:ffff,ES
 2a03:64c0::,2a03:64c0:ffff:ffff:ffff:ffff:ffff:ffff,UA
 2a03:64e0::,2a03:64e0:ffff:ffff:ffff:ffff:ffff:ffff,LB
-2a03:6500::,2a03:6500:ffff:ffff:ffff:ffff:ffff:ffff,RU
+2a03:6500::,2a03:6507:ffff:ffff:ffff:ffff:ffff:ffff,RU
 2a03:6520::,2a03:6520:ffff:ffff:ffff:ffff:ffff:ffff,ES
 2a03:6540::,2a03:6540:ffff:ffff:ffff:ffff:ffff:ffff,UA
 2a03:6560::,2a03:6560:ffff:ffff:ffff:ffff:ffff:ffff,FR
@@ -21492,6 +23659,7 @@
 2a03:6e40::,2a03:6e40:ffff:ffff:ffff:ffff:ffff:ffff,FR
 2a03:6e60::,2a03:6e60:ffff:ffff:ffff:ffff:ffff:ffff,IE
 2a03:6e80::,2a03:6e80:ffff:ffff:ffff:ffff:ffff:ffff,CZ
+2a03:6ea0::,2a03:6ea0:ffff:ffff:ffff:ffff:ffff:ffff,RU
 2a03:6ec0::,2a03:6ec0:ffff:ffff:ffff:ffff:ffff:ffff,HU
 2a03:6ee0::,2a03:6ee0:ffff:ffff:ffff:ffff:ffff:ffff,DE
 2a03:6f00::,2a03:6f00:ffff:ffff:ffff:ffff:ffff:ffff,RU
@@ -21517,7 +23685,7 @@
 2a03:71a0::,2a03:71a0:ffff:ffff:ffff:ffff:ffff:ffff,UA
 2a03:71c0::,2a03:71c0:ffff:ffff:ffff:ffff:ffff:ffff,CZ
 2a03:71e0::,2a03:71e0:ffff:ffff:ffff:ffff:ffff:ffff,NL
-2a03:7200::,2a03:7200:ffff:ffff:ffff:ffff:ffff:ffff,RU
+2a03:7200::,2a03:7207:ffff:ffff:ffff:ffff:ffff:ffff,RU
 2a03:7220::,2a03:7220:ffff:ffff:ffff:ffff:ffff:ffff,FR
 2a03:7240::,2a03:7240:ffff:ffff:ffff:ffff:ffff:ffff,CZ
 2a03:7260::,2a03:7260:ffff:ffff:ffff:ffff:ffff:ffff,ES
@@ -21576,6 +23744,7 @@
 2a03:7920::,2a03:7920:ffff:ffff:ffff:ffff:ffff:ffff,LB
 2a03:7940::,2a03:7940:ffff:ffff:ffff:ffff:ffff:ffff,PL
 2a03:7960::,2a03:7960:ffff:ffff:ffff:ffff:ffff:ffff,DE
+2a03:7980::,2a03:7980:ffff:ffff:ffff:ffff:ffff:ffff,NL
 2a03:79a0::,2a03:79a0:ffff:ffff:ffff:ffff:ffff:ffff,RU
 2a03:79c0::,2a03:79c0:ffff:ffff:ffff:ffff:ffff:ffff,RU
 2a03:79e0::,2a03:79e0:ffff:ffff:ffff:ffff:ffff:ffff,NL
@@ -21585,6 +23754,7 @@
 2a03:7a60::,2a03:7a60:ffff:ffff:ffff:ffff:ffff:ffff,NL
 2a03:7a80::,2a03:7a80:ffff:ffff:ffff:ffff:ffff:ffff,LV
 2a03:7aa0::,2a03:7aa0:ffff:ffff:ffff:ffff:ffff:ffff,IM
+2a03:7ac0::,2a03:7ac0:ffff:ffff:ffff:ffff:ffff:ffff,AD
 2a03:7ae0::,2a03:7ae0:ffff:ffff:ffff:ffff:ffff:ffff,DE
 2a03:7b00::,2a03:7b00:ffff:ffff:ffff:ffff:ffff:ffff,TR
 2a03:7b20::,2a03:7b20:ffff:ffff:ffff:ffff:ffff:ffff,KZ
@@ -21606,6 +23776,7 @@
 2a03:7d20::,2a03:7d20:ffff:ffff:ffff:ffff:ffff:ffff,TR
 2a03:7d40::,2a03:7d40:ffff:ffff:ffff:ffff:ffff:ffff,IE
 2a03:7d60::,2a03:7d60:ffff:ffff:ffff:ffff:ffff:ffff,IQ
+2a03:7d80::,2a03:7d80:ffff:ffff:ffff:ffff:ffff:ffff,RU
 2a03:7da0::,2a03:7da0:ffff:ffff:ffff:ffff:ffff:ffff,RU
 2a03:7dc0::,2a03:7dc0:ffff:ffff:ffff:ffff:ffff:ffff,RU
 2a03:7de0::,2a03:7de0:ffff:ffff:ffff:ffff:ffff:ffff,BE
@@ -21653,6 +23824,7 @@
 2a03:82a0::,2a03:82a0:ffff:ffff:ffff:ffff:ffff:ffff,AT
 2a03:82c0::,2a03:82c0:ffff:ffff:ffff:ffff:ffff:ffff,BG
 2a03:82e0::,2a03:82e0:ffff:ffff:ffff:ffff:ffff:ffff,NL
+2a03:8300::,2a03:8300:ffff:ffff:ffff:ffff:ffff:ffff,NL
 2a03:8320::,2a03:8320:ffff:ffff:ffff:ffff:ffff:ffff,CZ
 2a03:8340::,2a03:8340:ffff:ffff:ffff:ffff:ffff:ffff,BG
 2a03:8360::,2a03:8360:ffff:ffff:ffff:ffff:ffff:ffff,FR
@@ -21714,6 +23886,9 @@
 2a03:8a60::,2a03:8a60:ffff:ffff:ffff:ffff:ffff:ffff,NL
 2a03:8a80::,2a03:8a80:ffff:ffff:ffff:ffff:ffff:ffff,AT
 2a03:8aa0::,2a03:8aa0:ffff:ffff:ffff:ffff:ffff:ffff,ES
+2a03:8ac0::,2a03:8ac0:24f:ffff:ffff:ffff:ffff:ffff,US
+2a03:8ac0:250::,2a03:8ac0:250:ffff:ffff:ffff:ffff:ffff,SG
+2a03:8ac0:251::,2a03:8ac0:ffff:ffff:ffff:ffff:ffff:ffff,US
 2a03:8ae0::,2a03:8ae0:ffff:ffff:ffff:ffff:ffff:ffff,DE
 2a03:8b00::,2a03:8b00:ffff:ffff:ffff:ffff:ffff:ffff,SM
 2a03:8b20::,2a03:8b20:ffff:ffff:ffff:ffff:ffff:ffff,GB
@@ -21730,9 +23905,11 @@
 2a03:8c80::,2a03:8c87:ffff:ffff:ffff:ffff:ffff:ffff,IT
 2a03:8cc0::,2a03:8cc0:ffff:ffff:ffff:ffff:ffff:ffff,GB
 2a03:8ce0::,2a03:8ce0:ffff:ffff:ffff:ffff:ffff:ffff,RU
+2a03:8d00::,2a03:8d00:ffff:ffff:ffff:ffff:ffff:ffff,GB
 2a03:8d20::,2a03:8d20:ffff:ffff:ffff:ffff:ffff:ffff,AT
 2a03:8d40::,2a03:8d40:ffff:ffff:ffff:ffff:ffff:ffff,CH
 2a03:8d60::,2a03:8d60:ffff:ffff:ffff:ffff:ffff:ffff,SI
+2a03:8d80::,2a03:8d80:ffff:ffff:ffff:ffff:ffff:ffff,FR
 2a03:8da0::,2a03:8da0:ffff:ffff:ffff:ffff:ffff:ffff,CZ
 2a03:8dc0::,2a03:8dc0:ffff:ffff:ffff:ffff:ffff:ffff,DE
 2a03:8de0::,2a03:8de0:ffff:ffff:ffff:ffff:ffff:ffff,NL
@@ -21752,88 +23929,167 @@
 2a03:8fc0::,2a03:8fc0:ffff:ffff:ffff:ffff:ffff:ffff,DE
 2a03:8fe0::,2a03:8fe0:ffff:ffff:ffff:ffff:ffff:ffff,GB
 2a03:9000::,2a03:9000:ffff:ffff:ffff:ffff:ffff:ffff,RU
+2a03:9020::,2a03:9020:ffff:ffff:ffff:ffff:ffff:ffff,SE
 2a03:9040::,2a03:9040:ffff:ffff:ffff:ffff:ffff:ffff,GB
+2a03:9060::,2a03:9060:ffff:ffff:ffff:ffff:ffff:ffff,FR
 2a03:9080::,2a03:9080:ffff:ffff:ffff:ffff:ffff:ffff,IR
+2a03:90a0::,2a03:90a0:ffff:ffff:ffff:ffff:ffff:ffff,SE
 2a03:90c0::,2a03:90c0:ffff:ffff:ffff:ffff:ffff:ffff,AT
+2a03:90e0::,2a03:90e0:ffff:ffff:ffff:ffff:ffff:ffff,SA
 2a03:9100::,2a03:9100:ffff:ffff:ffff:ffff:ffff:ffff,TR
+2a03:9120::,2a03:9120:ffff:ffff:ffff:ffff:ffff:ffff,BY
 2a03:9140::,2a03:9140:ffff:ffff:ffff:ffff:ffff:ffff,PL
+2a03:9160::,2a03:9160:ffff:ffff:ffff:ffff:ffff:ffff,DE
 2a03:9180::,2a03:9180:ffff:ffff:ffff:ffff:ffff:ffff,FR
+2a03:91a0::,2a03:91a0:ffff:ffff:ffff:ffff:ffff:ffff,CH
 2a03:91c0::,2a03:91c0:ffff:ffff:ffff:ffff:ffff:ffff,IT
+2a03:91e0::,2a03:91e0:ffff:ffff:ffff:ffff:ffff:ffff,AT
 2a03:9200::,2a03:9200:ffff:ffff:ffff:ffff:ffff:ffff,CZ
+2a03:9220::,2a03:9220:ffff:ffff:ffff:ffff:ffff:ffff,UA
 2a03:9240::,2a03:9240:ffff:ffff:ffff:ffff:ffff:ffff,BA
+2a03:9260::,2a03:9260:ffff:ffff:ffff:ffff:ffff:ffff,FR
 2a03:9280::,2a03:9280:ffff:ffff:ffff:ffff:ffff:ffff,GB
+2a03:92a0::,2a03:92a0:ffff:ffff:ffff:ffff:ffff:ffff,CZ
 2a03:92c0::,2a03:92c0:ffff:ffff:ffff:ffff:ffff:ffff,FR
+2a03:92e0::,2a03:92e0:ffff:ffff:ffff:ffff:ffff:ffff,LU
 2a03:9300::,2a03:9300:ffff:ffff:ffff:ffff:ffff:ffff,PL
+2a03:9320::,2a03:9320:ffff:ffff:ffff:ffff:ffff:ffff,ES
 2a03:9340::,2a03:9340:ffff:ffff:ffff:ffff:ffff:ffff,ES
+2a03:9360::,2a03:9360:ffff:ffff:ffff:ffff:ffff:ffff,HR
 2a03:9380::,2a03:9380:ffff:ffff:ffff:ffff:ffff:ffff,GB
+2a03:93a0::,2a03:93a0:ffff:ffff:ffff:ffff:ffff:ffff,DE
 2a03:93c0::,2a03:93c0:ffff:ffff:ffff:ffff:ffff:ffff,RU
+2a03:93e0::,2a03:93e0:ffff:ffff:ffff:ffff:ffff:ffff,DE
 2a03:9400::,2a03:9400:ffff:ffff:ffff:ffff:ffff:ffff,RU
+2a03:9420::,2a03:9420:ffff:ffff:ffff:ffff:ffff:ffff,LU
 2a03:9440::,2a03:9440:ffff:ffff:ffff:ffff:ffff:ffff,TR
+2a03:9460::,2a03:9460:ffff:ffff:ffff:ffff:ffff:ffff,RU
 2a03:9480::,2a03:9480:ffff:ffff:ffff:ffff:ffff:ffff,DE
+2a03:94a0::,2a03:94a0:ffff:ffff:ffff:ffff:ffff:ffff,RS
 2a03:94c0::,2a03:94c0:ffff:ffff:ffff:ffff:ffff:ffff,GB
+2a03:94e0::,2a03:94e0:ffff:ffff:ffff:ffff:ffff:ffff,NO
 2a03:9500::,2a03:9500:ffff:ffff:ffff:ffff:ffff:ffff,PL
+2a03:9520::,2a03:9520:ffff:ffff:ffff:ffff:ffff:ffff,ES
 2a03:9540::,2a03:9540:ffff:ffff:ffff:ffff:ffff:ffff,CZ
+2a03:9560::,2a03:9567:ffff:ffff:ffff:ffff:ffff:ffff,PL
 2a03:9580::,2a03:9580:ffff:ffff:ffff:ffff:ffff:ffff,ES
+2a03:95a0::,2a03:95a0:ffff:ffff:ffff:ffff:ffff:ffff,BE
 2a03:95c0::,2a03:95c0:ffff:ffff:ffff:ffff:ffff:ffff,EE
+2a03:95e0::,2a03:95e0:ffff:ffff:ffff:ffff:ffff:ffff,DK
 2a03:9600::,2a03:9600:ffff:ffff:ffff:ffff:ffff:ffff,GB
+2a03:9620::,2a03:9620:ffff:ffff:ffff:ffff:ffff:ffff,NO
 2a03:9640::,2a03:9640:ffff:ffff:ffff:ffff:ffff:ffff,PS
+2a03:9660::,2a03:9660:ffff:ffff:ffff:ffff:ffff:ffff,CH
 2a03:9680::,2a03:9680:ffff:ffff:ffff:ffff:ffff:ffff,ES
+2a03:96a0::,2a03:96a0:ffff:ffff:ffff:ffff:ffff:ffff,DK
 2a03:96c0::,2a03:96c0:ffff:ffff:ffff:ffff:ffff:ffff,RU
+2a03:96e0::,2a03:96e0:ffff:ffff:ffff:ffff:ffff:ffff,NO
 2a03:9700::,2a03:9700:ffff:ffff:ffff:ffff:ffff:ffff,NL
+2a03:9720::,2a03:9720:ffff:ffff:ffff:ffff:ffff:ffff,NL
 2a03:9740::,2a03:9740:ffff:ffff:ffff:ffff:ffff:ffff,RU
+2a03:9760::,2a03:9760:ffff:ffff:ffff:ffff:ffff:ffff,RS
 2a03:9780::,2a03:9780:ffff:ffff:ffff:ffff:ffff:ffff,CZ
+2a03:97a0::,2a03:97a0:ffff:ffff:ffff:ffff:ffff:ffff,CH
 2a03:97c0::,2a03:97c1:ffff:ffff:ffff:ffff:ffff:ffff,BY
+2a03:97e0::,2a03:97e0:ffff:ffff:ffff:ffff:ffff:ffff,NO
 2a03:9800::,2a03:9807:ffff:ffff:ffff:ffff:ffff:ffff,GB
 2a03:9840::,2a03:9840:ffff:ffff:ffff:ffff:ffff:ffff,RU
+2a03:9860::,2a03:9860:ffff:ffff:ffff:ffff:ffff:ffff,UA
 2a03:9880::,2a03:9880:ffff:ffff:ffff:ffff:ffff:ffff,IT
+2a03:98a0::,2a03:98a0:ffff:ffff:ffff:ffff:ffff:ffff,GB
 2a03:98c0::,2a03:98c7:ffff:ffff:ffff:ffff:ffff:ffff,LU
 2a03:9900::,2a03:9900:ffff:ffff:ffff:ffff:ffff:ffff,HU
+2a03:9920::,2a03:9920:ffff:ffff:ffff:ffff:ffff:ffff,SE
 2a03:9940::,2a03:9940:ffff:ffff:ffff:ffff:ffff:ffff,AT
+2a03:9960::,2a03:9960:ffff:ffff:ffff:ffff:ffff:ffff,FR
 2a03:9980::,2a03:9980:ffff:ffff:ffff:ffff:ffff:ffff,DE
+2a03:99a0::,2a03:99a0:ffff:ffff:ffff:ffff:ffff:ffff,ES
 2a03:99c0::,2a03:99c0:ffff:ffff:ffff:ffff:ffff:ffff,GB
+2a03:99e0::,2a03:99e0:ffff:ffff:ffff:ffff:ffff:ffff,RU
 2a03:9a00::,2a03:9a07:ffff:ffff:ffff:ffff:ffff:ffff,NO
 2a03:9a40::,2a03:9a40:ffff:ffff:ffff:ffff:ffff:ffff,FR
+2a03:9a60::,2a03:9a60:ffff:ffff:ffff:ffff:ffff:ffff,CH
 2a03:9a80::,2a03:9a80:ffff:ffff:ffff:ffff:ffff:ffff,SE
+2a03:9aa0::,2a03:9aa0:ffff:ffff:ffff:ffff:ffff:ffff,DK
 2a03:9ac0::,2a03:9ac0:ffff:ffff:ffff:ffff:ffff:ffff,PL
+2a03:9ae0::,2a03:9ae0:ffff:ffff:ffff:ffff:ffff:ffff,DK
 2a03:9b00::,2a03:9b00:ffff:ffff:ffff:ffff:ffff:ffff,FI
+2a03:9b20::,2a03:9b20:ffff:ffff:ffff:ffff:ffff:ffff,AT
 2a03:9b40::,2a03:9b40:ffff:ffff:ffff:ffff:ffff:ffff,DE
+2a03:9b60::,2a03:9b60:ffff:ffff:ffff:ffff:ffff:ffff,BY
 2a03:9b80::,2a03:9b80:ffff:ffff:ffff:ffff:ffff:ffff,FI
+2a03:9ba0::,2a03:9ba0:ffff:ffff:ffff:ffff:ffff:ffff,GB
 2a03:9bc0::,2a03:9bc0:ffff:ffff:ffff:ffff:ffff:ffff,ES
+2a03:9be0::,2a03:9be0:ffff:ffff:ffff:ffff:ffff:ffff,PL
 2a03:9c00::,2a03:9c00:ffff:ffff:ffff:ffff:ffff:ffff,RO
+2a03:9c20::,2a03:9c20:ffff:ffff:ffff:ffff:ffff:ffff,RO
 2a03:9c40::,2a03:9c40:ffff:ffff:ffff:ffff:ffff:ffff,LU
+2a03:9c60::,2a03:9c60:ffff:ffff:ffff:ffff:ffff:ffff,PL
 2a03:9c80::,2a03:9c80:ffff:ffff:ffff:ffff:ffff:ffff,PT
+2a03:9ca0::,2a03:9ca0:ffff:ffff:ffff:ffff:ffff:ffff,RU
 2a03:9cc0::,2a03:9cc7:ffff:ffff:ffff:ffff:ffff:ffff,BE
 2a03:9d00::,2a03:9d00:ffff:ffff:ffff:ffff:ffff:ffff,DE
+2a03:9d20::,2a03:9d20:ffff:ffff:ffff:ffff:ffff:ffff,ES
 2a03:9d40::,2a03:9d40:ffff:ffff:ffff:ffff:ffff:ffff,NL
+2a03:9d60::,2a03:9d60:ffff:ffff:ffff:ffff:ffff:ffff,FR
 2a03:9d80::,2a03:9d80:ffff:ffff:ffff:ffff:ffff:ffff,RS
+2a03:9da0::,2a03:9da0:ffff:ffff:ffff:ffff:ffff:ffff,GB
 2a03:9dc0::,2a03:9dc0:ffff:ffff:ffff:ffff:ffff:ffff,GB
+2a03:9de0::,2a03:9de0:ffff:ffff:ffff:ffff:ffff:ffff,LB
 2a03:9e00::,2a03:9e00:ffff:ffff:ffff:ffff:ffff:ffff,IM
+2a03:9e20::,2a03:9e20:ffff:ffff:ffff:ffff:ffff:ffff,IT
 2a03:9e40::,2a03:9e47:ffff:ffff:ffff:ffff:ffff:ffff,DE
 2a03:9e80::,2a03:9e80:ffff:ffff:ffff:ffff:ffff:ffff,GB
+2a03:9ea0::,2a03:9ea0:ffff:ffff:ffff:ffff:ffff:ffff,SE
 2a03:9ec0::,2a03:9ec0:ffff:ffff:ffff:ffff:ffff:ffff,GB
+2a03:9ee0::,2a03:9ee0:ffff:ffff:ffff:ffff:ffff:ffff,HU
 2a03:9f00::,2a03:9f00:ffff:ffff:ffff:ffff:ffff:ffff,GB
+2a03:9f20::,2a03:9f20:ffff:ffff:ffff:ffff:ffff:ffff,DE
 2a03:9f40::,2a03:9f40:ffff:ffff:ffff:ffff:ffff:ffff,FR
+2a03:9f60::,2a03:9f60:ffff:ffff:ffff:ffff:ffff:ffff,IQ
 2a03:9f80::,2a03:9f80:ffff:ffff:ffff:ffff:ffff:ffff,FI
+2a03:9fa0::,2a03:9fa0:ffff:ffff:ffff:ffff:ffff:ffff,US
 2a03:9fc0::,2a03:9fc0:ffff:ffff:ffff:ffff:ffff:ffff,SE
+2a03:9fe0::,2a03:9fe0:ffff:ffff:ffff:ffff:ffff:ffff,RU
 2a03:a000::,2a03:a000:ffff:ffff:ffff:ffff:ffff:ffff,GB
+2a03:a020::,2a03:a020:ffff:ffff:ffff:ffff:ffff:ffff,SE
 2a03:a040::,2a03:a040:ffff:ffff:ffff:ffff:ffff:ffff,RU
+2a03:a060::,2a03:a060:ffff:ffff:ffff:ffff:ffff:ffff,RU
 2a03:a080::,2a03:a080:ffff:ffff:ffff:ffff:ffff:ffff,DE
+2a03:a0a0::,2a03:a0a0:ffff:ffff:ffff:ffff:ffff:ffff,FR
 2a03:a0c0::,2a03:a0c0:ffff:ffff:ffff:ffff:ffff:ffff,GB
+2a03:a0e0::,2a03:a0e0:ffff:ffff:ffff:ffff:ffff:ffff,RU
 2a03:a100::,2a03:a100:ffff:ffff:ffff:ffff:ffff:ffff,SI
+2a03:a120::,2a03:a120:ffff:ffff:ffff:ffff:ffff:ffff,AE
 2a03:a140::,2a03:a140:ffff:ffff:ffff:ffff:ffff:ffff,FR
+2a03:a160::,2a03:a160:ffff:ffff:ffff:ffff:ffff:ffff,AT
 2a03:a180::,2a03:a180:ffff:ffff:ffff:ffff:ffff:ffff,RU
+2a03:a1a0::,2a03:a1a0:ffff:ffff:ffff:ffff:ffff:ffff,BE
 2a03:a1c0::,2a03:a1c0:ffff:ffff:ffff:ffff:ffff:ffff,RU
+2a03:a1e0::,2a03:a1e0:ffff:ffff:ffff:ffff:ffff:ffff,RU
 2a03:a200::,2a03:a200:ffff:ffff:ffff:ffff:ffff:ffff,SK
+2a03:a220::,2a03:a220:ffff:ffff:ffff:ffff:ffff:ffff,PL
 2a03:a240::,2a03:a240:ffff:ffff:ffff:ffff:ffff:ffff,FR
+2a03:a260::,2a03:a260:ffff:ffff:ffff:ffff:ffff:ffff,IT
 2a03:a280::,2a03:a280:ffff:ffff:ffff:ffff:ffff:ffff,IT
+2a03:a2a0::,2a03:a2a0:ffff:ffff:ffff:ffff:ffff:ffff,RU
 2a03:a2c0::,2a03:a2c7:ffff:ffff:ffff:ffff:ffff:ffff,FR
+2a03:a2e0::,2a03:a2e0:ffff:ffff:ffff:ffff:ffff:ffff,PL
 2a03:a300::,2a03:a300:ffff:ffff:ffff:ffff:ffff:ffff,KZ
+2a03:a320::,2a03:a320:ffff:ffff:ffff:ffff:ffff:ffff,ES
+2a03:a360::,2a03:a360:ffff:ffff:ffff:ffff:ffff:ffff,CH
 2a03:a380::,2a03:a380:ffff:ffff:ffff:ffff:ffff:ffff,IT
+2a03:a3a0::,2a03:a3a0:ffff:ffff:ffff:ffff:ffff:ffff,NL
 2a03:a3c0::,2a03:a3c0:ffff:ffff:ffff:ffff:ffff:ffff,IT
+2a03:a3e0::,2a03:a3e0:ffff:ffff:ffff:ffff:ffff:ffff,LB
 2a03:a400::,2a03:a400:ffff:ffff:ffff:ffff:ffff:ffff,RU
+2a03:a420::,2a03:a420:ffff:ffff:ffff:ffff:ffff:ffff,ES
 2a03:a440::,2a03:a440:ffff:ffff:ffff:ffff:ffff:ffff,ES
+2a03:a460::,2a03:a460:ffff:ffff:ffff:ffff:ffff:ffff,TR
 2a03:a480::,2a03:a480:ffff:ffff:ffff:ffff:ffff:ffff,DK
+2a03:a4a0::,2a03:a4a0:ffff:ffff:ffff:ffff:ffff:ffff,RU
 2a03:a4c0::,2a03:a4c0:ffff:ffff:ffff:ffff:ffff:ffff,GB
+2a03:a4e0::,2a03:a4e0:ffff:ffff:ffff:ffff:ffff:ffff,NO
 2a03:a500::,2a03:a500:ffff:ffff:ffff:ffff:ffff:ffff,IT
 2a03:a540::,2a03:a540:ffff:ffff:ffff:ffff:ffff:ffff,DE
 2a03:a580::,2a03:a580:ffff:ffff:ffff:ffff:ffff:ffff,FR
@@ -21861,6 +24117,7 @@
 2a03:ab00::,2a03:ab00:ffff:ffff:ffff:ffff:ffff:ffff,CZ
 2a03:ab40::,2a03:ab40:ffff:ffff:ffff:ffff:ffff:ffff,AT
 2a03:ab80::,2a03:ab80:ffff:ffff:ffff:ffff:ffff:ffff,ES
+2a03:abc0::,2a03:abc0:ffff:ffff:ffff:ffff:ffff:ffff,NL
 2a03:ac00::,2a03:ac00:ffff:ffff:ffff:ffff:ffff:ffff,FR
 2a03:ac40::,2a03:ac40:ffff:ffff:ffff:ffff:ffff:ffff,CH
 2a03:ac80::,2a03:ac80:ffff:ffff:ffff:ffff:ffff:ffff,SE
@@ -21889,7 +24146,7 @@
 2a03:b180::,2a03:b180:ffff:ffff:ffff:ffff:ffff:ffff,AE
 2a03:b1c0::,2a03:b1c0:ffff:ffff:ffff:ffff:ffff:ffff,RU
 2a03:b200::,2a03:b207:ffff:ffff:ffff:ffff:ffff:ffff,GB
-2a03:b240::,2a03:b240:ffff:ffff:ffff:ffff:ffff:ffff,CH
+2a03:b240::,2a03:b247:ffff:ffff:ffff:ffff:ffff:ffff,CH
 2a03:b280::,2a03:b280:ffff:ffff:ffff:ffff:ffff:ffff,CZ
 2a03:b2c0::,2a03:b2c0:ffff:ffff:ffff:ffff:ffff:ffff,CH
 2a03:b300::,2a03:b300:ffff:ffff:ffff:ffff:ffff:ffff,GB
@@ -22026,7 +24283,9 @@
 2a03:d3c0::,2a03:d3c0:ffff:ffff:ffff:ffff:ffff:ffff,DE
 2a03:d400::,2a03:d400:ffff:ffff:ffff:ffff:ffff:ffff,DE
 2a03:d440::,2a03:d440:ffff:ffff:ffff:ffff:ffff:ffff,HU
-2a03:d480::,2a03:d480:ffff:ffff:ffff:ffff:ffff:ffff,GB
+2a03:d480::,2a03:d480::ffff:ffff:ffff:ffff:ffff,GB
+2a03:d480:1::,2a03:d480:1:7fff:ffff:ffff:ffff:ffff,IM
+2a03:d480:1:8000::,2a03:d480:ffff:ffff:ffff:ffff:ffff:ffff,GB
 2a03:d4c0::,2a03:d4c0:ffff:ffff:ffff:ffff:ffff:ffff,GB
 2a03:d500::,2a03:d500:ffff:ffff:ffff:ffff:ffff:ffff,NO
 2a03:d540::,2a03:d540:ffff:ffff:ffff:ffff:ffff:ffff,SE
@@ -22042,11 +24301,12 @@
 2a03:d7c0::,2a03:d7c7:ffff:ffff:ffff:ffff:ffff:ffff,SE
 2a03:d800::,2a03:d800:ffff:ffff:ffff:ffff:ffff:ffff,NL
 2a03:d840::,2a03:d840:ffff:ffff:ffff:ffff:ffff:ffff,CZ
-2a03:d880::,2a03:d880:ffff:ffff:ffff:ffff:ffff:ffff,GB
+2a03:d880::,2a03:d887:ffff:ffff:ffff:ffff:ffff:ffff,GB
 2a03:d8c0::,2a03:d8c0:ffff:ffff:ffff:ffff:ffff:ffff,DE
 2a03:d900::,2a03:d900:ffff:ffff:ffff:ffff:ffff:ffff,SE
 2a03:d940::,2a03:d940:ffff:ffff:ffff:ffff:ffff:ffff,FR
 2a03:d980::,2a03:d980:ffff:ffff:ffff:ffff:ffff:ffff,DE
+2a03:d9c0::,2a03:d9c0:ffff:ffff:ffff:ffff:ffff:ffff,CZ
 2a03:da00::,2a03:da00:ffff:ffff:ffff:ffff:ffff:ffff,HU
 2a03:da40::,2a03:da40:ffff:ffff:ffff:ffff:ffff:ffff,CH
 2a03:da80::,2a03:da80:ffff:ffff:ffff:ffff:ffff:ffff,AT
@@ -22109,7 +24369,6 @@
 2a03:e8c0::,2a03:e8c0:ffff:ffff:ffff:ffff:ffff:ffff,RU
 2a03:e900::,2a03:e900:ffff:ffff:ffff:ffff:ffff:ffff,ES
 2a03:e940::,2a03:e940:ffff:ffff:ffff:ffff:ffff:ffff,CH
-2a03:e980::,2a03:e980:ffff:ffff:ffff:ffff:ffff:ffff,IS
 2a03:e9c0::,2a03:e9c0:ffff:ffff:ffff:ffff:ffff:ffff,RU
 2a03:ea00::,2a03:ea00:ffff:ffff:ffff:ffff:ffff:ffff,NO
 2a03:ea40::,2a03:ea40:ffff:ffff:ffff:ffff:ffff:ffff,NL
@@ -22134,7 +24393,6 @@
 2a03:ef00::,2a03:ef00:ffff:ffff:ffff:ffff:ffff:ffff,SE
 2a03:ef40::,2a03:ef40:ffff:ffff:ffff:ffff:ffff:ffff,IR
 2a03:ef80::,2a03:ef80:ffff:ffff:ffff:ffff:ffff:ffff,IT
-2a03:efc0::,2a03:efc0:ffff:ffff:ffff:ffff:ffff:ffff,GB
 2a03:f000::,2a03:f000:ffff:ffff:ffff:ffff:ffff:ffff,GR
 2a03:f040::,2a03:f040:ffff:ffff:ffff:ffff:ffff:ffff,SK
 2a03:f080::,2a03:f080:ffff:ffff:ffff:ffff:ffff:ffff,AT
@@ -22254,7 +24512,6 @@
 2a04:d40::,2a04:d47:ffff:ffff:ffff:ffff:ffff:ffff,IT
 2a04:d80::,2a04:d87:ffff:ffff:ffff:ffff:ffff:ffff,RU
 2a04:dc0::,2a04:dc7:ffff:ffff:ffff:ffff:ffff:ffff,RU
-2a04:e00::,2a04:e07:ffff:ffff:ffff:ffff:ffff:ffff,IT
 2a04:e40::,2a04:e47:ffff:ffff:ffff:ffff:ffff:ffff,FR
 2a04:e80::,2a04:e87:ffff:ffff:ffff:ffff:ffff:ffff,ES
 2a04:ec0::,2a04:ec7:ffff:ffff:ffff:ffff:ffff:ffff,GB
@@ -22376,7 +24633,6 @@
 2a04:2b00::,2a04:2b07:ffff:ffff:ffff:ffff:ffff:ffff,GB
 2a04:2b40::,2a04:2b47:ffff:ffff:ffff:ffff:ffff:ffff,PL
 2a04:2b80::,2a04:2b87:ffff:ffff:ffff:ffff:ffff:ffff,RO
-2a04:2bc0::,2a04:2bc7:ffff:ffff:ffff:ffff:ffff:ffff,FR
 2a04:2c00::,2a04:2c07:ffff:ffff:ffff:ffff:ffff:ffff,UA
 2a04:2c40:7::,2a04:2c40:7:7fff:ffff:ffff:ffff:ffff,FR
 2a04:2c80::,2a04:2c87:ffff:ffff:ffff:ffff:ffff:ffff,UA
@@ -22541,6 +24797,7 @@
 2a04:5380::,2a04:5387:ffff:ffff:ffff:ffff:ffff:ffff,FR
 2a04:53c0::,2a04:53c7:ffff:ffff:ffff:ffff:ffff:ffff,PT
 2a04:5400::,2a04:5407:ffff:ffff:ffff:ffff:ffff:ffff,IE
+2a04:5440::,2a04:5447:ffff:ffff:ffff:ffff:ffff:ffff,FR
 2a04:5480::,2a04:5487:ffff:ffff:ffff:ffff:ffff:ffff,TR
 2a04:54c0::,2a04:54c7:ffff:ffff:ffff:ffff:ffff:ffff,NO
 2a04:5500::,2a04:5507:ffff:ffff:ffff:ffff:ffff:ffff,RU
@@ -22555,7 +24812,6 @@
 2a04:5740::,2a04:5747:ffff:ffff:ffff:ffff:ffff:ffff,DE
 2a04:5780::,2a04:5787:ffff:ffff:ffff:ffff:ffff:ffff,DE
 2a04:57c0::,2a04:57c7:ffff:ffff:ffff:ffff:ffff:ffff,SE
-2a04:5800::,2a04:5807:ffff:ffff:ffff:ffff:ffff:ffff,IT
 2a04:5880::,2a04:5887:ffff:ffff:ffff:ffff:ffff:ffff,IT
 2a04:58c0::,2a04:58c7:ffff:ffff:ffff:ffff:ffff:ffff,RU
 2a04:5900::,2a04:5907:ffff:ffff:ffff:ffff:ffff:ffff,AL
@@ -22667,12 +24923,12 @@
 2a04:7300::,2a04:7307:ffff:ffff:ffff:ffff:ffff:ffff,GB
 2a04:7340::,2a04:7347:ffff:ffff:ffff:ffff:ffff:ffff,GB
 2a04:7380::,2a04:7387:ffff:ffff:ffff:ffff:ffff:ffff,GB
+2a04:73c0::,2a04:73c7:ffff:ffff:ffff:ffff:ffff:ffff,RS
 2a04:7400::,2a04:7407:ffff:ffff:ffff:ffff:ffff:ffff,ME
 2a04:7440::,2a04:7447:ffff:ffff:ffff:ffff:ffff:ffff,DE
 2a04:7480::,2a04:7487:ffff:ffff:ffff:ffff:ffff:ffff,DE
 2a04:74c0::,2a04:74c7:ffff:ffff:ffff:ffff:ffff:ffff,FR
 2a04:7500::,2a04:7507:ffff:ffff:ffff:ffff:ffff:ffff,AT
-2a04:7540::,2a04:7547:ffff:ffff:ffff:ffff:ffff:ffff,GB
 2a04:7580::,2a04:7587:ffff:ffff:ffff:ffff:ffff:ffff,MD
 2a04:75c0::,2a04:75c7:ffff:ffff:ffff:ffff:ffff:ffff,UA
 2a04:7600::,2a04:7607:ffff:ffff:ffff:ffff:ffff:ffff,NO
@@ -22698,6 +24954,7 @@
 2a04:7ac0::,2a04:7ac7:ffff:ffff:ffff:ffff:ffff:ffff,DE
 2a04:7b00::,2a04:7b07:ffff:ffff:ffff:ffff:ffff:ffff,IT
 2a04:7b40::,2a04:7b47:ffff:ffff:ffff:ffff:ffff:ffff,DE
+2a04:7b80::,2a04:7b87:ffff:ffff:ffff:ffff:ffff:ffff,TR
 2a04:7bc0::,2a04:7bc7:ffff:ffff:ffff:ffff:ffff:ffff,SA
 2a04:7c00::,2a04:7c07:ffff:ffff:ffff:ffff:ffff:ffff,NL
 2a04:7c40::,2a04:7c47:ffff:ffff:ffff:ffff:ffff:ffff,ES
@@ -22713,6 +24970,7 @@
 2a04:7ec0::,2a04:7ec7:ffff:ffff:ffff:ffff:ffff:ffff,ES
 2a04:7f00::,2a04:7f07:ffff:ffff:ffff:ffff:ffff:ffff,BE
 2a04:7f40::,2a04:7f47:ffff:ffff:ffff:ffff:ffff:ffff,NO
+2a04:7f80::,2a04:7f87:ffff:ffff:ffff:ffff:ffff:ffff,QA
 2a04:7fc0::,2a04:7fc7:ffff:ffff:ffff:ffff:ffff:ffff,GB
 2a04:8000::,2a04:8007:ffff:ffff:ffff:ffff:ffff:ffff,UA
 2a04:8040::,2a04:8047:ffff:ffff:ffff:ffff:ffff:ffff,FR
@@ -22772,6 +25030,7 @@
 2a04:8d40::,2a04:8d47:ffff:ffff:ffff:ffff:ffff:ffff,SE
 2a04:8d80::,2a04:8d87:ffff:ffff:ffff:ffff:ffff:ffff,GB
 2a04:8dc0::,2a04:8dc7:ffff:ffff:ffff:ffff:ffff:ffff,LU
+2a04:8e00::,2a04:8e07:ffff:ffff:ffff:ffff:ffff:ffff,MK
 2a04:8e40::,2a04:8e47:ffff:ffff:ffff:ffff:ffff:ffff,NL
 2a04:8e80::,2a04:8e81:ffff:ffff:ffff:ffff:ffff:ffff,NL
 2a04:8e90::,2a04:8e91:ffff:ffff:ffff:ffff:ffff:ffff,CH
@@ -22899,13 +25158,13 @@
 2a04:acc0::,2a04:acc7:ffff:ffff:ffff:ffff:ffff:ffff,IR
 2a04:ad00::,2a04:ad07:ffff:ffff:ffff:ffff:ffff:ffff,IQ
 2a04:ad40::,2a04:ad47:ffff:ffff:ffff:ffff:ffff:ffff,FI
-2a04:ad80::,2a04:ad87:ffff:ffff:ffff:ffff:ffff:ffff,GB
+2a04:ad80::,2a04:ad80::7fff:ffff:ffff:ffff:ffff,NL
+2a04:ad80:0:8000::,2a04:ad87:ffff:ffff:ffff:ffff:ffff:ffff,GB
 2a04:adc0::,2a04:adc7:ffff:ffff:ffff:ffff:ffff:ffff,RU
 2a04:ae00::,2a04:ae3f:ffff:ffff:ffff:ffff:ffff:ffff,SE
 2a04:b000::,2a04:b007:ffff:ffff:ffff:ffff:ffff:ffff,GB
 2a04:b040::,2a04:b047:ffff:ffff:ffff:ffff:ffff:ffff,NL
 2a04:b080::,2a04:b087:ffff:ffff:ffff:ffff:ffff:ffff,FI
-2a04:b0c0::,2a04:b0c7:ffff:ffff:ffff:ffff:ffff:ffff,PL
 2a04:b100::,2a04:b107:ffff:ffff:ffff:ffff:ffff:ffff,RU
 2a04:b140::,2a04:b147:ffff:ffff:ffff:ffff:ffff:ffff,TR
 2a04:b180::,2a04:b187:ffff:ffff:ffff:ffff:ffff:ffff,FR
@@ -22926,14 +25185,12 @@
 2a04:b540::,2a04:b547:ffff:ffff:ffff:ffff:ffff:ffff,SK
 2a04:b580::,2a04:b587:ffff:ffff:ffff:ffff:ffff:ffff,DE
 2a04:b5c0::,2a04:b5c7:ffff:ffff:ffff:ffff:ffff:ffff,BE
-2a04:b600::,2a04:b607:ffff:ffff:ffff:ffff:ffff:ffff,FR
 2a04:b640::,2a04:b647:ffff:ffff:ffff:ffff:ffff:ffff,DE
 2a04:b680::,2a04:b687:ffff:ffff:ffff:ffff:ffff:ffff,GB
 2a04:b6c0::,2a04:b6c7:ffff:ffff:ffff:ffff:ffff:ffff,GB
 2a04:b700::,2a04:b707:ffff:ffff:ffff:ffff:ffff:ffff,NL
 2a04:b740::,2a04:b747:ffff:ffff:ffff:ffff:ffff:ffff,PL
 2a04:b780::,2a04:b787:ffff:ffff:ffff:ffff:ffff:ffff,GB
-2a04:b7c0::,2a04:b7c7:ffff:ffff:ffff:ffff:ffff:ffff,BG
 2a04:b800::,2a04:b807:ffff:ffff:ffff:ffff:ffff:ffff,GB
 2a04:b840::,2a04:b847:ffff:ffff:ffff:ffff:ffff:ffff,PL
 2a04:b880::,2a04:b887:ffff:ffff:ffff:ffff:ffff:ffff,ES
@@ -22993,6 +25250,7 @@
 2a04:c600::,2a04:c607:ffff:ffff:ffff:ffff:ffff:ffff,NL
 2a04:c640::,2a04:c647:ffff:ffff:ffff:ffff:ffff:ffff,IT
 2a04:c680::,2a04:c687:ffff:ffff:ffff:ffff:ffff:ffff,GB
+2a04:c6c0::,2a04:c6c7:ffff:ffff:ffff:ffff:ffff:ffff,SE
 2a04:c700::,2a04:c707:ffff:ffff:ffff:ffff:ffff:ffff,GB
 2a04:c740::,2a04:c747:ffff:ffff:ffff:ffff:ffff:ffff,CZ
 2a04:c780::,2a04:c787:ffff:ffff:ffff:ffff:ffff:ffff,NL
@@ -23051,6 +25309,7 @@
 2a04:d4c0::,2a04:d4c7:ffff:ffff:ffff:ffff:ffff:ffff,GB
 2a04:d500::,2a04:d507:ffff:ffff:ffff:ffff:ffff:ffff,FI
 2a04:d540::,2a04:d547:ffff:ffff:ffff:ffff:ffff:ffff,AT
+2a04:d580::,2a04:d587:ffff:ffff:ffff:ffff:ffff:ffff,SA
 2a04:d5c0::,2a04:d5c7:ffff:ffff:ffff:ffff:ffff:ffff,IE
 2a04:d600::,2a04:d607:ffff:ffff:ffff:ffff:ffff:ffff,GB
 2a04:d640::,2a04:d647:ffff:ffff:ffff:ffff:ffff:ffff,IE
@@ -23060,6 +25319,7 @@
 2a04:d740::,2a04:d747:ffff:ffff:ffff:ffff:ffff:ffff,DE
 2a04:d780::,2a04:d787:ffff:ffff:ffff:ffff:ffff:ffff,GB
 2a04:d7c0::,2a04:d7c7:ffff:ffff:ffff:ffff:ffff:ffff,NL
+2a04:d800::,2a04:d807:ffff:ffff:ffff:ffff:ffff:ffff,NO
 2a04:d840::,2a04:d847:ffff:ffff:ffff:ffff:ffff:ffff,GB
 2a04:d880::,2a04:d887:ffff:ffff:ffff:ffff:ffff:ffff,GB
 2a04:d8c0::,2a04:d8c7:ffff:ffff:ffff:ffff:ffff:ffff,GB
@@ -23107,6 +25367,8 @@
 2a04:e340::,2a04:e347:ffff:ffff:ffff:ffff:ffff:ffff,AE
 2a04:e380::,2a04:e387:ffff:ffff:ffff:ffff:ffff:ffff,RU
 2a04:e3c0::,2a04:e3c7:ffff:ffff:ffff:ffff:ffff:ffff,DK
+2a04:e400::,2a04:e407:ffff:ffff:ffff:ffff:ffff:ffff,NL
+2a04:e440::,2a04:e447:ffff:ffff:ffff:ffff:ffff:ffff,DE
 2a04:e480::,2a04:e487:ffff:ffff:ffff:ffff:ffff:ffff,IT
 2a04:e4c0:10::,2a04:e4c0:10:ffff:ffff:ffff:ffff:ffff,GB
 2a04:e4c0:11::,2a04:e4c0:11:ffff:ffff:ffff:ffff:ffff,DE
@@ -23143,6 +25405,7 @@
 2a04:eac0::,2a04:eac7:ffff:ffff:ffff:ffff:ffff:ffff,DE
 2a04:eb00::,2a04:eb07:ffff:ffff:ffff:ffff:ffff:ffff,LT
 2a04:eb40::,2a04:eb47:ffff:ffff:ffff:ffff:ffff:ffff,AL
+2a04:eb80::,2a04:eb87:ffff:ffff:ffff:ffff:ffff:ffff,RS
 2a04:ebc0::,2a04:ebc7:ffff:ffff:ffff:ffff:ffff:ffff,GB
 2a04:ec00::,2a04:ec01:ffff:ffff:ffff:ffff:ffff:ffff,NL
 2a04:ec10::,2a04:ec11:ffff:ffff:ffff:ffff:ffff:ffff,GB
@@ -23189,6 +25452,8 @@
 2a04:f5c0::,2a04:f5c7:ffff:ffff:ffff:ffff:ffff:ffff,IT
 2a04:f600::,2a04:f607:ffff:ffff:ffff:ffff:ffff:ffff,FR
 2a04:f680::,2a04:f687:ffff:ffff:ffff:ffff:ffff:ffff,AT
+2a04:f6c0::,2a04:f6c7:ffff:ffff:ffff:ffff:ffff:ffff,DE
+2a04:f700::,2a04:f707:ffff:ffff:ffff:ffff:ffff:ffff,PL
 2a04:f740::,2a04:f747:ffff:ffff:ffff:ffff:ffff:ffff,NL
 2a04:f780::,2a04:f787:ffff:ffff:ffff:ffff:ffff:ffff,IN
 2a04:f7c0::,2a04:f7c7:ffff:ffff:ffff:ffff:ffff:ffff,NL
@@ -23226,6 +25491,7 @@
 2a04:ff80::,2a04:ff87:ffff:ffff:ffff:ffff:ffff:ffff,BA
 2a04:ffc0::,2a04:ffc7:ffff:ffff:ffff:ffff:ffff:ffff,HU
 2a05::,2a05:7:ffff:ffff:ffff:ffff:ffff:ffff,BE
+2a05:40::,2a05:47:ffff:ffff:ffff:ffff:ffff:ffff,IT
 2a05:80::,2a05:87:ffff:ffff:ffff:ffff:ffff:ffff,CH
 2a05:c0::,2a05:c7:ffff:ffff:ffff:ffff:ffff:ffff,DK
 2a05:100::,2a05:107:ffff:ffff:ffff:ffff:ffff:ffff,GB
@@ -23238,7 +25504,6 @@
 2a05:300::,2a05:307:ffff:ffff:ffff:ffff:ffff:ffff,TR
 2a05:340::,2a05:347:ffff:ffff:ffff:ffff:ffff:ffff,ES
 2a05:380::,2a05:387:ffff:ffff:ffff:ffff:ffff:ffff,DE
-2a05:3c0::,2a05:3c7:ffff:ffff:ffff:ffff:ffff:ffff,FR
 2a05:400::,2a05:407:ffff:ffff:ffff:ffff:ffff:ffff,DE
 2a05:440::,2a05:447:ffff:ffff:ffff:ffff:ffff:ffff,PL
 2a05:480::,2a05:487:ffff:ffff:ffff:ffff:ffff:ffff,UA
@@ -23250,7 +25515,6 @@
 2a05:600::,2a05:607:ffff:ffff:ffff:ffff:ffff:ffff,CH
 2a05:640::,2a05:647:ffff:ffff:ffff:ffff:ffff:ffff,DE
 2a05:680::,2a05:687:ffff:ffff:ffff:ffff:ffff:ffff,NL
-2a05:6c0::,2a05:6c7:ffff:ffff:ffff:ffff:ffff:ffff,NL
 2a05:700::,2a05:707:ffff:ffff:ffff:ffff:ffff:ffff,LU
 2a05:740::,2a05:747:ffff:ffff:ffff:ffff:ffff:ffff,BE
 2a05:780::,2a05:787:ffff:ffff:ffff:ffff:ffff:ffff,FR
@@ -23273,9 +25537,12 @@
 2a05:b80::,2a05:b87:ffff:ffff:ffff:ffff:ffff:ffff,RU
 2a05:bc0::,2a05:bc7:ffff:ffff:ffff:ffff:ffff:ffff,DE
 2a05:c00::,2a05:c07:ffff:ffff:ffff:ffff:ffff:ffff,NO
+2a05:c40::,2a05:c47:ffff:ffff:ffff:ffff:ffff:ffff,NL
 2a05:c80::,2a05:c87:ffff:ffff:ffff:ffff:ffff:ffff,ES
 2a05:cc0::,2a05:cc7:ffff:ffff:ffff:ffff:ffff:ffff,GB
+2a05:d00::,2a05:d07:ffff:ffff:ffff:ffff:ffff:ffff,CH
 2a05:d40::,2a05:d47:ffff:ffff:ffff:ffff:ffff:ffff,FR
+2a05:d80::,2a05:d87:ffff:ffff:ffff:ffff:ffff:ffff,FR
 2a05:dc0::,2a05:dc7:ffff:ffff:ffff:ffff:ffff:ffff,ES
 2a05:e00::,2a05:e07:ffff:ffff:ffff:ffff:ffff:ffff,FR
 2a05:e40::,2a05:e47:ffff:ffff:ffff:ffff:ffff:ffff,AT
@@ -23284,6 +25551,7 @@
 2a05:f00::,2a05:f07:ffff:ffff:ffff:ffff:ffff:ffff,DE
 2a05:f40::,2a05:f47:ffff:ffff:ffff:ffff:ffff:ffff,FR
 2a05:f80::,2a05:f87:ffff:ffff:ffff:ffff:ffff:ffff,GB
+2a05:fc0::,2a05:fc7:ffff:ffff:ffff:ffff:ffff:ffff,CH
 2a05:1000::,2a05:1007:ffff:ffff:ffff:ffff:ffff:ffff,FR
 2a05:1040::,2a05:1047:ffff:ffff:ffff:ffff:ffff:ffff,GB
 2a05:1080::,2a05:1087:ffff:ffff:ffff:ffff:ffff:ffff,DE
@@ -23302,7 +25570,6 @@
 2a05:1380::,2a05:1387:ffff:ffff:ffff:ffff:ffff:ffff,IT
 2a05:13c0::,2a05:13c7:ffff:ffff:ffff:ffff:ffff:ffff,GB
 2a05:1400::,2a05:1407:ffff:ffff:ffff:ffff:ffff:ffff,AT
-2a05:1440::,2a05:1447:ffff:ffff:ffff:ffff:ffff:ffff,GB
 2a05:1480::,2a05:1487:ffff:ffff:ffff:ffff:ffff:ffff,PL
 2a05:14c0::,2a05:14c7:ffff:ffff:ffff:ffff:ffff:ffff,CH
 2a05:1500::,2a05:1507:ffff:ffff:ffff:ffff:ffff:ffff,DE
@@ -23335,12 +25602,15 @@
 2a05:1d80::,2a05:1d87:ffff:ffff:ffff:ffff:ffff:ffff,TR
 2a05:1dc0::,2a05:1dc7:ffff:ffff:ffff:ffff:ffff:ffff,IE
 2a05:1e00::,2a05:1e07:ffff:ffff:ffff:ffff:ffff:ffff,CH
+2a05:1e40::,2a05:1e47:ffff:ffff:ffff:ffff:ffff:ffff,FR
+2a05:1e80::,2a05:1e87:ffff:ffff:ffff:ffff:ffff:ffff,NL
 2a05:1ec0::,2a05:1ec7:ffff:ffff:ffff:ffff:ffff:ffff,FR
 2a05:1f00::,2a05:1f07:ffff:ffff:ffff:ffff:ffff:ffff,GB
 2a05:1f40::,2a05:1f47:ffff:ffff:ffff:ffff:ffff:ffff,FI
 2a05:1f80::,2a05:1f87:ffff:ffff:ffff:ffff:ffff:ffff,BA
 2a05:1fc0::,2a05:1fc7:ffff:ffff:ffff:ffff:ffff:ffff,RO
 2a05:2000::,2a05:2007:ffff:ffff:ffff:ffff:ffff:ffff,SE
+2a05:2040::,2a05:2047:ffff:ffff:ffff:ffff:ffff:ffff,ES
 2a05:2080::,2a05:2087:ffff:ffff:ffff:ffff:ffff:ffff,GB
 2a05:20c0::,2a05:20c7:ffff:ffff:ffff:ffff:ffff:ffff,DE
 2a05:2100::,2a05:2107:ffff:ffff:ffff:ffff:ffff:ffff,CZ
@@ -23348,7 +25618,11 @@
 2a05:2180::,2a05:2187:ffff:ffff:ffff:ffff:ffff:ffff,TM
 2a05:21c0::,2a05:21c7:ffff:ffff:ffff:ffff:ffff:ffff,SE
 2a05:2200::,2a05:2207:ffff:ffff:ffff:ffff:ffff:ffff,NL
-2a05:2240::,2a05:2247:ffff:ffff:ffff:ffff:ffff:ffff,SE
+2a05:2240::,2a05:2242:436:ffff:ffff:ffff:ffff:ffff,SE
+2a05:2242:437::,2a05:2242:437:7fff:ffff:ffff:ffff:ffff,NO
+2a05:2242:437:8000::,2a05:2242:437:ffff:ffff:ffff:ffff:ffff,SE
+2a05:2242:438::,2a05:2242:438:7fff:ffff:ffff:ffff:ffff,NO
+2a05:2242:438:8000::,2a05:2247:ffff:ffff:ffff:ffff:ffff:ffff,SE
 2a05:2280::,2a05:2287:ffff:ffff:ffff:ffff:ffff:ffff,SI
 2a05:22c0::,2a05:22c7:ffff:ffff:ffff:ffff:ffff:ffff,NL
 2a05:2300::,2a05:2307:ffff:ffff:ffff:ffff:ffff:ffff,NL
@@ -23356,24 +25630,26 @@
 2a05:2380::,2a05:2387:ffff:ffff:ffff:ffff:ffff:ffff,BE
 2a05:23c0::,2a05:23c7:ffff:ffff:ffff:ffff:ffff:ffff,IT
 2a05:2400::,2a05:2407:ffff:ffff:ffff:ffff:ffff:ffff,PL
+2a05:2440::,2a05:2447:ffff:ffff:ffff:ffff:ffff:ffff,SE
 2a05:2480::,2a05:2487:ffff:ffff:ffff:ffff:ffff:ffff,AE
 2a05:24c0::,2a05:24c7:ffff:ffff:ffff:ffff:ffff:ffff,NL
 2a05:2500::,2a05:2507:ffff:ffff:ffff:ffff:ffff:ffff,NL
 2a05:2540::,2a05:2547:ffff:ffff:ffff:ffff:ffff:ffff,IE
 2a05:2580::,2a05:2587:ffff:ffff:ffff:ffff:ffff:ffff,UA
+2a05:25c0::,2a05:25c7:ffff:ffff:ffff:ffff:ffff:ffff,KW
 2a05:2600::,2a05:2607:ffff:ffff:ffff:ffff:ffff:ffff,BE
 2a05:2640::,2a05:2647:ffff:ffff:ffff:ffff:ffff:ffff,FR
 2a05:2680::,2a05:2687:ffff:ffff:ffff:ffff:ffff:ffff,GB
 2a05:26c0::,2a05:26c7:ffff:ffff:ffff:ffff:ffff:ffff,GB
 2a05:2700::,2a05:2707:ffff:ffff:ffff:ffff:ffff:ffff,CH
 2a05:2740::,2a05:2747:ffff:ffff:ffff:ffff:ffff:ffff,CH
+2a05:2780::,2a05:2787:ffff:ffff:ffff:ffff:ffff:ffff,IT
 2a05:27c0::,2a05:27c7:ffff:ffff:ffff:ffff:ffff:ffff,KZ
 2a05:2800::,2a05:2807:ffff:ffff:ffff:ffff:ffff:ffff,IE
 2a05:2840::,2a05:2847:ffff:ffff:ffff:ffff:ffff:ffff,NO
 2a05:2880::,2a05:2887:ffff:ffff:ffff:ffff:ffff:ffff,BE
 2a05:28c0::,2a05:28c7:ffff:ffff:ffff:ffff:ffff:ffff,PT
 2a05:2900::,2a05:2907:ffff:ffff:ffff:ffff:ffff:ffff,NL
-2a05:2940::,2a05:2947:ffff:ffff:ffff:ffff:ffff:ffff,RU
 2a05:2980::,2a05:2987:ffff:ffff:ffff:ffff:ffff:ffff,DE
 2a05:29c0::,2a05:29c7:ffff:ffff:ffff:ffff:ffff:ffff,UA
 2a05:2a00::,2a05:2a07:ffff:ffff:ffff:ffff:ffff:ffff,GB
@@ -23412,8 +25688,8 @@
 2a05:3200::,2a05:3207:ffff:ffff:ffff:ffff:ffff:ffff,NL
 2a05:3240::,2a05:3247:ffff:ffff:ffff:ffff:ffff:ffff,DE
 2a05:3280::,2a05:3287:ffff:ffff:ffff:ffff:ffff:ffff,SA
+2a05:32c0::,2a05:32c7:ffff:ffff:ffff:ffff:ffff:ffff,DE
 2a05:3300::,2a05:3307:ffff:ffff:ffff:ffff:ffff:ffff,FR
-2a05:3340::,2a05:3347:ffff:ffff:ffff:ffff:ffff:ffff,DE
 2a05:3380::,2a05:3387:ffff:ffff:ffff:ffff:ffff:ffff,YE
 2a05:33c0::,2a05:33c7:ffff:ffff:ffff:ffff:ffff:ffff,SI
 2a05:3400::,2a05:3407:ffff:ffff:ffff:ffff:ffff:ffff,SE
@@ -23427,7 +25703,6 @@
 2a05:3600::,2a05:3607:ffff:ffff:ffff:ffff:ffff:ffff,NL
 2a05:3640::,2a05:3647:ffff:ffff:ffff:ffff:ffff:ffff,PL
 2a05:3680::,2a05:3687:ffff:ffff:ffff:ffff:ffff:ffff,IT
-2a05:36c0::,2a05:36c7:ffff:ffff:ffff:ffff:ffff:ffff,CH
 2a05:3700::,2a05:3707:ffff:ffff:ffff:ffff:ffff:ffff,FR
 2a05:3740::,2a05:3747:ffff:ffff:ffff:ffff:ffff:ffff,RU
 2a05:3780::,2a05:3787:ffff:ffff:ffff:ffff:ffff:ffff,CH
@@ -23456,7 +25731,6 @@
 2a05:3d00::,2a05:3d07:ffff:ffff:ffff:ffff:ffff:ffff,BE
 2a05:3d40::,2a05:3d47:ffff:ffff:ffff:ffff:ffff:ffff,CZ
 2a05:3d80::,2a05:3d87:ffff:ffff:ffff:ffff:ffff:ffff,CH
-2a05:3dc0::,2a05:3dc7:ffff:ffff:ffff:ffff:ffff:ffff,TR
 2a05:3e00::,2a05:3e07:ffff:ffff:ffff:ffff:ffff:ffff,DE
 2a05:3e40::,2a05:3e47:ffff:ffff:ffff:ffff:ffff:ffff,IR
 2a05:3e80::,2a05:3e87:ffff:ffff:ffff:ffff:ffff:ffff,RU
@@ -23487,6 +25761,7 @@
 2a05:44c0::,2a05:44c7:ffff:ffff:ffff:ffff:ffff:ffff,NL
 2a05:4500::,2a05:4507:ffff:ffff:ffff:ffff:ffff:ffff,CZ
 2a05:4540::,2a05:4547:ffff:ffff:ffff:ffff:ffff:ffff,SE
+2a05:4580::,2a05:4587:ffff:ffff:ffff:ffff:ffff:ffff,IR
 2a05:45c0::,2a05:45c7:ffff:ffff:ffff:ffff:ffff:ffff,UZ
 2a05:4600::,2a05:4607:ffff:ffff:ffff:ffff:ffff:ffff,DK
 2a05:4640::,2a05:4647:ffff:ffff:ffff:ffff:ffff:ffff,TR
@@ -23496,6 +25771,7 @@
 2a05:4740::,2a05:4747:ffff:ffff:ffff:ffff:ffff:ffff,CH
 2a05:4780::,2a05:4787:ffff:ffff:ffff:ffff:ffff:ffff,FR
 2a05:47c0::,2a05:47c7:ffff:ffff:ffff:ffff:ffff:ffff,FR
+2a05:4800::,2a05:4807:ffff:ffff:ffff:ffff:ffff:ffff,RU
 2a05:4840::,2a05:4847:ffff:ffff:ffff:ffff:ffff:ffff,DE
 2a05:4880::,2a05:4887:ffff:ffff:ffff:ffff:ffff:ffff,FR
 2a05:48c0::,2a05:48c7:ffff:ffff:ffff:ffff:ffff:ffff,IT
@@ -23504,6 +25780,7 @@
 2a05:4980::,2a05:4987:ffff:ffff:ffff:ffff:ffff:ffff,RS
 2a05:49c0::,2a05:49c7:ffff:ffff:ffff:ffff:ffff:ffff,IR
 2a05:4a00::,2a05:4a07:ffff:ffff:ffff:ffff:ffff:ffff,IT
+2a05:4a40::,2a05:4a47:ffff:ffff:ffff:ffff:ffff:ffff,CZ
 2a05:4ac0::,2a05:4ac7:ffff:ffff:ffff:ffff:ffff:ffff,ES
 2a05:4b00::,2a05:4b07:ffff:ffff:ffff:ffff:ffff:ffff,UA
 2a05:4b40::,2a05:4b47:ffff:ffff:ffff:ffff:ffff:ffff,RU
@@ -23528,6 +25805,7 @@
 2a05:5000::,2a05:5007:ffff:ffff:ffff:ffff:ffff:ffff,FR
 2a05:5040::,2a05:5047:ffff:ffff:ffff:ffff:ffff:ffff,IT
 2a05:5080::,2a05:5080:ffff:ffff:ffff:ffff:ffff:ffff,RU
+2a05:50a0::,2a05:50a3:ffff:ffff:ffff:ffff:ffff:ffff,RO
 2a05:50c0::,2a05:50c7:ffff:ffff:ffff:ffff:ffff:ffff,IQ
 2a05:5100::,2a05:5107:ffff:ffff:ffff:ffff:ffff:ffff,DE
 2a05:5140::,2a05:5147:ffff:ffff:ffff:ffff:ffff:ffff,NL
@@ -23557,6 +25835,7 @@
 2a05:5700::,2a05:5707:ffff:ffff:ffff:ffff:ffff:ffff,RO
 2a05:5740::,2a05:5747:ffff:ffff:ffff:ffff:ffff:ffff,UA
 2a05:5780::,2a05:5787:ffff:ffff:ffff:ffff:ffff:ffff,TR
+2a05:57c0::,2a05:57c7:ffff:ffff:ffff:ffff:ffff:ffff,DE
 2a05:5800::,2a05:5807:ffff:ffff:ffff:ffff:ffff:ffff,DE
 2a05:5840::,2a05:5847:ffff:ffff:ffff:ffff:ffff:ffff,RU
 2a05:5880::,2a05:5887:ffff:ffff:ffff:ffff:ffff:ffff,NO
@@ -23578,6 +25857,7 @@
 2a05:5c80::,2a05:5c87:ffff:ffff:ffff:ffff:ffff:ffff,ES
 2a05:5cc0::,2a05:5cc7:ffff:ffff:ffff:ffff:ffff:ffff,ES
 2a05:5d00::,2a05:5d07:ffff:ffff:ffff:ffff:ffff:ffff,RU
+2a05:5d40::,2a05:5d47:ffff:ffff:ffff:ffff:ffff:ffff,ES
 2a05:5d80::,2a05:5d87:ffff:ffff:ffff:ffff:ffff:ffff,MK
 2a05:5dc0::,2a05:5dc7:ffff:ffff:ffff:ffff:ffff:ffff,RU
 2a05:5e00::,2a05:5e07:ffff:ffff:ffff:ffff:ffff:ffff,AE
@@ -23607,6 +25887,7 @@
 2a05:6400::,2a05:6407:ffff:ffff:ffff:ffff:ffff:ffff,BE
 2a05:6440::,2a05:6447:ffff:ffff:ffff:ffff:ffff:ffff,NL
 2a05:6480::,2a05:6487:ffff:ffff:ffff:ffff:ffff:ffff,IR
+2a05:64c0::,2a05:64c7:ffff:ffff:ffff:ffff:ffff:ffff,TR
 2a05:6500::,2a05:6507:ffff:ffff:ffff:ffff:ffff:ffff,ES
 2a05:6540::,2a05:6547:ffff:ffff:ffff:ffff:ffff:ffff,RU
 2a05:6580::,2a05:6587:ffff:ffff:ffff:ffff:ffff:ffff,ES
@@ -23654,6 +25935,7 @@
 2a05:7000::,2a05:7007:ffff:ffff:ffff:ffff:ffff:ffff,CH
 2a05:7040::,2a05:7047:ffff:ffff:ffff:ffff:ffff:ffff,GB
 2a05:7080::,2a05:7087:ffff:ffff:ffff:ffff:ffff:ffff,ES
+2a05:70c0::,2a05:70c7:ffff:ffff:ffff:ffff:ffff:ffff,HR
 2a05:7100::,2a05:7107:ffff:ffff:ffff:ffff:ffff:ffff,PL
 2a05:7140::,2a05:7147:ffff:ffff:ffff:ffff:ffff:ffff,MD
 2a05:7180::,2a05:7187:ffff:ffff:ffff:ffff:ffff:ffff,DE
@@ -23708,6 +25990,7 @@
 2a05:7dc0::,2a05:7dc1:ffff:ffff:ffff:ffff:ffff:ffff,DE
 2a05:7de0::,2a05:7de3:ffff:ffff:ffff:ffff:ffff:ffff,IR
 2a05:7e00::,2a05:7e07:ffff:ffff:ffff:ffff:ffff:ffff,CH
+2a05:7e40::,2a05:7e47:ffff:ffff:ffff:ffff:ffff:ffff,DE
 2a05:7e80::,2a05:7e87:ffff:ffff:ffff:ffff:ffff:ffff,RU
 2a05:7ec0::,2a05:7ec7:ffff:ffff:ffff:ffff:ffff:ffff,CZ
 2a05:7f00::,2a05:7f07:ffff:ffff:ffff:ffff:ffff:ffff,AT
@@ -23773,6 +26056,7 @@
 2a05:8dc0::,2a05:8dc7:ffff:ffff:ffff:ffff:ffff:ffff,GB
 2a05:8e00::,2a05:8e07:ffff:ffff:ffff:ffff:ffff:ffff,ES
 2a05:8e40::,2a05:8e47:ffff:ffff:ffff:ffff:ffff:ffff,DE
+2a05:8e80::,2a05:8e87:ffff:ffff:ffff:ffff:ffff:ffff,GB
 2a05:8ec0::,2a05:8ec7:ffff:ffff:ffff:ffff:ffff:ffff,LB
 2a05:8f00::,2a05:8f07:ffff:ffff:ffff:ffff:ffff:ffff,CH
 2a05:8f40::,2a05:8f47:ffff:ffff:ffff:ffff:ffff:ffff,NL
@@ -23784,6 +26068,7 @@
 2a05:90c0::,2a05:90c7:ffff:ffff:ffff:ffff:ffff:ffff,NL
 2a05:9100::,2a05:9107:ffff:ffff:ffff:ffff:ffff:ffff,FI
 2a05:9140::,2a05:9147:ffff:ffff:ffff:ffff:ffff:ffff,DE
+2a05:9180::,2a05:9187:ffff:ffff:ffff:ffff:ffff:ffff,NL
 2a05:91c0::,2a05:91c7:ffff:ffff:ffff:ffff:ffff:ffff,RO
 2a05:9200::,2a05:9207:ffff:ffff:ffff:ffff:ffff:ffff,RU
 2a05:9240::,2a05:9247:ffff:ffff:ffff:ffff:ffff:ffff,IR
@@ -23794,7 +26079,6 @@
 2a05:9380::,2a05:9387:ffff:ffff:ffff:ffff:ffff:ffff,GB
 2a05:93c0::,2a05:93c7:ffff:ffff:ffff:ffff:ffff:ffff,NL
 2a05:9400::,2a05:9407:ffff:ffff:ffff:ffff:ffff:ffff,BG
-2a05:9440::,2a05:9447:ffff:ffff:ffff:ffff:ffff:ffff,GB
 2a05:9480::,2a05:9487:ffff:ffff:ffff:ffff:ffff:ffff,IQ
 2a05:94c0::,2a05:94c7:ffff:ffff:ffff:ffff:ffff:ffff,IR
 2a05:9500::,2a05:9507:ffff:ffff:ffff:ffff:ffff:ffff,TR
@@ -23906,9 +26190,14 @@
 2a05:afc0::,2a05:afc7:ffff:ffff:ffff:ffff:ffff:ffff,FR
 2a05:b000::,2a05:b007:ffff:ffff:ffff:ffff:ffff:ffff,BE
 2a05:b040::,2a05:b047:ffff:ffff:ffff:ffff:ffff:ffff,CH
+2a05:b080::,2a05:b087:ffff:ffff:ffff:ffff:ffff:ffff,FI
+2a05:b0c0::,2a05:b0c6:25f:ffff:ffff:ffff:ffff:ffff,GB
+2a05:b0c6:260::,2a05:b0c6:260:7fff:ffff:ffff:ffff:ffff,US
+2a05:b0c6:260:8000::,2a05:b0c6:6ff:ffff:ffff:ffff:ffff:ffff,GB
+2a05:b0c6:700::,2a05:b0c6:7ff:ffff:ffff:ffff:ffff:ffff,AT
+2a05:b0c6:800::,2a05:b0c7:ffff:ffff:ffff:ffff:ffff:ffff,GB
 2a05:b100::,2a05:b107:ffff:ffff:ffff:ffff:ffff:ffff,GB
 2a05:b140::,2a05:b147:ffff:ffff:ffff:ffff:ffff:ffff,TR
-2a05:b180::,2a05:b187:ffff:ffff:ffff:ffff:ffff:ffff,UA
 2a05:b1c0::,2a05:b1c7:ffff:ffff:ffff:ffff:ffff:ffff,IR
 2a05:b200::,2a05:b207:ffff:ffff:ffff:ffff:ffff:ffff,RU
 2a05:b240::,2a05:b247:ffff:ffff:ffff:ffff:ffff:ffff,IT
@@ -23937,7 +26226,6 @@
 2a05:b800::,2a05:b807:ffff:ffff:ffff:ffff:ffff:ffff,CZ
 2a05:b840::,2a05:b847:ffff:ffff:ffff:ffff:ffff:ffff,DE
 2a05:b880::,2a05:b887:ffff:ffff:ffff:ffff:ffff:ffff,SE
-2a05:b8c0::,2a05:b8c7:ffff:ffff:ffff:ffff:ffff:ffff,SE
 2a05:b900::,2a05:b907:ffff:ffff:ffff:ffff:ffff:ffff,TR
 2a05:b940::,2a05:b947:ffff:ffff:ffff:ffff:ffff:ffff,DE
 2a05:b980::,2a05:b987:ffff:ffff:ffff:ffff:ffff:ffff,LB
@@ -23963,12 +26251,12 @@
 2a05:be80::,2a05:be87:ffff:ffff:ffff:ffff:ffff:ffff,GB
 2a05:bec0::,2a05:bec7:ffff:ffff:ffff:ffff:ffff:ffff,DE
 2a05:bf00::,2a05:bf07:ffff:ffff:ffff:ffff:ffff:ffff,TR
+2a05:bf40::,2a05:bf47:ffff:ffff:ffff:ffff:ffff:ffff,GB
 2a05:bf80::,2a05:bf87:ffff:ffff:ffff:ffff:ffff:ffff,IT
 2a05:bfc0::,2a05:bfc7:ffff:ffff:ffff:ffff:ffff:ffff,IT
 2a05:c000::,2a05:c007:ffff:ffff:ffff:ffff:ffff:ffff,IR
 2a05:c040::,2a05:c047:ffff:ffff:ffff:ffff:ffff:ffff,CH
 2a05:c080::,2a05:c087:ffff:ffff:ffff:ffff:ffff:ffff,NL
-2a05:c0c0::,2a05:c0c7:ffff:ffff:ffff:ffff:ffff:ffff,ES
 2a05:c100::,2a05:c107:ffff:ffff:ffff:ffff:ffff:ffff,FR
 2a05:c140::,2a05:c147:ffff:ffff:ffff:ffff:ffff:ffff,RU
 2a05:c180::,2a05:c187:ffff:ffff:ffff:ffff:ffff:ffff,GB
@@ -24026,6 +26314,7 @@
 2a05:ce80::,2a05:ce87:ffff:ffff:ffff:ffff:ffff:ffff,RU
 2a05:cec0::,2a05:cec7:ffff:ffff:ffff:ffff:ffff:ffff,DE
 2a05:cf00::,2a05:cf07:ffff:ffff:ffff:ffff:ffff:ffff,DE
+2a05:cf40::,2a05:cf47:ffff:ffff:ffff:ffff:ffff:ffff,DE
 2a05:cf80::,2a05:cf87:ffff:ffff:ffff:ffff:ffff:ffff,RU
 2a05:cfc0::,2a05:cfc7:ffff:ffff:ffff:ffff:ffff:ffff,NL
 2a05:d000::,2a05:d07f:ffff:ffff:ffff:ffff:ffff:ffff,IE
@@ -24034,7 +26323,6 @@
 2a05:d480::,2a05:d487:ffff:ffff:ffff:ffff:ffff:ffff,NL
 2a05:d4c0::,2a05:d4c7:ffff:ffff:ffff:ffff:ffff:ffff,DE
 2a05:d500::,2a05:d507:ffff:ffff:ffff:ffff:ffff:ffff,DE
-2a05:d540::,2a05:d547:ffff:ffff:ffff:ffff:ffff:ffff,ES
 2a05:d580::,2a05:d587:ffff:ffff:ffff:ffff:ffff:ffff,DE
 2a05:d5c0::,2a05:d5c7:ffff:ffff:ffff:ffff:ffff:ffff,GE
 2a05:d600::,2a05:d607:ffff:ffff:ffff:ffff:ffff:ffff,LB
@@ -24079,13 +26367,16 @@
 2a05:dfc0:1ee4::,2a05:dfc0:1ee4:ffff:ffff:ffff:ffff:ffff,CA
 2a05:dfc0:1ee5::,2a05:dfc0:6938:ffff:ffff:ffff:ffff:ffff,GB
 2a05:dfc0:6939::,2a05:dfc0:6939:ffff:ffff:ffff:ffff:ffff,NL
-2a05:dfc0:693a::,2a05:dfc7:8:ffff:ffff:ffff:ffff:ffff,GB
+2a05:dfc0:693a::,2a05:dfc7:7:ffff:ffff:ffff:ffff:ffff,GB
+2a05:dfc7:8::,2a05:dfc7:8:7fff:ffff:ffff:ffff:ffff,SG
+2a05:dfc7:8:8000::,2a05:dfc7:8:ffff:ffff:ffff:ffff:ffff,GB
 2a05:dfc7:9::,2a05:dfc7:9:7fff:ffff:ffff:ffff:ffff,SG
 2a05:dfc7:9:8000::,2a05:dfc7:f:ffff:ffff:ffff:ffff:ffff,GB
 2a05:dfc7:10::,2a05:dfc7:10:ffff:ffff:ffff:ffff:ffff,NL
-2a05:dfc7:11::,2a05:dfc7:19:ffff:ffff:ffff:ffff:ffff,GB
+2a05:dfc7:11::,2a05:dfc7:19:ffff:ffff:ffff:ffff:ffff,CH
 2a05:dfc7:1a::,2a05:dfc7:1a::,AT
-2a05:dfc7:1a::1,2a05:dfc7:3f:ffff:ffff:ffff:ffff:ffff,GB
+2a05:dfc7:1a::1,2a05:dfc7:1f:ffff:ffff:ffff:ffff:ffff,CH
+2a05:dfc7:20::,2a05:dfc7:3f:ffff:ffff:ffff:ffff:ffff,GB
 2a05:dfc7:40::,2a05:dfc7:40:ffff:ffff:ffff:ffff:ffff,BY
 2a05:dfc7:41::,2a05:dfc7:ffff:ffff:ffff:ffff:ffff:ffff,GB
 2a05:e000::,2a05:e007:ffff:ffff:ffff:ffff:ffff:ffff,DK
@@ -24119,6 +26410,7 @@
 2a05:e700::,2a05:e707:ffff:ffff:ffff:ffff:ffff:ffff,DE
 2a05:e740::,2a05:e747:ffff:ffff:ffff:ffff:ffff:ffff,DE
 2a05:e780::,2a05:e787:ffff:ffff:ffff:ffff:ffff:ffff,IR
+2a05:e7c0::,2a05:e7c7:ffff:ffff:ffff:ffff:ffff:ffff,FR
 2a05:e800::,2a05:e807:ffff:ffff:ffff:ffff:ffff:ffff,SK
 2a05:e840::,2a05:e847:ffff:ffff:ffff:ffff:ffff:ffff,SE
 2a05:e880::,2a05:e887:ffff:ffff:ffff:ffff:ffff:ffff,NO
@@ -24171,8 +26463,7 @@
 2a05:f400::,2a05:f407:ffff:ffff:ffff:ffff:ffff:ffff,CH
 2a05:f440::,2a05:f447:ffff:ffff:ffff:ffff:ffff:ffff,FR
 2a05:f480::,2a05:f487:ffff:ffff:ffff:ffff:ffff:ffff,FR
-2a05:f4c0::,2a05:f4c7:ffff:ffff:ffff:ffff:ffff:ffff,ES
-2a05:f500::,2a05:f507:ffff:ffff:ffff:ffff:ffff:ffff,ES
+2a05:f4c0::,2a05:f4c7:ffff:ffff:ffff:ffff:ffff:ffff,RO
 2a05:f540::,2a05:f547:ffff:ffff:ffff:ffff:ffff:ffff,FR
 2a05:f580::,2a05:f587:ffff:ffff:ffff:ffff:ffff:ffff,GB
 2a05:f5c0::,2a05:f5c7:ffff:ffff:ffff:ffff:ffff:ffff,HU
@@ -24197,9 +26488,9 @@
 2a05:fa80::,2a05:fa87:ffff:ffff:ffff:ffff:ffff:ffff,ES
 2a05:fac0::,2a05:fac7:ffff:ffff:ffff:ffff:ffff:ffff,FR
 2a05:fb00::,2a05:fb07:ffff:ffff:ffff:ffff:ffff:ffff,SE
-2a05:fb40::,2a05:fb47:ffff:ffff:ffff:ffff:ffff:ffff,GB
 2a05:fb80::,2a05:fb87:ffff:ffff:ffff:ffff:ffff:ffff,DE
 2a05:fbc0::,2a05:fbc3:ffff:ffff:ffff:ffff:ffff:ffff,TR
+2a05:fbe0::,2a05:fbe3:ffff:ffff:ffff:ffff:ffff:ffff,CZ
 2a05:fc00::,2a05:fc07:ffff:ffff:ffff:ffff:ffff:ffff,AT
 2a05:fc40::,2a05:fc47:ffff:ffff:ffff:ffff:ffff:ffff,DE
 2a05:fc80::,2a05:fc87:ffff:ffff:ffff:ffff:ffff:ffff,CH
@@ -24210,6 +26501,7 @@
 2a05:fdc0::,2a05:fdc7:ffff:ffff:ffff:ffff:ffff:ffff,AL
 2a05:fe00::,2a05:fe07:ffff:ffff:ffff:ffff:ffff:ffff,IT
 2a05:fe40::,2a05:fe47:ffff:ffff:ffff:ffff:ffff:ffff,TR
+2a05:fe80::,2a05:fe87:ffff:ffff:ffff:ffff:ffff:ffff,DE
 2a05:fec0::,2a05:fec7:ffff:ffff:ffff:ffff:ffff:ffff,TR
 2a05:ff00::,2a05:ff07:ffff:ffff:ffff:ffff:ffff:ffff,DE
 2a05:ff40::,2a05:ff47:ffff:ffff:ffff:ffff:ffff:ffff,SE
@@ -24235,7 +26527,6 @@
 2a06:440::,2a06:447:ffff:ffff:ffff:ffff:ffff:ffff,SE
 2a06:480::,2a06:487:ffff:ffff:ffff:ffff:ffff:ffff,DE
 2a06:4c0::,2a06:4c7:ffff:ffff:ffff:ffff:ffff:ffff,BG
-2a06:500::,2a06:507:ffff:ffff:ffff:ffff:ffff:ffff,FR
 2a06:540::,2a06:547:ffff:ffff:ffff:ffff:ffff:ffff,DE
 2a06:580::,2a06:587:ffff:ffff:ffff:ffff:ffff:ffff,KZ
 2a06:5c0::,2a06:5c7:ffff:ffff:ffff:ffff:ffff:ffff,IT
@@ -24265,11 +26556,12 @@
 2a06:bc0::,2a06:bc7:ffff:ffff:ffff:ffff:ffff:ffff,IR
 2a06:c00::,2a06:c07:ffff:ffff:ffff:ffff:ffff:ffff,CH
 2a06:c40::,2a06:c47:ffff:ffff:ffff:ffff:ffff:ffff,GB
-2a06:c80::,2a06:c87:ffff:ffff:ffff:ffff:ffff:ffff,SE
 2a06:cc0::,2a06:cc7:ffff:ffff:ffff:ffff:ffff:ffff,SK
 2a06:d00::,2a06:d07:ffff:ffff:ffff:ffff:ffff:ffff,IT
 2a06:d40::,2a06:d47:ffff:ffff:ffff:ffff:ffff:ffff,US
-2a06:d80::,2a06:d87:ffff:ffff:ffff:ffff:ffff:ffff,GB
+2a06:d80::,2a06:d86:1fe:ffff:ffff:ffff:ffff:ffff,GB
+2a06:d86:1ff::,2a06:d86:1ff:7fff:ffff:ffff:ffff:ffff,US
+2a06:d86:1ff:8000::,2a06:d87:ffff:ffff:ffff:ffff:ffff:ffff,GB
 2a06:dc0::,2a06:dc7:ffff:ffff:ffff:ffff:ffff:ffff,IT
 2a06:e00::,2a06:e07:ffff:ffff:ffff:ffff:ffff:ffff,NL
 2a06:e40::,2a06:e47:ffff:ffff:ffff:ffff:ffff:ffff,GB
@@ -24291,7 +26583,9 @@
 2a06:1240::,2a06:1247:ffff:ffff:ffff:ffff:ffff:ffff,CZ
 2a06:1280::,2a06:1280:bee0:ffff:ffff:ffff:ffff:ffff,BY
 2a06:1280:bee1::,2a06:1280:bee1:ffff:ffff:ffff:ffff:ffff,NZ
-2a06:1280:bee2::,2a06:1287:ffff:ffff:ffff:ffff:ffff:ffff,BY
+2a06:1280:bee2::,2a06:1287:1f:ffff:ffff:ffff:ffff:ffff,BY
+2a06:1287:20::,2a06:1287:2f:ffff:ffff:ffff:ffff:ffff,AT
+2a06:1287:30::,2a06:1287:ffff:ffff:ffff:ffff:ffff:ffff,BY
 2a06:12c0::,2a06:12c7:ffff:ffff:ffff:ffff:ffff:ffff,DE
 2a06:1300::,2a06:1307:ffff:ffff:ffff:ffff:ffff:ffff,RS
 2a06:1340::,2a06:1347:ffff:ffff:ffff:ffff:ffff:ffff,PL
@@ -24306,7 +26600,6 @@
 2a06:1580::,2a06:1587:ffff:ffff:ffff:ffff:ffff:ffff,GE
 2a06:15c0::,2a06:15c7:ffff:ffff:ffff:ffff:ffff:ffff,FR
 2a06:1600::,2a06:1607:ffff:ffff:ffff:ffff:ffff:ffff,GB
-2a06:1640::,2a06:1647:ffff:ffff:ffff:ffff:ffff:ffff,ES
 2a06:1680::,2a06:1687:ffff:ffff:ffff:ffff:ffff:ffff,ES
 2a06:16c0::,2a06:16c7:ffff:ffff:ffff:ffff:ffff:ffff,KW
 2a06:1700::,2a06:1707:ffff:ffff:ffff:ffff:ffff:ffff,RO
@@ -24349,9 +26642,9 @@
 2a06:2040::,2a06:2047:ffff:ffff:ffff:ffff:ffff:ffff,FR
 2a06:2080::,2a06:2087:ffff:ffff:ffff:ffff:ffff:ffff,IT
 2a06:20c0::,2a06:20c7:ffff:ffff:ffff:ffff:ffff:ffff,FI
-2a06:2100::,2a06:2107:ffff:ffff:ffff:ffff:ffff:ffff,RU
 2a06:2140::,2a06:2147:ffff:ffff:ffff:ffff:ffff:ffff,CZ
 2a06:2180::,2a06:2187:ffff:ffff:ffff:ffff:ffff:ffff,SK
+2a06:21c0::,2a06:21c7:ffff:ffff:ffff:ffff:ffff:ffff,NL
 2a06:2200::,2a06:2207:ffff:ffff:ffff:ffff:ffff:ffff,IR
 2a06:2240::,2a06:2247:ffff:ffff:ffff:ffff:ffff:ffff,NO
 2a06:2280::,2a06:2287:ffff:ffff:ffff:ffff:ffff:ffff,UA
@@ -24372,7 +26665,7 @@
 2a06:2640::,2a06:2647:ffff:ffff:ffff:ffff:ffff:ffff,DE
 2a06:2680::,2a06:2687:ffff:ffff:ffff:ffff:ffff:ffff,RU
 2a06:26c0::,2a06:26c7:ffff:ffff:ffff:ffff:ffff:ffff,PL
-2a06:2700::,2a06:2707:ffff:ffff:ffff:ffff:ffff:ffff,ES
+2a06:2700::,2a06:2707:ffff:ffff:ffff:ffff:ffff:ffff,RO
 2a06:2740::,2a06:2747:ffff:ffff:ffff:ffff:ffff:ffff,FR
 2a06:2780::,2a06:2787:ffff:ffff:ffff:ffff:ffff:ffff,DE
 2a06:27c0::,2a06:27c7:ffff:ffff:ffff:ffff:ffff:ffff,GB
@@ -24395,6 +26688,7 @@
 2a06:2c00::,2a06:2c07:ffff:ffff:ffff:ffff:ffff:ffff,IR
 2a06:2c40::,2a06:2c47:ffff:ffff:ffff:ffff:ffff:ffff,SK
 2a06:2c80::,2a06:2c87:ffff:ffff:ffff:ffff:ffff:ffff,RO
+2a06:2cc0::,2a06:2cc7:ffff:ffff:ffff:ffff:ffff:ffff,DE
 2a06:2d00::,2a06:2d07:ffff:ffff:ffff:ffff:ffff:ffff,TR
 2a06:2d40::,2a06:2d47:ffff:ffff:ffff:ffff:ffff:ffff,NL
 2a06:2d80::,2a06:2d87:ffff:ffff:ffff:ffff:ffff:ffff,RU
@@ -24406,20 +26700,25 @@
 2a06:2e80::,2a06:2e87:ffff:ffff:ffff:ffff:ffff:ffff,NL
 2a06:2ec0::,2a06:2ec7:ffff:ffff:ffff:ffff:ffff:ffff,NL
 2a06:2f00::,2a06:2f07:ffff:ffff:ffff:ffff:ffff:ffff,QA
+2a06:2f40::,2a06:2f47:ffff:ffff:ffff:ffff:ffff:ffff,SE
 2a06:2f80::,2a06:2f87:ffff:ffff:ffff:ffff:ffff:ffff,DE
 2a06:2fc0::,2a06:2fc7:ffff:ffff:ffff:ffff:ffff:ffff,FR
 2a06:3000::,2a06:3007:ffff:ffff:ffff:ffff:ffff:ffff,GB
-2a06:3040::,2a06:3047:ffff:ffff:ffff:ffff:ffff:ffff,RO
+2a06:3040::,2a06:3047:ffff:ffff:ffff:ffff:ffff:ffff,GE
 2a06:3080::,2a06:3087:ffff:ffff:ffff:ffff:ffff:ffff,NL
 2a06:30c0::,2a06:30c7:ffff:ffff:ffff:ffff:ffff:ffff,DE
 2a06:3100::,2a06:3107:ffff:ffff:ffff:ffff:ffff:ffff,NL
-2a06:3140::,2a06:3147:ffff:ffff:ffff:ffff:ffff:ffff,IR
+2a06:3180::,2a06:3187:ffff:ffff:ffff:ffff:ffff:ffff,SA
+2a06:31c0::,2a06:31c7:ffff:ffff:ffff:ffff:ffff:ffff,NO
 2a06:3200::,2a06:3207:ffff:ffff:ffff:ffff:ffff:ffff,DE
 2a06:3240::,2a06:3247:ffff:ffff:ffff:ffff:ffff:ffff,NL
+2a06:3280::,2a06:3287:ffff:ffff:ffff:ffff:ffff:ffff,IT
+2a06:32c0::,2a06:32c7:ffff:ffff:ffff:ffff:ffff:ffff,IR
 2a06:3300::,2a06:3307:ffff:ffff:ffff:ffff:ffff:ffff,DE
 2a06:3340::,2a06:3347:ffff:ffff:ffff:ffff:ffff:ffff,NO
 2a06:3380::,2a06:3387:ffff:ffff:ffff:ffff:ffff:ffff,DE
 2a06:33c0::,2a06:33c7:ffff:ffff:ffff:ffff:ffff:ffff,GB
+2a06:3400::,2a06:3407:ffff:ffff:ffff:ffff:ffff:ffff,GB
 2a06:3440::,2a06:3447:ffff:ffff:ffff:ffff:ffff:ffff,DK
 2a06:3480::,2a06:3487:ffff:ffff:ffff:ffff:ffff:ffff,LB
 2a06:34c0::,2a06:34c7:ffff:ffff:ffff:ffff:ffff:ffff,DE
@@ -24434,6 +26733,7 @@
 2a06:3700::,2a06:3707:ffff:ffff:ffff:ffff:ffff:ffff,DE
 2a06:3740::,2a06:3747:ffff:ffff:ffff:ffff:ffff:ffff,UA
 2a06:3780::,2a06:3787:ffff:ffff:ffff:ffff:ffff:ffff,GB
+2a06:37c0::,2a06:37c7:ffff:ffff:ffff:ffff:ffff:ffff,ES
 2a06:3800::,2a06:3807:ffff:ffff:ffff:ffff:ffff:ffff,NL
 2a06:3840::,2a06:3847:ffff:ffff:ffff:ffff:ffff:ffff,BE
 2a06:3880::,2a06:3887:ffff:ffff:ffff:ffff:ffff:ffff,NL
@@ -24457,13 +26757,11 @@
 2a06:3d00::,2a06:3d07:ffff:ffff:ffff:ffff:ffff:ffff,GR
 2a06:3d40::,2a06:3d47:ffff:ffff:ffff:ffff:ffff:ffff,RU
 2a06:3d80::,2a06:3d87:ffff:ffff:ffff:ffff:ffff:ffff,NL
-2a06:3dc0::,2a06:3dc7:ffff:ffff:ffff:ffff:ffff:ffff,RU
 2a06:3e00::,2a06:3e07:ffff:ffff:ffff:ffff:ffff:ffff,DE
 2a06:3e40::,2a06:3e47:ffff:ffff:ffff:ffff:ffff:ffff,DE
 2a06:3e80::,2a06:3e87:ffff:ffff:ffff:ffff:ffff:ffff,NL
 2a06:3ec0::,2a06:3ec7:ffff:ffff:ffff:ffff:ffff:ffff,NL
 2a06:3f00::,2a06:3f07:ffff:ffff:ffff:ffff:ffff:ffff,GB
-2a06:3f40::,2a06:3f47:ffff:ffff:ffff:ffff:ffff:ffff,IR
 2a06:3f80::,2a06:3f87:ffff:ffff:ffff:ffff:ffff:ffff,ES
 2a06:3fc0::,2a06:3fc7:ffff:ffff:ffff:ffff:ffff:ffff,GB
 2a06:4000::,2a06:4007:ffff:ffff:ffff:ffff:ffff:ffff,DK
@@ -24493,9 +26791,9 @@
 2a06:4600::,2a06:4607:ffff:ffff:ffff:ffff:ffff:ffff,DE
 2a06:4640::,2a06:4647:ffff:ffff:ffff:ffff:ffff:ffff,KW
 2a06:4680::,2a06:4687:ffff:ffff:ffff:ffff:ffff:ffff,RU
-2a06:46c0::,2a06:46c7:ffff:ffff:ffff:ffff:ffff:ffff,ES
-2a06:4700::,2a06:4707:ffff:ffff:ffff:ffff:ffff:ffff,ES
-2a06:4740::,2a06:4747:ffff:ffff:ffff:ffff:ffff:ffff,ES
+2a06:46c0::,2a06:46c7:ffff:ffff:ffff:ffff:ffff:ffff,RO
+2a06:4700::,2a06:4707:ffff:ffff:ffff:ffff:ffff:ffff,RO
+2a06:4740::,2a06:4747:ffff:ffff:ffff:ffff:ffff:ffff,RO
 2a06:4780::,2a06:4787:ffff:ffff:ffff:ffff:ffff:ffff,ES
 2a06:47c0::,2a06:47c7:ffff:ffff:ffff:ffff:ffff:ffff,RU
 2a06:4800::,2a06:4807:ffff:ffff:ffff:ffff:ffff:ffff,ES
@@ -24505,7 +26803,6 @@
 2a06:4900::,2a06:4907:ffff:ffff:ffff:ffff:ffff:ffff,DE
 2a06:4940::,2a06:4947:ffff:ffff:ffff:ffff:ffff:ffff,LU
 2a06:4980::,2a06:4987:ffff:ffff:ffff:ffff:ffff:ffff,LV
-2a06:49c0::,2a06:49c7:ffff:ffff:ffff:ffff:ffff:ffff,IR
 2a06:4a00::,2a06:4a07:ffff:ffff:ffff:ffff:ffff:ffff,PT
 2a06:4a40::,2a06:4a47:ffff:ffff:ffff:ffff:ffff:ffff,RO
 2a06:4a80::,2a06:4a87:ffff:ffff:ffff:ffff:ffff:ffff,NL
@@ -24514,7 +26811,6 @@
 2a06:4b40::,2a06:4b47:ffff:ffff:ffff:ffff:ffff:ffff,TR
 2a06:4b80::,2a06:4b87:ffff:ffff:ffff:ffff:ffff:ffff,IR
 2a06:4bc0::,2a06:4bc7:ffff:ffff:ffff:ffff:ffff:ffff,GB
-2a06:4c00::,2a06:4c07:ffff:ffff:ffff:ffff:ffff:ffff,DE
 2a06:4c40::,2a06:4c47:ffff:ffff:ffff:ffff:ffff:ffff,RU
 2a06:4c80::,2a06:4c87:ffff:ffff:ffff:ffff:ffff:ffff,NL
 2a06:4cc0::,2a06:4cc7:ffff:ffff:ffff:ffff:ffff:ffff,GB
@@ -24536,6 +26832,8 @@
 2a06:50c0::,2a06:50c7:ffff:ffff:ffff:ffff:ffff:ffff,NL
 2a06:5100::,2a06:5107:ffff:ffff:ffff:ffff:ffff:ffff,CH
 2a06:5140::,2a06:5147:ffff:ffff:ffff:ffff:ffff:ffff,IT
+2a06:5180::,2a06:5187:ffff:ffff:ffff:ffff:ffff:ffff,TR
+2a06:51c0::,2a06:51c7:ffff:ffff:ffff:ffff:ffff:ffff,PL
 2a06:5200::,2a06:5207:ffff:ffff:ffff:ffff:ffff:ffff,IE
 2a06:5240::,2a06:5247:ffff:ffff:ffff:ffff:ffff:ffff,DE
 2a06:5280::,2a06:5287:ffff:ffff:ffff:ffff:ffff:ffff,RO
@@ -24547,7 +26845,6 @@
 2a06:5400::,2a06:5407:ffff:ffff:ffff:ffff:ffff:ffff,DE
 2a06:5440::,2a06:5447:ffff:ffff:ffff:ffff:ffff:ffff,RU
 2a06:5480::,2a06:5487:ffff:ffff:ffff:ffff:ffff:ffff,IR
-2a06:54c0::,2a06:54c7:ffff:ffff:ffff:ffff:ffff:ffff,IR
 2a06:5500::,2a06:5507:ffff:ffff:ffff:ffff:ffff:ffff,BG
 2a06:5540::,2a06:5547:ffff:ffff:ffff:ffff:ffff:ffff,PS
 2a06:5580::,2a06:5587:ffff:ffff:ffff:ffff:ffff:ffff,IL
@@ -24556,8 +26853,8 @@
 2a06:5640::,2a06:5647:ffff:ffff:ffff:ffff:ffff:ffff,DE
 2a06:5680::,2a06:5687:ffff:ffff:ffff:ffff:ffff:ffff,AT
 2a06:56c0::,2a06:56c7:ffff:ffff:ffff:ffff:ffff:ffff,CH
-2a06:5700::,2a06:5707:ffff:ffff:ffff:ffff:ffff:ffff,RO
-2a06:5740::,2a06:5747:ffff:ffff:ffff:ffff:ffff:ffff,RO
+2a06:5700::,2a06:5707:ffff:ffff:ffff:ffff:ffff:ffff,DE
+2a06:5740::,2a06:5747:ffff:ffff:ffff:ffff:ffff:ffff,GE
 2a06:5780::,2a06:5787:ffff:ffff:ffff:ffff:ffff:ffff,RO
 2a06:57c0::,2a06:57c7:ffff:ffff:ffff:ffff:ffff:ffff,RO
 2a06:5800::,2a06:5807:ffff:ffff:ffff:ffff:ffff:ffff,RO
@@ -24659,7 +26956,6 @@
 2a06:7000::,2a06:7007:ffff:ffff:ffff:ffff:ffff:ffff,GB
 2a06:7040::,2a06:7047:ffff:ffff:ffff:ffff:ffff:ffff,AT
 2a06:7080::,2a06:7087:ffff:ffff:ffff:ffff:ffff:ffff,IE
-2a06:70c0::,2a06:70c7:ffff:ffff:ffff:ffff:ffff:ffff,IR
 2a06:7100::,2a06:7107:ffff:ffff:ffff:ffff:ffff:ffff,NL
 2a06:7140::,2a06:7147:ffff:ffff:ffff:ffff:ffff:ffff,IR
 2a06:7180::,2a06:7187:ffff:ffff:ffff:ffff:ffff:ffff,DE
@@ -24669,7 +26965,7 @@
 2a06:7280::,2a06:7287:ffff:ffff:ffff:ffff:ffff:ffff,IT
 2a06:72c0::,2a06:72c7:ffff:ffff:ffff:ffff:ffff:ffff,NL
 2a06:7300::,2a06:7307:ffff:ffff:ffff:ffff:ffff:ffff,UA
-2a06:7340::,2a06:7347:ffff:ffff:ffff:ffff:ffff:ffff,HU
+2a06:7340::,2a06:7347:ffff:ffff:ffff:ffff:ffff:ffff,RO
 2a06:7380::,2a06:7387:ffff:ffff:ffff:ffff:ffff:ffff,DE
 2a06:73c0::,2a06:73c7:ffff:ffff:ffff:ffff:ffff:ffff,AL
 2a06:7400::,2a06:7407:ffff:ffff:ffff:ffff:ffff:ffff,RO
@@ -24724,15 +27020,25 @@
 2a06:8040::,2a06:8047:ffff:ffff:ffff:ffff:ffff:ffff,FR
 2a06:8080::,2a06:8087:ffff:ffff:ffff:ffff:ffff:ffff,CZ
 2a06:80c0::,2a06:80c7:ffff:ffff:ffff:ffff:ffff:ffff,DE
-2a06:8100::,2a06:8107:ffff:ffff:ffff:ffff:ffff:ffff,HU
-2a06:8140::,2a06:8147:ffff:ffff:ffff:ffff:ffff:ffff,CZ
-2a06:8180::,2a06:8181:fef:ffff:ffff:ffff:ffff:ffff,GB
+2a06:8100::,2a06:8107:ffff:ffff:ffff:ffff:ffff:ffff,RO
+2a06:8140::,2a06:8147:ffff:ffff:ffff:ffff:ffff:ffff,DE
+2a06:8180::,2a06:8181:9f:ffff:ffff:ffff:ffff:ffff,GB
+2a06:8181:a0::,2a06:8181:af:ffff:ffff:ffff:ffff:ffff,NL
+2a06:8181:b0::,2a06:8181:fef:ffff:ffff:ffff:ffff:ffff,GB
 2a06:8181:ff0::,2a06:8181:fff:ffff:ffff:ffff:ffff:ffff,AT
-2a06:8181:1000::,2a06:8187:ffff:ffff:ffff:ffff:ffff:ffff,GB
+2a06:8181:1000::,2a06:8181:1fcf:ffff:ffff:ffff:ffff:ffff,GB
+2a06:8181:1fd0::,2a06:8181:1fdf:ffff:ffff:ffff:ffff:ffff,AT
+2a06:8181:1fe0::,2a06:8184:ffff:ffff:ffff:ffff:ffff:ffff,GB
+2a06:8185::,2a06:8185:ffff:ffff:ffff:ffff:ffff:ffff,CH
+2a06:8186::,2a06:8187:fcff:ffff:ffff:ffff:ffff:ffff,GB
+2a06:8187:fd00::,2a06:8187:fdff:ffff:ffff:ffff:ffff:ffff,FR
+2a06:8187:fe00::,2a06:8187:ffff:ffff:ffff:ffff:ffff:ffff,GB
 2a06:81c0::,2a06:81c7:ffff:ffff:ffff:ffff:ffff:ffff,NO
 2a06:8200::,2a06:8207:ffff:ffff:ffff:ffff:ffff:ffff,IR
 2a06:8240::,2a06:8247:ffff:ffff:ffff:ffff:ffff:ffff,MY
-2a06:8280::,2a06:8287:ffff:ffff:ffff:ffff:ffff:ffff,CH
+2a06:8280::,2a06:8280:ffff:ffff:ffff:ffff:ffff:ffff,CH
+2a06:8281::,2a06:8281:ffff:ffff:ffff:ffff:ffff:ffff,DE
+2a06:8282::,2a06:8287:ffff:ffff:ffff:ffff:ffff:ffff,CH
 2a06:82c0::,2a06:82c7:ffff:ffff:ffff:ffff:ffff:ffff,FR
 2a06:8340::,2a06:8347:ffff:ffff:ffff:ffff:ffff:ffff,PL
 2a06:8380::,2a06:8387:ffff:ffff:ffff:ffff:ffff:ffff,IR
@@ -24773,6 +27079,24 @@
 2a06:8c40::,2a06:8c47:ffff:ffff:ffff:ffff:ffff:ffff,ES
 2a06:8c80::,2a06:8c87:ffff:ffff:ffff:ffff:ffff:ffff,UA
 2a06:8cc0::,2a06:8cc7:ffff:ffff:ffff:ffff:ffff:ffff,IT
+2a06:8d00::,2a06:8d07:ffff:ffff:ffff:ffff:ffff:ffff,IR
+2a06:8d40::,2a06:8d47:ffff:ffff:ffff:ffff:ffff:ffff,NL
+2a06:8d80::,2a06:8d87:ffff:ffff:ffff:ffff:ffff:ffff,GB
+2a06:8dc0::,2a06:8dc7:ffff:ffff:ffff:ffff:ffff:ffff,GB
+2a06:8e00::,2a06:8e07:ffff:ffff:ffff:ffff:ffff:ffff,GB
+2a06:8e40::,2a06:8e47:ffff:ffff:ffff:ffff:ffff:ffff,GB
+2a06:8e80::,2a06:8e87:ffff:ffff:ffff:ffff:ffff:ffff,GB
+2a06:8ec0::,2a06:8ec0:1:ffff:ffff:ffff:ffff:ffff,GB
+2a06:8ec0:2::,2a06:8ec0:2:ffff:ffff:ffff:ffff:ffff,CH
+2a06:8ec0:3::,2a06:8ec0:3:ffff:ffff:ffff:ffff:ffff,GB
+2a06:8ec0:4::,2a06:8ec0:4:ffff:ffff:ffff:ffff:ffff,NL
+2a06:8ec0:5::,2a06:8ec0:5:ffff:ffff:ffff:ffff:ffff,GB
+2a06:8ec0:6::,2a06:8ec0:6:ffff:ffff:ffff:ffff:ffff,SE
+2a06:8ec0:7::,2a06:8ec7:ffff:ffff:ffff:ffff:ffff:ffff,GB
+2a06:8f00::,2a06:8f07:ffff:ffff:ffff:ffff:ffff:ffff,AL
+2a06:8f40::,2a06:8f47:ffff:ffff:ffff:ffff:ffff:ffff,ES
+2a06:8f80::,2a06:8f87:ffff:ffff:ffff:ffff:ffff:ffff,FI
+2a06:8fc0::,2a06:8fc7:ffff:ffff:ffff:ffff:ffff:ffff,IT
 2a06:9000::,2a06:9007:ffff:ffff:ffff:ffff:ffff:ffff,UA
 2a06:9040::,2a06:9047:ffff:ffff:ffff:ffff:ffff:ffff,DE
 2a06:9080::,2a06:9087:ffff:ffff:ffff:ffff:ffff:ffff,TR
@@ -24805,6 +27129,409 @@
 2a06:9740::,2a06:9747:ffff:ffff:ffff:ffff:ffff:ffff,DE
 2a06:9780::,2a06:9787:ffff:ffff:ffff:ffff:ffff:ffff,CZ
 2a06:97c0::,2a06:97c7:ffff:ffff:ffff:ffff:ffff:ffff,RS
+2a06:9800::,2a06:9807:ffff:ffff:ffff:ffff:ffff:ffff,GB
+2a06:9840::,2a06:9847:ffff:ffff:ffff:ffff:ffff:ffff,FR
+2a06:98c0::,2a06:98c7:ffff:ffff:ffff:ffff:ffff:ffff,GB
+2a06:9900::,2a06:9907:ffff:ffff:ffff:ffff:ffff:ffff,NO
+2a06:9940::,2a06:9947:ffff:ffff:ffff:ffff:ffff:ffff,ES
+2a06:9980::,2a06:9987:ffff:ffff:ffff:ffff:ffff:ffff,RU
+2a06:99c0::,2a06:99c7:ffff:ffff:ffff:ffff:ffff:ffff,ES
+2a06:9a00::,2a06:9a07:ffff:ffff:ffff:ffff:ffff:ffff,IR
+2a06:9a40::,2a06:9a47:ffff:ffff:ffff:ffff:ffff:ffff,IL
+2a06:9a80::,2a06:9a87:ffff:ffff:ffff:ffff:ffff:ffff,GB
+2a06:9ac0::,2a06:9ac7:ffff:ffff:ffff:ffff:ffff:ffff,CH
+2a06:9b00::,2a06:9b07:ffff:ffff:ffff:ffff:ffff:ffff,PL
+2a06:9b40::,2a06:9b47:ffff:ffff:ffff:ffff:ffff:ffff,IR
+2a06:9b80::,2a06:9b87:ffff:ffff:ffff:ffff:ffff:ffff,BE
+2a06:9bc0::,2a06:9bc7:ffff:ffff:ffff:ffff:ffff:ffff,RU
+2a06:9c00::,2a06:9c07:ffff:ffff:ffff:ffff:ffff:ffff,GB
+2a06:9c40::,2a06:9c47:ffff:ffff:ffff:ffff:ffff:ffff,SE
+2a06:9c80::,2a06:9c87:ffff:ffff:ffff:ffff:ffff:ffff,IT
+2a06:9cc0::,2a06:9cc7:ffff:ffff:ffff:ffff:ffff:ffff,AT
+2a06:9d00::,2a06:9d07:ffff:ffff:ffff:ffff:ffff:ffff,GB
+2a06:9d40::,2a06:9d47:ffff:ffff:ffff:ffff:ffff:ffff,IT
+2a06:9d80::,2a06:9d87:ffff:ffff:ffff:ffff:ffff:ffff,UA
+2a06:9dc0::,2a06:9dc7:ffff:ffff:ffff:ffff:ffff:ffff,UA
+2a06:9e00::,2a06:9e07:ffff:ffff:ffff:ffff:ffff:ffff,NL
+2a06:9e40::,2a06:9e47:ffff:ffff:ffff:ffff:ffff:ffff,UA
+2a06:9e80::,2a06:9e87:ffff:ffff:ffff:ffff:ffff:ffff,GB
+2a06:9ec0::,2a06:9ec7:ffff:ffff:ffff:ffff:ffff:ffff,IR
+2a06:9f00::,2a06:9f07:ffff:ffff:ffff:ffff:ffff:ffff,BG
+2a06:9f40::,2a06:9f47:ffff:ffff:ffff:ffff:ffff:ffff,NO
+2a06:9f80::,2a06:9f87:ffff:ffff:ffff:ffff:ffff:ffff,VA
+2a06:9fc0::,2a06:9fc7:ffff:ffff:ffff:ffff:ffff:ffff,DK
+2a06:a000::,2a06:a007:ffff:ffff:ffff:ffff:ffff:ffff,IS
+2a06:a040::,2a06:a047:ffff:ffff:ffff:ffff:ffff:ffff,TR
+2a06:a080::,2a06:a087:ffff:ffff:ffff:ffff:ffff:ffff,NL
+2a06:a0c0::,2a06:a0c7:ffff:ffff:ffff:ffff:ffff:ffff,FI
+2a06:a100::,2a06:a107:ffff:ffff:ffff:ffff:ffff:ffff,IS
+2a06:a140::,2a06:a147:ffff:ffff:ffff:ffff:ffff:ffff,NL
+2a06:a180::,2a06:a187:ffff:ffff:ffff:ffff:ffff:ffff,RU
+2a06:a1c0::,2a06:a1c7:ffff:ffff:ffff:ffff:ffff:ffff,IL
+2a06:a200::,2a06:a207:ffff:ffff:ffff:ffff:ffff:ffff,ES
+2a06:a240::,2a06:a247:ffff:ffff:ffff:ffff:ffff:ffff,GB
+2a06:a280::,2a06:a287:ffff:ffff:ffff:ffff:ffff:ffff,SK
+2a06:a2c0::,2a06:a2c7:ffff:ffff:ffff:ffff:ffff:ffff,GB
+2a06:a300::,2a06:a307:ffff:ffff:ffff:ffff:ffff:ffff,PL
+2a06:a340::,2a06:a347:ffff:ffff:ffff:ffff:ffff:ffff,GB
+2a06:a380::,2a06:a387:ffff:ffff:ffff:ffff:ffff:ffff,GB
+2a06:a3c0::,2a06:a3c7:ffff:ffff:ffff:ffff:ffff:ffff,PL
+2a06:a400::,2a06:a407:ffff:ffff:ffff:ffff:ffff:ffff,FR
+2a06:a440::,2a06:a447:ffff:ffff:ffff:ffff:ffff:ffff,PL
+2a06:a480::,2a06:a487:ffff:ffff:ffff:ffff:ffff:ffff,RU
+2a06:a4c0::,2a06:a4c7:ffff:ffff:ffff:ffff:ffff:ffff,IR
+2a06:a500::,2a06:a507:ffff:ffff:ffff:ffff:ffff:ffff,FR
+2a06:a540::,2a06:a547:ffff:ffff:ffff:ffff:ffff:ffff,GB
+2a06:a580::,2a06:a587:ffff:ffff:ffff:ffff:ffff:ffff,NO
+2a06:a5c0::,2a06:a5c7:ffff:ffff:ffff:ffff:ffff:ffff,NL
+2a06:a600::,2a06:a607:ffff:ffff:ffff:ffff:ffff:ffff,NL
+2a06:a640::,2a06:a647:ffff:ffff:ffff:ffff:ffff:ffff,RU
+2a06:a680::,2a06:a687:ffff:ffff:ffff:ffff:ffff:ffff,TR
+2a06:a6c0::,2a06:a6c7:ffff:ffff:ffff:ffff:ffff:ffff,ES
+2a06:a700::,2a06:a707:ffff:ffff:ffff:ffff:ffff:ffff,NL
+2a06:a740::,2a06:a747:ffff:ffff:ffff:ffff:ffff:ffff,NO
+2a06:a780::,2a06:a787:ffff:ffff:ffff:ffff:ffff:ffff,CZ
+2a06:a7c0::,2a06:a7c7:ffff:ffff:ffff:ffff:ffff:ffff,GB
+2a06:a800::,2a06:a807:ffff:ffff:ffff:ffff:ffff:ffff,GB
+2a06:a840::,2a06:a847:ffff:ffff:ffff:ffff:ffff:ffff,NL
+2a06:a880::,2a06:a887:ffff:ffff:ffff:ffff:ffff:ffff,RO
+2a06:a8c0::,2a06:a8c7:ffff:ffff:ffff:ffff:ffff:ffff,DE
+2a06:a900::,2a06:a907:ffff:ffff:ffff:ffff:ffff:ffff,CH
+2a06:a940::,2a06:a947:ffff:ffff:ffff:ffff:ffff:ffff,TR
+2a06:a980::,2a06:a987:ffff:ffff:ffff:ffff:ffff:ffff,IT
+2a06:a9c0::,2a06:a9c7:ffff:ffff:ffff:ffff:ffff:ffff,RU
+2a06:aa00::,2a06:aa07:ffff:ffff:ffff:ffff:ffff:ffff,RU
+2a06:aa40::,2a06:aa47:ffff:ffff:ffff:ffff:ffff:ffff,PL
+2a06:aa80::,2a06:aa87:ffff:ffff:ffff:ffff:ffff:ffff,RU
+2a06:aac0::,2a06:aac7:ffff:ffff:ffff:ffff:ffff:ffff,EE
+2a06:ab00::,2a06:ab07:ffff:ffff:ffff:ffff:ffff:ffff,NL
+2a06:ab40::,2a06:ab47:ffff:ffff:ffff:ffff:ffff:ffff,IR
+2a06:ab80::,2a06:ab87:ffff:ffff:ffff:ffff:ffff:ffff,ES
+2a06:abc0::,2a06:abc7:ffff:ffff:ffff:ffff:ffff:ffff,IR
+2a06:ac00::,2a06:ac07:ffff:ffff:ffff:ffff:ffff:ffff,FR
+2a06:ac40::,2a06:ac47:ffff:ffff:ffff:ffff:ffff:ffff,GB
+2a06:ac80::,2a06:ac87:ffff:ffff:ffff:ffff:ffff:ffff,DE
+2a06:acc0::,2a06:acc7:ffff:ffff:ffff:ffff:ffff:ffff,RU
+2a06:ad00::,2a06:ad07:ffff:ffff:ffff:ffff:ffff:ffff,NO
+2a06:ad40::,2a06:ad47:ffff:ffff:ffff:ffff:ffff:ffff,TR
+2a06:ad80::,2a06:ad87:ffff:ffff:ffff:ffff:ffff:ffff,FR
+2a06:adc0::,2a06:adc7:ffff:ffff:ffff:ffff:ffff:ffff,TR
+2a06:ae00::,2a06:ae07:ffff:ffff:ffff:ffff:ffff:ffff,FI
+2a06:ae40::,2a06:ae47:ffff:ffff:ffff:ffff:ffff:ffff,FI
+2a06:ae80::,2a06:ae87:ffff:ffff:ffff:ffff:ffff:ffff,ES
+2a06:aec0::,2a06:aec7:ffff:ffff:ffff:ffff:ffff:ffff,RU
+2a06:af00::,2a06:af07:ffff:ffff:ffff:ffff:ffff:ffff,PL
+2a06:af40::,2a06:af47:ffff:ffff:ffff:ffff:ffff:ffff,IS
+2a06:af80::,2a06:af87:ffff:ffff:ffff:ffff:ffff:ffff,IR
+2a06:afc0::,2a06:afc7:ffff:ffff:ffff:ffff:ffff:ffff,RO
+2a06:b000::,2a06:b007:ffff:ffff:ffff:ffff:ffff:ffff,CH
+2a06:b040::,2a06:b047:ffff:ffff:ffff:ffff:ffff:ffff,NO
+2a06:b080::,2a06:b087:ffff:ffff:ffff:ffff:ffff:ffff,DE
+2a06:b0c0::,2a06:b0c7:ffff:ffff:ffff:ffff:ffff:ffff,NO
+2a06:b100::,2a06:b107:ffff:ffff:ffff:ffff:ffff:ffff,FI
+2a06:b140::,2a06:b147:ffff:ffff:ffff:ffff:ffff:ffff,NO
+2a06:b180::,2a06:b187:ffff:ffff:ffff:ffff:ffff:ffff,ES
+2a06:b1c0::,2a06:b1c7:ffff:ffff:ffff:ffff:ffff:ffff,PL
+2a06:b200::,2a06:b207:ffff:ffff:ffff:ffff:ffff:ffff,IR
+2a06:b240::,2a06:b247:ffff:ffff:ffff:ffff:ffff:ffff,GB
+2a06:b280::,2a06:b287:ffff:ffff:ffff:ffff:ffff:ffff,DK
+2a06:b2c0::,2a06:b2c7:ffff:ffff:ffff:ffff:ffff:ffff,PT
+2a06:b300::,2a06:b307:ffff:ffff:ffff:ffff:ffff:ffff,ES
+2a06:b340::,2a06:b347:ffff:ffff:ffff:ffff:ffff:ffff,AT
+2a06:b380::,2a06:b387:ffff:ffff:ffff:ffff:ffff:ffff,GB
+2a06:b3c0::,2a06:b3c7:ffff:ffff:ffff:ffff:ffff:ffff,IR
+2a06:b400::,2a06:b407:ffff:ffff:ffff:ffff:ffff:ffff,RU
+2a06:b440::,2a06:b447:ffff:ffff:ffff:ffff:ffff:ffff,IR
+2a06:b480::,2a06:b487:ffff:ffff:ffff:ffff:ffff:ffff,PL
+2a06:b4c0::,2a06:b4c7:ffff:ffff:ffff:ffff:ffff:ffff,RU
+2a06:b500::,2a06:b507:ffff:ffff:ffff:ffff:ffff:ffff,DE
+2a06:b540::,2a06:b547:ffff:ffff:ffff:ffff:ffff:ffff,LB
+2a06:b580::,2a06:b587:ffff:ffff:ffff:ffff:ffff:ffff,DE
+2a06:b5c0::,2a06:b5c7:ffff:ffff:ffff:ffff:ffff:ffff,NL
+2a06:b600::,2a06:b607:ffff:ffff:ffff:ffff:ffff:ffff,DE
+2a06:b640::,2a06:b647:ffff:ffff:ffff:ffff:ffff:ffff,IT
+2a06:b680::,2a06:b687:ffff:ffff:ffff:ffff:ffff:ffff,PL
+2a06:b6c0::,2a06:b6c7:ffff:ffff:ffff:ffff:ffff:ffff,NL
+2a06:b700::,2a06:b707:ffff:ffff:ffff:ffff:ffff:ffff,FI
+2a06:b740::,2a06:b747:ffff:ffff:ffff:ffff:ffff:ffff,DK
+2a06:b780::,2a06:b787:ffff:ffff:ffff:ffff:ffff:ffff,TR
+2a06:b7c0::,2a06:b7c7:ffff:ffff:ffff:ffff:ffff:ffff,NL
+2a06:b800::,2a06:b807:ffff:ffff:ffff:ffff:ffff:ffff,KZ
+2a06:b840::,2a06:b847:ffff:ffff:ffff:ffff:ffff:ffff,FR
+2a06:b880::,2a06:b887:ffff:ffff:ffff:ffff:ffff:ffff,LB
+2a06:b8c0::,2a06:b8c7:ffff:ffff:ffff:ffff:ffff:ffff,LB
+2a06:b900::,2a06:b907:ffff:ffff:ffff:ffff:ffff:ffff,LB
+2a06:b940::,2a06:b947:ffff:ffff:ffff:ffff:ffff:ffff,LB
+2a06:b980::,2a06:b987:ffff:ffff:ffff:ffff:ffff:ffff,ES
+2a06:b9c0::,2a06:b9c7:ffff:ffff:ffff:ffff:ffff:ffff,DE
+2a06:ba00::,2a06:ba07:ffff:ffff:ffff:ffff:ffff:ffff,DK
+2a06:ba40::,2a06:ba47:ffff:ffff:ffff:ffff:ffff:ffff,NL
+2a06:ba80::,2a06:ba87:ffff:ffff:ffff:ffff:ffff:ffff,RU
+2a06:bac0::,2a06:bac7:ffff:ffff:ffff:ffff:ffff:ffff,CZ
+2a06:bb00::,2a06:bb07:ffff:ffff:ffff:ffff:ffff:ffff,PL
+2a06:bb40::,2a06:bb47:ffff:ffff:ffff:ffff:ffff:ffff,RU
+2a06:bb80::,2a06:bb87:ffff:ffff:ffff:ffff:ffff:ffff,GB
+2a06:bbc0::,2a06:bbc7:ffff:ffff:ffff:ffff:ffff:ffff,IT
+2a06:bc00::,2a06:bc07:ffff:ffff:ffff:ffff:ffff:ffff,CH
+2a06:bc40::,2a06:bc47:ffff:ffff:ffff:ffff:ffff:ffff,US
+2a06:bc80::,2a06:bc87:ffff:ffff:ffff:ffff:ffff:ffff,GB
+2a06:bcc0::,2a06:bcc7:ffff:ffff:ffff:ffff:ffff:ffff,DE
+2a06:bd00::,2a06:bd07:ffff:ffff:ffff:ffff:ffff:ffff,NO
+2a06:bd40::,2a06:bd47:ffff:ffff:ffff:ffff:ffff:ffff,NL
+2a06:bd80::,2a06:bd87:ffff:ffff:ffff:ffff:ffff:ffff,IS
+2a06:be00::,2a06:be07:ffff:ffff:ffff:ffff:ffff:ffff,DE
+2a06:be40::,2a06:be47:ffff:ffff:ffff:ffff:ffff:ffff,IT
+2a06:be80::,2a06:be87:ffff:ffff:ffff:ffff:ffff:ffff,DE
+2a06:bec0::,2a06:bec7:ffff:ffff:ffff:ffff:ffff:ffff,IR
+2a06:bf00::,2a06:bf07:ffff:ffff:ffff:ffff:ffff:ffff,IS
+2a06:bf40::,2a06:bf47:ffff:ffff:ffff:ffff:ffff:ffff,NL
+2a06:bf80::,2a06:bf87:ffff:ffff:ffff:ffff:ffff:ffff,DE
+2a06:bfc0::,2a06:bfc7:ffff:ffff:ffff:ffff:ffff:ffff,SK
+2a06:c000::,2a06:c007:ffff:ffff:ffff:ffff:ffff:ffff,RU
+2a06:c040::,2a06:c047:ffff:ffff:ffff:ffff:ffff:ffff,DE
+2a06:c080::,2a06:c087:ffff:ffff:ffff:ffff:ffff:ffff,DK
+2a06:c0c0::,2a06:c0c7:ffff:ffff:ffff:ffff:ffff:ffff,UA
+2a06:c100::,2a06:c107:ffff:ffff:ffff:ffff:ffff:ffff,IT
+2a06:c140::,2a06:c147:ffff:ffff:ffff:ffff:ffff:ffff,AT
+2a06:c180::,2a06:c187:ffff:ffff:ffff:ffff:ffff:ffff,SI
+2a06:c1c0::,2a06:c1c7:ffff:ffff:ffff:ffff:ffff:ffff,NL
+2a06:c200::,2a06:c207:ffff:ffff:ffff:ffff:ffff:ffff,IT
+2a06:c240::,2a06:c247:ffff:ffff:ffff:ffff:ffff:ffff,SE
+2a06:c280::,2a06:c287:ffff:ffff:ffff:ffff:ffff:ffff,NL
+2a06:c2c0::,2a06:c2c7:ffff:ffff:ffff:ffff:ffff:ffff,IT
+2a06:c300::,2a06:c307:ffff:ffff:ffff:ffff:ffff:ffff,DK
+2a06:c340::,2a06:c347:ffff:ffff:ffff:ffff:ffff:ffff,DE
+2a06:c380::,2a06:c387:ffff:ffff:ffff:ffff:ffff:ffff,TR
+2a06:c3c0::,2a06:c3c7:ffff:ffff:ffff:ffff:ffff:ffff,RU
+2a06:c400::,2a06:c407:ffff:ffff:ffff:ffff:ffff:ffff,TR
+2a06:c440::,2a06:c447:ffff:ffff:ffff:ffff:ffff:ffff,FR
+2a06:c480::,2a06:c487:ffff:ffff:ffff:ffff:ffff:ffff,FR
+2a06:c4c0::,2a06:c4c7:ffff:ffff:ffff:ffff:ffff:ffff,AT
+2a06:c500::,2a06:c507:ffff:ffff:ffff:ffff:ffff:ffff,AT
+2a06:c540::,2a06:c547:ffff:ffff:ffff:ffff:ffff:ffff,FR
+2a06:c580::,2a06:c587:ffff:ffff:ffff:ffff:ffff:ffff,DE
+2a06:c5c0::,2a06:c5c7:ffff:ffff:ffff:ffff:ffff:ffff,GB
+2a06:c600::,2a06:c607:ffff:ffff:ffff:ffff:ffff:ffff,DE
+2a06:c640::,2a06:c647:ffff:ffff:ffff:ffff:ffff:ffff,DE
+2a06:c680::,2a06:c687:ffff:ffff:ffff:ffff:ffff:ffff,RU
+2a06:c6c0::,2a06:c6c7:ffff:ffff:ffff:ffff:ffff:ffff,RU
+2a06:c700::,2a06:c707:ffff:ffff:ffff:ffff:ffff:ffff,IL
+2a06:c740::,2a06:c747:ffff:ffff:ffff:ffff:ffff:ffff,NO
+2a06:c780::,2a06:c787:ffff:ffff:ffff:ffff:ffff:ffff,FI
+2a06:c7c0::,2a06:c7c7:ffff:ffff:ffff:ffff:ffff:ffff,FI
+2a06:c800::,2a06:c807:ffff:ffff:ffff:ffff:ffff:ffff,FR
+2a06:c840::,2a06:c847:ffff:ffff:ffff:ffff:ffff:ffff,FI
+2a06:c880::,2a06:c887:ffff:ffff:ffff:ffff:ffff:ffff,IT
+2a06:c8c0::,2a06:c8c7:ffff:ffff:ffff:ffff:ffff:ffff,NL
+2a06:c900::,2a06:c907:ffff:ffff:ffff:ffff:ffff:ffff,ES
+2a06:c940::,2a06:c947:ffff:ffff:ffff:ffff:ffff:ffff,PL
+2a06:c980::,2a06:c987:ffff:ffff:ffff:ffff:ffff:ffff,ES
+2a06:c9c0::,2a06:c9c7:ffff:ffff:ffff:ffff:ffff:ffff,DK
+2a06:ca00::,2a06:ca07:ffff:ffff:ffff:ffff:ffff:ffff,GB
+2a06:ca40::,2a06:ca47:ffff:ffff:ffff:ffff:ffff:ffff,GB
+2a06:ca80::,2a06:ca87:ffff:ffff:ffff:ffff:ffff:ffff,RU
+2a06:cac0::,2a06:cac7:ffff:ffff:ffff:ffff:ffff:ffff,IR
+2a06:cb00::,2a06:cb07:ffff:ffff:ffff:ffff:ffff:ffff,LB
+2a06:cb40::,2a06:cb47:ffff:ffff:ffff:ffff:ffff:ffff,NL
+2a06:cb80::,2a06:cb87:ffff:ffff:ffff:ffff:ffff:ffff,CH
+2a06:cbc0::,2a06:cbc7:ffff:ffff:ffff:ffff:ffff:ffff,DE
+2a06:cc00::,2a06:cc07:ffff:ffff:ffff:ffff:ffff:ffff,RO
+2a06:cc40::,2a06:cc47:ffff:ffff:ffff:ffff:ffff:ffff,IR
+2a06:cc80::,2a06:cc87:ffff:ffff:ffff:ffff:ffff:ffff,NO
+2a06:ccc0::,2a06:ccc7:ffff:ffff:ffff:ffff:ffff:ffff,IT
+2a06:cd00::,2a06:cd07:ffff:ffff:ffff:ffff:ffff:ffff,NL
+2a06:cd40::,2a06:cd47:ffff:ffff:ffff:ffff:ffff:ffff,RO
+2a06:cd80::,2a06:cd87:ffff:ffff:ffff:ffff:ffff:ffff,IR
+2a06:cdc0::,2a06:cdc7:ffff:ffff:ffff:ffff:ffff:ffff,PT
+2a06:ce00::,2a06:ce07:ffff:ffff:ffff:ffff:ffff:ffff,ES
+2a06:ce40::,2a06:ce47:ffff:ffff:ffff:ffff:ffff:ffff,ES
+2a06:ce80::,2a06:ce87:ffff:ffff:ffff:ffff:ffff:ffff,NL
+2a06:cec0::,2a06:cec7:ffff:ffff:ffff:ffff:ffff:ffff,RO
+2a06:cf00::,2a06:cf07:ffff:ffff:ffff:ffff:ffff:ffff,DE
+2a06:cf40::,2a06:cf47:ffff:ffff:ffff:ffff:ffff:ffff,TR
+2a06:cf80::,2a06:cf87:ffff:ffff:ffff:ffff:ffff:ffff,FI
+2a06:cfc0::,2a06:cfc7:ffff:ffff:ffff:ffff:ffff:ffff,IT
+2a06:d000::,2a06:d007:ffff:ffff:ffff:ffff:ffff:ffff,UA
+2a06:d040::,2a06:d047:ffff:ffff:ffff:ffff:ffff:ffff,CH
+2a06:d080::,2a06:d087:ffff:ffff:ffff:ffff:ffff:ffff,ES
+2a06:d0c0::,2a06:d0c7:ffff:ffff:ffff:ffff:ffff:ffff,FR
+2a06:d100::,2a06:d107:ffff:ffff:ffff:ffff:ffff:ffff,FR
+2a06:d140::,2a06:d147:ffff:ffff:ffff:ffff:ffff:ffff,GB
+2a06:d180::,2a06:d187:ffff:ffff:ffff:ffff:ffff:ffff,AT
+2a06:d1c0::,2a06:d1c7:ffff:ffff:ffff:ffff:ffff:ffff,GB
+2a06:d200::,2a06:d207:ffff:ffff:ffff:ffff:ffff:ffff,IR
+2a06:d240::,2a06:d247:ffff:ffff:ffff:ffff:ffff:ffff,HU
+2a06:d280::,2a06:d287:ffff:ffff:ffff:ffff:ffff:ffff,UA
+2a06:d2c0::,2a06:d2c7:ffff:ffff:ffff:ffff:ffff:ffff,NO
+2a06:d300::,2a06:d307:ffff:ffff:ffff:ffff:ffff:ffff,SY
+2a06:d340::,2a06:d347:ffff:ffff:ffff:ffff:ffff:ffff,DE
+2a06:d380::,2a06:d387:ffff:ffff:ffff:ffff:ffff:ffff,DK
+2a06:d3c0::,2a06:d3c7:ffff:ffff:ffff:ffff:ffff:ffff,NO
+2a06:d400::,2a06:d407:ffff:ffff:ffff:ffff:ffff:ffff,IR
+2a06:d440::,2a06:d447:ffff:ffff:ffff:ffff:ffff:ffff,IT
+2a06:d480::,2a06:d487:ffff:ffff:ffff:ffff:ffff:ffff,DK
+2a06:d4c0::,2a06:d4c7:ffff:ffff:ffff:ffff:ffff:ffff,GB
+2a06:d500::,2a06:d507:ffff:ffff:ffff:ffff:ffff:ffff,AT
+2a06:d540::,2a06:d547:ffff:ffff:ffff:ffff:ffff:ffff,CZ
+2a06:d580::,2a06:d587:ffff:ffff:ffff:ffff:ffff:ffff,CH
+2a06:d5c0::,2a06:d5c7:ffff:ffff:ffff:ffff:ffff:ffff,GB
+2a06:d600::,2a06:d607:ffff:ffff:ffff:ffff:ffff:ffff,ES
+2a06:d640::,2a06:d647:ffff:ffff:ffff:ffff:ffff:ffff,RU
+2a06:d680::,2a06:d687:ffff:ffff:ffff:ffff:ffff:ffff,DE
+2a06:d6c0::,2a06:d6c7:ffff:ffff:ffff:ffff:ffff:ffff,LT
+2a06:d700::,2a06:d707:ffff:ffff:ffff:ffff:ffff:ffff,IS
+2a06:d740::,2a06:d747:ffff:ffff:ffff:ffff:ffff:ffff,FR
+2a06:d780::,2a06:d787:ffff:ffff:ffff:ffff:ffff:ffff,PL
+2a06:d7c0::,2a06:d7c7:ffff:ffff:ffff:ffff:ffff:ffff,IQ
+2a06:d800::,2a06:d807:ffff:ffff:ffff:ffff:ffff:ffff,UA
+2a06:d840::,2a06:d847:ffff:ffff:ffff:ffff:ffff:ffff,IQ
+2a06:d880::,2a06:d887:ffff:ffff:ffff:ffff:ffff:ffff,FI
+2a06:d8c0::,2a06:d8c7:ffff:ffff:ffff:ffff:ffff:ffff,NO
+2a06:d900::,2a06:d907:ffff:ffff:ffff:ffff:ffff:ffff,RU
+2a06:d940::,2a06:d947:ffff:ffff:ffff:ffff:ffff:ffff,IR
+2a06:d980::,2a06:d987:ffff:ffff:ffff:ffff:ffff:ffff,IQ
+2a06:d9c0::,2a06:d9c7:ffff:ffff:ffff:ffff:ffff:ffff,CH
+2a06:da00::,2a06:da07:ffff:ffff:ffff:ffff:ffff:ffff,ES
+2a06:da40::,2a06:da47:ffff:ffff:ffff:ffff:ffff:ffff,ES
+2a06:da80::,2a06:da87:ffff:ffff:ffff:ffff:ffff:ffff,LT
+2a06:dac0::,2a06:dac7:ffff:ffff:ffff:ffff:ffff:ffff,GB
+2a06:db00::,2a06:db07:ffff:ffff:ffff:ffff:ffff:ffff,DK
+2a06:db40::,2a06:db47:ffff:ffff:ffff:ffff:ffff:ffff,GB
+2a06:db80::,2a06:db87:ffff:ffff:ffff:ffff:ffff:ffff,IR
+2a06:dbc0::,2a06:dbc7:ffff:ffff:ffff:ffff:ffff:ffff,SK
+2a06:dc00::,2a06:dc07:ffff:ffff:ffff:ffff:ffff:ffff,NL
+2a06:dc40::,2a06:dc47:ffff:ffff:ffff:ffff:ffff:ffff,RU
+2a06:dc80::,2a06:dc87:ffff:ffff:ffff:ffff:ffff:ffff,FR
+2a06:dcc0::,2a06:dcc7:ffff:ffff:ffff:ffff:ffff:ffff,NO
+2a06:dd00::,2a06:dd07:ffff:ffff:ffff:ffff:ffff:ffff,RU
+2a06:dd40::,2a06:dd47:ffff:ffff:ffff:ffff:ffff:ffff,GB
+2a06:dd80::,2a06:dd87:ffff:ffff:ffff:ffff:ffff:ffff,FR
+2a06:ddc0::,2a06:ddc7:ffff:ffff:ffff:ffff:ffff:ffff,RU
+2a06:de00::,2a06:de07:ffff:ffff:ffff:ffff:ffff:ffff,GB
+2a06:de40::,2a06:de47:ffff:ffff:ffff:ffff:ffff:ffff,IT
+2a06:de80::,2a06:de87:ffff:ffff:ffff:ffff:ffff:ffff,FR
+2a06:dec0::,2a06:dec7:ffff:ffff:ffff:ffff:ffff:ffff,PL
+2a06:df00::,2a06:df07:ffff:ffff:ffff:ffff:ffff:ffff,IT
+2a06:df40::,2a06:df47:ffff:ffff:ffff:ffff:ffff:ffff,TR
+2a06:df80::,2a06:df87:ffff:ffff:ffff:ffff:ffff:ffff,BG
+2a06:dfc0::,2a06:dfc7:ffff:ffff:ffff:ffff:ffff:ffff,LT
+2a06:e000::,2a06:e007:ffff:ffff:ffff:ffff:ffff:ffff,RO
+2a06:e040::,2a06:e047:ffff:ffff:ffff:ffff:ffff:ffff,FR
+2a06:e080::,2a06:e087:ffff:ffff:ffff:ffff:ffff:ffff,IR
+2a06:e0c0::,2a06:e0c7:ffff:ffff:ffff:ffff:ffff:ffff,RU
+2a06:e100::,2a06:e107:ffff:ffff:ffff:ffff:ffff:ffff,GB
+2a06:e140::,2a06:e147:ffff:ffff:ffff:ffff:ffff:ffff,ES
+2a06:e180::,2a06:e187:ffff:ffff:ffff:ffff:ffff:ffff,CZ
+2a06:e1c0::,2a06:e1c7:ffff:ffff:ffff:ffff:ffff:ffff,FR
+2a06:e200::,2a06:e207:ffff:ffff:ffff:ffff:ffff:ffff,RU
+2a06:e240::,2a06:e247:ffff:ffff:ffff:ffff:ffff:ffff,ES
+2a06:e280::,2a06:e287:ffff:ffff:ffff:ffff:ffff:ffff,GB
+2a06:e2c0::,2a06:e2c7:ffff:ffff:ffff:ffff:ffff:ffff,ES
+2a06:e300::,2a06:e307:ffff:ffff:ffff:ffff:ffff:ffff,IL
+2a06:e340::,2a06:e347:ffff:ffff:ffff:ffff:ffff:ffff,ME
+2a06:e380::,2a06:e387:ffff:ffff:ffff:ffff:ffff:ffff,DE
+2a06:e3c0::,2a06:e3c7:ffff:ffff:ffff:ffff:ffff:ffff,CZ
+2a06:e400::,2a06:e407:ffff:ffff:ffff:ffff:ffff:ffff,DE
+2a06:e440::,2a06:e447:ffff:ffff:ffff:ffff:ffff:ffff,KW
+2a06:e480::,2a06:e487:ffff:ffff:ffff:ffff:ffff:ffff,RS
+2a06:e4c0::,2a06:e4c7:ffff:ffff:ffff:ffff:ffff:ffff,UA
+2a06:e500::,2a06:e507:ffff:ffff:ffff:ffff:ffff:ffff,SK
+2a06:e540::,2a06:e547:ffff:ffff:ffff:ffff:ffff:ffff,ES
+2a06:e580::,2a06:e587:ffff:ffff:ffff:ffff:ffff:ffff,IT
+2a06:e5c0::,2a06:e5c7:ffff:ffff:ffff:ffff:ffff:ffff,RS
+2a06:e600::,2a06:e607:ffff:ffff:ffff:ffff:ffff:ffff,RU
+2a06:e640::,2a06:e647:ffff:ffff:ffff:ffff:ffff:ffff,PT
+2a06:e680::,2a06:e687:ffff:ffff:ffff:ffff:ffff:ffff,DE
+2a06:e6c0::,2a06:e6c7:ffff:ffff:ffff:ffff:ffff:ffff,LU
+2a06:e700::,2a06:e707:ffff:ffff:ffff:ffff:ffff:ffff,DE
+2a06:e740::,2a06:e747:ffff:ffff:ffff:ffff:ffff:ffff,IR
+2a06:e780::,2a06:e787:ffff:ffff:ffff:ffff:ffff:ffff,PL
+2a06:e7c0::,2a06:e7c7:ffff:ffff:ffff:ffff:ffff:ffff,FR
+2a06:e800::,2a06:e807:ffff:ffff:ffff:ffff:ffff:ffff,DK
+2a06:e840::,2a06:e847:ffff:ffff:ffff:ffff:ffff:ffff,ES
+2a06:e880::,2a06:e887:ffff:ffff:ffff:ffff:ffff:ffff,CH
+2a06:e8c0::,2a06:e8c7:ffff:ffff:ffff:ffff:ffff:ffff,LV
+2a06:e900::,2a06:e907:ffff:ffff:ffff:ffff:ffff:ffff,HU
+2a06:e940::,2a06:e947:ffff:ffff:ffff:ffff:ffff:ffff,RU
+2a06:e980::,2a06:e987:ffff:ffff:ffff:ffff:ffff:ffff,FR
+2a06:e9c0::,2a06:e9c7:ffff:ffff:ffff:ffff:ffff:ffff,DE
+2a06:ea00::,2a06:ea07:ffff:ffff:ffff:ffff:ffff:ffff,IT
+2a06:ea40::,2a06:ea47:ffff:ffff:ffff:ffff:ffff:ffff,SE
+2a06:ea80::,2a06:ea87:ffff:ffff:ffff:ffff:ffff:ffff,DE
+2a06:eac0::,2a06:eac7:ffff:ffff:ffff:ffff:ffff:ffff,DK
+2a06:eb00::,2a06:eb07:ffff:ffff:ffff:ffff:ffff:ffff,IT
+2a06:eb40::,2a06:eb47:ffff:ffff:ffff:ffff:ffff:ffff,DE
+2a06:eb80::,2a06:eb87:ffff:ffff:ffff:ffff:ffff:ffff,LB
+2a06:ebc0::,2a06:ebc7:ffff:ffff:ffff:ffff:ffff:ffff,LU
+2a06:ec00::,2a06:ec07:ffff:ffff:ffff:ffff:ffff:ffff,DE
+2a06:ec40::,2a06:ec47:ffff:ffff:ffff:ffff:ffff:ffff,IT
+2a06:ec80::,2a06:ec87:ffff:ffff:ffff:ffff:ffff:ffff,GB
+2a06:ecc0::,2a06:ecc7:ffff:ffff:ffff:ffff:ffff:ffff,FI
+2a06:ed00::,2a06:ed07:ffff:ffff:ffff:ffff:ffff:ffff,DE
+2a06:ed40::,2a06:ed47:ffff:ffff:ffff:ffff:ffff:ffff,CZ
+2a06:ed80::,2a06:ed87:ffff:ffff:ffff:ffff:ffff:ffff,TJ
+2a06:edc0::,2a06:edc7:ffff:ffff:ffff:ffff:ffff:ffff,DE
+2a06:ee00::,2a06:ee07:ffff:ffff:ffff:ffff:ffff:ffff,GB
+2a06:ee40::,2a06:ee47:ffff:ffff:ffff:ffff:ffff:ffff,DE
+2a06:ee80::,2a06:ee87:ffff:ffff:ffff:ffff:ffff:ffff,IQ
+2a06:eec0::,2a06:eec7:ffff:ffff:ffff:ffff:ffff:ffff,NL
+2a06:ef00::,2a06:ef07:ffff:ffff:ffff:ffff:ffff:ffff,FR
+2a06:ef40::,2a06:ef47:ffff:ffff:ffff:ffff:ffff:ffff,DE
+2a06:ef80::,2a06:ef87:ffff:ffff:ffff:ffff:ffff:ffff,RU
+2a06:efc0::,2a06:efc7:ffff:ffff:ffff:ffff:ffff:ffff,BE
+2a06:f000::,2a06:f007:ffff:ffff:ffff:ffff:ffff:ffff,SK
+2a06:f040::,2a06:f047:ffff:ffff:ffff:ffff:ffff:ffff,FI
+2a06:f080::,2a06:f087:ffff:ffff:ffff:ffff:ffff:ffff,CZ
+2a06:f0c0::,2a06:f0c7:ffff:ffff:ffff:ffff:ffff:ffff,ES
+2a06:f100::,2a06:f107:ffff:ffff:ffff:ffff:ffff:ffff,IR
+2a06:f140::,2a06:f147:ffff:ffff:ffff:ffff:ffff:ffff,DE
+2a06:f180::,2a06:f187:ffff:ffff:ffff:ffff:ffff:ffff,DK
+2a06:f1c0::,2a06:f1c7:ffff:ffff:ffff:ffff:ffff:ffff,FR
+2a06:f200::,2a06:f207:ffff:ffff:ffff:ffff:ffff:ffff,PL
+2a06:f240::,2a06:f247:ffff:ffff:ffff:ffff:ffff:ffff,DK
+2a06:f280::,2a06:f287:ffff:ffff:ffff:ffff:ffff:ffff,IT
+2a06:f2c0::,2a06:f2c7:ffff:ffff:ffff:ffff:ffff:ffff,IT
+2a06:f300::,2a06:f307:ffff:ffff:ffff:ffff:ffff:ffff,GB
+2a06:f340::,2a06:f347:ffff:ffff:ffff:ffff:ffff:ffff,IT
+2a06:f380::,2a06:f387:ffff:ffff:ffff:ffff:ffff:ffff,ES
+2a06:f3c0::,2a06:f3c7:ffff:ffff:ffff:ffff:ffff:ffff,PL
+2a06:f400::,2a06:f407:ffff:ffff:ffff:ffff:ffff:ffff,RU
+2a06:f440::,2a06:f447:ffff:ffff:ffff:ffff:ffff:ffff,CZ
+2a06:f480::,2a06:f487:ffff:ffff:ffff:ffff:ffff:ffff,CH
+2a06:f4c0::,2a06:f4c7:ffff:ffff:ffff:ffff:ffff:ffff,BE
+2a06:f500::,2a06:f507:ffff:ffff:ffff:ffff:ffff:ffff,BG
+2a06:f540::,2a06:f547:ffff:ffff:ffff:ffff:ffff:ffff,CZ
+2a06:f580::,2a06:f587:ffff:ffff:ffff:ffff:ffff:ffff,RU
+2a06:f5c0::,2a06:f5c7:ffff:ffff:ffff:ffff:ffff:ffff,GB
+2a06:f600::,2a06:f607:ffff:ffff:ffff:ffff:ffff:ffff,FR
+2a06:f640::,2a06:f647:ffff:ffff:ffff:ffff:ffff:ffff,GB
+2a06:f680::,2a06:f687:ffff:ffff:ffff:ffff:ffff:ffff,HU
+2a06:f6c0::,2a06:f6c7:ffff:ffff:ffff:ffff:ffff:ffff,CZ
+2a06:f700::,2a06:f707:ffff:ffff:ffff:ffff:ffff:ffff,NL
+2a06:f740::,2a06:f747:ffff:ffff:ffff:ffff:ffff:ffff,LU
+2a06:f780::,2a06:f787:ffff:ffff:ffff:ffff:ffff:ffff,NL
+2a06:f7c0::,2a06:f7c7:ffff:ffff:ffff:ffff:ffff:ffff,TR
+2a06:f800::,2a06:f807:ffff:ffff:ffff:ffff:ffff:ffff,NO
+2a06:f840::,2a06:f847:ffff:ffff:ffff:ffff:ffff:ffff,ES
+2a06:f880::,2a06:f887:ffff:ffff:ffff:ffff:ffff:ffff,US
+2a06:f8c0::,2a06:f8c7:ffff:ffff:ffff:ffff:ffff:ffff,TR
+2a06:f900::,2a06:f907:ffff:ffff:ffff:ffff:ffff:ffff,NL
+2a06:f940::,2a06:f947:ffff:ffff:ffff:ffff:ffff:ffff,AT
+2a06:f980::,2a06:f987:ffff:ffff:ffff:ffff:ffff:ffff,IE
+2a06:f9c0::,2a06:f9c7:ffff:ffff:ffff:ffff:ffff:ffff,NL
+2a06:fa00::,2a06:fa07:ffff:ffff:ffff:ffff:ffff:ffff,RU
+2a06:fa40::,2a06:fa47:ffff:ffff:ffff:ffff:ffff:ffff,TR
+2a06:fa80::,2a06:fa87:ffff:ffff:ffff:ffff:ffff:ffff,NO
+2a06:fac0::,2a06:fac7:ffff:ffff:ffff:ffff:ffff:ffff,IT
+2a06:fb00::,2a06:fb07:ffff:ffff:ffff:ffff:ffff:ffff,BG
+2a06:fb40::,2a06:fb47:ffff:ffff:ffff:ffff:ffff:ffff,CZ
+2a06:fb80::,2a06:fb87:ffff:ffff:ffff:ffff:ffff:ffff,AT
+2a06:fbc0::,2a06:fbc7:ffff:ffff:ffff:ffff:ffff:ffff,DE
+2a06:fc00::,2a06:fc07:ffff:ffff:ffff:ffff:ffff:ffff,RU
+2a06:fc40::,2a06:fc47:ffff:ffff:ffff:ffff:ffff:ffff,DK
+2a06:fc80::,2a06:fc87:ffff:ffff:ffff:ffff:ffff:ffff,ES
+2a06:fcc0::,2a06:fcc7:ffff:ffff:ffff:ffff:ffff:ffff,PL
+2a06:fd00::,2a06:fd07:ffff:ffff:ffff:ffff:ffff:ffff,BE
 2c0e::,2c0e:fff:ffff:ffff:ffff:ffff:ffff:ffff,EG
 2c0e:2000::,2c0e:2fff:ffff:ffff:ffff:ffff:ffff:ffff,ZA
 2c0e:4000::,2c0e:40ff:ffff:ffff:ffff:ffff:ffff:ffff,ZA
@@ -24842,6 +27569,22 @@
 2c0f:f4f8::,2c0f:f4f8:ffff:ffff:ffff:ffff:ffff:ffff,ZA
 2c0f:f500::,2c0f:f500:ffff:ffff:ffff:ffff:ffff:ffff,ZA
 2c0f:f508::,2c0f:f508:ffff:ffff:ffff:ffff:ffff:ffff,ZA
+2c0f:f510::,2c0f:f510:ffff:ffff:ffff:ffff:ffff:ffff,MW
+2c0f:f518::,2c0f:f518:ffff:ffff:ffff:ffff:ffff:ffff,LY
+2c0f:f520::,2c0f:f520:ffff:ffff:ffff:ffff:ffff:ffff,NG
+2c0f:f528::,2c0f:f528:ffff:ffff:ffff:ffff:ffff:ffff,ZA
+2c0f:f530::,2c0f:f530:ffff:ffff:ffff:ffff:ffff:ffff,SC
+2c0f:f538::,2c0f:f538:ffff:ffff:ffff:ffff:ffff:ffff,TZ
+2c0f:f540::,2c0f:f540:ffff:ffff:ffff:ffff:ffff:ffff,MZ
+2c0f:f548::,2c0f:f548:ffff:ffff:ffff:ffff:ffff:ffff,KE
+2c0f:f550::,2c0f:f550:ffff:ffff:ffff:ffff:ffff:ffff,MU
+2c0f:f558::,2c0f:f558:ffff:ffff:ffff:ffff:ffff:ffff,CD
+2c0f:f560::,2c0f:f560:ffff:ffff:ffff:ffff:ffff:ffff,KM
+2c0f:f568::,2c0f:f568:ffff:ffff:ffff:ffff:ffff:ffff,CG
+2c0f:f570::,2c0f:f570:ffff:ffff:ffff:ffff:ffff:ffff,ZA
+2c0f:f578::,2c0f:f578:ffff:ffff:ffff:ffff:ffff:ffff,TG
+2c0f:f580::,2c0f:f580:ffff:ffff:ffff:ffff:ffff:ffff,KE
+2c0f:f588::,2c0f:f588:ffff:ffff:ffff:ffff:ffff:ffff,ZA
 2c0f:f600::,2c0f:f600:ffff:ffff:ffff:ffff:ffff:ffff,GN
 2c0f:f608::,2c0f:f608:ffff:ffff:ffff:ffff:ffff:ffff,RE
 2c0f:f610::,2c0f:f610:ffff:ffff:ffff:ffff:ffff:ffff,ZA
@@ -25094,7 +27837,13 @@
 2c0f:fe98::,2c0f:fe98:ffff:ffff:ffff:ffff:ffff:ffff,TZ
 2c0f:fea0::,2c0f:fea0:ffff:ffff:ffff:ffff:ffff:ffff,NG
 2c0f:fea8::,2c0f:fea8:ffff:ffff:ffff:ffff:ffff:ffff,NG
-2c0f:feb0::,2c0f:feb1:ffff:ffff:ffff:ffff:ffff:ffff,MU
+2c0f:feb0::,2c0f:feb0:16:ffff:ffff:ffff:ffff:ffff,MU
+2c0f:feb0:17::,2c0f:feb0:17:7fff:ffff:ffff:ffff:ffff,KE
+2c0f:feb0:17:8000::,2c0f:feb0:1c:ffff:ffff:ffff:ffff:ffff,MU
+2c0f:feb0:1d::,2c0f:feb0:1d:7fff:ffff:ffff:ffff:ffff,MZ
+2c0f:feb0:1d:8000::,2c0f:feb0:1e:ffff:ffff:ffff:ffff:ffff,MU
+2c0f:feb0:1f::,2c0f:feb0:1f:7fff:ffff:ffff:ffff:ffff,ZA
+2c0f:feb0:1f:8000::,2c0f:feb1:ffff:ffff:ffff:ffff:ffff:ffff,MU
 2c0f:feb8::,2c0f:feb8:ffff:ffff:ffff:ffff:ffff:ffff,ZM
 2c0f:fec0::,2c0f:fec0:ffff:ffff:ffff:ffff:ffff:ffff,UG
 2c0f:fec8::,2c0f:fec8:ffff:ffff:ffff:ffff:ffff:ffff,SD
diff --git a/src/ext/README b/src/ext/README
index 5501aba..7ce1bc3 100644
--- a/src/ext/README
+++ b/src/ext/README
@@ -65,6 +65,10 @@ ed25519/donna/*
     Andrew Moon's semi-portable ed25519-donna implementation of
     ed25519. Public domain.
 
+keccak-tiny/
+
+    David Leon Gil's portable Keccak implementation. CC0.
+
 readpassphrase.[ch]
 
     Portable readpassphrase implementation from OpenSSH portable, version
diff --git a/src/ext/csiphash.c b/src/ext/csiphash.c
index 27c5358..b60f73a 100644
--- a/src/ext/csiphash.c
+++ b/src/ext/csiphash.c
@@ -97,65 +97,48 @@
 #endif
 
 uint64_t siphash24(const void *src, unsigned long src_sz, const struct sipkey *key) {
+	const uint8_t *m = src;
 	uint64_t k0 = key->k0;
 	uint64_t k1 = key->k1;
-	uint64_t b = (uint64_t)src_sz << 56;
-#ifdef UNALIGNED_OK
-	const uint64_t *in = (uint64_t*)src;
-#else
-	/* On platforms where alignment matters, if 'in' is a pointer to a
-	 * datatype that must be aligned, the compiler is allowed to
-	 * generate code that assumes that it is aligned as such.
-	 */
-	const uint8_t *in = (uint8_t *)src;
-#endif
-
-	uint64_t t;
-	uint8_t *pt, *m;
+	uint64_t last7 = (uint64_t)(src_sz & 0xff) << 56;
+	size_t i, blocks;
 
 	uint64_t v0 = k0 ^ 0x736f6d6570736575ULL;
 	uint64_t v1 = k1 ^ 0x646f72616e646f6dULL;
 	uint64_t v2 = k0 ^ 0x6c7967656e657261ULL;
 	uint64_t v3 = k1 ^ 0x7465646279746573ULL;
 
-	while (src_sz >= 8) {
+	for (i = 0, blocks = (src_sz & ~7); i < blocks; i+= 8) {
 #ifdef UNALIGNED_OK
-		uint64_t mi = _le64toh(*in);
-		in += 1;
+		uint64_t mi = _le64toh(*(m + i));
 #else
 		uint64_t mi;
-		memcpy(&mi, in, 8);
+		memcpy(&mi, m + i, 8);
 		mi = _le64toh(mi);
-		in += 8;
 #endif
-		src_sz -= 8;
 		v3 ^= mi;
 		DOUBLE_ROUND(v0,v1,v2,v3);
 		v0 ^= mi;
 	}
 
-	t = 0; pt = (uint8_t*)&t; m = (uint8_t*)in;
-	switch (src_sz) {
-	case 7: pt[6] = m[6];
-	case 6: pt[5] = m[5];
-	case 5: pt[4] = m[4];
-#ifdef UNALIGNED_OK
-	case 4: *((uint32_t*)&pt[0]) = *((uint32_t*)&m[0]); break;
-#else
-	case 4: pt[3] = m[3];
-#endif
-	case 3: pt[2] = m[2];
-	case 2: pt[1] = m[1];
-	case 1: pt[0] = m[0];
+	switch (src_sz - blocks) {
+		case 7: last7 |= (uint64_t)m[i + 6] << 48;
+		case 6: last7 |= (uint64_t)m[i + 5] << 40;
+		case 5: last7 |= (uint64_t)m[i + 4] << 32;
+		case 4: last7 |= (uint64_t)m[i + 3] << 24;
+		case 3: last7 |= (uint64_t)m[i + 2] << 16;
+		case 2: last7 |= (uint64_t)m[i + 1] <<  8;
+		case 1: last7 |= (uint64_t)m[i + 0]      ;
+		case 0:
+		default:;
 	}
-	b |= _le64toh(t);
-
-	v3 ^= b;
+	v3 ^= last7;
 	DOUBLE_ROUND(v0,v1,v2,v3);
-	v0 ^= b; v2 ^= 0xff;
+	v0 ^= last7;
+	v2 ^= 0xff;
 	DOUBLE_ROUND(v0,v1,v2,v3);
 	DOUBLE_ROUND(v0,v1,v2,v3);
-	return (v0 ^ v1) ^ (v2 ^ v3);
+	return v0 ^ v1 ^ v2 ^ v3;
 }
 
 
diff --git a/src/ext/ed25519/donna/ed25519_tor.c b/src/ext/ed25519/donna/ed25519_tor.c
index 12493f7..ac726ba 100644
--- a/src/ext/ed25519/donna/ed25519_tor.c
+++ b/src/ext/ed25519/donna/ed25519_tor.c
@@ -148,8 +148,7 @@ ed25519_donna_seckey(unsigned char *sk)
 {
   ed25519_secret_key seed;
 
-  if (crypto_strongest_rand(seed, 32))
-    return -1;
+  crypto_strongest_rand(seed, 32);
 
   ed25519_extsk(sk, seed);
 
diff --git a/src/ext/ed25519/ref10/randombytes.h b/src/ext/ed25519/ref10/randombytes.h
index fc709fc..8bf3163 100644
--- a/src/ext/ed25519/ref10/randombytes.h
+++ b/src/ext/ed25519/ref10/randombytes.h
@@ -1,4 +1,4 @@
 /* Added for Tor. */
 #include "crypto.h"
 #define randombytes(b, n) \
-  (crypto_strongest_rand((b), (n)))
+  (crypto_strongest_rand((b), (n)), 0)
diff --git a/src/ext/eventdns.c b/src/ext/eventdns.c
index a0c7ff2..37d8a7a 100644
--- a/src/ext/eventdns.c
+++ b/src/ext/eventdns.c
@@ -805,7 +805,7 @@ reply_handle(struct evdns_request *const req, u16 flags, u32 ttl, struct reply *
 	}
 }
 
-static INLINE int
+static inline int
 name_parse(u8 *packet, int length, int *idx, char *name_out, size_t name_out_len) {
 	int name_end = -1;
 	int j = *idx;
diff --git a/src/ext/ht.h b/src/ext/ht.h
index 19a67a6..28d1fe4 100644
--- a/src/ext/ht.h
+++ b/src/ext/ht.h
@@ -61,7 +61,7 @@
 #define HT_INIT(name, head)          name##_HT_INIT(head)
 #define HT_REP_IS_BAD_(name, head)    name##_HT_REP_IS_BAD_(head)
 /* Helper: */
-static INLINE unsigned
+static inline unsigned
 ht_improve_hash(unsigned h)
 {
   /* Aim to protect against poor hash functions by adding logic here
@@ -75,7 +75,7 @@ ht_improve_hash(unsigned h)
 
 #if 0
 /** Basic string hash function, from Java standard String.hashCode(). */
-static INLINE unsigned
+static inline unsigned
 ht_string_hash(const char *s)
 {
   unsigned h = 0;
@@ -90,7 +90,7 @@ ht_string_hash(const char *s)
 
 #if 0
 /** Basic string hash function, from Python's str.__hash__() */
-static INLINE unsigned
+static inline unsigned
 ht_string_hash(const char *s)
 {
   unsigned h;
@@ -143,7 +143,7 @@ ht_string_hash(const char *s)
   int name##_HT_GROW(struct name *ht, unsigned min_capacity);           \
   void name##_HT_CLEAR(struct name *ht);                                \
   int name##_HT_REP_IS_BAD_(const struct name *ht);                     \
-  static INLINE void                                                    \
+  static inline void                                                    \
   name##_HT_INIT(struct name *head) {                                   \
     head->hth_table_length = 0;                                         \
     head->hth_table = NULL;                                             \
@@ -153,7 +153,7 @@ ht_string_hash(const char *s)
   }                                                                     \
   /* Helper: returns a pointer to the right location in the table       \
    * 'head' to find or insert the element 'elm'. */                     \
-  static INLINE struct type **                                          \
+  static inline struct type **                                          \
   name##_HT_FIND_P_(struct name *head, struct type *elm)                \
   {                                                                     \
     struct type **p;                                                    \
@@ -169,7 +169,7 @@ ht_string_hash(const char *s)
   }                                                                     \
   /* Return a pointer to the element in the table 'head' matching 'elm', \
    * or NULL if no such element exists */                               \
-  ATTR_UNUSED static INLINE struct type *                               \
+  ATTR_UNUSED static inline struct type *                               \
   name##_HT_FIND(const struct name *head, struct type *elm)             \
   {                                                                     \
     struct type **p;                                                    \
@@ -180,7 +180,7 @@ ht_string_hash(const char *s)
   }                                                                     \
   /* Insert the element 'elm' into the table 'head'.  Do not call this  \
    * function if the table might already contain a matching element. */ \
-  ATTR_UNUSED static INLINE void                                        \
+  ATTR_UNUSED static inline void                                        \
   name##_HT_INSERT(struct name *head, struct type *elm)                 \
   {                                                                     \
     struct type **p;                                                    \
@@ -195,7 +195,7 @@ ht_string_hash(const char *s)
   /* Insert the element 'elm' into the table 'head'. If there already   \
    * a matching element in the table, replace that element and return   \
    * it. */                                                             \
-  ATTR_UNUSED static INLINE struct type *                               \
+  ATTR_UNUSED static inline struct type *                               \
   name##_HT_REPLACE(struct name *head, struct type *elm)                \
   {                                                                     \
     struct type **p, *r;                                                \
@@ -216,7 +216,7 @@ ht_string_hash(const char *s)
   }                                                                     \
   /* Remove any element matching 'elm' from the table 'head'.  If such  \
    * an element is found, return it; otherwise return NULL. */          \
-  ATTR_UNUSED static INLINE struct type *                               \
+  ATTR_UNUSED static inline struct type *                               \
   name##_HT_REMOVE(struct name *head, struct type *elm)                 \
   {                                                                     \
     struct type **p, *r;                                                \
@@ -234,7 +234,7 @@ ht_string_hash(const char *s)
    * using 'data' as its second argument.  If the function returns      \
    * nonzero, remove the most recently examined element before invoking \
    * the function again. */                                             \
-  ATTR_UNUSED static INLINE void                                        \
+  ATTR_UNUSED static inline void                                        \
   name##_HT_FOREACH_FN(struct name *head,                               \
                        int (*fn)(struct type *, void *),                \
                        void *data)                                      \
@@ -260,7 +260,7 @@ ht_string_hash(const char *s)
   /* Return a pointer to the first element in the table 'head', under   \
    * an arbitrary order.  This order is stable under remove operations, \
    * but not under others. If the table is empty, return NULL. */       \
-  ATTR_UNUSED static INLINE struct type **                              \
+  ATTR_UNUSED static inline struct type **                              \
   name##_HT_START(struct name *head)                                    \
   {                                                                     \
     unsigned b = 0;                                                     \
@@ -279,7 +279,7 @@ ht_string_hash(const char *s)
    * NULL.  If 'elm' is to be removed from the table, you must call     \
    * this function for the next value before you remove it.             \
    */                                                                   \
-  ATTR_UNUSED static INLINE struct type **                              \
+  ATTR_UNUSED static inline struct type **                              \
   name##_HT_NEXT(struct name *head, struct type **elm)                  \
   {                                                                     \
     if ((*elm)->field.hte_next) {                                       \
@@ -299,7 +299,7 @@ ht_string_hash(const char *s)
       return NULL;                                                      \
     }                                                                   \
   }                                                                     \
-  ATTR_UNUSED static INLINE struct type **                              \
+  ATTR_UNUSED static inline struct type **                              \
   name##_HT_NEXT_RMV(struct name *head, struct type **elm)              \
   {                                                                     \
     unsigned h = HT_ELT_HASH_(*elm, field, hashfn);                     \
diff --git a/src/ext/include.am b/src/ext/include.am
index 47d4c03..bf678f2 100644
--- a/src/ext/include.am
+++ b/src/ext/include.am
@@ -135,3 +135,16 @@ noinst_HEADERS += $(ED25519_DONNA_HDRS)
 LIBED25519_DONNA=src/ext/ed25519/donna/libed25519_donna.a
 noinst_LIBRARIES += $(LIBED25519_DONNA)
 
+src_ext_keccak_tiny_libkeccak_tiny_a_CFLAGS=
+
+src_ext_keccak_tiny_libkeccak_tiny_a_SOURCES= \
+	src/ext/keccak-tiny/keccak-tiny-unrolled.c
+
+LIBKECCAK_TINY_HDRS = \
+	src/ext/keccak-tiny/keccak-tiny.h
+
+noinst_HEADERS += $(LIBKECCAK_TINY_HDRS)
+
+LIBKECCAK_TINY=src/ext/keccak-tiny/libkeccak-tiny.a
+noinst_LIBRARIES += $(LIBKECCAK_TINY)
+
diff --git a/src/ext/keccak-tiny/README.markdown b/src/ext/keccak-tiny/README.markdown
new file mode 100644
index 0000000..784d6f6
--- /dev/null
+++ b/src/ext/keccak-tiny/README.markdown
@@ -0,0 +1,82 @@
+# libkeccak-tiny
+
+An implementation of the FIPS-202-defined SHA-3 and SHAKE functions
+in 120 cloc (156 lines). One C file, one header.
+
+The `Keccak-f[1600]` permutation is fully unrolled; it's nearly as fast
+as the Keccak team's optimized permutation.
+
+## Building
+
+    > clang -O3 -march=native -std=c11 -Wextra -dynamic -shared keccak-tiny.c -o libkeccak-tiny.dylib
+
+If you don't have a modern libc that includes the `memset_s` function,
+you can just add `-D"memset_s(W,WL,V,OL)=memset(W,V,OL)` to the command
+line.
+
+## Using
+
+Build the library, include the header, and do, e.g.,
+
+    shake256(out, 256, in, inlen);
+
+That's it.
+
+(Note: You can request less output from the fixed-output-length
+functions, but not more.)
+
+## TweetShake
+
+The relevant tweets:
+
+```C
+// @hashbreaker Inspired by TweetNaCl!
+// Keccak and SHA-3 are supposedly hard to implement. So, how many tweets does it take to get to the center of a sponge...?
+#define decshake(bits) int shake##bits(unsigned char* o, unsigned long, unsigned char*, unsigned long);                   /*begin keccak.h*/
+#define decsha3(bits) int sha3_##bits(unsigned char*,unsigned long,unsigned char*,unsigned long);
+decshake(128) decshake(256) decsha3(224) decsha3(256) decsha3(384) decsha3(512)                                             /*end keccak.h*/
+#define K static const /* Keccak constants: rho rotations, pi lanes, and iota RCs */                                      /*begin keccak.c*/
+typedef unsigned char byte;typedef byte*bytes;typedef unsigned long z;typedef unsigned long long u8;K u8 V=1ULL<<63;K u8 W=1ULL<<31;/*!gcc*/
+#define V (1ULL<<63)
+#define W (1ULL<31)
+K byte rho[24]={1,3,6,10,15,21,28,36,45,55,2,14,27,41,56,8,25,43,62,18,39,61,20,44};K u8 RC[24]={1,0x8082,V|0x808a,V|W|0x8000,0x808b,W|1,V|W
+|0x8081,V|0x8009,138,136,W|0x8009,W|10,W|0x808b,V|0x8b,V|0x8089,V|0x8003,V|0x8002,V|0x80,0x800a,V|W|0xa,V|W|0x8081,V|0x8080,W|1,V|W|0x8008};
+K byte pi[25]={10,7,11,17,18,3,5,16,8,21,24,4,15,23,19,13,12,2,20,14,22,9,6,1}; /**helpers:*/static inline z min(z a,z b){return (a<b)?a:b;}
+#define ROL(x, s) /* rotary shift */ (((x) << s) | ((x) >> (64-s)))              /**macros to fully unroll the Keccak-f[1600] permutation:*/
+#define R24(e) /* repeat 24 times */ e e e e e e e e e e e e e e e e e e e e e e e e
+#define L5(v,s,e) /* 5-unroll a loop */ v=0; e; v+=s; e; v+=s; e; v+=s; e; v+=s; e; v+=s;                              /**the permutation:*/
+static inline void keccakf(u8* a){u8 b[5]={0};u8 t=0;byte x,y,i=0; /*24 rounds:*/R24( L5(x,1,b[x]=0;L5(y,5, /*parity*/ b[x] ^= a[x+y]))
+L5(x,1,L5(y,5,/*theta*/a[y+x] ^= b[(x+4)%5] ^ ROL(b[(x+1)%5],1))) t=a[1];x=0;R24(b[0]=a[pi[x]];/*rho*/a[pi[x]]=ROL(t, rho[x]);t=b[0];x++;)
+L5(y,5,L5(x,1, /*chi*/ b[x] = a[y+x]) L5(x,1, a[y+x] = b[x] ^ ~b[(x+1)%5] & b[(x+2)%5])) /*iota*/ a[0] ^= RC[i]; i++; )}     /**keccak-f!**/
+#define FOR(i, ST, L, S) /*obvious*/ do { for (z i = 0; i < L; i += ST) { S; } } while (0)   /**now, the sponge construction in hash mode**/
+#define appl(NAME, S) /*macro to define array comprehensions*/ static inline void NAME(bytes dst, bytes src, z len) { FOR(i, 1, len, S); }
+/*helpers:*/ static inline void clear(bytes a) { FOR(i,1,200,a[i]=0); } appl(xorin, dst[i] ^= src[i])  appl(set, src[i] = dst[i])
+#define foldP(I, L, F) /* macro to fold app P F */ while (L >= r) { /*apply F*/ F(a, I, r); /*permute*/ keccakf(A); I += r; L -= r; }
+static inline int hash(bytes o,z olen,bytes in,z ilen,z r,byte D){ if((o == (void*)0)||((in == (void*)0)&&ilen != 0)||(r >= 200))return -1;
+/*absorb*/u8 A[25]={0};bytes a=(bytes)A;/*full blocks*/foldP(in,ilen,xorin);/*last block*/xorin(a,in,ilen);/**ds+padstart*/a[ilen]^=D;
+/*padend:*/a[r-1]^=0x80; /**permute**/keccakf(A); /**squeeze:**/foldP(o,olen,set);/*last bytes*/set(a,o,olen);/*done!*/clear(a);return 0;}
+#define defshake(bits) int shake##bits(bytes o, z olen, bytes in, z ilen) {return hash(o,olen,in,ilen,200-(bits/4),0x1f);}
+#define defsha3(bits) int sha3_##bits(bytes o,z olen,bytes in,z ilen) {return hash(o,min(olen,200-(bits/4)),in,ilen,200-(bits/4),0x06);}
+/*define the SHA3 and SHAKE instances:*/defshake(128) defshake(256) defsha3(224) defsha3(256) defsha3(384) defsha3(512)/*end keccak.c*/
+// ...chomp. 24 kinda legible tweets (3232 bytes). And a simple interface: shake256(digest, digestlen, in, inlen)
+// Clang recommended. GCC users will need to insert "#define V (1ULL<<63)" and "#define W (1ULL<31)" at the point marked "/*!gcc*/"
+// If you're using as a prefix MAC, you MUST replace the body of "clear" with "memset_s(a, 200, 0, 200)" to avoid misoptimization.
+// @everyone_who_is_still_using_sha1 Please stop using SHA-1.
+// Oh, one more thing: a C11-threaded, memmapped shake256sum in 10 tweets. (Your libc may need a shim for C11 thread support.)
+// echo -n string stdio stdint fcntl sys/mman sys/stat sys/types unistd threads|tr ' ' \\n|xargs -n1 -I_ echo '#include <_.h>'
+#include "kcksum_tweet.h"
+#define E(LABEL, MSG) if (err != 0) { strerror_r(err, serr, 1024); fprintf(stderr, "%s: '%s' %s\n", serr, fn, MSG); goto LABEL;}
+static mtx_t iomtx;void h(void* v);void h(void* v){char* fn=(char*)v;int err=0;char serr[1024]={0};/*open file*/int fd=open(fn, O_RDONLY);
+err=!fd;E(ret,"couldn't be opened.");/*stat it*/struct stat stat;err=fstat(fd,&stat);E(close,"doesn't exist.");err=!!(stat.st_mode&S_IFDIR);
+E(close,"not a regular file.");z length=(size_t)stat.st_size;/*mmap the file*/bytes in=length?mmap(0,length,PROT_READ,MAP_SHARED,fd,0):NULL;
+if(length&&(in==MAP_FAILED)){E(close,"mmap-ing failed.");}byte out[64]={0};/*hash it*/shake256(out,64,in,length);length&&munmap(in,length);
+/*lock io*/mtx_lock(&iomtx);printf("SHAKE256('%s') = ", fn);FOR(i,1,64,printf("%02x",out[i]));printf("\n");mtx_unlock(&iomtx);/*unlock io*/
+close:close(fd);ret:thrd_exit(err);}int main(int argc,char** argv){int err=0; mtx_init(&iomtx, mtx_plain); thrd_t t[4]; int res[4],i,j,k;
+for(i=1;i<argc;i+=4){for(j=0;j<4;j++){if((j+i)==argc){/*out of files*/goto join;} /*spawn*/ thrd_create(t + j,h,argv[i + j]);}
+join: for (k = 0; k < j; k++) { /*wait*/ err |= thrd_join(t[k], res + k); err |= res[k];} } mtx_destroy(&iomtx); return err; } /* done! */
+```
+
+
+## License
+
+[CC0](http://creativecommons.org/publicdomain/zero/1.0/)
diff --git a/src/ext/keccak-tiny/do.sh b/src/ext/keccak-tiny/do.sh
new file mode 100644
index 0000000..cf99f24
--- /dev/null
+++ b/src/ext/keccak-tiny/do.sh
@@ -0,0 +1,5 @@
+#!/usr/bin/env sh
+cc=$(which clang-3.6||which gcc-4.9||which clang||||which gcc)
+so=$(test -f /etc/asl.conf && printf dylib|| printf so)
+$cc "-Dinline=__attribute__((__always_inline__))" -O3 -march=native -std=c11 -Wextra -Wpedantic -Wall -dynamic -shared keccak-tiny.c -o libkeccak-tiny.$so
+$cc -Os -march=native -std=c11 -Wextra -Wpedantic -Wall -dynamic -shared keccak-tiny.c -o libkeccak-tiny-small.$so
diff --git a/src/ext/keccak-tiny/keccak-tiny-unrolled.c b/src/ext/keccak-tiny/keccak-tiny-unrolled.c
new file mode 100644
index 0000000..4b4f51c
--- /dev/null
+++ b/src/ext/keccak-tiny/keccak-tiny-unrolled.c
@@ -0,0 +1,368 @@
+/** libkeccak-tiny
+ *
+ * A single-file implementation of SHA-3 and SHAKE.
+ *
+ * Implementor: David Leon Gil
+ * License: CC0, attribution kindly requested. Blame taken too,
+ * but not liability.
+ */
+#include "keccak-tiny.h"
+
+#include <string.h>
+#include "crypto.h"
+
+/******** The Keccak-f[1600] permutation ********/
+
+/*** Constants. ***/
+static const uint8_t rho[24] = \
+  { 1,  3,   6, 10, 15, 21,
+    28, 36, 45, 55,  2, 14,
+    27, 41, 56,  8, 25, 43,
+    62, 18, 39, 61, 20, 44};
+static const uint8_t pi[24] = \
+  {10,  7, 11, 17, 18, 3,
+    5, 16,  8, 21, 24, 4,
+   15, 23, 19, 13, 12, 2,
+   20, 14, 22,  9, 6,  1};
+static const uint64_t RC[24] = \
+  {1ULL, 0x8082ULL, 0x800000000000808aULL, 0x8000000080008000ULL,
+   0x808bULL, 0x80000001ULL, 0x8000000080008081ULL, 0x8000000000008009ULL,
+   0x8aULL, 0x88ULL, 0x80008009ULL, 0x8000000aULL,
+   0x8000808bULL, 0x800000000000008bULL, 0x8000000000008089ULL, 0x8000000000008003ULL,
+   0x8000000000008002ULL, 0x8000000000000080ULL, 0x800aULL, 0x800000008000000aULL,
+   0x8000000080008081ULL, 0x8000000000008080ULL, 0x80000001ULL, 0x8000000080008008ULL};
+
+/*** Helper macros to unroll the permutation. ***/
+#define rol(x, s) (((x) << s) | ((x) >> (64 - s)))
+#define REPEAT6(e) e e e e e e
+#define REPEAT24(e) REPEAT6(e e e e)
+#define REPEAT5(e) e e e e e
+#define FOR5(v, s, e) \
+  v = 0;            \
+  REPEAT5(e; v += s;)
+
+/*** Keccak-f[1600] ***/
+static inline void keccakf(void* state) {
+  uint64_t* a = (uint64_t*)state;
+  uint64_t b[5] = {0};
+  uint64_t t = 0;
+  uint8_t x, y, i = 0;
+
+  REPEAT24(
+      // Theta
+      FOR5(x, 1,
+           b[x] = 0;
+           FOR5(y, 5,
+                b[x] ^= a[x + y]; ))
+      FOR5(x, 1,
+           FOR5(y, 5,
+                a[y + x] ^= b[(x + 4) % 5] ^ rol(b[(x + 1) % 5], 1); ))
+      // Rho and pi
+      t = a[1];
+      x = 0;
+      REPEAT24(b[0] = a[pi[x]];
+               a[pi[x]] = rol(t, rho[x]);
+               t = b[0];
+               x++; )
+      // Chi
+      FOR5(y,
+         5,
+         FOR5(x, 1,
+              b[x] = a[y + x];)
+         FOR5(x, 1,
+              a[y + x] = b[x] ^ ((~b[(x + 1) % 5]) & b[(x + 2) % 5]); ))
+      // Iota
+      a[0] ^= RC[i];
+      i++; )
+}
+
+/******** The FIPS202-defined functions. ********/
+
+/*** Some helper macros. ***/
+
+#define _(S) do { S } while (0)
+#define FOR(i, ST, L, S) \
+  _(for (size_t i = 0; i < L; i += ST) { S; })
+#define mkapply_ds(NAME, S)                                          \
+  static inline void NAME(uint8_t* dst,                              \
+                          const uint8_t* src,                        \
+                          size_t len) {                              \
+    FOR(i, 1, len, S);                                               \
+  }
+#define mkapply_sd(NAME, S)                                          \
+  static inline void NAME(const uint8_t* src,                        \
+                          uint8_t* dst,                              \
+                          size_t len) {                              \
+    FOR(i, 1, len, S);                                               \
+  }
+
+mkapply_ds(xorin, dst[i] ^= src[i])  // xorin
+mkapply_sd(setout, dst[i] = src[i])  // setout
+
+#define P keccakf
+#define Plen KECCAK_MAX_RATE
+
+#define KECCAK_DELIM_DIGEST 0x06
+#define KECCAK_DELIM_XOF 0x1f
+
+// Fold P*F over the full blocks of an input.
+#define foldP(I, L, F) \
+  while (L >= s->rate) {  \
+    F(s->a, I, s->rate);  \
+    P(s->a);              \
+    I += s->rate;         \
+    L -= s->rate;         \
+  }
+
+static inline void
+keccak_absorb_blocks(keccak_state *s, const uint8_t *buf, size_t nr_blocks)
+{
+  size_t blen = nr_blocks * s->rate;
+  foldP(buf, blen, xorin);
+}
+
+static int
+keccak_update(keccak_state *s, const uint8_t *buf, size_t len)
+{
+  if (s->finalized)
+    return -1;
+  if ((buf == NULL) && len != 0)
+    return -1;
+
+  size_t remaining = len;
+  while (remaining > 0) {
+    if (s->offset == 0) {
+      const size_t blocks = remaining / s->rate;
+      size_t direct_bytes = blocks * s->rate;
+      if (direct_bytes > 0) {
+        keccak_absorb_blocks(s, buf, blocks);
+        remaining -= direct_bytes;
+        buf += direct_bytes;
+      }
+    }
+
+    const size_t buf_avail = s->rate - s->offset;
+    const size_t buf_bytes = (buf_avail > remaining) ? remaining : buf_avail;
+    if (buf_bytes > 0) {
+      memcpy(&s->block[s->offset], buf, buf_bytes);
+      s->offset += buf_bytes;
+      remaining -= buf_bytes;
+      buf += buf_bytes;
+    }
+    if (s->offset == s->rate) {
+      keccak_absorb_blocks(s, s->block, 1);
+      s->offset = 0;
+    }
+  }
+  return 0;
+}
+
+static void
+keccak_finalize(keccak_state *s)
+{
+  // Xor in the DS and pad frame.
+  s->a[s->offset] ^= s->delim;
+  s->a[s->rate - 1] ^= 0x80;
+  // Xor in the last block.
+  xorin(s->a, s->block, s->offset);
+
+  memwipe(s->block, 0, sizeof(s->block));
+  s->finalized = 1;
+  s->offset = s->rate;
+}
+
+static inline void
+keccak_squeeze_blocks(keccak_state *s, uint8_t *out, size_t nr_blocks)
+{
+  for (size_t n = 0; n < nr_blocks; n++) {
+    keccakf(s->a);
+    setout(s->a, out, s->rate);
+    out += s->rate;
+  }
+}
+
+static int
+keccak_squeeze(keccak_state *s, uint8_t *out, size_t outlen)
+{
+  if (!s->finalized)
+    return -1;
+
+  size_t remaining = outlen;
+  while (remaining > 0) {
+    if (s->offset == s->rate) {
+      const size_t blocks = remaining / s->rate;
+      const size_t direct_bytes = blocks * s->rate;
+      if (blocks > 0) {
+        keccak_squeeze_blocks(s, out, blocks);
+        out += direct_bytes;
+        remaining -= direct_bytes;
+      }
+
+      if (remaining > 0) {
+        keccak_squeeze_blocks(s, s->block, 1);
+        s->offset = 0;
+      }
+    }
+
+    const size_t buf_bytes = s->rate - s->offset;
+    const size_t indirect_bytes = (buf_bytes > remaining) ? remaining : buf_bytes;
+    if (indirect_bytes > 0) {
+      memcpy(out, &s->block[s->offset], indirect_bytes);
+      out += indirect_bytes;
+      s->offset += indirect_bytes;
+      remaining -= indirect_bytes;
+    }
+  }
+  return 0;
+}
+
+int
+keccak_digest_init(keccak_state *s, size_t bits)
+{
+  if (s == NULL)
+    return -1;
+  if (bits != 224 && bits != 256 && bits != 384 && bits != 512)
+    return -1;
+
+  keccak_cleanse(s);
+  s->rate = KECCAK_RATE(bits);
+  s->delim = KECCAK_DELIM_DIGEST;
+  return 0;
+}
+
+int
+keccak_digest_update(keccak_state *s, const uint8_t *buf, size_t len)
+{
+  if (s == NULL)
+    return -1;
+  if (s->delim != KECCAK_DELIM_DIGEST)
+    return -1;
+
+  return keccak_update(s, buf, len);
+}
+
+int
+keccak_digest_sum(const keccak_state *s, uint8_t *out, size_t outlen)
+{
+  if (s == NULL)
+    return -1;
+  if (s->delim != KECCAK_DELIM_DIGEST)
+    return -1;
+  if (out == NULL || outlen > 4 * (KECCAK_MAX_RATE - s->rate) / 8)
+    return -1;
+
+  // Work in a copy so that incremental/rolling hashes are easy.
+  keccak_state s_tmp;
+  keccak_clone(&s_tmp, s);
+  keccak_finalize(&s_tmp);
+  int ret = keccak_squeeze(&s_tmp, out, outlen);
+  keccak_cleanse(&s_tmp);
+  return ret;
+}
+
+int
+keccak_xof_init(keccak_state *s, size_t bits)
+{
+  if (s == NULL)
+    return -1;
+  if (bits != 128 && bits != 256)
+    return -1;
+
+  keccak_cleanse(s);
+  s->rate = KECCAK_RATE(bits);
+  s->delim = KECCAK_DELIM_XOF;
+  return 0;
+}
+
+int
+keccak_xof_absorb(keccak_state *s, const uint8_t *buf, size_t len)
+{
+  if (s == NULL)
+    return -1;
+  if (s->delim != KECCAK_DELIM_XOF)
+    return -1;
+
+  return keccak_update(s, buf, len);
+}
+
+int
+keccak_xof_squeeze(keccak_state *s, uint8_t *out, size_t outlen)
+{
+  if (s == NULL)
+    return -1;
+  if (s->delim != KECCAK_DELIM_XOF)
+    return -1;
+
+  if (!s->finalized)
+    keccak_finalize(s);
+
+  return keccak_squeeze(s, out, outlen);
+}
+
+void
+keccak_clone(keccak_state *out, const keccak_state *in)
+{
+  memcpy(out, in, sizeof(keccak_state));
+}
+
+void
+keccak_cleanse(keccak_state *s)
+{
+  memwipe(s, 0, sizeof(keccak_state));
+}
+
+/** The sponge-based hash construction. **/
+static inline int hash(uint8_t* out, size_t outlen,
+                       const uint8_t* in, size_t inlen,
+                       size_t bits, uint8_t delim) {
+  if ((out == NULL) || ((in == NULL) && inlen != 0)) {
+    return -1;
+  }
+
+  int ret = 0;
+  keccak_state s;
+
+  switch (delim) {
+    case KECCAK_DELIM_DIGEST:
+      ret |= keccak_digest_init(&s, bits);
+      ret |= keccak_digest_update(&s, in, inlen);
+      // Use the internal API instead of sum to avoid the memcpy.
+      keccak_finalize(&s);
+      ret |= keccak_squeeze(&s, out, outlen);
+      break;
+    case KECCAK_DELIM_XOF:
+      ret |= keccak_xof_init(&s, bits);
+      ret |= keccak_xof_absorb(&s, in, inlen);
+      ret |= keccak_xof_squeeze(&s, out, outlen);
+      break;
+    default:
+      return -1;
+  }
+  keccak_cleanse(&s);
+  return ret;
+}
+
+/*** Helper macros to define SHA3 and SHAKE instances. ***/
+#define defshake(bits)                                            \
+  int shake##bits(uint8_t* out, size_t outlen,                    \
+                  const uint8_t* in, size_t inlen) {              \
+    return hash(out, outlen, in, inlen, bits, KECCAK_DELIM_XOF);  \
+  }
+#define defsha3(bits)                                             \
+  int sha3_##bits(uint8_t* out, size_t outlen,                    \
+                  const uint8_t* in, size_t inlen) {              \
+    if (outlen > (bits/8)) {                                      \
+      return -1;                                                  \
+    }                                                             \
+    return hash(out, outlen, in, inlen, bits, KECCAK_DELIM_DIGEST);  \
+  }
+
+/*** FIPS202 SHAKE VOFs ***/
+defshake(128)
+defshake(256)
+
+/*** FIPS202 SHA3 FOFs ***/
+defsha3(224)
+defsha3(256)
+defsha3(384)
+defsha3(512)
diff --git a/src/ext/keccak-tiny/keccak-tiny.c b/src/ext/keccak-tiny/keccak-tiny.c
new file mode 100644
index 0000000..76d89fa
--- /dev/null
+++ b/src/ext/keccak-tiny/keccak-tiny.c
@@ -0,0 +1,163 @@
+/** libkeccak-tiny
+ *
+ * A single-file implementation of SHA-3 and SHAKE.
+ *
+ * Implementor: David Leon Gil
+ * License: CC0, attribution kindly requested. Blame taken too,
+ * but not liability.
+ */
+#include "keccak-tiny.h"
+
+#include <stdint.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+/******** The Keccak-f[1600] permutation ********/
+
+/*** Constants. ***/
+static const uint8_t rho[24] = \
+  { 1,  3,   6, 10, 15, 21,
+    28, 36, 45, 55,  2, 14,
+    27, 41, 56,  8, 25, 43,
+    62, 18, 39, 61, 20, 44};
+static const uint8_t pi[24] = \
+  {10,  7, 11, 17, 18, 3,
+    5, 16,  8, 21, 24, 4,
+   15, 23, 19, 13, 12, 2,
+   20, 14, 22,  9, 6,  1};
+static const uint64_t RC[24] = \
+  {1ULL, 0x8082ULL, 0x800000000000808aULL, 0x8000000080008000ULL,
+   0x808bULL, 0x80000001ULL, 0x8000000080008081ULL, 0x8000000000008009ULL,
+   0x8aULL, 0x88ULL, 0x80008009ULL, 0x8000000aULL,
+   0x8000808bULL, 0x800000000000008bULL, 0x8000000000008089ULL, 0x8000000000008003ULL,
+   0x8000000000008002ULL, 0x8000000000000080ULL, 0x800aULL, 0x800000008000000aULL,
+   0x8000000080008081ULL, 0x8000000000008080ULL, 0x80000001ULL, 0x8000000080008008ULL};
+
+/*** Helper macros to unroll the permutation. ***/
+#define rol(x, s) (((x) << s) | ((x) >> (64 - s)))
+#define REPEAT6(e) e e e e e e
+#define REPEAT24(e) REPEAT6(e e e e)
+#define REPEAT5(e) e e e e e
+#define FOR5(v, s, e) \
+  v = 0;            \
+  REPEAT5(e; v += s;)
+
+/*** Keccak-f[1600] ***/
+static inline void keccakf(void* state) {
+  uint64_t* a = (uint64_t*)state;
+  uint64_t b[5] = {0};
+  uint64_t t = 0;
+  uint8_t x, y;
+
+  for (int i = 0; i < 24; i++) {
+    // Theta
+    FOR5(x, 1,
+         b[x] = 0;
+         FOR5(y, 5,
+              b[x] ^= a[x + y]; ))
+    FOR5(x, 1,
+         FOR5(y, 5,
+              a[y + x] ^= b[(x + 4) % 5] ^ rol(b[(x + 1) % 5], 1); ))
+    // Rho and pi
+    t = a[1];
+    x = 0;
+    REPEAT24(b[0] = a[pi[x]];
+             a[pi[x]] = rol(t, rho[x]);
+             t = b[0];
+             x++; )
+    // Chi
+    FOR5(y,
+       5,
+       FOR5(x, 1,
+            b[x] = a[y + x];)
+       FOR5(x, 1,
+            a[y + x] = b[x] ^ ((~b[(x + 1) % 5]) & b[(x + 2) % 5]); ))
+    // Iota
+    a[0] ^= RC[i];
+  }
+}
+
+/******** The FIPS202-defined functions. ********/
+
+/*** Some helper macros. ***/
+
+#define _(S) do { S } while (0)
+#define FOR(i, ST, L, S) \
+  _(for (size_t i = 0; i < L; i += ST) { S; })
+#define mkapply_ds(NAME, S)                                          \
+  static inline void NAME(uint8_t* dst,                              \
+                          const uint8_t* src,                        \
+                          size_t len) {                              \
+    FOR(i, 1, len, S);                                               \
+  }
+#define mkapply_sd(NAME, S)                                          \
+  static inline void NAME(const uint8_t* src,                        \
+                          uint8_t* dst,                              \
+                          size_t len) {                              \
+    FOR(i, 1, len, S);                                               \
+  }
+
+mkapply_ds(xorin, dst[i] ^= src[i])  // xorin
+mkapply_sd(setout, dst[i] = src[i])  // setout
+
+#define P keccakf
+#define Plen 200
+
+// Fold P*F over the full blocks of an input.
+#define foldP(I, L, F) \
+  while (L >= rate) {  \
+    F(a, I, rate);     \
+    P(a);              \
+    I += rate;         \
+    L -= rate;         \
+  }
+
+/** The sponge-based hash construction. **/
+static inline int hash(uint8_t* out, size_t outlen,
+                       const uint8_t* in, size_t inlen,
+                       size_t rate, uint8_t delim) {
+  if ((out == NULL) || ((in == NULL) && inlen != 0) || (rate >= Plen)) {
+    return -1;
+  }
+  uint8_t a[Plen] = {0};
+  // Absorb input.
+  foldP(in, inlen, xorin);
+  // Xor in the DS and pad frame.
+  a[inlen] ^= delim;
+  a[rate - 1] ^= 0x80;
+  // Xor in the last block.
+  xorin(a, in, inlen);
+  // Apply P
+  P(a);
+  // Squeeze output.
+  foldP(out, outlen, setout);
+  setout(a, out, outlen);
+  memset_s(a, 200, 0, 200);
+  return 0;
+}
+
+/*** Helper macros to define SHA3 and SHAKE instances. ***/
+#define defshake(bits)                                            \
+  int shake##bits(uint8_t* out, size_t outlen,                    \
+                  const uint8_t* in, size_t inlen) {              \
+    return hash(out, outlen, in, inlen, 200 - (bits / 4), 0x1f);  \
+  }
+#define defsha3(bits)                                             \
+  int sha3_##bits(uint8_t* out, size_t outlen,                    \
+                  const uint8_t* in, size_t inlen) {              \
+    if (outlen > (bits/8)) {                                      \
+      return -1;                                                  \
+    }                                                             \
+    return hash(out, outlen, in, inlen, 200 - (bits / 4), 0x06);  \
+  }
+
+/*** FIPS202 SHAKE VOFs ***/
+defshake(128)
+defshake(256)
+
+/*** FIPS202 SHA3 FOFs ***/
+defsha3(224)
+defsha3(256)
+defsha3(384)
+defsha3(512)
diff --git a/src/ext/keccak-tiny/keccak-tiny.h b/src/ext/keccak-tiny/keccak-tiny.h
new file mode 100644
index 0000000..7efea23
--- /dev/null
+++ b/src/ext/keccak-tiny/keccak-tiny.h
@@ -0,0 +1,66 @@
+#ifndef KECCAK_FIPS202_H
+#define KECCAK_FIPS202_H
+
+#include <stddef.h>
+#include "torint.h"
+
+#define KECCAK_MAX_RATE 200
+
+/* Calculate the rate (block size) from the security target. */
+#define KECCAK_RATE(bits) (KECCAK_MAX_RATE - (bits / 4))
+
+/* The internal structure of a FIPS202 hash/xof instance.  Most callers
+ * should treat this as an opaque structure.
+ */
+typedef struct keccak_state {
+  uint8_t a[KECCAK_MAX_RATE];
+  size_t rate;
+  uint8_t delim;
+
+  uint8_t block[KECCAK_MAX_RATE];
+  size_t offset;
+
+  uint8_t finalized : 1;
+} keccak_state;
+
+/* Initialize a Keccak instance suitable for SHA-3 hash functions. */
+int keccak_digest_init(keccak_state *s, size_t bits);
+
+/* Feed more data into the SHA-3 hash instance. */
+int keccak_digest_update(keccak_state *s, const uint8_t *buf, size_t len);
+
+/* Calculate the SHA-3 hash digest.  The state is unmodified to support
+ * calculating multiple/rolling digests.
+ */
+int keccak_digest_sum(const keccak_state *s, uint8_t *out, size_t outlen);
+
+/* Initialize a Keccak instance suitable for XOFs (SHAKE-128/256). */
+int keccak_xof_init(keccak_state *s, size_t bits);
+
+/* Absorb more data into the XOF.  Must not be called after a squeeze call. */
+int keccak_xof_absorb(keccak_state *s, const uint8_t *buf, size_t len);
+
+/* Squeeze data out of the XOF. Must not attempt to absorb additional data,
+ * after a squeeze has been called.
+ */
+int keccak_xof_squeeze(keccak_state *s, uint8_t *out, size_t outlen);
+
+/* Clone an existing hash/XOF instance. */
+void keccak_clone(keccak_state *out, const keccak_state *in);
+
+/* Cleanse sensitive data from a given hash instance. */
+void keccak_cleanse(keccak_state *s);
+
+#define decshake(bits) \
+  int shake##bits(uint8_t*, size_t, const uint8_t*, size_t);
+
+#define decsha3(bits) \
+  int sha3_##bits(uint8_t*, size_t, const uint8_t*, size_t);
+
+decshake(128)
+decshake(256)
+decsha3(224)
+decsha3(256)
+decsha3(384)
+decsha3(512)
+#endif
diff --git a/src/or/buffers.c b/src/or/buffers.c
index cc2f6f4..0108483 100644
--- a/src/or/buffers.c
+++ b/src/or/buffers.c
@@ -22,6 +22,7 @@
 #include "ext_orport.h"
 #include "util.h"
 #include "torlog.h"
+#include "main.h"
 #ifdef HAVE_UNISTD_H
 #include <unistd.h>
 #endif
@@ -78,7 +79,7 @@ static int parse_socks_client(const uint8_t *data, size_t datalen,
 
 /** Return the next character in <b>chunk</b> onto which data can be appended.
  * If the chunk is full, this might be off the end of chunk->mem. */
-static INLINE char *
+static inline char *
 CHUNK_WRITE_PTR(chunk_t *chunk)
 {
   return chunk->data + chunk->datalen;
@@ -86,7 +87,7 @@ CHUNK_WRITE_PTR(chunk_t *chunk)
 
 /** Return the number of bytes that can be written onto <b>chunk</b> without
  * running out of space. */
-static INLINE size_t
+static inline size_t
 CHUNK_REMAINING_CAPACITY(const chunk_t *chunk)
 {
   return (chunk->mem + chunk->memlen) - (chunk->data + chunk->datalen);
@@ -94,7 +95,7 @@ CHUNK_REMAINING_CAPACITY(const chunk_t *chunk)
 
 /** Move all bytes stored in <b>chunk</b> to the front of <b>chunk</b>->mem,
  * to free up space at the end. */
-static INLINE void
+static inline void
 chunk_repack(chunk_t *chunk)
 {
   if (chunk->datalen && chunk->data != &chunk->mem[0]) {
@@ -118,7 +119,7 @@ chunk_free_unchecked(chunk_t *chunk)
   total_bytes_allocated_in_chunks -= CHUNK_ALLOC_SIZE(chunk->memlen);
   tor_free(chunk);
 }
-static INLINE chunk_t *
+static inline chunk_t *
 chunk_new_with_alloc_size(size_t alloc)
 {
   chunk_t *ch;
@@ -136,7 +137,7 @@ chunk_new_with_alloc_size(size_t alloc)
 
 /** Expand <b>chunk</b> until it can hold <b>sz</b> bytes, and return a
  * new pointer to <b>chunk</b>.  Old pointers are no longer valid. */
-static INLINE chunk_t *
+static inline chunk_t *
 chunk_grow(chunk_t *chunk, size_t sz)
 {
   off_t offset;
@@ -165,7 +166,7 @@ chunk_grow(chunk_t *chunk, size_t sz)
 
 /** Return the allocation size we'd like to use to hold <b>target</b>
  * bytes. */
-static INLINE size_t
+static inline size_t
 preferred_chunk_size(size_t target)
 {
   size_t sz = MIN_CHUNK_ALLOC;
@@ -255,7 +256,7 @@ buf_get_first_chunk_data(const buf_t *buf, const char **cp, size_t *sz)
 #endif
 
 /** Remove the first <b>n</b> bytes from buf. */
-static INLINE void
+static inline void
 buf_remove_from_front(buf_t *buf, size_t n)
 {
   tor_assert(buf->datalen >= n);
@@ -452,7 +453,7 @@ buf_get_total_allocation(void)
  * <b>chunk</b> (which must be on <b>buf</b>). If we get an EOF, set
  * *<b>reached_eof</b> to 1.  Return -1 on error, 0 on eof or blocking,
  * and the number of bytes read otherwise. */
-static INLINE int
+static inline int
 read_to_chunk(buf_t *buf, chunk_t *chunk, tor_socket_t fd, size_t at_most,
               int *reached_eof, int *socket_error)
 {
@@ -488,7 +489,7 @@ read_to_chunk(buf_t *buf, chunk_t *chunk, tor_socket_t fd, size_t at_most,
 
 /** As read_to_chunk(), but return (negative) error code on error, blocking,
  * or TLS, and the number of bytes read otherwise. */
-static INLINE int
+static inline int
 read_to_chunk_tls(buf_t *buf, chunk_t *chunk, tor_tls_t *tls,
                   size_t at_most)
 {
@@ -611,7 +612,7 @@ read_to_buf_tls(tor_tls_t *tls, size_t at_most, buf_t *buf)
  * the bytes written from *<b>buf_flushlen</b>.  Return the number of bytes
  * written on success, 0 on blocking, -1 on failure.
  */
-static INLINE int
+static inline int
 flush_chunk(tor_socket_t s, buf_t *buf, chunk_t *chunk, size_t sz,
             size_t *buf_flushlen)
 {
@@ -646,7 +647,7 @@ flush_chunk(tor_socket_t s, buf_t *buf, chunk_t *chunk, size_t sz,
  * bytes written from *<b>buf_flushlen</b>.  Return the number of bytes
  * written on success, and a TOR_TLS error code on failure or blocking.
  */
-static INLINE int
+static inline int
 flush_chunk_tls(tor_tls_t *tls, buf_t *buf, chunk_t *chunk,
                 size_t sz, size_t *buf_flushlen)
 {
@@ -797,7 +798,7 @@ write_to_buf(const char *string, size_t string_len, buf_t *buf)
 /** Helper: copy the first <b>string_len</b> bytes from <b>buf</b>
  * onto <b>string</b>.
  */
-static INLINE void
+static inline void
 peek_from_buf(char *string, size_t string_len, const buf_t *buf)
 {
   chunk_t *chunk;
@@ -842,7 +843,7 @@ fetch_from_buf(char *string, size_t string_len, buf_t *buf)
 
 /** True iff the cell command <b>command</b> is one that implies a
  * variable-length cell in Tor link protocol <b>linkproto</b>. */
-static INLINE int
+static inline int
 cell_command_is_var_length(uint8_t command, int linkproto)
 {
   /* If linkproto is v2 (2), CELL_VERSIONS is the only variable-length cells
@@ -1083,7 +1084,7 @@ buf_find_pos_of_char(char ch, buf_pos_t *out)
 
 /** Advance <b>pos</b> by a single character, if there are any more characters
  * in the buffer.  Returns 0 on success, -1 on failure. */
-static INLINE int
+static inline int
 buf_pos_inc(buf_pos_t *pos)
 {
   ++pos->pos;
@@ -1945,7 +1946,7 @@ parse_socks(const char *data, size_t datalen, socks_request_t *req,
         log_warn(LD_PROTOCOL,
                  "Your application (using socks4 to port %d) gave Tor "
                  "a malformed hostname: %s. Rejecting the connection.",
-                 req->port, escaped(req->address));
+                 req->port, escaped_safe_str_client(req->address));
         return -1;
       }
       if (authend != authstart) {
diff --git a/src/or/channel.c b/src/or/channel.c
index 21522a5..46e8338 100644
--- a/src/or/channel.c
+++ b/src/or/channel.c
@@ -127,13 +127,13 @@ typedef struct channel_idmap_entry_s {
   TOR_LIST_HEAD(channel_list_s, channel_s) channel_list;
 } channel_idmap_entry_t;
 
-static INLINE unsigned
+static inline unsigned
 channel_idmap_hash(const channel_idmap_entry_t *ent)
 {
   return (unsigned) siphash24g(ent->digest, DIGEST_LEN);
 }
 
-static INLINE int
+static inline int
 channel_idmap_eq(const channel_idmap_entry_t *a,
                   const channel_idmap_entry_t *b)
 {
diff --git a/src/or/channel.h b/src/or/channel.h
index 2b38ca7..5fa2aa8 100644
--- a/src/or/channel.h
+++ b/src/or/channel.h
@@ -531,7 +531,7 @@ channel_t * channel_next_with_digest(channel_t *chan);
                                         CHANNEL_IS_OPEN(chan) || \
                                         CHANNEL_IS_MAINT(chan))
 
-static INLINE int
+static inline int
 channel_is_in_state(channel_t *chan, channel_state_t state)
 {
   return chan->state == state;
diff --git a/src/or/channeltls.c b/src/or/channeltls.c
index c90f569..f0333e8 100644
--- a/src/or/channeltls.c
+++ b/src/or/channeltls.c
@@ -1663,30 +1663,9 @@ channel_tls_process_netinfo_cell(cell_t *cell, channel_tls_t *chan)
 #define NETINFO_NOTICE_SKEW 3600
   if (labs(apparent_skew) > NETINFO_NOTICE_SKEW &&
       router_get_by_id_digest(chan->conn->identity_digest)) {
-    char dbuf[64];
-    int severity;
-    /*XXXX be smarter about when everybody says we are skewed. */
-    if (router_digest_is_trusted_dir(chan->conn->identity_digest))
-      severity = LOG_WARN;
-    else
-      severity = LOG_INFO;
-    format_time_interval(dbuf, sizeof(dbuf), apparent_skew);
-    log_fn(severity, LD_GENERAL,
-           "Received NETINFO cell with skewed time from "
-           "server at %s:%d.  It seems that our clock is %s by %s, or "
-           "that theirs is %s. Tor requires an accurate clock to work: "
-           "please check your time and date settings.",
-           chan->conn->base_.address,
-           (int)(chan->conn->base_.port),
-           apparent_skew > 0 ? "ahead" : "behind",
-           dbuf,
-           apparent_skew > 0 ? "behind" : "ahead");
-    if (severity == LOG_WARN) /* only tell the controller if an authority */
-      control_event_general_status(LOG_WARN,
-                          "CLOCK_SKEW SKEW=%ld SOURCE=OR:%s:%d",
-                          apparent_skew,
-                          chan->conn->base_.address,
-                          chan->conn->base_.port);
+    int trusted = router_digest_is_trusted_dir(chan->conn->identity_digest);
+    clock_skew_warning(TO_CONN(chan->conn), apparent_skew, trusted, LD_GENERAL,
+                       "NETINFO cell", "OR");
   }
 
   /* XXX maybe act on my_apparent_addr, if the source is sufficiently
diff --git a/src/or/circuitbuild.c b/src/or/circuitbuild.c
index 0688398..719d27c 100644
--- a/src/or/circuitbuild.c
+++ b/src/or/circuitbuild.c
@@ -498,6 +498,14 @@ circuit_handle_first_hop(origin_circuit_t *circ)
   tor_assert(firsthop);
   tor_assert(firsthop->extend_info);
 
+  /* XX/teor - does tor ever need build a circuit directly to itself? */
+  if (tor_addr_is_internal(&firsthop->extend_info->addr, 0) &&
+      !get_options()->ExtendAllowPrivateAddresses) {
+    log_fn(LOG_PROTOCOL_WARN, LD_PROTOCOL,
+           "Client asked me to connect directly to a private address");
+    return -END_CIRC_REASON_TORPROTOCOL;
+  }
+
   /* now see if we're already connected to the first OR in 'route' */
   log_debug(LD_CIRC,"Looking for firsthop '%s'",
             fmt_addrport(&firsthop->extend_info->addr,
@@ -737,7 +745,7 @@ inform_testing_reachability(void)
 
 /** Return true iff we should send a create_fast cell to start building a given
  * circuit */
-static INLINE int
+static inline int
 should_use_create_fast_for_circuit(origin_circuit_t *circ)
 {
   const or_options_t *options = get_options();
diff --git a/src/or/circuitlist.c b/src/or/circuitlist.c
index 716024d..dcbeb1e 100644
--- a/src/or/circuitlist.c
+++ b/src/or/circuitlist.c
@@ -44,11 +44,16 @@ static smartlist_t *global_circuitlist = NULL;
 /** A list of all the circuits in CIRCUIT_STATE_CHAN_WAIT. */
 static smartlist_t *circuits_pending_chans = NULL;
 
+/** A list of all the circuits that have been marked with
+ * circuit_mark_for_close and which are waiting for circuit_about_to_free. */
+static smartlist_t *circuits_pending_close = NULL;
+
 static void circuit_free_cpath_node(crypt_path_t *victim);
 static void cpath_ref_decref(crypt_path_reference_t *cpath_ref);
 //static void circuit_set_rend_token(or_circuit_t *circ, int is_rend_circ,
 //                                   const uint8_t *token);
 static void circuit_clear_rend_token(or_circuit_t *circ);
+static void circuit_about_to_free(circuit_t *circ);
 
 /********* END VARIABLES ************/
 
@@ -66,7 +71,7 @@ typedef struct chan_circid_circuit_map_t {
 /** Helper for hash tables: compare the channel and circuit ID for a and
  * b, and return less than, equal to, or greater than zero appropriately.
  */
-static INLINE int
+static inline int
 chan_circid_entries_eq_(chan_circid_circuit_map_t *a,
                         chan_circid_circuit_map_t *b)
 {
@@ -75,7 +80,7 @@ chan_circid_entries_eq_(chan_circid_circuit_map_t *a,
 
 /** Helper: return a hash based on circuit ID and the pointer value of
  * chan in <b>a</b>. */
-static INLINE unsigned int
+static inline unsigned int
 chan_circid_entry_hash_(chan_circid_circuit_map_t *a)
 {
   /* Try to squeze the siphash input into 8 bytes to save any extra siphash
@@ -451,16 +456,27 @@ circuit_count_pending_on_channel(channel_t *chan)
 void
 circuit_close_all_marked(void)
 {
+  if (circuits_pending_close == NULL)
+    return;
+
   smartlist_t *lst = circuit_get_global_list();
-  SMARTLIST_FOREACH_BEGIN(lst, circuit_t *, circ) {
-    /* Fix up index if SMARTLIST_DEL_CURRENT just moved this one. */
-    circ->global_circuitlist_idx = circ_sl_idx;
-    if (circ->marked_for_close) {
-      circ->global_circuitlist_idx = -1;
-      circuit_free(circ);
-      SMARTLIST_DEL_CURRENT(lst, circ);
+  SMARTLIST_FOREACH_BEGIN(circuits_pending_close, circuit_t *, circ) {
+    tor_assert(circ->marked_for_close);
+
+    /* Remove it from the circuit list. */
+    int idx = circ->global_circuitlist_idx;
+    smartlist_del(lst, idx);
+    if (idx < smartlist_len(lst)) {
+      circuit_t *replacement = smartlist_get(lst, idx);
+      replacement->global_circuitlist_idx = idx;
     }
+    circ->global_circuitlist_idx = -1;
+
+    circuit_about_to_free(circ);
+    circuit_free(circ);
   } SMARTLIST_FOREACH_END(circ);
+
+  smartlist_clear(circuits_pending_close);
 }
 
 /** Return the head of the global linked list of circuits. */
@@ -895,6 +911,9 @@ circuit_free_all(void)
   smartlist_free(circuits_pending_chans);
   circuits_pending_chans = NULL;
 
+  smartlist_free(circuits_pending_close);
+  circuits_pending_close = NULL;
+
   {
     chan_circid_circuit_map_t **elt, **next, *c;
     for (elt = HT_START(chan_circid_map, &chan_circid_map);
@@ -1030,7 +1049,7 @@ circuit_get_by_global_id(uint32_t id)
  * If <b>found_entry_out</b> is provided, set it to true if we have a
  * placeholder entry for circid/chan, and leave it unset otherwise.
  */
-static INLINE circuit_t *
+static inline circuit_t *
 circuit_get_by_circid_channel_impl(circid_t circ_id, channel_t *chan,
                                    int *found_entry_out)
 {
@@ -1703,6 +1722,39 @@ circuit_mark_for_close_, (circuit_t *circ, int reason, int line,
     reason = END_CIRC_REASON_NONE;
   }
 
+  circ->marked_for_close = line;
+  circ->marked_for_close_file = file;
+  circ->marked_for_close_reason = reason;
+  circ->marked_for_close_orig_reason = orig_reason;
+
+  if (!CIRCUIT_IS_ORIGIN(circ)) {
+    or_circuit_t *or_circ = TO_OR_CIRCUIT(circ);
+    if (or_circ->rend_splice) {
+      if (!or_circ->rend_splice->base_.marked_for_close) {
+        /* do this after marking this circuit, to avoid infinite recursion. */
+        circuit_mark_for_close(TO_CIRCUIT(or_circ->rend_splice), reason);
+      }
+      or_circ->rend_splice = NULL;
+    }
+  }
+
+  if (circuits_pending_close == NULL)
+    circuits_pending_close = smartlist_new();
+
+  smartlist_add(circuits_pending_close, circ);
+}
+
+/** Called immediately before freeing a marked circuit <b>circ</b>.
+ * Disconnects the circuit from other data structures, launches events
+ * as appropriate, and performs other housekeeping.
+ */
+static void
+circuit_about_to_free(circuit_t *circ)
+{
+
+  int reason = circ->marked_for_close_reason;
+  int orig_reason = circ->marked_for_close_orig_reason;
+
   if (circ->state == CIRCUIT_STATE_ONIONSKIN_PENDING) {
     onion_pending_remove(TO_OR_CIRCUIT(circ));
   }
@@ -1726,6 +1778,7 @@ circuit_mark_for_close_, (circuit_t *circ, int reason, int line,
      (circ->state == CIRCUIT_STATE_OPEN)?CIRC_EVENT_CLOSED:CIRC_EVENT_FAILED,
      orig_reason);
   }
+
   if (circ->purpose == CIRCUIT_PURPOSE_C_INTRODUCE_ACK_WAIT) {
     origin_circuit_t *ocirc = TO_ORIGIN_CIRCUIT(circ);
     int timed_out = (reason == END_CIRC_REASON_TIMEOUT);
@@ -1810,20 +1863,6 @@ circuit_mark_for_close_, (circuit_t *circ, int reason, int line,
       connection_edge_destroy(circ->n_circ_id, conn);
     ocirc->p_streams = NULL;
   }
-
-  circ->marked_for_close = line;
-  circ->marked_for_close_file = file;
-
-  if (!CIRCUIT_IS_ORIGIN(circ)) {
-    or_circuit_t *or_circ = TO_OR_CIRCUIT(circ);
-    if (or_circ->rend_splice) {
-      if (!or_circ->rend_splice->base_.marked_for_close) {
-        /* do this after marking this circuit, to avoid infinite recursion. */
-        circuit_mark_for_close(TO_CIRCUIT(or_circ->rend_splice), reason);
-      }
-      or_circ->rend_splice = NULL;
-    }
-  }
 }
 
 /** Given a marked circuit <b>circ</b>, aggressively free its cell queues to
diff --git a/src/or/circuitmux.c b/src/or/circuitmux.c
index a77bffa..94d1eb6 100644
--- a/src/or/circuitmux.c
+++ b/src/or/circuitmux.c
@@ -186,10 +186,10 @@ struct chanid_circid_muxinfo_t {
  * Static function declarations
  */
 
-static INLINE int
+static inline int
 chanid_circid_entries_eq(chanid_circid_muxinfo_t *a,
                          chanid_circid_muxinfo_t *b);
-static INLINE unsigned int
+static inline unsigned int
 chanid_circid_entry_hash(chanid_circid_muxinfo_t *a);
 static chanid_circid_muxinfo_t *
 circuitmux_find_map_entry(circuitmux_t *cmux, circuit_t *circ);
@@ -199,12 +199,12 @@ circuitmux_make_circuit_active(circuitmux_t *cmux, circuit_t *circ,
 static void
 circuitmux_make_circuit_inactive(circuitmux_t *cmux, circuit_t *circ,
                                  cell_direction_t direction);
-static INLINE void
+static inline void
 circuitmux_move_active_circ_to_tail(circuitmux_t *cmux, circuit_t *circ,
                                     cell_direction_t direction);
-static INLINE circuit_t **
+static inline circuit_t **
 circuitmux_next_active_circ_p(circuitmux_t *cmux, circuit_t *circ);
-static INLINE circuit_t **
+static inline circuit_t **
 circuitmux_prev_active_circ_p(circuitmux_t *cmux, circuit_t *circ);
 static void circuitmux_assert_okay_pass_one(circuitmux_t *cmux);
 static void circuitmux_assert_okay_pass_two(circuitmux_t *cmux);
@@ -226,7 +226,7 @@ static int64_t global_destroy_ctr = 0;
  * used by circuitmux_notify_xmit_cells().
  */
 
-static INLINE void
+static inline void
 circuitmux_move_active_circ_to_tail(circuitmux_t *cmux, circuit_t *circ,
                                     cell_direction_t direction)
 {
@@ -306,7 +306,7 @@ circuitmux_move_active_circ_to_tail(circuitmux_t *cmux, circuit_t *circ,
   circuitmux_assert_okay_paranoid(cmux);
 }
 
-static INLINE circuit_t **
+static inline circuit_t **
 circuitmux_next_active_circ_p(circuitmux_t *cmux, circuit_t *circ)
 {
   tor_assert(cmux);
@@ -319,7 +319,7 @@ circuitmux_next_active_circ_p(circuitmux_t *cmux, circuit_t *circ)
   }
 }
 
-static INLINE circuit_t **
+static inline circuit_t **
 circuitmux_prev_active_circ_p(circuitmux_t *cmux, circuit_t *circ)
 {
   tor_assert(cmux);
@@ -338,7 +338,7 @@ circuitmux_prev_active_circ_p(circuitmux_t *cmux, circuit_t *circ)
  * than zero appropriately.
  */
 
-static INLINE int
+static inline int
 chanid_circid_entries_eq(chanid_circid_muxinfo_t *a,
                          chanid_circid_muxinfo_t *b)
 {
@@ -349,7 +349,7 @@ chanid_circid_entries_eq(chanid_circid_muxinfo_t *a,
  * Helper: return a hash based on circuit ID and channel ID in a.
  */
 
-static INLINE unsigned int
+static inline unsigned int
 chanid_circid_entry_hash(chanid_circid_muxinfo_t *a)
 {
     return (((unsigned int)(a->circ_id) << 8) ^
diff --git a/src/or/circuitmux_ewma.c b/src/or/circuitmux_ewma.c
index 1c0318d..0c61fb2 100644
--- a/src/or/circuitmux_ewma.c
+++ b/src/or/circuitmux_ewma.c
@@ -115,7 +115,7 @@ TO_EWMA_POL_CIRC_DATA(circuitmux_policy_circ_data_t *);
  * if the cast is impossible.
  */
 
-static INLINE ewma_policy_data_t *
+static inline ewma_policy_data_t *
 TO_EWMA_POL_DATA(circuitmux_policy_data_t *pol)
 {
   if (!pol) return NULL;
@@ -130,7 +130,7 @@ TO_EWMA_POL_DATA(circuitmux_policy_data_t *pol)
  * and assert if the cast is impossible.
  */
 
-static INLINE ewma_policy_circ_data_t *
+static inline ewma_policy_circ_data_t *
 TO_EWMA_POL_CIRC_DATA(circuitmux_policy_circ_data_t *pol)
 {
   if (!pol) return NULL;
@@ -147,7 +147,7 @@ static int compare_cell_ewma_counts(const void *p1, const void *p2);
 static unsigned cell_ewma_tick_from_timeval(const struct timeval *now,
                                             double *remainder_out);
 static circuit_t * cell_ewma_to_circuit(cell_ewma_t *ewma);
-static INLINE double get_scale_factor(unsigned from_tick, unsigned to_tick);
+static inline double get_scale_factor(unsigned from_tick, unsigned to_tick);
 static cell_ewma_t * pop_first_cell_ewma(ewma_policy_data_t *pol);
 static void remove_cell_ewma(ewma_policy_data_t *pol, cell_ewma_t *ewma);
 static void scale_single_cell_ewma(cell_ewma_t *ewma, unsigned cur_tick);
@@ -644,7 +644,7 @@ cell_ewma_set_scale_factor(const or_options_t *options,
 
 /** Return the multiplier necessary to convert the value of a cell sent in
  * 'from_tick' to one sent in 'to_tick'. */
-static INLINE double
+static inline double
 get_scale_factor(unsigned from_tick, unsigned to_tick)
 {
   /* This math can wrap around, but that's okay: unsigned overflow is
diff --git a/src/or/circuituse.c b/src/or/circuituse.c
index 00340fd..05201a5 100644
--- a/src/or/circuituse.c
+++ b/src/or/circuituse.c
@@ -92,7 +92,7 @@ circuit_is_acceptable(const origin_circuit_t *origin_circ,
   /* decide if this circ is suitable for this conn */
 
   /* for rend circs, circ->cpath->prev is not the last router in the
-   * circuit, it's the magical extra bob hop. so just check the nickname
+   * circuit, it's the magical extra service hop. so just check the nickname
    * of the one we meant to finish at.
    */
   build_state = origin_circ->build_state;
@@ -1123,7 +1123,7 @@ circuit_build_needed_circs(time_t now)
    * don't require an exit circuit, review in #13814.
    * This allows HSs to function in a consensus without exits. */
   if (router_have_consensus_path() != CONSENSUS_PATH_UNKNOWN)
-    connection_ap_attach_pending();
+    connection_ap_rescan_and_attach_pending();
 
   /* make sure any hidden services have enough intro points
    * HS intro point streams only require an internal circuit */
@@ -1475,7 +1475,7 @@ circuit_has_opened(origin_circuit_t *circ)
     case CIRCUIT_PURPOSE_C_ESTABLISH_REND:
       rend_client_rendcirc_has_opened(circ);
       /* Start building an intro circ if we don't have one yet. */
-      connection_ap_attach_pending();
+      connection_ap_attach_pending(1);
       /* This isn't a call to circuit_try_attaching_streams because a
        * circuit in _C_ESTABLISH_REND state isn't connected to its
        * hidden service yet, thus we can't attach streams to it yet,
@@ -1493,11 +1493,11 @@ circuit_has_opened(origin_circuit_t *circ)
       circuit_try_attaching_streams(circ);
       break;
     case CIRCUIT_PURPOSE_S_ESTABLISH_INTRO:
-      /* at Bob, waiting for introductions */
+      /* at the service, waiting for introductions */
       rend_service_intro_has_opened(circ);
       break;
     case CIRCUIT_PURPOSE_S_CONNECT_REND:
-      /* at Bob, connecting to rend point */
+      /* at the service, connecting to rend point */
       rend_service_rendezvous_has_opened(circ);
       break;
     case CIRCUIT_PURPOSE_TESTING:
@@ -1537,14 +1537,14 @@ void
 circuit_try_attaching_streams(origin_circuit_t *circ)
 {
   /* Attach streams to this circuit if we can. */
-  connection_ap_attach_pending();
+  connection_ap_attach_pending(1);
 
   /* The call to circuit_try_clearing_isolation_state here will do
    * nothing and return 0 if we didn't attach any streams to circ
    * above. */
   if (circuit_try_clearing_isolation_state(circ)) {
     /* Maybe *now* we can attach some streams to this circuit. */
-    connection_ap_attach_pending();
+    connection_ap_attach_pending(1);
   }
 }
 
@@ -1617,32 +1617,32 @@ circuit_build_failed(origin_circuit_t *circ)
       circuit_testing_failed(circ, failed_at_last_hop);
       break;
     case CIRCUIT_PURPOSE_S_ESTABLISH_INTRO:
-      /* at Bob, waiting for introductions */
+      /* at the service, waiting for introductions */
       if (circ->base_.state != CIRCUIT_STATE_OPEN) {
         circuit_increment_failure_count();
       }
-      /* no need to care here, because bob will rebuild intro
+      /* no need to care here, because the service will rebuild intro
        * points periodically. */
       break;
     case CIRCUIT_PURPOSE_C_INTRODUCING:
-      /* at Alice, connecting to intro point */
-      /* Don't increment failure count, since Bob may have picked
+      /* at the client, connecting to intro point */
+      /* Don't increment failure count, since the service may have picked
        * the introduction point maliciously */
-      /* Alice will pick a new intro point when this one dies, if
+      /* The client will pick a new intro point when this one dies, if
        * the stream in question still cares. No need to act here. */
       break;
     case CIRCUIT_PURPOSE_C_ESTABLISH_REND:
-      /* at Alice, waiting for Bob */
+      /* at the client, waiting for the service */
       circuit_increment_failure_count();
-      /* Alice will pick a new rend point when this one dies, if
+      /* the client will pick a new rend point when this one dies, if
        * the stream in question still cares. No need to act here. */
       break;
     case CIRCUIT_PURPOSE_S_CONNECT_REND:
-      /* at Bob, connecting to rend point */
-      /* Don't increment failure count, since Alice may have picked
+      /* at the service, connecting to rend point */
+      /* Don't increment failure count, since the client may have picked
        * the rendezvous point maliciously */
       log_info(LD_REND,
-               "Couldn't connect to Alice's chosen rend point %s "
+               "Couldn't connect to the client's chosen rend point %s "
                "(%s hop failed).",
                escaped(build_state_get_exit_nickname(circ->build_state)),
                failed_at_last_hop?"last":"non-last");
@@ -1986,6 +1986,7 @@ circuit_get_open_circ_or_launch(entry_connection_t *conn,
                  "No intro points for '%s': re-fetching service descriptor.",
                  safe_str_client(rend_data->onion_address));
         rend_client_refetch_v2_renddesc(rend_data);
+        connection_ap_mark_as_non_pending_circuit(conn);
         ENTRY_TO_CONN(conn)->state = AP_CONN_STATE_RENDDESC_WAIT;
         return 0;
       }
@@ -2240,7 +2241,7 @@ consider_recording_trackhost(const entry_connection_t *conn,
   char fp[HEX_DIGEST_LEN+1];
 
   /* Search the addressmap for this conn's destination. */
-  /* If he's not in the address map.. */
+  /* If they're not in the address map.. */
   if (!options->TrackHostExits ||
       addressmap_have_mapping(conn->socks_request->address,
                               options->TrackHostExitsExpire))
diff --git a/src/or/config.c b/src/or/config.c
index fa860af..d2d8815 100644
--- a/src/or/config.c
+++ b/src/or/config.c
@@ -212,6 +212,7 @@ static config_var_t option_vars_[] = {
   V(CookieAuthFile,              STRING,   NULL),
   V(CountPrivateBandwidth,       BOOL,     "0"),
   V(DataDirectory,               FILENAME, NULL),
+  V(DataDirectoryGroupReadable,  BOOL,     "0"),
   V(DisableNetwork,              BOOL,     "0"),
   V(DirAllowPrivateAddresses,    BOOL,     "0"),
   V(TestingAuthDirTimeToLearnReachability, INTERVAL, "30 minutes"),
@@ -221,6 +222,7 @@ static config_var_t option_vars_[] = {
   V(DirPortFrontPage,            FILENAME, NULL),
   VAR("DirReqStatistics",        BOOL,     DirReqStatistics_option, "1"),
   VAR("DirAuthority",            LINELIST, DirAuthorities, NULL),
+  V(DirCache,                    BOOL,     "1"),
   V(DirAuthorityFallbackRate,    DOUBLE,   "1.0"),
   V(DisableAllSwap,              BOOL,     "0"),
   V(DisableDebuggerAttachment,   BOOL,     "1"),
@@ -251,6 +253,7 @@ static config_var_t option_vars_[] = {
   V(ExtORPortCookieAuthFileGroupReadable, BOOL, "0"),
   V(ExtraInfoStatistics,         BOOL,     "1"),
   V(FallbackDir,                 LINELIST, NULL),
+  V(UseDefaultFallbackDirs,      BOOL,     "1"),
 
   OBSOLETE("FallbackNetworkstatusFile"),
   V(FascistFirewall,             BOOL,     "0"),
@@ -308,10 +311,12 @@ static config_var_t option_vars_[] = {
   V(Socks5ProxyUsername,         STRING,   NULL),
   V(Socks5ProxyPassword,         STRING,   NULL),
   V(KeepalivePeriod,             INTERVAL, "5 minutes"),
+  V(KeepBindCapabilities,            AUTOBOOL, "auto"),
   VAR("Log",                     LINELIST, Logs,             NULL),
   V(LogMessageDomains,           BOOL,     "0"),
   V(LogTimeGranularity,          MSEC_INTERVAL, "1 second"),
   V(TruncateLogFile,             BOOL,     "0"),
+  V(SyslogIdentityTag,           STRING,   NULL),
   V(LongLivedPorts,              CSV,
         "21,22,706,1863,5050,5190,5222,5223,6523,6667,6697,8300"),
   VAR("MapAddress",              LINELIST, AddressMap,           NULL),
@@ -473,10 +478,40 @@ static config_var_t option_vars_[] = {
   V(TestingClientConsensusDownloadSchedule, CSV_INTERVAL, "0, 0, 60, "
                                  "300, 600, 1800, 3600, 3600, 3600, "
                                  "10800, 21600, 43200"),
+  /* With the TestingClientBootstrapConsensus*Download* below:
+   * Clients with only authorities will try:
+   *  - 3 authorities over 10 seconds, then wait 60 minutes.
+   * Clients with authorities and fallbacks will try:
+   *  - 2 authorities and 4 fallbacks over 21 seconds, then wait 60 minutes.
+   * Clients will also retry when an application request arrives.
+   * After a number of failed reqests, clients retry every 3 days + 1 hour.
+   *
+   * Clients used to try 2 authorities over 10 seconds, then wait for
+   * 60 minutes or an application request.
+   *
+   * When clients have authorities and fallbacks available, they use these
+   * schedules: (we stagger the times to avoid thundering herds) */
+  V(TestingClientBootstrapConsensusAuthorityDownloadSchedule, CSV_INTERVAL,
+    "10, 11, 3600, 10800, 25200, 54000, 111600, 262800" /* 3 days + 1 hour */),
+  V(TestingClientBootstrapConsensusFallbackDownloadSchedule, CSV_INTERVAL,
+    "0, 1, 4, 11, 3600, 10800, 25200, 54000, 111600, 262800"),
+  /* When clients only have authorities available, they use this schedule: */
+  V(TestingClientBootstrapConsensusAuthorityOnlyDownloadSchedule, CSV_INTERVAL,
+    "0, 3, 7, 3600, 10800, 25200, 54000, 111600, 262800"),
+  /* We don't want to overwhelm slow networks (or mirrors whose replies are
+   * blocked), but we also don't want to fail if only some mirrors are
+   * blackholed. Clients will try 3 directories simultaneously.
+   * (Relays never use simultaneous connections.) */
+  V(TestingClientBootstrapConsensusMaxInProgressTries, UINT, "3"),
   V(TestingBridgeDownloadSchedule, CSV_INTERVAL, "3600, 900, 900, 3600"),
   V(TestingClientMaxIntervalWithoutRequest, INTERVAL, "10 minutes"),
   V(TestingDirConnectionMaxStall, INTERVAL, "5 minutes"),
   V(TestingConsensusMaxDownloadTries, UINT, "8"),
+  /* Since we try connections rapidly and simultaneously, we can afford
+   * to give up earlier. (This protects against overloading directories.) */
+  V(TestingClientBootstrapConsensusMaxDownloadTries, UINT, "7"),
+  /* We want to give up much earlier if we're only using authorities. */
+  V(TestingClientBootstrapConsensusAuthorityOnlyMaxDownloadTries, UINT, "4"),
   V(TestingDescriptorMaxDownloadTries, UINT, "8"),
   V(TestingMicrodescMaxDownloadTries, UINT, "8"),
   V(TestingCertMaxDownloadTries, UINT, "8"),
@@ -523,10 +558,18 @@ static const config_var_t testing_tor_network_defaults[] = {
                                  "15, 20, 30, 60"),
   V(TestingClientConsensusDownloadSchedule, CSV_INTERVAL, "0, 0, 5, 10, "
                                  "15, 20, 30, 60"),
+  V(TestingClientBootstrapConsensusAuthorityDownloadSchedule, CSV_INTERVAL,
+    "0, 2, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 8, 16, 32, 60"),
+  V(TestingClientBootstrapConsensusFallbackDownloadSchedule, CSV_INTERVAL,
+    "0, 1, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 8, 16, 32, 60"),
+  V(TestingClientBootstrapConsensusAuthorityOnlyDownloadSchedule, CSV_INTERVAL,
+    "0, 1, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 8, 16, 32, 60"),
   V(TestingBridgeDownloadSchedule, CSV_INTERVAL, "60, 30, 30, 60"),
   V(TestingClientMaxIntervalWithoutRequest, INTERVAL, "5 seconds"),
   V(TestingDirConnectionMaxStall, INTERVAL, "30 seconds"),
   V(TestingConsensusMaxDownloadTries, UINT, "80"),
+  V(TestingClientBootstrapConsensusMaxDownloadTries, UINT, "80"),
+  V(TestingClientBootstrapConsensusAuthorityOnlyMaxDownloadTries, UINT, "80"),
   V(TestingDescriptorMaxDownloadTries, UINT, "80"),
   V(TestingMicrodescMaxDownloadTries, UINT, "80"),
   V(TestingCertMaxDownloadTries, UINT, "80"),
@@ -547,7 +590,6 @@ static const config_var_t testing_tor_network_defaults[] = {
 static char *get_windows_conf_root(void);
 #endif
 static int options_act_reversible(const or_options_t *old_options, char **msg);
-static int options_act(const or_options_t *old_options);
 static int options_transition_allowed(const or_options_t *old,
                                       const or_options_t *new,
                                       char **msg);
@@ -558,15 +600,12 @@ static int options_transition_affects_descriptor(
 static int check_nickname_list(char **lst, const char *name, char **msg);
 static char *get_bindaddr_from_transport_listen_line(const char *line,
                                                      const char *transport);
-static int parse_dir_authority_line(const char *line,
-                                 dirinfo_type_t required_type,
-                                 int validate_only);
-static void port_cfg_free(port_cfg_t *port);
 static int parse_ports(or_options_t *options, int validate_only,
                               char **msg_out, int *n_ports_out,
                               int *world_writable_control_socket);
 static int check_server_ports(const smartlist_t *ports,
-                              const or_options_t *options);
+                              const or_options_t *options,
+                              int *num_low_ports_out);
 
 static int validate_data_directory(or_options_t *options);
 static int write_configuration_file(const char *fname,
@@ -625,15 +664,15 @@ static char *global_dirfrontpagecontents = NULL;
 static smartlist_t *configured_ports = NULL;
 
 /** Return the contents of our frontpage string, or NULL if not configured. */
-const char *
-get_dirportfrontpage(void)
+MOCK_IMPL(const char*,
+get_dirportfrontpage, (void))
 {
   return global_dirfrontpagecontents;
 }
 
-/** Return the currently configured options. */
-or_options_t *
-get_options_mutable(void)
+/** Returns the currently configured options. */
+MOCK_IMPL(or_options_t *,
+get_options_mutable, (void))
 {
   tor_assert(global_options);
   return global_options;
@@ -793,7 +832,6 @@ config_free_all(void)
 
   tor_free(torrc_fname);
   tor_free(torrc_defaults_fname);
-  tor_free(the_tor_version);
   tor_free(global_dirfrontpagecontents);
 
   tor_free(the_short_tor_version);
@@ -865,6 +903,7 @@ static const char *default_authorities[] = {
     "128.31.0.39:9131 9695 DFC3 5FFE B861 329B 9F1A B04C 4639 7020 CE31",
   "tor26 orport=443 "
     "v3ident=14C131DFC5C6F93646BE72FA1401C02A8DF2E8B4 "
+    "ipv6=[2001:858:2:2:aabb:0:563b:1526]:443 "
     "86.59.21.38:80 847B 1F85 0344 D787 6491 A548 92F9 0493 4E4E B85D",
   "dizum orport=443 "
     "v3ident=E8A9C45EDE6D711294FADF8E7951F4DE6CA56B58 "
@@ -873,30 +912,43 @@ static const char *default_authorities[] = {
     "82.94.251.203:80 4A0C CD2D DC79 9508 3D73 F5D6 6710 0C8A 5831 F16D",
   "gabelmoo orport=443 "
     "v3ident=ED03BB616EB2F60BEC80151114BB25CEF515B226 "
+    "ipv6=[2001:638:a000:4140::ffff:189]:443 "
     "131.188.40.189:80 F204 4413 DAC2 E02E 3D6B CF47 35A1 9BCA 1DE9 7281",
   "dannenberg orport=443 "
-    "v3ident=585769C78764D58426B8B52B6651A5A71137189A "
+    "v3ident=0232AF901C31A04EE9848595AF9BB7620D4C5B2E "
     "193.23.244.244:80 7BE6 83E6 5D48 1413 21C5 ED92 F075 C553 64AC 7123",
   "urras orport=80 "
     "v3ident=80550987E1D626E3EBA5E5E75A458DE0626D088C "
-    "208.83.223.34:443 0AD3 FA88 4D18 F89E EA2D 89C0 1937 9E0E 7FD9 4417",
+    "208.83.223.34:443 0AD3 FA88 4D18 F89E EA2D 89C0 1937 9E0E 7FD9 4417"
+    /* XX/teor - urras may have an IPv6 address, but it's not in urras'
+     * descriptor as of 11 Dec 2015. See #17813. */,
   "maatuska orport=80 "
     "v3ident=49015F787433103580E3B66A1707A00E60F2D15B "
+    "ipv6=[2001:67c:289c::9]:80 "
     "171.25.193.9:443 BD6A 8292 55CB 08E6 6FBE 7D37 4836 3586 E46B 3810",
   "Faravahar orport=443 "
     "v3ident=EFCBE720AB3A82B99F9E953CD5BF50F7EEFC7B97 "
     "154.35.175.225:80 CF6D 0AAF B385 BE71 B8E1 11FC 5CFF 4B47 9237 33BC",
   "longclaw orport=443 "
     "v3ident=23D15D965BC35114467363C165C4F724B64B4F66 "
+    "ipv6=[2620:13:4000:8000:60:f3ff:fea1:7cff]:443 "
     "199.254.238.52:80 74A9 1064 6BCE EFBC D2E8 74FC 1DC9 9743 0F96 8145",
   NULL
 };
 
+/** List of fallback directory authorities. The list is generated by opt-in of
+ * relays that meet certain stability criteria.
+ */
+static const char *default_fallbacks[] = {
+#include "fallback_dirs.inc"
+  NULL
+};
+
 /** Add the default directory authorities directly into the trusted dir list,
  * but only add them insofar as they share bits with <b>type</b>.
  * Each authority's bits are restricted to the bits shared with <b>type</b>.
  * If <b>type</b> is ALL_DIRINFO or NO_DIRINFO (zero), add all authorities. */
-static void
+STATIC void
 add_default_trusted_dir_authorities(dirinfo_type_t type)
 {
   int i;
@@ -914,13 +966,10 @@ MOCK_IMPL(void,
 add_default_fallback_dir_servers,(void))
 {
   int i;
-  const char *fallback[] = {
-    NULL
-  };
-  for (i=0; fallback[i]; i++) {
-    if (parse_dir_fallback_line(fallback[i], 0)<0) {
+  for (i=0; default_fallbacks[i]; i++) {
+    if (parse_dir_fallback_line(default_fallbacks[i], 0)<0) {
       log_err(LD_BUG, "Couldn't parse internal FallbackDir line %s",
-              fallback[i]);
+              default_fallbacks[i]);
     }
   }
 }
@@ -990,6 +1039,7 @@ consider_adding_dir_servers(const or_options_t *options,
     !smartlist_len(router_get_fallback_dir_servers()) || !old_options ||
     !config_lines_eq(options->DirAuthorities, old_options->DirAuthorities) ||
     !config_lines_eq(options->FallbackDir, old_options->FallbackDir) ||
+    (options->UseDefaultFallbackDirs != old_options->UseDefaultFallbackDirs) ||
     !config_lines_eq(options->AlternateBridgeAuthority,
                      old_options->AlternateBridgeAuthority) ||
     !config_lines_eq(options->AlternateDirAuthority,
@@ -1018,8 +1068,8 @@ consider_adding_dir_servers(const or_options_t *options,
       type |= V3_DIRINFO | EXTRAINFO_DIRINFO | MICRODESC_DIRINFO;
       /* Only add the default fallback directories when the DirAuthorities,
        * AlternateDirAuthority, and FallbackDir directory config options
-       * are set to their defaults. */
-      if (!options->FallbackDir) {
+       * are set to their defaults, and when UseDefaultFallbackDirs is 1. */
+      if (!options->FallbackDir && options->UseDefaultFallbackDirs) {
         add_default_fallback_dir_servers();
       }
     }
@@ -1044,6 +1094,9 @@ consider_adding_dir_servers(const or_options_t *options,
   return 0;
 }
 
+/* Helps determine flags to pass to switch_id. */
+static int have_low_ports = -1;
+
 /** Fetch the active option list, and take actions based on it. All of the
  * things we do should survive being done repeatedly.  If present,
  * <b>old_options</b> contains the previous value of the options.
@@ -1178,7 +1231,16 @@ options_act_reversible(const or_options_t *old_options, char **msg)
 
   /* Setuid/setgid as appropriate */
   if (options->User) {
-    if (switch_id(options->User) != 0) {
+    tor_assert(have_low_ports != -1);
+    unsigned switch_id_flags = 0;
+    if (options->KeepBindCapabilities == 1) {
+      switch_id_flags |= SWITCH_ID_KEEP_BINDLOW;
+      switch_id_flags |= SWITCH_ID_WARN_IF_NO_CAPS;
+    }
+    if (options->KeepBindCapabilities == -1 && have_low_ports) {
+      switch_id_flags |= SWITCH_ID_KEEP_BINDLOW;
+    }
+    if (switch_id(options->User, switch_id_flags) != 0) {
       /* No need to roll back, since you can't change the value. */
       *msg = tor_strdup("Problem with User value. See logs for details.");
       goto done;
@@ -1186,16 +1248,30 @@ options_act_reversible(const or_options_t *old_options, char **msg)
   }
 
   /* Ensure data directory is private; create if possible. */
+  cpd_check_t cpd_opts = running_tor ? CPD_CREATE : CPD_CHECK;
+  if (options->DataDirectoryGroupReadable)
+      cpd_opts |= CPD_GROUP_READ;
   if (check_private_dir(options->DataDirectory,
-                        running_tor ? CPD_CREATE : CPD_CHECK,
+                        cpd_opts,
                         options->User)<0) {
     tor_asprintf(msg,
               "Couldn't access/create private data directory \"%s\"",
               options->DataDirectory);
+
     goto done;
     /* No need to roll back, since you can't change the value. */
   }
 
+#ifndef _WIN32
+  if (options->DataDirectoryGroupReadable) {
+    /* Only new dirs created get new opts, also enforce group read. */
+    if (chmod(options->DataDirectory, 0750)) {
+      log_warn(LD_FS,"Unable to make %s group-readable: %s",
+               options->DataDirectory, strerror(errno));
+    }
+  }
+#endif
+
   /* Bail out at this point if we're not going to be a client or server:
    * we don't run Tor itself. */
   if (!running_tor)
@@ -1368,7 +1444,7 @@ options_transition_requires_fresh_tls_context(const or_options_t *old_options,
  * Note: We haven't moved all the "act on new configuration" logic
  * here yet.  Some is still in do_hup() and other places.
  */
-static int
+STATIC int
 options_act(const or_options_t *old_options)
 {
   config_line_t *cl;
@@ -1390,10 +1466,12 @@ options_act(const or_options_t *old_options)
     if (options->DisableDebuggerAttachment && !disabled_debugger_attach &&
         running_tor) {
       int ok = tor_disable_debugger_attach();
+      /* LCOV_EXCL_START the warned_debugger_attach is 0 can't reach inside. */
       if (warned_debugger_attach && ok == 1) {
         log_notice(LD_CONFIG, "Disabled attaching debuggers for unprivileged "
                    "users.");
       }
+      /* LCOV_EXCL_STOP */
       disabled_debugger_attach = (ok == 1);
     } else if (!options->DisableDebuggerAttachment &&
                !warned_debugger_attach) {
@@ -1420,12 +1498,14 @@ options_act(const or_options_t *old_options)
 #endif
 
 #ifdef ENABLE_TOR2WEB_MODE
+/* LCOV_EXCL_START */
   if (!options->Tor2webMode) {
     log_err(LD_CONFIG, "This copy of Tor was compiled to run in "
             "'tor2web mode'. It can only be run with the Tor2webMode torrc "
             "option enabled.");
     return -1;
   }
+/* LCOV_EXCL_STOP */
 #else
   if (options->Tor2webMode) {
     log_err(LD_CONFIG, "This copy of Tor was not compiled to run in "
@@ -1437,7 +1517,7 @@ options_act(const or_options_t *old_options)
 #endif
 
   /* If we are a bridge with a pluggable transport proxy but no
-     Extended ORPort, inform the user that she is missing out. */
+     Extended ORPort, inform the user that they are missing out. */
   if (server_mode(options) && options->ServerTransportPlugin &&
       !options->ExtORPort_lines) {
     log_notice(LD_CONFIG, "We use pluggable transports but the Extended "
@@ -1689,8 +1769,8 @@ options_act(const or_options_t *old_options)
     if (revise_trackexithosts)
       addressmap_clear_excluded_trackexithosts(options);
 
-    if (!options->AutomapHostsOnResolve) {
-      if (old_options->AutomapHostsOnResolve)
+    if (!options->AutomapHostsOnResolve &&
+        old_options->AutomapHostsOnResolve) {
         revise_automap_entries = 1;
     } else {
       if (!smartlist_strings_eq(old_options->AutomapHostsSuffixes,
@@ -1829,8 +1909,8 @@ options_act(const or_options_t *old_options)
       print_notice = 1;
     }
     if (print_notice)
-      log_notice(LD_CONFIG, "Configured to measure statistics. Look for "
-                 "the *-stats files that will first be written to the "
+        log_notice(LD_CONFIG, "Configured to measure statistics. Look for "
+                "the *-stats files that will first be written to the "
                  "data directory in 24 hours from now.");
   }
 
@@ -3380,8 +3460,30 @@ options_validate(or_options_t *old_options, or_options_t *options,
       options->AccountingRule = ACCT_SUM;
     else if (!strcmp(options->AccountingRule_option, "max"))
       options->AccountingRule = ACCT_MAX;
+    else if (!strcmp(options->AccountingRule_option, "in"))
+      options->AccountingRule = ACCT_IN;
+    else if (!strcmp(options->AccountingRule_option, "out"))
+      options->AccountingRule = ACCT_OUT;
     else
-      REJECT("AccountingRule must be 'sum' or 'max'");
+      REJECT("AccountingRule must be 'sum', 'max', 'in', or 'out'");
+  }
+
+  if (options->DirPort_set && !options->DirCache) {
+    REJECT("DirPort configured but DirCache disabled. DirPort requires "
+           "DirCache.");
+  }
+
+  if (options->BridgeRelay && !options->DirCache) {
+    REJECT("We're a bridge but DirCache is disabled. BridgeRelay requires "
+           "DirCache.");
+  }
+
+  if (server_mode(options)) {
+    char *msg = NULL;
+    if (have_enough_mem_for_dircache(options, 0, &msg)) {
+      log_warn(LD_CONFIG, "%s", msg);
+      tor_free(msg);
+    }
   }
 
   if (options->HTTPProxy) { /* parse it now */
@@ -3532,6 +3634,13 @@ options_validate(or_options_t *old_options, or_options_t *options,
   if (validate_addr_policies(options, msg) < 0)
     return -1;
 
+  /* If FallbackDir is set, we don't UseDefaultFallbackDirs */
+  if (options->UseDefaultFallbackDirs && options->FallbackDir) {
+    log_info(LD_CONFIG, "You have set UseDefaultFallbackDirs 1 and "
+             "FallbackDir(s). Ignoring UseDefaultFallbackDirs, and "
+             "using the FallbackDir(s) you have set.");
+  }
+
   if (validate_dir_servers(options, old_options) < 0)
     REJECT("Directory authority/fallback line did not parse. See logs "
            "for details.");
@@ -3734,10 +3843,16 @@ options_validate(or_options_t *old_options, or_options_t *options,
   CHECK_DEFAULT(TestingClientDownloadSchedule);
   CHECK_DEFAULT(TestingServerConsensusDownloadSchedule);
   CHECK_DEFAULT(TestingClientConsensusDownloadSchedule);
+  CHECK_DEFAULT(TestingClientBootstrapConsensusAuthorityDownloadSchedule);
+  CHECK_DEFAULT(TestingClientBootstrapConsensusFallbackDownloadSchedule);
+  CHECK_DEFAULT(TestingClientBootstrapConsensusAuthorityOnlyDownloadSchedule);
   CHECK_DEFAULT(TestingBridgeDownloadSchedule);
   CHECK_DEFAULT(TestingClientMaxIntervalWithoutRequest);
   CHECK_DEFAULT(TestingDirConnectionMaxStall);
   CHECK_DEFAULT(TestingConsensusMaxDownloadTries);
+  CHECK_DEFAULT(TestingClientBootstrapConsensusMaxDownloadTries);
+  CHECK_DEFAULT(TestingClientBootstrapConsensusAuthorityOnlyMaxDownloadTries);
+  CHECK_DEFAULT(TestingClientBootstrapConsensusMaxInProgressTries);
   CHECK_DEFAULT(TestingDescriptorMaxDownloadTries);
   CHECK_DEFAULT(TestingMicrodescMaxDownloadTries);
   CHECK_DEFAULT(TestingCertMaxDownloadTries);
@@ -3812,11 +3927,41 @@ options_validate(or_options_t *old_options, or_options_t *options,
   }
 
   if (options->TestingConsensusMaxDownloadTries < 2) {
-    REJECT("TestingConsensusMaxDownloadTries must be greater than 1.");
+    REJECT("TestingConsensusMaxDownloadTries must be greater than 2.");
   } else if (options->TestingConsensusMaxDownloadTries > 800) {
     COMPLAIN("TestingConsensusMaxDownloadTries is insanely high.");
   }
 
+  if (options->TestingClientBootstrapConsensusMaxDownloadTries < 2) {
+    REJECT("TestingClientBootstrapConsensusMaxDownloadTries must be greater "
+           "than 2."
+           );
+  } else if (options->TestingClientBootstrapConsensusMaxDownloadTries > 800) {
+    COMPLAIN("TestingClientBootstrapConsensusMaxDownloadTries is insanely "
+             "high.");
+  }
+
+  if (options->TestingClientBootstrapConsensusAuthorityOnlyMaxDownloadTries
+      < 2) {
+    REJECT("TestingClientBootstrapConsensusAuthorityOnlyMaxDownloadTries must "
+           "be greater than 2."
+           );
+  } else if (
+        options->TestingClientBootstrapConsensusAuthorityOnlyMaxDownloadTries
+        > 800) {
+    COMPLAIN("TestingClientBootstrapConsensusAuthorityOnlyMaxDownloadTries is "
+             "insanely high.");
+  }
+
+  if (options->TestingClientBootstrapConsensusMaxInProgressTries < 1) {
+    REJECT("TestingClientBootstrapConsensusMaxInProgressTries must be greater "
+           "than 0.");
+  } else if (options->TestingClientBootstrapConsensusMaxInProgressTries
+             > 100) {
+    COMPLAIN("TestingClientBootstrapConsensusMaxInProgressTries is insanely "
+             "high.");
+  }
+
   if (options->TestingDescriptorMaxDownloadTries < 2) {
     REJECT("TestingDescriptorMaxDownloadTries must be greater than 1.");
   } else if (options->TestingDescriptorMaxDownloadTries > 800) {
@@ -3949,6 +4094,52 @@ compute_real_max_mem_in_queues(const uint64_t val, int log_guess)
   }
 }
 
+/* If we have less than 300 MB suggest disabling dircache */
+#define DIRCACHE_MIN_MB_BANDWIDTH 300
+#define DIRCACHE_MIN_BANDWIDTH (DIRCACHE_MIN_MB_BANDWIDTH*ONE_MEGABYTE)
+#define STRINGIFY(val) #val
+
+/** Create a warning message for emitting if we are a dircache but may not have
+ * enough system memory, or if we are not a dircache but probably should be.
+ * Return -1 when a message is returned in *msg*, else return 0. */
+STATIC int
+have_enough_mem_for_dircache(const or_options_t *options, size_t total_mem,
+                             char **msg)
+{
+  *msg = NULL;
+  /* XXX We should possibly be looking at MaxMemInQueues here
+   * unconditionally.  Or we should believe total_mem unconditionally. */
+  if (total_mem == 0) {
+    if (get_total_system_memory(&total_mem) < 0) {
+      total_mem = options->MaxMemInQueues >= SIZE_MAX ?
+        SIZE_MAX : (size_t)options->MaxMemInQueues;
+    }
+  }
+  if (options->DirCache) {
+    if (total_mem < DIRCACHE_MIN_BANDWIDTH) {
+      if (options->BridgeRelay) {
+        *msg = strdup("Running a Bridge with less than "
+                      STRINGIFY(DIRCACHE_MIN_MB_BANDWIDTH) " MB of memory is "
+                      "not recommended.");
+      } else {
+        *msg = strdup("Being a directory cache (default) with less than "
+                      STRINGIFY(DIRCACHE_MIN_MB_BANDWIDTH) " MB of memory is "
+                      "not recommended and may consume most of the available "
+                      "resources, consider disabling this functionality by "
+                      "setting the DirCache option to 0.");
+      }
+    }
+  } else {
+    if (total_mem >= DIRCACHE_MIN_BANDWIDTH) {
+      *msg = strdup("DirCache is disabled and we are configured as a "
+               "relay. This may disqualify us from becoming a guard in the "
+               "future.");
+    }
+  }
+  return *msg == NULL ? 0 : -1;
+}
+#undef STRINGIFY
+
 /** Helper: return true iff s1 and s2 are both NULL, or both non-NULL
  * equal strings. */
 static int
@@ -3996,6 +4187,18 @@ options_transition_allowed(const or_options_t *old,
     return -1;
   }
 
+  if (old->KeepBindCapabilities != new_val->KeepBindCapabilities) {
+    *msg = tor_strdup("While Tor is running, changing KeepBindCapabilities is "
+                      "not allowed.");
+    return -1;
+  }
+
+  if (!opt_streq(old->SyslogIdentityTag, new_val->SyslogIdentityTag)) {
+    *msg = tor_strdup("While Tor is running, changing "
+                      "SyslogIdentityTag is not allowed.");
+    return -1;
+  }
+
   if ((old->HardwareAccel != new_val->HardwareAccel)
       || !opt_streq(old->AccelName, new_val->AccelName)
       || !opt_streq(old->AccelDir, new_val->AccelDir)) {
@@ -4125,7 +4328,8 @@ options_transition_affects_descriptor(const or_options_t *old_options,
       !opt_streq(old_options->MyFamily, new_options->MyFamily) ||
       !opt_streq(old_options->AccountingStart, new_options->AccountingStart) ||
       old_options->AccountingMax != new_options->AccountingMax ||
-      public_server_mode(old_options) != public_server_mode(new_options))
+      public_server_mode(old_options) != public_server_mode(new_options) ||
+      old_options->DirCache != new_options->DirCache)
     return 1;
 
   return 0;
@@ -4937,7 +5141,7 @@ options_init_logs(const or_options_t *old_options, or_options_t *options,
         !strcasecmp(smartlist_get(elts,0), "syslog")) {
 #ifdef HAVE_SYSLOG_H
       if (!validate_only) {
-        add_syslog_log(severity);
+        add_syslog_log(severity, options->SyslogIdentityTag);
       }
 #else
       log_warn(LD_CONFIG, "Syslog is not supported on this system. Sorry.");
@@ -5510,13 +5714,14 @@ get_options_for_server_transport(const char *transport)
  * (minus whatever bits it's missing) as a valid authority.
  * Return 0 on success or filtering out by type,
  * or -1 if the line isn't well-formed or if we can't add it. */
-static int
+STATIC int
 parse_dir_authority_line(const char *line, dirinfo_type_t required_type,
                          int validate_only)
 {
   smartlist_t *items = NULL;
   int r;
   char *addrport=NULL, *address=NULL, *nickname=NULL, *fingerprint=NULL;
+  tor_addr_port_t ipv6_addrport, *ipv6_addrport_ptr = NULL;
   uint16_t dir_port = 0, or_port = 0;
   char digest[DIGEST_LEN];
   char v3_digest[DIGEST_LEN];
@@ -5573,6 +5778,20 @@ parse_dir_authority_line(const char *line, dirinfo_type_t required_type,
       } else {
         type |= V3_DIRINFO|EXTRAINFO_DIRINFO|MICRODESC_DIRINFO;
       }
+    } else if (!strcasecmpstart(flag, "ipv6=")) {
+      if (ipv6_addrport_ptr) {
+        log_warn(LD_CONFIG, "Redundant ipv6 addr/port on DirAuthority line");
+      } else {
+        if (tor_addr_port_parse(LOG_WARN, flag+strlen("ipv6="),
+                                &ipv6_addrport.addr, &ipv6_addrport.port,
+                                -1) < 0
+            || tor_addr_family(&ipv6_addrport.addr) != AF_INET6) {
+          log_warn(LD_CONFIG, "Bad ipv6 addr/port %s on DirAuthority line",
+                   escaped(flag));
+          goto err;
+        }
+        ipv6_addrport_ptr = &ipv6_addrport;
+      }
     } else {
       log_warn(LD_CONFIG, "Unrecognized flag '%s' on DirAuthority line",
                flag);
@@ -5615,6 +5834,7 @@ parse_dir_authority_line(const char *line, dirinfo_type_t required_type,
     log_debug(LD_DIR, "Trusted %d dirserver at %s:%d (%s)", (int)type,
               address, (int)dir_port, (char*)smartlist_get(items,0));
     if (!(ds = trusted_dir_server_new(nickname, address, dir_port, or_port,
+                                      ipv6_addrport_ptr,
                                       digest, v3_digest, type, weight)))
       goto err;
     dir_server_add(ds);
@@ -5652,6 +5872,7 @@ parse_dir_fallback_line(const char *line,
   int ok;
   char id[DIGEST_LEN];
   char *address=NULL;
+  tor_addr_port_t ipv6_addrport, *ipv6_addrport_ptr = NULL;
   double weight=1.0;
 
   memset(id, 0, sizeof(id));
@@ -5670,6 +5891,20 @@ parse_dir_fallback_line(const char *line,
     } else if (!strcmpstart(cp, "id=")) {
       ok = !base16_decode(id, DIGEST_LEN,
                           cp+strlen("id="), strlen(cp)-strlen("id="));
+    } else if (!strcasecmpstart(cp, "ipv6=")) {
+      if (ipv6_addrport_ptr) {
+        log_warn(LD_CONFIG, "Redundant ipv6 addr/port on FallbackDir line");
+      } else {
+        if (tor_addr_port_parse(LOG_WARN, cp+strlen("ipv6="),
+                                &ipv6_addrport.addr, &ipv6_addrport.port,
+                                -1) < 0
+            || tor_addr_family(&ipv6_addrport.addr) != AF_INET6) {
+          log_warn(LD_CONFIG, "Bad ipv6 addr/port %s on FallbackDir line",
+                   escaped(cp));
+          goto end;
+        }
+        ipv6_addrport_ptr = &ipv6_addrport;
+      }
     } else if (!strcmpstart(cp, "weight=")) {
       int ok;
       const char *wstring = cp + strlen("weight=");
@@ -5711,7 +5946,8 @@ parse_dir_fallback_line(const char *line,
 
   if (!validate_only) {
     dir_server_t *ds;
-    ds = fallback_dir_server_new(&addr, dirport, orport, id, weight);
+    ds = fallback_dir_server_new(&addr, dirport, orport, ipv6_addrport_ptr,
+                                 id, weight);
     if (!ds) {
       log_warn(LD_CONFIG, "Couldn't create FallbackDir %s", escaped(line));
       goto end;
@@ -5730,7 +5966,7 @@ parse_dir_fallback_line(const char *line,
 }
 
 /** Allocate and return a new port_cfg_t with reasonable defaults. */
-static port_cfg_t *
+STATIC port_cfg_t *
 port_cfg_new(size_t namelen)
 {
   tor_assert(namelen <= SIZE_T_CEILING - sizeof(port_cfg_t) - 1);
@@ -5742,7 +5978,7 @@ port_cfg_new(size_t namelen)
 }
 
 /** Free all storage held in <b>port</b> */
-static void
+STATIC void
 port_cfg_free(port_cfg_t *port)
 {
   tor_free(port);
@@ -5796,9 +6032,9 @@ warn_nonlocal_ext_orports(const smartlist_t *ports, const char *portname)
   } SMARTLIST_FOREACH_END(port);
 }
 
-/** Given a list of port_cfg_t in <b>ports</b>, warn any controller port there
- * is listening on any non-loopback address.  If <b>forbid_nonlocal</b> is
- * true, then emit a stronger warning and remove the port from the list.
+/** Given a list of port_cfg_t in <b>ports</b>, warn if any controller port
+ * there is listening on any non-loopback address.  If <b>forbid_nonlocal</b>
+ * is true, then emit a stronger warning and remove the port from the list.
  */
 static void
 warn_nonlocal_controller_ports(smartlist_t *ports, unsigned forbid_nonlocal)
@@ -5838,15 +6074,6 @@ warn_nonlocal_controller_ports(smartlist_t *ports, unsigned forbid_nonlocal)
   } SMARTLIST_FOREACH_END(port);
 }
 
-#define CL_PORT_NO_STREAM_OPTIONS (1u<<0)
-#define CL_PORT_WARN_NONLOCAL (1u<<1)
-#define CL_PORT_ALLOW_EXTRA_LISTENADDR (1u<<2)
-#define CL_PORT_SERVER_OPTIONS (1u<<3)
-#define CL_PORT_FORBID_NONLOCAL (1u<<4)
-#define CL_PORT_TAKES_HOSTNAMES (1u<<5)
-#define CL_PORT_IS_UNIXSOCKET (1u<<6)
-#define CL_PORT_DFLT_GROUP_WRITABLE (1u<<7)
-
 #ifdef HAVE_SYS_UN_H
 
 /** Parse the given <b>addrport</b> and set <b>path_out</b> if a Unix socket
@@ -5934,7 +6161,7 @@ config_parse_unix_port(const char *addrport, char **path_out)
  * <b>out</b> for every port that the client should listen on.  Return 0
  * on success, -1 on failure.
  */
-static int
+STATIC int
 parse_port_config(smartlist_t *out,
                   const config_line_t *ports,
                   const config_line_t *listenaddrs,
@@ -6140,7 +6367,7 @@ parse_port_config(smartlist_t *out,
         }
         port = ptmp;
       } else {
-        log_warn(LD_CONFIG, "Couldn't parse address '%s' for %sPort",
+        log_warn(LD_CONFIG, "Couldn't parse address %s for %sPort",
                  escaped(addrport), portname);
         goto err;
       }
@@ -6528,10 +6755,13 @@ parse_ports(or_options_t *options, int validate_only,
     }
   }
 
-  if (check_server_ports(ports, options) < 0) {
+  int n_low_ports = 0;
+  if (check_server_ports(ports, options, &n_low_ports) < 0) {
     *msg = tor_strdup("Misconfigured server ports");
     goto err;
   }
+  if (have_low_ports < 0)
+    have_low_ports = (n_low_ports > 0);
 
   *n_ports_out = smartlist_len(ports);
 
@@ -6585,10 +6815,12 @@ parse_ports(or_options_t *options, int validate_only,
 }
 
 /** Given a list of <b>port_cfg_t</b> in <b>ports</b>, check them for internal
- * consistency and warn as appropriate. */
+ * consistency and warn as appropriate.  Set *<b>n_low_ports_out</b> to the
+ * number of sub-1024 ports we will be binding. */
 static int
 check_server_ports(const smartlist_t *ports,
-                   const or_options_t *options)
+                   const or_options_t *options,
+                   int *n_low_ports_out)
 {
   int n_orport_advertised = 0;
   int n_orport_advertised_ipv4 = 0;
@@ -6651,23 +6883,31 @@ check_server_ports(const smartlist_t *ports,
     r = -1;
   }
 
-  if (n_low_port && options->AccountingMax) {
+  if (n_low_port && options->AccountingMax &&
+      (!have_capability_support() || options->KeepBindCapabilities == 0)) {
+    const char *extra = "";
+    if (options->KeepBindCapabilities == 0 && have_capability_support())
+      extra = ", and you have disabled KeepBindCapabilities.";
     log_warn(LD_CONFIG,
           "You have set AccountingMax to use hibernation. You have also "
-          "chosen a low DirPort or OrPort. This combination can make Tor stop "
+          "chosen a low DirPort or OrPort%s."
+          "This combination can make Tor stop "
           "working when it tries to re-attach the port after a period of "
           "hibernation. Please choose a different port or turn off "
           "hibernation unless you know this combination will work on your "
-          "platform.");
+          "platform.", extra);
   }
 
+  if (n_low_ports_out)
+    *n_low_ports_out = n_low_port;
+
   return r;
 }
 
 /** Return a list of port_cfg_t for client ports parsed from the
  * options. */
-const smartlist_t *
-get_configured_ports(void)
+MOCK_IMPL(const smartlist_t *,
+get_configured_ports,(void))
 {
   if (!configured_ports)
     configured_ports = smartlist_new();
@@ -7151,7 +7391,7 @@ getinfo_helper_config(control_connection_t *conn,
     smartlist_free(sl);
   } else if (!strcmp(question, "config/defaults")) {
     smartlist_t *sl = smartlist_new();
-    int i, dirauth_lines_seen = 0;
+    int i, dirauth_lines_seen = 0, fallback_lines_seen = 0;
     for (i = 0; option_vars_[i].name; ++i) {
       const config_var_t *var = &option_vars_[i];
       if (var->initvalue != NULL) {
@@ -7162,6 +7402,13 @@ getinfo_helper_config(control_connection_t *conn,
            */
           ++dirauth_lines_seen;
         }
+        if (strcmp(option_vars_[i].name, "FallbackDir") == 0) {
+          /*
+           * Similarly count fallback lines, so that we can decided later
+           * to add the defaults manually.
+           */
+          ++fallback_lines_seen;
+        }
         char *val = esc_for_log(var->initvalue);
         smartlist_add_asprintf(sl, "%s %s\n",var->name,val);
         tor_free(val);
@@ -7187,6 +7434,24 @@ getinfo_helper_config(control_connection_t *conn,
       }
     }
 
+    if (fallback_lines_seen == 0 &&
+        get_options()->UseDefaultFallbackDirs == 1) {
+      /*
+       * We didn't see any explicitly configured fallback mirrors,
+       * so add the defaults to the list manually.
+       *
+       * default_fallbacks is included earlier in this file and
+       * is a const char ** NULL-terminated array of fallback config lines.
+       */
+      const char **i;
+
+      for (i = default_fallbacks; *i != NULL; ++i) {
+        char *val = esc_for_log(*i);
+        smartlist_add_asprintf(sl, "FallbackDir %s\n", val);
+        tor_free(val);
+      }
+    }
+
     *answer = smartlist_join_strings(sl, "", 0, NULL);
     SMARTLIST_FOREACH(sl, char *, c, tor_free(c));
     smartlist_free(sl);
@@ -7329,8 +7594,7 @@ init_cookie_authentication(const char *fname, const char *header,
 
   /* Generate the cookie */
   *cookie_out = tor_malloc(cookie_len);
-  if (crypto_rand((char *)*cookie_out, cookie_len) < 0)
-    goto done;
+  crypto_rand((char *)*cookie_out, cookie_len);
 
   /* Create the string that should be written on the file. */
   memcpy(cookie_file_str, header, strlen(header));
diff --git a/src/or/config.h b/src/or/config.h
index 0ee1e1a..c7ce57d 100644
--- a/src/or/config.h
+++ b/src/or/config.h
@@ -14,9 +14,9 @@
 
 #include "testsupport.h"
 
-const char *get_dirportfrontpage(void);
-MOCK_DECL(const or_options_t *,get_options,(void));
-or_options_t *get_options_mutable(void);
+MOCK_DECL(const char*, get_dirportfrontpage, (void));
+MOCK_DECL(const or_options_t *, get_options, (void));
+MOCK_DECL(or_options_t *, get_options_mutable, (void));
 int set_options(or_options_t *new_val, char **msg);
 void config_free_all(void);
 const char *safe_str_client(const char *address);
@@ -76,7 +76,7 @@ int write_to_data_subdir(const char* subdir, const char* fname,
 
 int get_num_cpus(const or_options_t *options);
 
-const smartlist_t *get_configured_ports(void);
+MOCK_DECL(const smartlist_t *,get_configured_ports,(void));
 int get_first_advertised_port_by_type_af(int listener_type,
                                          int address_family);
 #define get_primary_or_port() \
@@ -136,10 +136,23 @@ smartlist_t *get_options_from_transport_options_line(const char *line,
 smartlist_t *get_options_for_server_transport(const char *transport);
 
 #ifdef CONFIG_PRIVATE
+
+#define CL_PORT_NO_STREAM_OPTIONS (1u<<0)
+#define CL_PORT_WARN_NONLOCAL (1u<<1)
+#define CL_PORT_ALLOW_EXTRA_LISTENADDR (1u<<2)
+#define CL_PORT_SERVER_OPTIONS (1u<<3)
+#define CL_PORT_FORBID_NONLOCAL (1u<<4)
+#define CL_PORT_TAKES_HOSTNAMES (1u<<5)
+#define CL_PORT_IS_UNIXSOCKET (1u<<6)
+#define CL_PORT_DFLT_GROUP_WRITABLE (1u<<7)
+
+STATIC int options_act(const or_options_t *old_options);
 #ifdef TOR_UNIT_TESTS
 extern struct config_format_t options_format;
 #endif
 
+STATIC port_cfg_t *port_cfg_new(size_t namelen);
+STATIC void port_cfg_free(port_cfg_t *port);
 STATIC void or_options_free(or_options_t *options);
 STATIC int options_validate(or_options_t *old_options,
                             or_options_t *options,
@@ -150,10 +163,22 @@ STATIC int parse_transport_line(const or_options_t *options,
                                 int server);
 STATIC int consider_adding_dir_servers(const or_options_t *options,
                                        const or_options_t *old_options);
+STATIC void add_default_trusted_dir_authorities(dirinfo_type_t type);
 MOCK_DECL(STATIC void, add_default_fallback_dir_servers, (void));
-STATIC int
-parse_dir_fallback_line(const char *line,
-                        int validate_only);
+STATIC int parse_dir_authority_line(const char *line,
+                                    dirinfo_type_t required_type,
+                                    int validate_only);
+STATIC int parse_dir_fallback_line(const char *line, int validate_only);
+STATIC int have_enough_mem_for_dircache(const or_options_t *options,
+                                        size_t total_mem, char **msg);
+STATIC int parse_port_config(smartlist_t *out,
+                  const config_line_t *ports,
+                  const config_line_t *listenaddrs,
+                  const char *portname,
+                  int listener_type,
+                  const char *defaultaddr,
+                  int defaultport,
+                  const unsigned flags);
 #endif
 
 #endif
diff --git a/src/or/connection.c b/src/or/connection.c
index 78176d3..123c33a 100644
--- a/src/or/connection.c
+++ b/src/or/connection.c
@@ -678,6 +678,13 @@ connection_free,(connection_t *conn))
   if (conn->type == CONN_TYPE_CONTROL) {
     connection_control_closed(TO_CONTROL_CONN(conn));
   }
+#if 1
+  /* DEBUGGING */
+  if (conn->type == CONN_TYPE_AP) {
+    connection_ap_warn_and_unmark_if_pending_circ(TO_ENTRY_CONN(conn),
+                                                  "connection_free");
+  }
+#endif
   connection_unregister_events(conn);
   connection_free_(conn);
 }
@@ -1128,11 +1135,12 @@ connection_listener_new(const struct sockaddr *listensockaddr,
                tor_socket_strerror(errno));
     }
 
-#if defined USE_TRANSPARENT && defined(IP_TRANSPARENT)
+#if defined(USE_TRANSPARENT) && defined(IP_TRANSPARENT)
     if (options->TransProxyType_parsed == TPT_TPROXY &&
         type == CONN_TYPE_AP_TRANS_LISTENER) {
       int one = 1;
-      if (setsockopt(s, SOL_IP, IP_TRANSPARENT, &one, sizeof(one)) < 0) {
+      if (setsockopt(s, SOL_IP, IP_TRANSPARENT, (void*)&one,
+                     (socklen_t)sizeof(one)) < 0) {
         const char *extra = "";
         int e = tor_socket_errno(s);
         if (e == EPERM)
@@ -1146,16 +1154,11 @@ connection_listener_new(const struct sockaddr *listensockaddr,
 
 #ifdef IPV6_V6ONLY
     if (listensockaddr->sa_family == AF_INET6) {
-#ifdef _WIN32
-      /* In Redmond, this kind of thing passes for standards-conformance. */
-      DWORD one = 1;
-#else
       int one = 1;
-#endif
       /* We need to set IPV6_V6ONLY so that this socket can't get used for
        * IPv4 connections. */
       if (setsockopt(s,IPPROTO_IPV6, IPV6_V6ONLY,
-                     (void*)&one, sizeof(one)) < 0) {
+                     (void*)&one, (socklen_t)sizeof(one)) < 0) {
         int e = tor_socket_errno(s);
         log_warn(LD_NET, "Error setting IPV6_V6ONLY flag: %s",
                  tor_socket_strerror(e));
@@ -1437,7 +1440,7 @@ connection_handle_listener_read(connection_t *conn, int new_type)
   if (!SOCKET_OK(news)) { /* accept() error */
     int e = tor_socket_errno(conn->s);
     if (ERRNO_IS_ACCEPT_EAGAIN(e)) {
-      return 0; /* he hung up before we could accept(). that's fine. */
+      return 0; /* they hung up before we could accept(). that's fine. */
     } else if (ERRNO_IS_RESOURCE_LIMIT(e)) {
       warn_too_many_conns();
       return 0;
@@ -1597,6 +1600,8 @@ connection_init_accepted_conn(connection_t *conn,
           break;
         case CONN_TYPE_AP_TRANS_LISTENER:
           TO_ENTRY_CONN(conn)->is_transparent_ap = 1;
+          /* XXXX028 -- is this correct still, with the addition of
+           * pending_entry_connections ? */
           conn->state = AP_CONN_STATE_CIRCUIT_WAIT;
           return connection_ap_process_transparent(TO_ENTRY_CONN(conn));
         case CONN_TYPE_AP_NATD_LISTENER:
@@ -1616,13 +1621,18 @@ connection_init_accepted_conn(connection_t *conn,
   return 0;
 }
 
-static int
-connection_connect_sockaddr(connection_t *conn,
+/** Take conn, make a nonblocking socket; try to connect to
+ * sa, binding to bindaddr if sa is not localhost. If fail, return -1 and if
+ * applicable put your best guess about errno into *<b>socket_error</b>.
+ * If connected return 1, if EAGAIN return 0.
+ */
+MOCK_IMPL(STATIC int,
+connection_connect_sockaddr,(connection_t *conn,
                             const struct sockaddr *sa,
                             socklen_t sa_len,
                             const struct sockaddr *bindaddr,
                             socklen_t bindaddr_len,
-                            int *socket_error)
+                            int *socket_error))
 {
   tor_socket_t s;
   int inprogress = 0;
@@ -1706,10 +1716,13 @@ connection_connect_sockaddr(connection_t *conn,
 }
 
 /** Take conn, make a nonblocking socket; try to connect to
- * addr:port (they arrive in *host order*). If fail, return -1 and if
+ * addr:port (port arrives in *host order*). If fail, return -1 and if
  * applicable put your best guess about errno into *<b>socket_error</b>.
  * Else assign s to conn-\>s: if connected return 1, if EAGAIN return 0.
  *
+ * addr:port can be different to conn->addr:conn->port if connecting through
+ * a proxy.
+ *
  * address is used to make the logs useful.
  *
  * On success, add conn to the list of polled connections.
@@ -2381,6 +2394,14 @@ retry_listener_ports(smartlist_t *old_conns,
     if (port->server_cfg.no_listen)
       continue;
 
+#ifndef _WIN32
+    /* We don't need to be root to create a UNIX socket, so defer until after
+     * setuid. */
+    const or_options_t *options = get_options();
+    if (port->is_unix_addr && !geteuid() && strcmp(options->User, "root"))
+      continue;
+#endif
+
     if (port->is_unix_addr) {
       listensockaddr = (struct sockaddr *)
         create_unix_sockaddr(port->unix_addr,
@@ -3585,7 +3606,7 @@ connection_read_to_buf(connection_t *conn, ssize_t *max_to_read,
   }
 
   /* Call even if result is 0, since the global read bucket may
-   * have reached 0 on a different conn, and this guy needs to
+   * have reached 0 on a different conn, and this connection needs to
    * know to stop reading. */
   connection_consider_empty_read_buckets(conn);
   if (n_written > 0 && connection_is_writing(conn))
@@ -4081,7 +4102,7 @@ connection_handle_write_impl(connection_t *conn, int force)
   }
 
   /* Call even if result is 0, since the global write bucket may
-   * have reached 0 on a different conn, and this guy needs to
+   * have reached 0 on a different conn, and this connection needs to
    * know to stop writing. */
   connection_consider_empty_write_buckets(conn);
   if (n_read > 0 && connection_is_reading(conn))
@@ -4209,24 +4230,32 @@ connection_write_to_buf_impl_,(const char *string, size_t len,
   }
 }
 
+/** Return a connection_t * from get_connection_array() that satisfies test on
+ * var, and that is not marked for close. */
+#define CONN_GET_TEMPLATE(var, test)               \
+  STMT_BEGIN                                       \
+    smartlist_t *conns = get_connection_array();   \
+    SMARTLIST_FOREACH(conns, connection_t *, var,  \
+    {                                              \
+      if (var && (test) && !var->marked_for_close) \
+        return var;                                \
+    });                                            \
+    return NULL;                                   \
+  STMT_END
+
 /** Return a connection with given type, address, port, and purpose;
- * or NULL if no such connection exists. */
+ * or NULL if no such connection exists (or if all such connections are marked
+ * for close). */
 connection_t *
 connection_get_by_type_addr_port_purpose(int type,
                                          const tor_addr_t *addr, uint16_t port,
                                          int purpose)
 {
-  smartlist_t *conns = get_connection_array();
-  SMARTLIST_FOREACH(conns, connection_t *, conn,
-  {
-    if (conn->type == type &&
+  CONN_GET_TEMPLATE(conn,
+       (conn->type == type &&
         tor_addr_eq(&conn->addr, addr) &&
         conn->port == port &&
-        conn->purpose == purpose &&
-        !conn->marked_for_close)
-      return conn;
-  });
-  return NULL;
+        conn->purpose == purpose));
 }
 
 /** Return the stream with id <b>id</b> if it is not already marked for
@@ -4235,13 +4264,7 @@ connection_get_by_type_addr_port_purpose(int type,
 connection_t *
 connection_get_by_global_id(uint64_t id)
 {
-  smartlist_t *conns = get_connection_array();
-  SMARTLIST_FOREACH(conns, connection_t *, conn,
-  {
-    if (conn->global_identifier == id)
-      return conn;
-  });
-  return NULL;
+  CONN_GET_TEMPLATE(conn, conn->global_identifier == id);
 }
 
 /** Return a connection of type <b>type</b> that is not marked for close.
@@ -4249,13 +4272,7 @@ connection_get_by_global_id(uint64_t id)
 connection_t *
 connection_get_by_type(int type)
 {
-  smartlist_t *conns = get_connection_array();
-  SMARTLIST_FOREACH(conns, connection_t *, conn,
-  {
-    if (conn->type == type && !conn->marked_for_close)
-      return conn;
-  });
-  return NULL;
+  CONN_GET_TEMPLATE(conn, conn->type == type);
 }
 
 /** Return a connection of type <b>type</b> that is in state <b>state</b>,
@@ -4264,13 +4281,7 @@ connection_get_by_type(int type)
 connection_t *
 connection_get_by_type_state(int type, int state)
 {
-  smartlist_t *conns = get_connection_array();
-  SMARTLIST_FOREACH(conns, connection_t *, conn,
-  {
-    if (conn->type == type && conn->state == state && !conn->marked_for_close)
-      return conn;
-  });
-  return NULL;
+  CONN_GET_TEMPLATE(conn, conn->type == type && conn->state == state);
 }
 
 /** Return a connection of type <b>type</b> that has rendquery equal
@@ -4281,55 +4292,141 @@ connection_t *
 connection_get_by_type_state_rendquery(int type, int state,
                                        const char *rendquery)
 {
-  smartlist_t *conns = get_connection_array();
-
   tor_assert(type == CONN_TYPE_DIR ||
              type == CONN_TYPE_AP || type == CONN_TYPE_EXIT);
   tor_assert(rendquery);
 
-  SMARTLIST_FOREACH_BEGIN(conns, connection_t *, conn) {
-    if (conn->type == type &&
-        !conn->marked_for_close &&
-        (!state || state == conn->state)) {
-      if (type == CONN_TYPE_DIR &&
+  CONN_GET_TEMPLATE(conn,
+       (conn->type == type &&
+        (!state || state == conn->state)) &&
+        (
+         (type == CONN_TYPE_DIR &&
           TO_DIR_CONN(conn)->rend_data &&
           !rend_cmp_service_ids(rendquery,
                                 TO_DIR_CONN(conn)->rend_data->onion_address))
-        return conn;
-      else if (CONN_IS_EDGE(conn) &&
+         ||
+              (CONN_IS_EDGE(conn) &&
                TO_EDGE_CONN(conn)->rend_data &&
                !rend_cmp_service_ids(rendquery,
                             TO_EDGE_CONN(conn)->rend_data->onion_address))
-        return conn;
-    }
-  } SMARTLIST_FOREACH_END(conn);
-  return NULL;
+         ));
 }
 
+#define CONN_FIRST_AND_FREE_TEMPLATE(sl)       \
+  STMT_BEGIN                                   \
+    if (smartlist_len(sl) > 0) {               \
+      void *first_item = smartlist_get(sl, 0); \
+      smartlist_free(sl);                      \
+      return first_item;                       \
+    } else {                                   \
+      smartlist_free(sl);                      \
+      return NULL;                             \
+    }                                          \
+  STMT_END
+
 /** Return a directory connection (if any one exists) that is fetching
- * the item described by <b>state</b>/<b>resource</b> */
+ * the item described by <b>purpose</b>/<b>resource</b>, otherwise return NULL.
+ */
 dir_connection_t *
-connection_dir_get_by_purpose_and_resource(int purpose,
+connection_dir_get_by_purpose_and_resource(
+                                           int purpose,
                                            const char *resource)
 {
-  smartlist_t *conns = get_connection_array();
+  smartlist_t *conns = connection_dir_list_by_purpose_and_resource(
+                                                          purpose,
+                                                          resource);
+  CONN_FIRST_AND_FREE_TEMPLATE(conns);
+}
 
-  SMARTLIST_FOREACH_BEGIN(conns, connection_t *, conn) {
-    dir_connection_t *dirconn;
-    if (conn->type != CONN_TYPE_DIR || conn->marked_for_close ||
-        conn->purpose != purpose)
-      continue;
-    dirconn = TO_DIR_CONN(conn);
-    if (dirconn->requested_resource == NULL) {
-      if (resource == NULL)
-        return dirconn;
-    } else if (resource) {
-      if (0 == strcmp(resource, dirconn->requested_resource))
-        return dirconn;
-    }
-  } SMARTLIST_FOREACH_END(conn);
+/** Return a new smartlist of dir_connection_t * from get_connection_array()
+ * that satisfy conn_test on connection_t *conn_var, and dirconn_test on
+ * dir_connection_t *dirconn_var. conn_var must be of CONN_TYPE_DIR and not
+ * marked for close to be included in the list. */
+#define DIR_CONN_LIST_TEMPLATE(conn_var, conn_test,             \
+                               dirconn_var, dirconn_test)       \
+  STMT_BEGIN                                                    \
+    smartlist_t *conns = get_connection_array();                \
+    smartlist_t *dir_conns = smartlist_new();                   \
+    SMARTLIST_FOREACH_BEGIN(conns, connection_t *, conn_var) {  \
+      if (conn_var && (conn_test)                               \
+          && conn_var->type == CONN_TYPE_DIR                    \
+          && !conn_var->marked_for_close) {                     \
+        dir_connection_t *dirconn_var = TO_DIR_CONN(conn_var);  \
+        if (dirconn_var && (dirconn_test)) {                    \
+          smartlist_add(dir_conns, dirconn_var);                \
+        }                                                       \
+      }                                                         \
+    } SMARTLIST_FOREACH_END(conn_var);                          \
+    return dir_conns;                                           \
+  STMT_END
+
+/** Return a list of directory connections that are fetching the item
+ * described by <b>purpose</b>/<b>resource</b>. If there are none,
+ * return an empty list. This list must be freed using smartlist_free,
+ * but the pointers in it must not be freed.
+ * Note that this list should not be cached, as the pointers in it can be
+ * freed if their connections close. */
+smartlist_t *
+connection_dir_list_by_purpose_and_resource(
+                                            int purpose,
+                                            const char *resource)
+{
+  DIR_CONN_LIST_TEMPLATE(conn,
+                         conn->purpose == purpose,
+                         dirconn,
+                         0 == strcmp_opt(resource,
+                                         dirconn->requested_resource));
+}
 
-  return NULL;
+/** Return a directory connection (if any one exists) that is fetching
+ * the item described by <b>purpose</b>/<b>resource</b>/<b>state</b>,
+ * otherwise return NULL. */
+dir_connection_t *
+connection_dir_get_by_purpose_resource_and_state(
+                                                 int purpose,
+                                                 const char *resource,
+                                                 int state)
+{
+  smartlist_t *conns =
+    connection_dir_list_by_purpose_resource_and_state(
+                                                      purpose,
+                                                      resource,
+                                                      state);
+  CONN_FIRST_AND_FREE_TEMPLATE(conns);
+}
+
+#undef CONN_FIRST_AND_FREE_TEMPLATE
+
+/** Return a list of directory connections that are fetching the item
+ * described by <b>purpose</b>/<b>resource</b>/<b>state</b>. If there are
+ * none, return an empty list. This list must be freed using smartlist_free,
+ * but the pointers in it must not be freed.
+ * Note that this list should not be cached, as the pointers in it can be
+ * freed if their connections close. */
+smartlist_t *
+connection_dir_list_by_purpose_resource_and_state(
+                                                  int purpose,
+                                                  const char *resource,
+                                                  int state)
+{
+  DIR_CONN_LIST_TEMPLATE(conn,
+                         conn->purpose == purpose && conn->state == state,
+                         dirconn,
+                         0 == strcmp_opt(resource,
+                                         dirconn->requested_resource));
+}
+
+#undef DIR_CONN_LIST_TEMPLATE
+
+/** Return an arbitrary active OR connection that isn't <b>this_conn</b>.
+ *
+ * We use this to guess if we should tell the controller that we
+ * didn't manage to connect to any of our bridges. */
+static connection_t *
+connection_get_another_active_or_conn(const or_connection_t *this_conn)
+{
+  CONN_GET_TEMPLATE(conn,
+                    conn != TO_CONN(this_conn) && conn->type == CONN_TYPE_OR);
 }
 
 /** Return 1 if there are any active OR connections apart from
@@ -4340,23 +4437,18 @@ connection_dir_get_by_purpose_and_resource(int purpose,
 int
 any_other_active_or_conns(const or_connection_t *this_conn)
 {
-  smartlist_t *conns = get_connection_array();
-  SMARTLIST_FOREACH_BEGIN(conns, connection_t *, conn) {
-    if (conn == TO_CONN(this_conn)) { /* don't consider this conn */
-      continue;
-    }
-
-    if (conn->type == CONN_TYPE_OR &&
-        !conn->marked_for_close) {
-      log_debug(LD_DIR, "%s: Found an OR connection: %s",
-                __func__, conn->address);
-      return 1;
-    }
-  } SMARTLIST_FOREACH_END(conn);
+  connection_t *conn = connection_get_another_active_or_conn(this_conn);
+  if (conn != NULL) {
+    log_debug(LD_DIR, "%s: Found an OR connection: %s",
+              __func__, conn->address);
+    return 1;
+  }
 
   return 0;
 }
 
+#undef CONN_GET_TEMPLATE
+
 /** Return 1 if <b>conn</b> is a listener conn, else return 0. */
 int
 connection_is_listener(connection_t *conn)
@@ -5012,3 +5104,34 @@ connection_free_all(void)
 #endif
 }
 
+/** Log a warning, and possibly emit a control event, that <b>received</b> came
+ * at a skewed time.  <b>trusted</b> indicates that the <b>source</b> was one
+ * that we had more faith in and therefore the warning level should have higher
+ * severity.
+ */
+void
+clock_skew_warning(const connection_t *conn, long apparent_skew, int trusted,
+                   log_domain_mask_t domain, const char *received,
+                   const char *source)
+{
+  char dbuf[64];
+  char *ext_source = NULL;
+  format_time_interval(dbuf, sizeof(dbuf), apparent_skew);
+  if (conn)
+    tor_asprintf(&ext_source, "%s:%s:%d", source, conn->address, conn->port);
+  else
+    ext_source = tor_strdup(source);
+  log_fn(trusted ? LOG_WARN : LOG_INFO, domain,
+         "Received %s with skewed time (%s): "
+         "It seems that our clock is %s by %s, or that theirs is %s%s. "
+         "Tor requires an accurate clock to work: please check your time, "
+         "timezone, and date settings.", received, ext_source,
+         apparent_skew > 0 ? "ahead" : "behind", dbuf,
+         apparent_skew > 0 ? "behind" : "ahead",
+         (!conn || trusted) ? "" : ", or they are sending us the wrong time");
+  if (trusted)
+    control_event_general_status(LOG_WARN, "CLOCK_SKEW SKEW=%ld SOURCE=%s",
+                                 apparent_skew, ext_source);
+  tor_free(ext_source);
+}
+
diff --git a/src/or/connection.h b/src/or/connection.h
index b6ff3d7..59ea6d8 100644
--- a/src/or/connection.h
+++ b/src/or/connection.h
@@ -146,12 +146,12 @@ static void connection_write_to_buf(const char *string, size_t len,
 /* DOCDOC connection_write_to_buf_zlib */
 static void connection_write_to_buf_zlib(const char *string, size_t len,
                                          dir_connection_t *conn, int done);
-static INLINE void
+static inline void
 connection_write_to_buf(const char *string, size_t len, connection_t *conn)
 {
   connection_write_to_buf_impl_(string, len, conn, 0);
 }
-static INLINE void
+static inline void
 connection_write_to_buf_zlib(const char *string, size_t len,
                              dir_connection_t *conn, int done)
 {
@@ -163,7 +163,7 @@ static size_t connection_get_inbuf_len(connection_t *conn);
 /* DOCDOC connection_get_outbuf_len */
 static size_t connection_get_outbuf_len(connection_t *conn);
 
-static INLINE size_t
+static inline size_t
 connection_get_inbuf_len(connection_t *conn)
 {
   IF_HAS_BUFFEREVENT(conn, {
@@ -173,7 +173,7 @@ connection_get_inbuf_len(connection_t *conn)
   }
 }
 
-static INLINE size_t
+static inline size_t
 connection_get_outbuf_len(connection_t *conn)
 {
   IF_HAS_BUFFEREVENT(conn, {
@@ -193,7 +193,57 @@ connection_t *connection_get_by_type_state(int type, int state);
 connection_t *connection_get_by_type_state_rendquery(int type, int state,
                                                      const char *rendquery);
 dir_connection_t *connection_dir_get_by_purpose_and_resource(
-                                           int state, const char *resource);
+                                                  int purpose,
+                                                  const char *resource);
+dir_connection_t *connection_dir_get_by_purpose_resource_and_state(
+                                                  int purpose,
+                                                  const char *resource,
+                                                  int state);
+smartlist_t *connection_dir_list_by_purpose_and_resource(
+                                                  int purpose,
+                                                  const char *resource);
+smartlist_t *connection_dir_list_by_purpose_resource_and_state(
+                                                  int purpose,
+                                                  const char *resource,
+                                                  int state);
+
+#define CONN_LEN_AND_FREE_TEMPLATE(sl) \
+  STMT_BEGIN                           \
+    int len = smartlist_len(sl);       \
+    smartlist_free(sl);                \
+    return len;                        \
+  STMT_END
+
+/** Return a count of directory connections that are fetching the item
+ * described by <b>purpose</b>/<b>resource</b>. */
+static inline int
+connection_dir_count_by_purpose_and_resource(
+                                             int purpose,
+                                             const char *resource)
+{
+  smartlist_t *conns = connection_dir_list_by_purpose_and_resource(
+                                                                   purpose,
+                                                                   resource);
+  CONN_LEN_AND_FREE_TEMPLATE(conns);
+}
+
+/** Return a count of directory connections that are fetching the item
+ * described by <b>purpose</b>/<b>resource</b>/<b>state</b>. */
+static inline int
+connection_dir_count_by_purpose_resource_and_state(
+                                                   int purpose,
+                                                   const char *resource,
+                                                   int state)
+{
+  smartlist_t *conns =
+    connection_dir_list_by_purpose_resource_and_state(
+                                                      purpose,
+                                                      resource,
+                                                      state);
+  CONN_LEN_AND_FREE_TEMPLATE(conns);
+}
+
+#undef CONN_LEN_AND_FREE_TEMPLATE
 
 int any_other_active_or_conns(const or_connection_t *this_conn);
 
@@ -210,6 +260,10 @@ int connection_or_nonopen_was_started_here(or_connection_t *conn);
 void connection_dump_buffer_mem_stats(int severity);
 void remove_file_if_very_old(const char *fname, time_t now);
 
+void clock_skew_warning(const connection_t *conn, long apparent_skew,
+                        int trusted, log_domain_mask_t domain,
+                        const char *received, const char *source);
+
 #ifdef USE_BUFFEREVENTS
 int connection_type_uses_bufferevent(connection_t *conn);
 void connection_configure_bufferevent_callbacks(connection_t *conn);
@@ -235,6 +289,13 @@ void connection_buckets_note_empty_ts(uint32_t *timestamp_var,
                                       int tokens_before,
                                       size_t tokens_removed,
                                       const struct timeval *tvnow);
+MOCK_DECL(STATIC int,connection_connect_sockaddr,
+                                            (connection_t *conn,
+                                             const struct sockaddr *sa,
+                                             socklen_t sa_len,
+                                             const struct sockaddr *bindaddr,
+                                             socklen_t bindaddr_len,
+                                             int *socket_error));
 #endif
 
 #endif
diff --git a/src/or/connection_edge.c b/src/or/connection_edge.c
index 729ef8a..dd81142 100644
--- a/src/or/connection_edge.c
+++ b/src/or/connection_edge.c
@@ -11,6 +11,9 @@
 #define CONNECTION_EDGE_PRIVATE
 
 #include "or.h"
+
+#include "backtrace.h"
+
 #include "addressmap.h"
 #include "buffers.h"
 #include "channel.h"
@@ -503,6 +506,16 @@ connection_edge_finished_connecting(edge_connection_t *edge_conn)
   return connection_edge_process_inbuf(edge_conn, 1);
 }
 
+/** A list of all the entry_connection_t * objects that are not marked
+ * for close, and are in AP_CONN_STATE_CIRCUIT_WAIT.
+ *
+ * (Right now, we check in several places to make sure that this list is
+ * correct.  When it's incorrect, we'll fix it, and log a BUG message.)
+ */
+static smartlist_t *pending_entry_connections = NULL;
+
+static int untried_pending_connections = 0;
+
 /** Common code to connection_(ap|exit)_about_to_close. */
 static void
 connection_edge_about_to_close(edge_connection_t *edge_conn)
@@ -525,6 +538,8 @@ connection_ap_about_to_close(entry_connection_t *entry_conn)
   edge_connection_t *edge_conn = ENTRY_TO_EDGE_CONN(entry_conn);
   connection_t *conn = ENTRY_TO_CONN(entry_conn);
 
+  connection_edge_about_to_close(edge_conn);
+
   if (entry_conn->socks_request->has_finished == 0) {
     /* since conn gets removed right after this function finishes,
      * there's no point trying to send back a reply at this point. */
@@ -543,6 +558,20 @@ connection_ap_about_to_close(entry_connection_t *entry_conn)
              conn->marked_for_close_file, conn->marked_for_close);
     dnsserv_reject_request(entry_conn);
   }
+
+  if (TO_CONN(edge_conn)->state == AP_CONN_STATE_CIRCUIT_WAIT) {
+    smartlist_remove(pending_entry_connections, entry_conn);
+  }
+
+#if 1
+  /* Check to make sure that this isn't in pending_entry_connections if it
+   * didn't actually belong there. */
+  if (TO_CONN(edge_conn)->type == CONN_TYPE_AP) {
+    connection_ap_warn_and_unmark_if_pending_circ(entry_conn,
+                                                  "about_to_close");
+  }
+#endif
+
   control_event_stream_bandwidth(edge_conn);
   control_event_stream_status(entry_conn, STREAM_EVENT_CLOSED,
                               edge_conn->end_reason);
@@ -711,26 +740,181 @@ connection_ap_expire_beginning(void)
   } SMARTLIST_FOREACH_END(base_conn);
 }
 
-/** Tell any AP streams that are waiting for a new circuit to try again,
- * either attaching to an available circ or launching a new one.
+/**
+ * As connection_ap_attach_pending, but first scans the entire connection
+ * array to see if any elements are missing.
  */
 void
-connection_ap_attach_pending(void)
+connection_ap_rescan_and_attach_pending(void)
 {
   entry_connection_t *entry_conn;
   smartlist_t *conns = get_connection_array();
+
+  if (PREDICT_UNLIKELY(NULL == pending_entry_connections))
+    pending_entry_connections = smartlist_new();
+
   SMARTLIST_FOREACH_BEGIN(conns, connection_t *, conn) {
     if (conn->marked_for_close ||
         conn->type != CONN_TYPE_AP ||
         conn->state != AP_CONN_STATE_CIRCUIT_WAIT)
       continue;
+
     entry_conn = TO_ENTRY_CONN(conn);
+    tor_assert(entry_conn);
+    if (! smartlist_contains(pending_entry_connections, entry_conn)) {
+      log_warn(LD_BUG, "Found a connection %p that was supposed to be "
+               "in pending_entry_connections, but wasn't. No worries; "
+               "adding it.",
+               pending_entry_connections);
+      untried_pending_connections = 1;
+      connection_ap_mark_as_pending_circuit(entry_conn);
+    }
+
+  } SMARTLIST_FOREACH_END(conn);
+
+  connection_ap_attach_pending(1);
+}
+
+#ifdef DEBUGGING_17659
+#define UNMARK() do {                           \
+    entry_conn->marked_pending_circ_line = 0;   \
+    entry_conn->marked_pending_circ_file = 0;   \
+  } while (0)
+#else
+#define UNMARK() do { } while (0)
+#endif
+
+/** Tell any AP streams that are listed as waiting for a new circuit to try
+ * again, either attaching to an available circ or launching a new one.
+ *
+ * If <b>retry</b> is false, only check the list if it contains at least one
+ * streams that we have not yet tried to attach to a circuit.
+ */
+void
+connection_ap_attach_pending(int retry)
+{
+  if (PREDICT_UNLIKELY(!pending_entry_connections)) {
+    return;
+  }
+
+  if (untried_pending_connections == 0 && !retry)
+    return;
+
+  /* Don't allow modifications to pending_entry_connections while we are
+   * iterating over it. */
+  smartlist_t *pending = pending_entry_connections;
+  pending_entry_connections = smartlist_new();
+
+  SMARTLIST_FOREACH_BEGIN(pending,
+                          entry_connection_t *, entry_conn) {
+    connection_t *conn = ENTRY_TO_CONN(entry_conn);
+    tor_assert(conn && entry_conn);
+    if (conn->marked_for_close) {
+      UNMARK();
+      continue;
+    }
+    if (conn->magic != ENTRY_CONNECTION_MAGIC) {
+      log_warn(LD_BUG, "%p has impossible magic value %u.",
+               entry_conn, (unsigned)conn->magic);
+      UNMARK();
+      continue;
+    }
+    if (conn->state != AP_CONN_STATE_CIRCUIT_WAIT) {
+      log_warn(LD_BUG, "%p is no longer in circuit_wait. Its current state "
+               "is %s. Why is it on pending_entry_connections?",
+               entry_conn,
+               conn_state_to_string(conn->type, conn->state));
+      UNMARK();
+      continue;
+    }
+
     if (connection_ap_handshake_attach_circuit(entry_conn) < 0) {
       if (!conn->marked_for_close)
         connection_mark_unattached_ap(entry_conn,
                                       END_STREAM_REASON_CANT_ATTACH);
     }
-  } SMARTLIST_FOREACH_END(conn);
+
+    if (! conn->marked_for_close &&
+        conn->type == CONN_TYPE_AP &&
+        conn->state == AP_CONN_STATE_CIRCUIT_WAIT) {
+      if (!smartlist_contains(pending_entry_connections, entry_conn)) {
+        smartlist_add(pending_entry_connections, entry_conn);
+        continue;
+      }
+    }
+
+    UNMARK();
+  } SMARTLIST_FOREACH_END(entry_conn);
+
+  smartlist_free(pending);
+  untried_pending_connections = 0;
+}
+
+/** Mark <b>entry_conn</b> as needing to get attached to a circuit.
+ *
+ * And <b>entry_conn</b> must be in AP_CONN_STATE_CIRCUIT_WAIT,
+ * should not already be pending a circuit.  The circuit will get
+ * launched or the connection will get attached the next time we
+ * call connection_ap_attach_pending().
+ */
+void
+connection_ap_mark_as_pending_circuit_(entry_connection_t *entry_conn,
+                                       const char *fname, int lineno)
+{
+  connection_t *conn = ENTRY_TO_CONN(entry_conn);
+  tor_assert(conn->state == AP_CONN_STATE_CIRCUIT_WAIT);
+  tor_assert(conn->magic == ENTRY_CONNECTION_MAGIC);
+  if (conn->marked_for_close)
+    return;
+
+  if (PREDICT_UNLIKELY(NULL == pending_entry_connections))
+    pending_entry_connections = smartlist_new();
+
+  if (PREDICT_UNLIKELY(smartlist_contains(pending_entry_connections,
+                                          entry_conn))) {
+    log_warn(LD_BUG, "What?? pending_entry_connections already contains %p! "
+             "(Called from %s:%d.)",
+             entry_conn, fname, lineno);
+#ifdef DEBUGGING_17659
+    const char *f2 = entry_conn->marked_pending_circ_file;
+    log_warn(LD_BUG, "(Previously called from %s:%d.)\n",
+             f2 ? f2 : "<NULL>",
+             entry_conn->marked_pending_circ_line);
+#endif
+    log_backtrace(LOG_WARN, LD_BUG, "To debug, this may help");
+    return;
+  }
+
+#ifdef DEBUGGING_17659
+  entry_conn->marked_pending_circ_line = (uint16_t) lineno;
+  entry_conn->marked_pending_circ_file = fname;
+#endif
+
+  untried_pending_connections = 1;
+  smartlist_add(pending_entry_connections, entry_conn);
+}
+
+/** Mark <b>entry_conn</b> as no longer waiting for a circuit. */
+void
+connection_ap_mark_as_non_pending_circuit(entry_connection_t *entry_conn)
+{
+  if (PREDICT_UNLIKELY(NULL == pending_entry_connections))
+    return;
+  UNMARK();
+  smartlist_remove(pending_entry_connections, entry_conn);
+}
+
+/** DOCDOC */
+void
+connection_ap_warn_and_unmark_if_pending_circ(entry_connection_t *entry_conn,
+                                              const char *where)
+{
+  if (pending_entry_connections &&
+      smartlist_contains(pending_entry_connections, entry_conn)) {
+    log_warn(LD_BUG, "What was %p doing in pending_entry_connections in %s?",
+             entry_conn, where);
+    connection_ap_mark_as_non_pending_circuit(entry_conn);
+  }
 }
 
 /** Tell any AP streams that are waiting for a one-hop tunnel to
@@ -851,12 +1035,13 @@ connection_ap_detach_retriable(entry_connection_t *conn,
      * a tunneled directory connection, then just attach it. */
     ENTRY_TO_CONN(conn)->state = AP_CONN_STATE_CIRCUIT_WAIT;
     circuit_detach_stream(TO_CIRCUIT(circ),ENTRY_TO_EDGE_CONN(conn));
-    return connection_ap_handshake_attach_circuit(conn);
+    connection_ap_mark_as_pending_circuit(conn);
   } else {
+    CONNECTION_AP_EXPECT_NONPENDING(conn);
     ENTRY_TO_CONN(conn)->state = AP_CONN_STATE_CONTROLLER_WAIT;
     circuit_detach_stream(TO_CIRCUIT(circ),ENTRY_TO_EDGE_CONN(conn));
-    return 0;
   }
+  return 0;
 }
 
 /** Check if <b>conn</b> is using a dangerous port. Then warn and/or
@@ -905,6 +1090,7 @@ connection_ap_rewrite_and_attach_if_allowed(entry_connection_t *conn,
   const or_options_t *options = get_options();
 
   if (options->LeaveStreamsUnattached) {
+    CONNECTION_AP_EXPECT_NONPENDING(conn);
     ENTRY_TO_CONN(conn)->state = AP_CONN_STATE_CONTROLLER_WAIT;
     return 0;
   }
@@ -1454,10 +1640,12 @@ connection_ap_handshake_rewrite_and_attach(entry_connection_t *conn,
     /* If we were given a circuit to attach to, try to attach. Otherwise,
      * try to find a good one and attach to that. */
     int rv;
-    if (circ)
-      rv =  connection_ap_handshake_attach_chosen_circuit(conn, circ, cpath);
-    else
-      rv = connection_ap_handshake_attach_circuit(conn);
+    if (circ) {
+      rv = connection_ap_handshake_attach_chosen_circuit(conn, circ, cpath);
+    } else {
+      connection_ap_mark_as_pending_circuit(conn);
+      rv = 0;
+    }
 
     /* If the above function returned 0 then we're waiting for a circuit.
      * if it returned 1, we're attached.  Both are okay.  But if it returned
@@ -1554,6 +1742,7 @@ connection_ap_handshake_rewrite_and_attach(entry_connection_t *conn,
      * Also, a fetch could have been requested if the onion address was not
      * found in the cache previously. */
     if (refetch_desc || !rend_client_any_intro_points_usable(entry)) {
+      connection_ap_mark_as_non_pending_circuit(conn);
       base_conn->state = AP_CONN_STATE_RENDDESC_WAIT;
       log_info(LD_REND, "Unknown descriptor %s. Fetching.",
           safe_str_client(rend_data->onion_address));
@@ -1564,11 +1753,7 @@ connection_ap_handshake_rewrite_and_attach(entry_connection_t *conn,
     /* We have the descriptor so launch a connection to the HS. */
     base_conn->state = AP_CONN_STATE_CIRCUIT_WAIT;
     log_info(LD_REND, "Descriptor is here. Great.");
-    if (connection_ap_handshake_attach_circuit(conn) < 0) {
-      if (!base_conn->marked_for_close)
-        connection_mark_unattached_ap(conn, END_STREAM_REASON_CANT_ATTACH);
-      return -1;
-    }
+    connection_ap_mark_as_pending_circuit(conn);
     return 0;
   }
 
@@ -2324,12 +2509,7 @@ connection_ap_make_link(connection_t *partner,
   control_event_stream_status(conn, STREAM_EVENT_NEW, 0);
 
   /* attaching to a dirty circuit is fine */
-  if (connection_ap_handshake_attach_circuit(conn) < 0) {
-    if (!base_conn->marked_for_close)
-      connection_mark_unattached_ap(conn, END_STREAM_REASON_CANT_ATTACH);
-    return NULL;
-  }
-
+  connection_ap_mark_as_pending_circuit(conn);
   log_info(LD_APP,"... application connection created and linked.");
   return conn;
 }
@@ -2771,8 +2951,8 @@ connection_exit_begin_conn(cell_t *cell, circuit_t *circ)
       return 0;
     }
     /* Make sure to get the 'real' address of the previous hop: the
-     * caller might want to know whether his IP address has changed, and
-     * we might already have corrected base_.addr[ess] for the relay's
+     * caller might want to know whether the remote IP address has changed,
+     * and we might already have corrected base_.addr[ess] for the relay's
      * canonical IP address. */
     if (or_circ && or_circ->p_chan)
       address = tor_strdup(channel_get_actual_remote_address(or_circ->p_chan));
@@ -3478,3 +3658,12 @@ circuit_clear_isolation(origin_circuit_t *circ)
   circ->socks_username_len = circ->socks_password_len = 0;
 }
 
+/** Free all storage held in module-scoped variables for connection_edge.c */
+void
+connection_edge_free_all(void)
+{
+  untried_pending_connections = 0;
+  smartlist_free(pending_entry_connections);
+  pending_entry_connections = NULL;
+}
+
diff --git a/src/or/connection_edge.h b/src/or/connection_edge.h
index 7c0b9c0..2aba801 100644
--- a/src/or/connection_edge.h
+++ b/src/or/connection_edge.h
@@ -64,7 +64,20 @@ int connection_edge_is_rendezvous_stream(edge_connection_t *conn);
 int connection_ap_can_use_exit(const entry_connection_t *conn,
                                const node_t *exit);
 void connection_ap_expire_beginning(void);
-void connection_ap_attach_pending(void);
+void connection_ap_rescan_and_attach_pending(void);
+void connection_ap_attach_pending(int retry);
+void connection_ap_mark_as_pending_circuit_(entry_connection_t *entry_conn,
+                                           const char *file, int line);
+#define connection_ap_mark_as_pending_circuit(c) \
+  connection_ap_mark_as_pending_circuit_((c), __FILE__, __LINE__)
+void connection_ap_mark_as_non_pending_circuit(entry_connection_t *entry_conn);
+#define CONNECTION_AP_EXPECT_NONPENDING(c) do {                         \
+    if (ENTRY_TO_CONN(c)->state == AP_CONN_STATE_CIRCUIT_WAIT) {        \
+      log_warn(LD_BUG, "At %s:%d: %p was unexpectedly in circuit_wait.", \
+               __FILE__, __LINE__, (c));                                \
+      connection_ap_mark_as_non_pending_circuit(c);                     \
+    }                                                                   \
+  } while (0)
 void connection_ap_fail_onehop(const char *failed_digest,
                                cpath_build_state_t *build_state);
 void circuit_discard_optional_exit_enclaves(extend_info_t *info);
@@ -100,6 +113,12 @@ int connection_edge_update_circuit_isolation(const entry_connection_t *conn,
 void circuit_clear_isolation(origin_circuit_t *circ);
 streamid_t get_unique_stream_id_by_circ(origin_circuit_t *circ);
 
+void connection_edge_free_all(void);
+
+void connection_ap_warn_and_unmark_if_pending_circ(
+                                             entry_connection_t *entry_conn,
+                                             const char *where);
+
 /** @name Begin-cell flags
  *
  * These flags are used in RELAY_BEGIN cells to change the default behavior
diff --git a/src/or/connection_or.c b/src/or/connection_or.c
index a967c93..29e8153 100644
--- a/src/or/connection_or.c
+++ b/src/or/connection_or.c
@@ -1450,17 +1450,12 @@ connection_tls_continue_handshake(or_connection_t *conn)
 {
   int result;
   check_no_tls_errors();
- again:
-  if (conn->base_.state == OR_CONN_STATE_TLS_CLIENT_RENEGOTIATING) {
-    // log_notice(LD_OR, "Renegotiate with %p", conn->tls);
-    result = tor_tls_renegotiate(conn->tls);
-    // log_notice(LD_OR, "Result: %d", result);
-  } else {
-    tor_assert(conn->base_.state == OR_CONN_STATE_TLS_HANDSHAKING);
-    // log_notice(LD_OR, "Continue handshake with %p", conn->tls);
-    result = tor_tls_handshake(conn->tls);
-    // log_notice(LD_OR, "Result: %d", result);
-  }
+
+  tor_assert(conn->base_.state == OR_CONN_STATE_TLS_HANDSHAKING);
+  // log_notice(LD_OR, "Continue handshake with %p", conn->tls);
+  result = tor_tls_handshake(conn->tls);
+  // log_notice(LD_OR, "Result: %d", result);
+
   switch (result) {
     CASE_TOR_TLS_ERROR_ANY:
     log_info(LD_OR,"tls error [%s]. breaking connection.",
@@ -1469,23 +1464,10 @@ connection_tls_continue_handshake(or_connection_t *conn)
     case TOR_TLS_DONE:
       if (! tor_tls_used_v1_handshake(conn->tls)) {
         if (!tor_tls_is_server(conn->tls)) {
-          if (conn->base_.state == OR_CONN_STATE_TLS_HANDSHAKING) {
-            if (tor_tls_received_v3_certificate(conn->tls)) {
-              log_info(LD_OR, "Client got a v3 cert!  Moving on to v3 "
-                       "handshake with ciphersuite %s",
-                       tor_tls_get_ciphersuite_name(conn->tls));
-              return connection_or_launch_v3_or_handshake(conn);
-            } else {
-              log_debug(LD_OR, "Done with initial SSL handshake (client-side)."
-                        " Requesting renegotiation.");
-              connection_or_change_state(conn,
-                  OR_CONN_STATE_TLS_CLIENT_RENEGOTIATING);
-              goto again;
-            }
-          }
-          // log_notice(LD_OR,"Done. state was %d.", conn->base_.state);
+          tor_assert(conn->base_.state == OR_CONN_STATE_TLS_HANDSHAKING);
+          return connection_or_launch_v3_or_handshake(conn);
         } else {
-          /* v2/v3 handshake, but not a client. */
+          /* v2/v3 handshake, but we are not a client. */
           log_debug(LD_OR, "Done with initial SSL handshake (server-side). "
                            "Expecting renegotiation or VERSIONS cell");
           tor_tls_set_renegotiate_callback(conn->tls,
@@ -1498,6 +1480,7 @@ connection_tls_continue_handshake(or_connection_t *conn)
           return 0;
         }
       }
+      tor_assert(tor_tls_is_server(conn->tls));
       return connection_tls_finish_handshake(conn);
     case TOR_TLS_WANTWRITE:
       connection_start_writing(TO_CONN(conn));
@@ -1533,22 +1516,8 @@ connection_or_handle_event_cb(struct bufferevent *bufev, short event,
     if (! tor_tls_used_v1_handshake(conn->tls)) {
       if (!tor_tls_is_server(conn->tls)) {
         if (conn->base_.state == OR_CONN_STATE_TLS_HANDSHAKING) {
-          if (tor_tls_received_v3_certificate(conn->tls)) {
-            log_info(LD_OR, "Client got a v3 cert!");
-            if (connection_or_launch_v3_or_handshake(conn) < 0)
-              connection_or_close_for_error(conn, 0);
-            return;
-          } else {
-            connection_or_change_state(conn,
-                OR_CONN_STATE_TLS_CLIENT_RENEGOTIATING);
-            tor_tls_unblock_renegotiation(conn->tls);
-            if (bufferevent_ssl_renegotiate(conn->base_.bufev)<0) {
-              log_warn(LD_OR, "Start_renegotiating went badly.");
-              connection_or_close_for_error(conn, 0);
-            }
-            tor_tls_unblock_renegotiation(conn->tls);
-            return; /* ???? */
-          }
+          if (connection_or_launch_v3_or_handshake(conn) < 0)
+            connection_or_close_for_error(conn, 0);
         }
       } else {
         const int handshakes = tor_tls_get_num_server_handshakes(conn->tls);
@@ -1612,11 +1581,11 @@ connection_or_nonopen_was_started_here(or_connection_t *conn)
 }
 
 /** <b>Conn</b> just completed its handshake. Return 0 if all is well, and
- * return -1 if he is lying, broken, or otherwise something is wrong.
+ * return -1 if they are lying, broken, or otherwise something is wrong.
  *
  * If we initiated this connection (<b>started_here</b> is true), make sure
  * the other side sent a correctly formed certificate. If I initiated the
- * connection, make sure it's the right guy.
+ * connection, make sure it's the right relay by checking the certificate.
  *
  * Otherwise (if we _didn't_ initiate this connection), it's okay for
  * the certificate to be weird or absent.
@@ -1632,7 +1601,7 @@ connection_or_nonopen_was_started_here(or_connection_t *conn)
  * 1) Set conn->circ_id_type according to tor-spec.txt.
  * 2) If we're an authdirserver and we initiated the connection: drop all
  *    descriptors that claim to be on that IP/port but that aren't
- *    this guy; and note that this guy is reachable.
+ *    this relay; and note that this relay is reachable.
  * 3) If this is a bridge and we didn't configure its identity
  *    fingerprint, remember the keyid we just learned.
  */
@@ -1785,7 +1754,7 @@ connection_or_client_used(or_connection_t *conn)
  *
  * Make sure we are happy with the person we just handshaked with.
  *
- * If he initiated the connection, make sure he's not already connected,
+ * If they initiated the connection, make sure they're not already connected,
  * then initialize conn from the information in router.
  *
  * If all is successful, call circuit_n_conn_done() to handle events
@@ -1800,6 +1769,8 @@ connection_tls_finish_handshake(or_connection_t *conn)
   char digest_rcvd[DIGEST_LEN];
   int started_here = connection_or_nonopen_was_started_here(conn);
 
+  tor_assert(!started_here);
+
   log_debug(LD_HANDSHAKE,"%s tls handshake on %p with %s done, using "
             "ciphersuite %s. verifying.",
             started_here?"outgoing":"incoming",
@@ -1815,10 +1786,8 @@ connection_tls_finish_handshake(or_connection_t *conn)
 
   if (tor_tls_used_v1_handshake(conn->tls)) {
     conn->link_proto = 1;
-    if (!started_here) {
-      connection_or_init_conn_from_address(conn, &conn->base_.addr,
-                                           conn->base_.port, digest_rcvd, 0);
-    }
+    connection_or_init_conn_from_address(conn, &conn->base_.addr,
+                                         conn->base_.port, digest_rcvd, 0);
     tor_tls_block_renegotiation(conn->tls);
     rep_hist_note_negotiated_link_proto(1, started_here);
     return connection_or_set_state_open(conn);
@@ -1826,10 +1795,8 @@ connection_tls_finish_handshake(or_connection_t *conn)
     connection_or_change_state(conn, OR_CONN_STATE_OR_HANDSHAKING_V2);
     if (connection_init_or_handshake_state(conn, started_here) < 0)
       return -1;
-    if (!started_here) {
-      connection_or_init_conn_from_address(conn, &conn->base_.addr,
-                                           conn->base_.port, digest_rcvd, 0);
-    }
+    connection_or_init_conn_from_address(conn, &conn->base_.addr,
+                                         conn->base_.port, digest_rcvd, 0);
     return connection_or_send_versions(conn, 0);
   }
 }
@@ -1844,7 +1811,6 @@ static int
 connection_or_launch_v3_or_handshake(or_connection_t *conn)
 {
   tor_assert(connection_or_nonopen_was_started_here(conn));
-  tor_assert(tor_tls_received_v3_certificate(conn->tls));
 
   circuit_build_times_network_is_live(get_circuit_build_times_mutable());
 
@@ -2290,8 +2256,7 @@ connection_or_send_auth_challenge_cell(or_connection_t *conn)
 
   auth_challenge_cell_t *ac = auth_challenge_cell_new();
 
-  if (crypto_rand((char*)ac->challenge, sizeof(ac->challenge)) < 0)
-    goto done;
+  crypto_rand((char*)ac->challenge, sizeof(ac->challenge));
 
   auth_challenge_cell_add_methods(ac, AUTHTYPE_RSA_SHA256_TLSSECRET);
   auth_challenge_cell_set_n_methods(ac,
diff --git a/src/or/control.c b/src/or/control.c
index 220e7e5..66182fe 100644
--- a/src/or/control.c
+++ b/src/or/control.c
@@ -192,7 +192,7 @@ static void flush_queued_events_cb(evutil_socket_t fd, short what, void *arg);
 
 /** Given a control event code for a message event, return the corresponding
  * log severity. */
-static INLINE int
+static inline int
 event_to_log_severity(int event)
 {
   switch (event) {
@@ -206,7 +206,7 @@ event_to_log_severity(int event)
 }
 
 /** Given a log severity, return the corresponding control event code. */
-static INLINE int
+static inline int
 log_severity_to_event(int severity)
 {
   switch (severity) {
@@ -325,7 +325,7 @@ control_event_is_interesting(int event)
 /** Append a NUL-terminated string <b>s</b> to the end of
  * <b>conn</b>-\>outbuf.
  */
-static INLINE void
+static inline void
 connection_write_str_to_buf(const char *s, control_connection_t *conn)
 {
   size_t len = strlen(s);
@@ -428,7 +428,7 @@ read_escaped_data(const char *data, size_t len, char **out)
 /** If the first <b>in_len_max</b> characters in <b>start</b> contain a
  * double-quoted string with escaped characters, return the length of that
  * string (as encoded, including quotes).  Otherwise return -1. */
-static INLINE int
+static inline int
 get_escaped_string_length(const char *start, size_t in_len_max,
                           int *chars_out)
 {
@@ -1927,6 +1927,22 @@ getinfo_helper_dir(control_connection_t *control_conn,
       *errmsg = "Not found in cache";
       return -1;
     }
+  } else if (!strcmpstart(question, "hs/service/desc/id/")) {
+    rend_cache_entry_t *e = NULL;
+
+    question += strlen("hs/service/desc/id/");
+    if (strlen(question) != REND_SERVICE_ID_LEN_BASE32) {
+      *errmsg = "Invalid address";
+      return -1;
+    }
+
+    if (!rend_cache_lookup_v2_desc_as_service(question, &e)) {
+      /* Descriptor found in cache */
+      *answer = tor_strdup(e->desc);
+    } else {
+      *errmsg = "Not found in cache";
+      return -1;
+    }
   } else if (!strcmpstart(question, "md/id/")) {
     const node_t *node = node_get_by_hex_id(question+strlen("md/id/"));
     const microdesc_t *md = NULL;
@@ -2481,6 +2497,8 @@ static const getinfo_item_t getinfo_items[] = {
   PREFIX("extra-info/digest/", dir, "Extra-info documents by digest."),
   PREFIX("hs/client/desc/id", dir,
          "Hidden Service descriptor in client's cache by onion."),
+  PREFIX("hs/service/desc/id/", dir,
+         "Hidden Service descriptor in services's cache by onion."),
   PREFIX("net/listeners/", listeners, "Bound addresses by type"),
   ITEM("ns/all", networkstatus,
        "Brief summary of router status (v2 directory format)"),
@@ -2544,6 +2562,12 @@ static const getinfo_item_t getinfo_items[] = {
        "v3 Networkstatus consensus as retrieved from a DirPort."),
   ITEM("exit-policy/default", policies,
        "The default value appended to the configured exit policy."),
+  ITEM("exit-policy/reject-private/default", policies,
+       "The default rules appended to the configured exit policy by"
+       " ExitPolicyRejectPrivate."),
+  ITEM("exit-policy/reject-private/relay", policies,
+       "The relay-specific rules appended to the configured exit policy by"
+       " ExitPolicyRejectPrivate."),
   ITEM("exit-policy/full", policies, "The entire exit policy of onion router"),
   ITEM("exit-policy/ipv4", policies, "IPv4 parts of exit policy"),
   ITEM("exit-policy/ipv6", policies, "IPv6 parts of exit policy"),
@@ -2987,6 +3011,7 @@ handle_control_attachstream(control_connection_t *conn, uint32_t len,
     edge_conn->end_reason = 0;
     if (tmpcirc)
       circuit_detach_stream(tmpcirc, edge_conn);
+    CONNECTION_AP_EXPECT_NONPENDING(ap_conn);
     TO_CONN(edge_conn)->state = AP_CONN_STATE_CONTROLLER_WAIT;
   }
 
@@ -3418,8 +3443,7 @@ handle_control_authchallenge(control_connection_t *conn, uint32_t len,
     tor_free(client_nonce);
     return -1;
   }
-  const int fail = crypto_rand(server_nonce, SAFECOOKIE_SERVER_NONCE_LEN);
-  tor_assert(!fail);
+  crypto_rand(server_nonce, SAFECOOKIE_SERVER_NONCE_LEN);
 
   /* Now compute and send the server-to-controller response, and the
    * server's nonce. */
@@ -6233,6 +6257,31 @@ get_desc_id_from_query(const rend_data_t *rend_data, const char *hsdir_fp)
   return desc_id;
 }
 
+/** send HS_DESC CREATED event when a local service generates a descriptor.
+ *
+ * <b>service_id</b> is the descriptor onion address.
+ * <b>desc_id_base32</b> is the descriptor ID.
+ * <b>replica</b> is the the descriptor replica number.
+ */
+void
+control_event_hs_descriptor_created(const char *service_id,
+                                    const char *desc_id_base32,
+                                    int replica)
+{
+  if (!service_id || !desc_id_base32) {
+    log_warn(LD_BUG, "Called with service_digest==%p, "
+             "desc_id_base32==%p", service_id, desc_id_base32);
+    return;
+  }
+
+  send_control_event(EVENT_HS_DESC,
+                     "650 HS_DESC CREATED %s UNKNOWN UNKNOWN %s "
+                     "REPLICA=%d\r\n",
+                     service_id,
+                     desc_id_base32,
+                     replica);
+}
+
 /** send HS_DESC upload event.
  *
  * <b>service_id</b> is the descriptor onion address.
diff --git a/src/or/control.h b/src/or/control.h
index fdf7903..1f8e2bc 100644
--- a/src/or/control.h
+++ b/src/or/control.h
@@ -117,6 +117,9 @@ MOCK_DECL(const char *, node_describe_longname_by_id,(const char *id_digest));
 void control_event_hs_descriptor_requested(const rend_data_t *rend_query,
                                            const char *desc_id_base32,
                                            const char *hs_dir);
+void control_event_hs_descriptor_created(const char *service_id,
+                                         const char *desc_id_base32,
+                                         int replica);
 void control_event_hs_descriptor_upload(const char *service_id,
                                         const char *desc_id_base32,
                                         const char *hs_dir);
diff --git a/src/or/directory.c b/src/or/directory.c
index 9461606..c1fa37f 100644
--- a/src/or/directory.c
+++ b/src/or/directory.c
@@ -143,7 +143,7 @@ purpose_needs_anonymity(uint8_t dir_purpose, uint8_t router_purpose)
 
 /** Return a newly allocated string describing <b>auth</b>. Only describes
  * authority features. */
-static char *
+STATIC char *
 authdir_type_to_string(dirinfo_type_t auth)
 {
   char *result;
@@ -162,7 +162,7 @@ authdir_type_to_string(dirinfo_type_t auth)
 }
 
 /** Return a string describing a given directory connection purpose. */
-static const char *
+STATIC const char *
 dir_conn_purpose_to_string(int purpose)
 {
   switch (purpose)
@@ -370,7 +370,7 @@ directory_post_to_dirservers(uint8_t dir_purpose, uint8_t router_purpose,
 
 /** Return true iff, according to the values in <b>options</b>, we should be
  * using directory guards for direct downloads of directory information. */
-static int
+STATIC int
 should_use_directory_guards(const or_options_t *options)
 {
   /* Public (non-bridge) servers never use directory guards. */
@@ -425,14 +425,17 @@ directory_pick_generic_dirserver(dirinfo_type_t type, int pds_flags,
  * Use <b>pds_flags</b> as arguments to router_pick_directory_server()
  * or router_pick_trusteddirserver().
  */
-MOCK_IMPL(void, directory_get_from_dirserver, (uint8_t dir_purpose,
-                                               uint8_t router_purpose,
-                                               const char *resource,
-                                               int pds_flags))
+MOCK_IMPL(void, directory_get_from_dirserver, (
+                            uint8_t dir_purpose,
+                            uint8_t router_purpose,
+                            const char *resource,
+                            int pds_flags,
+                            download_want_authority_t want_authority))
 {
   const routerstatus_t *rs = NULL;
   const or_options_t *options = get_options();
-  int prefer_authority = directory_fetches_from_authorities(options);
+  int prefer_authority = (directory_fetches_from_authorities(options)
+                          || want_authority == DL_WANT_AUTHORITY);
   int require_authority = 0;
   int get_via_tor = purpose_needs_anonymity(dir_purpose, router_purpose);
   dirinfo_type_t type = dir_fetch_type(dir_purpose, router_purpose, resource);
@@ -666,15 +669,15 @@ directory_initiate_command_routerstatus_rend(const routerstatus_t *status,
  * When fetching a rendezvous descriptor, <b>resource</b> is the service ID we
  * want to fetch.
  */
-void
-directory_initiate_command_routerstatus(const routerstatus_t *status,
-                                        uint8_t dir_purpose,
-                                        uint8_t router_purpose,
-                                        dir_indirection_t indirection,
-                                        const char *resource,
-                                        const char *payload,
-                                        size_t payload_len,
-                                        time_t if_modified_since)
+MOCK_IMPL(void, directory_initiate_command_routerstatus,
+                (const routerstatus_t *status,
+                 uint8_t dir_purpose,
+                 uint8_t router_purpose,
+                 dir_indirection_t indirection,
+                 const char *resource,
+                 const char *payload,
+                 size_t payload_len,
+                 time_t if_modified_since))
 {
   directory_initiate_command_routerstatus_rend(status, dir_purpose,
                                           router_purpose,
@@ -712,7 +715,7 @@ connection_dir_request_failed(dir_connection_t *conn)
     return; /* this was a test fetch. don't retry. */
   }
   if (!entry_list_is_constrained(get_options()))
-    router_set_status(conn->identity_digest, 0); /* don't try him again */
+    router_set_status(conn->identity_digest, 0); /* don't try this one again */
   if (conn->base_.purpose == DIR_PURPOSE_FETCH_SERVERDESC ||
              conn->base_.purpose == DIR_PURPOSE_FETCH_EXTRAINFO) {
     log_info(LD_DIR, "Giving up on serverdesc/extrainfo fetch from "
@@ -940,6 +943,15 @@ directory_initiate_command_rend(const tor_addr_t *_addr,
   log_debug(LD_DIR, "anonymized %d, use_begindir %d.",
             anonymized_connection, use_begindir);
 
+  if (!dir_port && !use_begindir) {
+    char ipaddr[TOR_ADDR_BUF_LEN];
+    tor_addr_to_str(ipaddr, _addr, TOR_ADDR_BUF_LEN, 0);
+    log_warn(LD_BUG, "Cannot use directory server without dirport or "
+                     "begindir! Address: %s, ORPort: %d, DirPort: %d",
+                     escaped_safe_str_client(ipaddr), or_port, dir_port);
+    return;
+  }
+
   log_debug(LD_DIR, "Initiating %s", dir_conn_purpose_to_string(dir_purpose));
 
 #ifndef NON_ANONYMOUS_MODE_ENABLED
@@ -958,6 +970,12 @@ directory_initiate_command_rend(const tor_addr_t *_addr,
     return;
   }
 
+  /* ensure we don't make excess connections when we're already downloading
+   * a consensus during bootstrap */
+  if (connection_dir_avoid_extra_connection_for_purpose(dir_purpose)) {
+    return;
+  }
+
   conn = dir_connection_new(tor_addr_family(&addr));
 
   /* set up conn so it's got all the data we need to remember */
@@ -991,16 +1009,16 @@ directory_initiate_command_rend(const tor_addr_t *_addr,
     switch (connection_connect(TO_CONN(conn), conn->base_.address, &addr,
                                dir_port, &socket_error)) {
       case -1:
-        connection_dir_request_failed(conn); /* retry if we want */
-        /* XXX we only pass 'conn' above, not 'resource', 'payload',
-         * etc. So in many situations it can't retry! -RD */
-        connection_free(TO_CONN(conn));
+        connection_mark_for_close(TO_CONN(conn));
         return;
       case 1:
         /* start flushing conn */
         conn->base_.state = DIR_CONN_STATE_CLIENT_SENDING;
         /* fall through */
       case 0:
+        if (connection_dir_close_consensus_conn_if_extra(conn)) {
+          return;
+        }
         /* queue the command on the outbuf */
         directory_send_command(conn, dir_purpose, 1, resource,
                                payload, payload_len,
@@ -1044,6 +1062,9 @@ directory_initiate_command_rend(const tor_addr_t *_addr,
       connection_mark_for_close(TO_CONN(conn));
       return;
     }
+    if (connection_dir_close_consensus_conn_if_extra(conn)) {
+      return;
+    }
     conn->base_.state = DIR_CONN_STATE_CLIENT_SENDING;
     /* queue the command on the outbuf */
     directory_send_command(conn, dir_purpose, 0, resource,
@@ -1598,7 +1619,7 @@ connection_dir_client_reached_eof(dir_connection_t *conn)
   size_t body_len = 0, orig_len = 0;
   int status_code;
   time_t date_header = 0;
-  long delta;
+  long apparent_skew;
   compress_method_t compression;
   int plausible;
   int skewed = 0;
@@ -1657,28 +1678,15 @@ connection_dir_client_reached_eof(dir_connection_t *conn)
      * and the date header.  (We used to check now-date_header, but that's
      * inaccurate if we spend a lot of time downloading.)
      */
-    delta = conn->base_.timestamp_lastwritten - date_header;
-    if (labs(delta)>ALLOW_DIRECTORY_TIME_SKEW) {
-      char dbuf[64];
+    apparent_skew = conn->base_.timestamp_lastwritten - date_header;
+    if (labs(apparent_skew)>ALLOW_DIRECTORY_TIME_SKEW) {
       int trusted = router_digest_is_trusted_dir(conn->identity_digest);
-      format_time_interval(dbuf, sizeof(dbuf), delta);
-      log_fn(trusted ? LOG_WARN : LOG_INFO,
-             LD_HTTP,
-             "Received directory with skewed time (server '%s:%d'): "
-             "It seems that our clock is %s by %s, or that theirs is %s. "
-             "Tor requires an accurate clock to work: please check your time, "
-             "timezone, and date settings.",
-             conn->base_.address, conn->base_.port,
-             delta>0 ? "ahead" : "behind", dbuf,
-             delta>0 ? "behind" : "ahead");
+      clock_skew_warning(TO_CONN(conn), apparent_skew, trusted, LD_HTTP,
+                         "directory", "DIRSERV");
       skewed = 1; /* don't check the recommended-versions line */
-      if (trusted)
-        control_event_general_status(LOG_WARN,
-                                 "CLOCK_SKEW SKEW=%ld SOURCE=DIRSERV:%s:%d",
-                                 delta, conn->base_.address, conn->base_.port);
     } else {
       log_debug(LD_HTTP, "Time on received directory is within tolerance; "
-                "we are %ld seconds skewed.  (That's okay.)", delta);
+                "we are %ld seconds skewed.  (That's okay.)", apparent_skew);
     }
   }
   (void) skewed; /* skewed isn't used yet. */
@@ -2593,7 +2601,7 @@ client_likes_consensus(networkstatus_t *v, const char *want_url)
 
 /** Return the compression level we should use for sending a compressed
  * response of size <b>n_bytes</b>. */
-static zlib_compression_level_t
+STATIC zlib_compression_level_t
 choose_compression_level(ssize_t n_bytes)
 {
   if (! have_been_under_memory_pressure()) {
@@ -2614,7 +2622,7 @@ choose_compression_level(ssize_t n_bytes)
  * service descriptor.  On finding one, write a response into
  * conn-\>outbuf.  If the request is unrecognized, send a 400.
  * Always return 0. */
-static int
+STATIC int
 directory_handle_command_get(dir_connection_t *conn, const char *headers,
                              const char *req_body, size_t req_body_len)
 {
@@ -2874,7 +2882,7 @@ directory_handle_command_get(dir_connection_t *conn, const char *headers,
       });
 
     if (global_write_bucket_low(TO_CONN(conn), estimated_len, 2)) {
-      write_http_status_line(conn, 503, "Directory busy, try again later.");
+      write_http_status_line(conn, 503, "Directory busy, try again later");
       goto vote_done;
     }
     write_http_response_header(conn, body_len ? body_len : -1, compressed,
@@ -3071,7 +3079,7 @@ directory_handle_command_get(dir_connection_t *conn, const char *headers,
                       len += c->cache_info.signed_descriptor_len);
 
     if (global_write_bucket_low(TO_CONN(conn), compressed?len/2:len, 2)) {
-      write_http_status_line(conn, 503, "Directory busy, try again later.");
+      write_http_status_line(conn, 503, "Directory busy, try again later");
       goto keys_done;
     }
 
@@ -3398,7 +3406,7 @@ connection_dir_finished_flushing(dir_connection_t *conn)
   tor_assert(conn->base_.type == CONN_TYPE_DIR);
 
   /* Note that we have finished writing the directory response. For direct
-   * connections this means we're done, for tunneled connections its only
+   * connections this means we're done; for tunneled connections it's only
    * an intermediate step. */
   if (conn->dirreq_id)
     geoip_change_dirreq_state(conn->dirreq_id, DIRREQ_TUNNELED,
@@ -3439,8 +3447,205 @@ connection_dir_finished_flushing(dir_connection_t *conn)
   return 0;
 }
 
+/* A helper function for connection_dir_close_consensus_conn_if_extra()
+ * and connection_dir_close_extra_consensus_conns() that returns 0 if
+ * we can't have, or don't want to close, excess consensus connections. */
+STATIC int
+connection_dir_would_close_consensus_conn_helper(void)
+{
+  const or_options_t *options = get_options();
+
+  /* we're only interested in closing excess connections if we could
+   * have created any in the first place */
+  if (!networkstatus_consensus_can_use_multiple_directories(options)) {
+    return 0;
+  }
+
+  /* We want to close excess connections downloading a consensus.
+   * If there aren't any excess, we don't have anything to close. */
+  if (!networkstatus_consensus_has_excess_connections()) {
+    return 0;
+  }
+
+  /* If we have excess connections, but none of them are downloading a
+   * consensus, and we are still bootstrapping (that is, we have no usable
+   * consensus), we don't want to close any until one starts downloading. */
+  if (!networkstatus_consensus_is_downloading_usable_flavor()
+      && networkstatus_consensus_is_boostrapping(time(NULL))) {
+    return 0;
+  }
+
+  /* If we have just stopped bootstrapping (that is, just parsed a consensus),
+   * we might still have some excess connections hanging around. So we still
+   * have to check if we want to close any, even if we've stopped
+   * bootstrapping. */
+  return 1;
+}
+
+/* Check if we would close excess consensus connections. If we would, any
+ * new consensus connection would become excess immediately, so return 1.
+ * Otherwise, return 0. */
+int
+connection_dir_avoid_extra_connection_for_purpose(unsigned int purpose)
+{
+  const or_options_t *options = get_options();
+
+  /* We're not interested in connections that aren't fetching a consensus. */
+  if (purpose != DIR_PURPOSE_FETCH_CONSENSUS) {
+    return 0;
+  }
+
+  /* we're only interested in avoiding excess connections if we could
+   * have created any in the first place */
+  if (!networkstatus_consensus_can_use_multiple_directories(options)) {
+    return 0;
+  }
+
+  /* If there are connections downloading a consensus, and we are still
+   * bootstrapping (that is, we have no usable consensus), we can be sure that
+   * any further connections would be excess. */
+  if (networkstatus_consensus_is_downloading_usable_flavor()
+      && networkstatus_consensus_is_boostrapping(time(NULL))) {
+    return 1;
+  }
+
+  return 0;
+}
+
+/* Check if we have excess consensus download connection attempts, and close
+ * conn:
+ * - if we don't have a consensus, and we're downloading a consensus, and conn
+ *   is not downloading a consensus yet, close it;
+ * - if we do have a consensus, conn is excess, close it. */
+int
+connection_dir_close_consensus_conn_if_extra(dir_connection_t *conn)
+{
+  tor_assert(conn);
+  tor_assert(conn->base_.type == CONN_TYPE_DIR);
+
+  /* We're not interested in connections that aren't fetching a consensus. */
+  if (conn->base_.purpose != DIR_PURPOSE_FETCH_CONSENSUS) {
+    return 0;
+  }
+
+  /* The connection has already been closed */
+  if (conn->base_.marked_for_close) {
+    return 0;
+  }
+
+  if (!connection_dir_would_close_consensus_conn_helper()) {
+    return 0;
+  }
+
+  const int we_are_bootstrapping = networkstatus_consensus_is_boostrapping(
+                                                                  time(NULL));
+
+  /* We don't want to check other connections to see if they are downloading,
+   * as this is prone to race-conditions. So leave it for
+   * connection_dir_consider_close_extra_consensus_conns() to clean up.
+   *
+   * But if conn has just started connecting, or we have a consensus already,
+   * we can be sure it's not needed any more. */
+  if (!we_are_bootstrapping
+      || conn->base_.state == DIR_CONN_STATE_CONNECTING) {
+    connection_close_immediate(&conn->base_);
+    connection_mark_for_close(&conn->base_);
+    return -1;
+  }
+
+  return 0;
+}
+
+/* Check if we have excess consensus download connection attempts, and close
+ * them:
+ * - if we don't have a consensus, and we're downloading a consensus, keep an
+ *   earlier connection, or a connection to a fallback directory, and close
+ *   all other connections;
+ * - if we do have a consensus, close all connections: they are all excess. */
+void
+connection_dir_close_extra_consensus_conns(void)
+{
+  if (!connection_dir_would_close_consensus_conn_helper()) {
+    return;
+  }
+
+  int we_are_bootstrapping = networkstatus_consensus_is_boostrapping(
+                                                                  time(NULL));
+
+  const char *usable_resource = networkstatus_get_flavor_name(
+                                                  usable_consensus_flavor());
+  smartlist_t *consens_usable_conns =
+                 connection_dir_list_by_purpose_and_resource(
+                                                  DIR_PURPOSE_FETCH_CONSENSUS,
+                                                  usable_resource);
+
+  /* If we want to keep a connection that's downloading, find a connection to
+   * keep, favouring:
+   * - connections opened earlier (they are likely to have progressed further)
+   * - connections to fallbacks (to reduce the load on authorities) */
+  dir_connection_t *kept_download_conn = NULL;
+  int kept_is_authority = 0;
+  if (we_are_bootstrapping) {
+    SMARTLIST_FOREACH_BEGIN(consens_usable_conns,
+                            dir_connection_t *, d) {
+      tor_assert(d);
+      int d_is_authority = router_digest_is_trusted_dir(d->identity_digest);
+      /* keep the first connection that is past the connecting state, but
+       * prefer fallbacks. */
+      if (d->base_.state != DIR_CONN_STATE_CONNECTING) {
+        if (!kept_download_conn || (kept_is_authority && !d_is_authority)) {
+          kept_download_conn = d;
+          kept_is_authority = d_is_authority;
+          /* we've found the earliest fallback, and want to keep it regardless
+           * of any other connections */
+          if (!kept_is_authority)
+            break;
+        }
+      }
+    } SMARTLIST_FOREACH_END(d);
+  }
+
+  SMARTLIST_FOREACH_BEGIN(consens_usable_conns,
+                          dir_connection_t *, d) {
+    tor_assert(d);
+    /* don't close this connection if it's the one we want to keep */
+    if (kept_download_conn && d == kept_download_conn)
+      continue;
+    /* mark all other connections for close */
+    if (!d->base_.marked_for_close) {
+      connection_close_immediate(&d->base_);
+      connection_mark_for_close(&d->base_);
+    }
+  } SMARTLIST_FOREACH_END(d);
+
+  smartlist_free(consens_usable_conns);
+  consens_usable_conns = NULL;
+
+  /* make sure we've closed all excess connections */
+  const int final_connecting_conn_count =
+              connection_dir_count_by_purpose_resource_and_state(
+                                                DIR_PURPOSE_FETCH_CONSENSUS,
+                                                usable_resource,
+                                                DIR_CONN_STATE_CONNECTING);
+  if (final_connecting_conn_count > 0) {
+    log_warn(LD_BUG, "Expected 0 consensus connections connecting after "
+             "cleanup, got %d.", final_connecting_conn_count);
+  }
+  const int expected_final_conn_count = (we_are_bootstrapping ? 1 : 0);
+  const int final_conn_count =
+              connection_dir_count_by_purpose_and_resource(
+                                                DIR_PURPOSE_FETCH_CONSENSUS,
+                                                usable_resource);
+  if (final_conn_count > expected_final_conn_count) {
+    log_warn(LD_BUG, "Expected %d consensus connections after cleanup, got "
+             "%d.", expected_final_conn_count, final_connecting_conn_count);
+  }
+}
+
 /** Connected handler for directory connections: begin sending data to the
- * server */
+ * server, and return 0, or, if the connection is an excess bootstrap
+ * connection, close all excess bootstrap connections.
+ * Only used when connections don't immediately connect. */
 int
 connection_dir_finished_connecting(dir_connection_t *conn)
 {
@@ -3451,31 +3656,63 @@ connection_dir_finished_connecting(dir_connection_t *conn)
   log_debug(LD_HTTP,"Dir connection to router %s:%u established.",
             conn->base_.address,conn->base_.port);
 
-  conn->base_.state = DIR_CONN_STATE_CLIENT_SENDING; /* start flushing conn */
+  if (connection_dir_close_consensus_conn_if_extra(conn)) {
+    return -1;
+  }
+
+  /* start flushing conn */
+  conn->base_.state = DIR_CONN_STATE_CLIENT_SENDING;
   return 0;
 }
 
 /** Decide which download schedule we want to use based on descriptor type
- * in <b>dls</b> and whether we are acting as directory <b>server</b>, and
- * then return a list of int pointers defining download delays in seconds.
- * Helper function for download_status_increment_failure() and
- * download_status_reset(). */
-static const smartlist_t *
-find_dl_schedule_and_len(download_status_t *dls, int server)
+ * in <b>dls</b> and <b>options</b>.
+ * Then return a list of int pointers defining download delays in seconds.
+ * Helper function for download_status_increment_failure(),
+ * download_status_reset(), and download_status_increment_attempt(). */
+STATIC const smartlist_t *
+find_dl_schedule(download_status_t *dls, const or_options_t *options)
 {
+  const int dir_server = dir_server_mode(options);
+  const int multi_d = networkstatus_consensus_can_use_multiple_directories(
+                                                                    options);
+  const int we_are_bootstrapping = networkstatus_consensus_is_boostrapping(
+                                                                 time(NULL));
+  const int use_fallbacks = networkstatus_consensus_can_use_extra_fallbacks(
+                                                                    options);
   switch (dls->schedule) {
     case DL_SCHED_GENERIC:
-      if (server)
-        return get_options()->TestingServerDownloadSchedule;
-      else
-        return get_options()->TestingClientDownloadSchedule;
+      if (dir_server) {
+        return options->TestingServerDownloadSchedule;
+      } else {
+        return options->TestingClientDownloadSchedule;
+      }
     case DL_SCHED_CONSENSUS:
-      if (server)
-        return get_options()->TestingServerConsensusDownloadSchedule;
-      else
-        return get_options()->TestingClientConsensusDownloadSchedule;
+      if (!multi_d) {
+        return options->TestingServerConsensusDownloadSchedule;
+      } else {
+        if (we_are_bootstrapping) {
+          if (!use_fallbacks) {
+            /* A bootstrapping client without extra fallback directories */
+            return
+         options->TestingClientBootstrapConsensusAuthorityOnlyDownloadSchedule;
+          } else if (dls->want_authority) {
+            /* A bootstrapping client with extra fallback directories, but
+             * connecting to an authority */
+            return
+             options->TestingClientBootstrapConsensusAuthorityDownloadSchedule;
+          } else {
+            /* A bootstrapping client connecting to extra fallback directories
+             */
+            return
+              options->TestingClientBootstrapConsensusFallbackDownloadSchedule;
+          }
+        } else {
+          return options->TestingClientConsensusDownloadSchedule;
+        }
+      }
     case DL_SCHED_BRIDGE:
-      return get_options()->TestingBridgeDownloadSchedule;
+      return options->TestingBridgeDownloadSchedule;
     default:
       tor_assert(0);
   }
@@ -3484,54 +3721,168 @@ find_dl_schedule_and_len(download_status_t *dls, int server)
   return NULL;
 }
 
-/** Called when an attempt to download <b>dls</b> has failed with HTTP status
+/* Find the current delay for dls based on schedule.
+ * Set dls->next_attempt_at based on now, and return the delay.
+ * Helper for download_status_increment_failure and
+ * download_status_increment_attempt. */
+STATIC int
+download_status_schedule_get_delay(download_status_t *dls,
+                                   const smartlist_t *schedule,
+                                   time_t now)
+{
+  tor_assert(dls);
+  tor_assert(schedule);
+
+  int delay = INT_MAX;
+  uint8_t dls_schedule_position = (dls->increment_on
+                                   == DL_SCHED_INCREMENT_ATTEMPT
+                                   ? dls->n_download_attempts
+                                   : dls->n_download_failures);
+
+  if (dls_schedule_position < smartlist_len(schedule))
+    delay = *(int *)smartlist_get(schedule, dls_schedule_position);
+  else if (dls_schedule_position == IMPOSSIBLE_TO_DOWNLOAD)
+    delay = INT_MAX;
+  else
+    delay = *(int *)smartlist_get(schedule, smartlist_len(schedule) - 1);
+
+  /* A negative delay makes no sense. Knowing that delay is
+   * non-negative allows us to safely do the wrapping check below. */
+  tor_assert(delay >= 0);
+
+  /* Avoid now+delay overflowing INT_MAX, by comparing with a subtraction
+   * that won't overflow (since delay is non-negative). */
+  if (delay < INT_MAX && now <= INT_MAX - delay) {
+    dls->next_attempt_at = now+delay;
+  } else {
+    dls->next_attempt_at = TIME_MAX;
+  }
+
+  return delay;
+}
+
+/* Log a debug message about item, which increments on increment_action, has
+ * incremented dls_n_download_increments times. The message varies based on
+ * was_schedule_incremented (if not, not_incremented_response is logged), and
+ * the values of increment, dls_next_attempt_at, and now.
+ * Helper for download_status_increment_failure and
+ * download_status_increment_attempt. */
+static void
+download_status_log_helper(const char *item, int was_schedule_incremented,
+                           const char *increment_action,
+                           const char *not_incremented_response,
+                           uint8_t dls_n_download_increments, int increment,
+                           time_t dls_next_attempt_at, time_t now)
+{
+  if (item) {
+    if (!was_schedule_incremented)
+      log_debug(LD_DIR, "%s %s %d time(s); I'll try again %s.",
+                item, increment_action, (int)dls_n_download_increments,
+                not_incremented_response);
+    else if (increment == 0)
+      log_debug(LD_DIR, "%s %s %d time(s); I'll try again immediately.",
+                item, increment_action, (int)dls_n_download_increments);
+    else if (dls_next_attempt_at < TIME_MAX)
+      log_debug(LD_DIR, "%s %s %d time(s); I'll try again in %d seconds.",
+                item, increment_action, (int)dls_n_download_increments,
+                (int)(dls_next_attempt_at-now));
+    else
+      log_debug(LD_DIR, "%s %s %d time(s); Giving up for a while.",
+                item, increment_action, (int)dls_n_download_increments);
+  }
+}
+
+/** Determine when a failed download attempt should be retried.
+ * Called when an attempt to download <b>dls</b> has failed with HTTP status
  * <b>status_code</b>.  Increment the failure count (if the code indicates a
- * real failure) and set <b>dls</b>-\>next_attempt_at to an appropriate time
- * in the future. */
+ * real failure, or if we're a server) and set <b>dls</b>-\>next_attempt_at to
+ * an appropriate time in the future and return it.
+ * If <b>dls->increment_on</b> is DL_SCHED_INCREMENT_ATTEMPT, increment the
+ * failure count, and return a time in the far future for the next attempt (to
+ * avoid an immediate retry). */
 time_t
 download_status_increment_failure(download_status_t *dls, int status_code,
                                   const char *item, int server, time_t now)
 {
-  const smartlist_t *schedule;
-  int increment;
+  int increment = -1;
   tor_assert(dls);
+
+  /* only count the failure if it's permanent, or we're a server */
   if (status_code != 503 || server) {
     if (dls->n_download_failures < IMPOSSIBLE_TO_DOWNLOAD-1)
       ++dls->n_download_failures;
   }
 
-  schedule = find_dl_schedule_and_len(dls, server);
+  if (dls->increment_on == DL_SCHED_INCREMENT_FAILURE) {
+    /* We don't find out that a failure-based schedule has attempted a
+     * connection until that connection fails.
+     * We'll never find out about successful connections, but this doesn't
+     * matter, because schedules are reset after a successful download.
+     */
+    if (dls->n_download_attempts < IMPOSSIBLE_TO_DOWNLOAD-1)
+      ++dls->n_download_attempts;
 
-  if (dls->n_download_failures < smartlist_len(schedule))
-    increment = *(int *)smartlist_get(schedule, dls->n_download_failures);
-  else if (dls->n_download_failures == IMPOSSIBLE_TO_DOWNLOAD)
-    increment = INT_MAX;
-  else
-    increment = *(int *)smartlist_get(schedule, smartlist_len(schedule) - 1);
+    /* only return a failure retry time if this schedule increments on failures
+     */
+    const smartlist_t *schedule = find_dl_schedule(dls, get_options());
+    increment = download_status_schedule_get_delay(dls, schedule, now);
+  }
 
-  if (increment < INT_MAX)
-    dls->next_attempt_at = now+increment;
-  else
-    dls->next_attempt_at = TIME_MAX;
+  download_status_log_helper(item, !dls->increment_on, "failed",
+                             "concurrently", dls->n_download_failures,
+                             increment, dls->next_attempt_at, now);
 
-  if (item) {
-    if (increment == 0)
-      log_debug(LD_DIR, "%s failed %d time(s); I'll try again immediately.",
-                item, (int)dls->n_download_failures);
-    else if (dls->next_attempt_at < TIME_MAX)
-      log_debug(LD_DIR, "%s failed %d time(s); I'll try again in %d seconds.",
-                item, (int)dls->n_download_failures,
-                (int)(dls->next_attempt_at-now));
-    else
-      log_debug(LD_DIR, "%s failed %d time(s); Giving up for a while.",
-                item, (int)dls->n_download_failures);
+  if (dls->increment_on == DL_SCHED_INCREMENT_ATTEMPT) {
+    /* stop this schedule retrying on failure, it will launch concurrent
+     * connections instead */
+    return TIME_MAX;
+  } else {
+    return dls->next_attempt_at;
   }
+}
+
+/** Determine when the next download attempt should be made when using an
+ * attempt-based (potentially concurrent) download schedule.
+ * Called when an attempt to download <b>dls</b> is being initiated.
+ * Increment the attempt count and set <b>dls</b>-\>next_attempt_at to an
+ * appropriate time in the future and return it.
+ * If <b>dls->increment_on</b> is DL_SCHED_INCREMENT_FAILURE, don't increment
+ * the attempts, and return a time in the far future (to avoid launching a
+ * concurrent attempt). */
+time_t
+download_status_increment_attempt(download_status_t *dls, const char *item,
+                                  time_t now)
+{
+  int delay = -1;
+  tor_assert(dls);
+
+  if (dls->increment_on == DL_SCHED_INCREMENT_FAILURE) {
+    /* this schedule should retry on failure, and not launch any concurrent
+     attempts */
+    log_info(LD_BUG, "Tried to launch an attempt-based connection on a "
+             "failure-based schedule.");
+    return TIME_MAX;
+  }
+
+  if (dls->n_download_attempts < IMPOSSIBLE_TO_DOWNLOAD-1)
+    ++dls->n_download_attempts;
+
+  const smartlist_t *schedule = find_dl_schedule(dls, get_options());
+  delay = download_status_schedule_get_delay(dls, schedule, now);
+
+  download_status_log_helper(item, dls->increment_on, "attempted",
+                             "on failure", dls->n_download_attempts,
+                             delay, dls->next_attempt_at, now);
+
   return dls->next_attempt_at;
 }
 
 /** Reset <b>dls</b> so that it will be considered downloadable
  * immediately, and/or to show that we don't need it anymore.
  *
+ * Must be called to initialise a download schedule, otherwise the zeroth item
+ * in the schedule will never be used.
+ *
  * (We find the zeroth element of the download schedule, and set
  * next_attempt_at to be the appropriate offset from 'now'. In most
  * cases this means setting it to 'now', so the item will be immediately
@@ -3540,14 +3891,16 @@ download_status_increment_failure(download_status_t *dls, int status_code,
 void
 download_status_reset(download_status_t *dls)
 {
-  if (dls->n_download_failures == IMPOSSIBLE_TO_DOWNLOAD)
+  if (dls->n_download_failures == IMPOSSIBLE_TO_DOWNLOAD
+      || dls->n_download_attempts == IMPOSSIBLE_TO_DOWNLOAD)
     return; /* Don't reset this. */
 
-  const smartlist_t *schedule = find_dl_schedule_and_len(
-                          dls, get_options()->DirPort_set);
+  const smartlist_t *schedule = find_dl_schedule(dls, get_options());
 
   dls->n_download_failures = 0;
+  dls->n_download_attempts = 0;
   dls->next_attempt_at = time(NULL) + *(int *)smartlist_get(schedule, 0);
+  /* Don't reset dls->want_authority or dls->increment_on */
 }
 
 /** Return the number of failures on <b>dls</b> since the last success (if
@@ -3558,6 +3911,22 @@ download_status_get_n_failures(const download_status_t *dls)
   return dls->n_download_failures;
 }
 
+/** Return the number of attempts to download <b>dls</b> since the last success
+ * (if any). This can differ from download_status_get_n_failures() due to
+ * outstanding concurrent attempts. */
+int
+download_status_get_n_attempts(const download_status_t *dls)
+{
+  return dls->n_download_attempts;
+}
+
+/** Return the next time to attempt to download <b>dls</b>. */
+time_t
+download_status_get_next_attempt_at(const download_status_t *dls)
+{
+  return dls->next_attempt_at;
+}
+
 /** Called when one or more routerdesc (or extrainfo, if <b>was_extrainfo</b>)
  * fetches have failed (with uppercase fingerprints listed in <b>failed</b>,
  * either as descriptor digests or as identity digests based on
diff --git a/src/or/directory.h b/src/or/directory.h
index 4899eb5..c5b5a5a 100644
--- a/src/or/directory.h
+++ b/src/or/directory.h
@@ -16,10 +16,12 @@ int directories_have_accepted_server_descriptor(void);
 void directory_post_to_dirservers(uint8_t dir_purpose, uint8_t router_purpose,
                                   dirinfo_type_t type, const char *payload,
                                   size_t payload_len, size_t extrainfo_len);
-MOCK_DECL(void, directory_get_from_dirserver, (uint8_t dir_purpose,
-                                               uint8_t router_purpose,
-                                               const char *resource,
-                                               int pds_flags));
+MOCK_DECL(void, directory_get_from_dirserver, (
+                          uint8_t dir_purpose,
+                          uint8_t router_purpose,
+                          const char *resource,
+                          int pds_flags,
+                          download_want_authority_t want_authority));
 void directory_get_from_all_authorities(uint8_t dir_purpose,
                                         uint8_t router_purpose,
                                         const char *resource);
@@ -37,14 +39,16 @@ typedef enum {
   DIRIND_ANON_DIRPORT,
 } dir_indirection_t;
 
-void directory_initiate_command_routerstatus(const routerstatus_t *status,
-                                             uint8_t dir_purpose,
-                                             uint8_t router_purpose,
-                                             dir_indirection_t indirection,
-                                             const char *resource,
-                                             const char *payload,
-                                             size_t payload_len,
-                                             time_t if_modified_since);
+MOCK_DECL(void, directory_initiate_command_routerstatus,
+                (const routerstatus_t *status,
+                 uint8_t dir_purpose,
+                 uint8_t router_purpose,
+                 dir_indirection_t indirection,
+                 const char *resource,
+                 const char *payload,
+                 size_t payload_len,
+                 time_t if_modified_since));
+
 void directory_initiate_command_routerstatus_rend(const routerstatus_t *status,
                                                   uint8_t dir_purpose,
                                                   uint8_t router_purpose,
@@ -72,6 +76,9 @@ void directory_initiate_command(const tor_addr_t *addr,
                                 const char *resource,
                                 const char *payload, size_t payload_len,
                                 time_t if_modified_since);
+int connection_dir_avoid_extra_connection_for_purpose(unsigned int purpose);
+int connection_dir_close_consensus_conn_if_extra(dir_connection_t *conn);
+void connection_dir_close_extra_consensus_conns(void);
 
 #define DSR_HEX       (1<<0)
 #define DSR_BASE64    (1<<1)
@@ -90,34 +97,41 @@ int router_supports_extrainfo(const char *identity_digest, int is_authority);
 time_t download_status_increment_failure(download_status_t *dls,
                                          int status_code, const char *item,
                                          int server, time_t now);
+time_t download_status_increment_attempt(download_status_t *dls,
+                                         const char *item,  time_t now);
 /** Increment the failure count of the download_status_t <b>dls</b>, with
  * the optional status code <b>sc</b>. */
 #define download_status_failed(dls, sc)                                 \
   download_status_increment_failure((dls), (sc), NULL,                  \
-                                    get_options()->DirPort_set, time(NULL))
+                                    dir_server_mode(get_options()), \
+                                    time(NULL))
 
 void download_status_reset(download_status_t *dls);
 static int download_status_is_ready(download_status_t *dls, time_t now,
                                     int max_failures);
 /** Return true iff, as of <b>now</b>, the resource tracked by <b>dls</b> is
  * ready to get its download reattempted. */
-static INLINE int
+static inline int
 download_status_is_ready(download_status_t *dls, time_t now,
                          int max_failures)
 {
-  return (dls->n_download_failures <= max_failures
-          && dls->next_attempt_at <= now);
+  int under_failure_limit = (dls->n_download_failures <= max_failures
+                             && dls->n_download_attempts <= max_failures);
+  return (under_failure_limit && dls->next_attempt_at <= now);
 }
 
 static void download_status_mark_impossible(download_status_t *dl);
 /** Mark <b>dl</b> as never downloadable. */
-static INLINE void
+static inline void
 download_status_mark_impossible(download_status_t *dl)
 {
   dl->n_download_failures = IMPOSSIBLE_TO_DOWNLOAD;
+  dl->n_download_attempts = IMPOSSIBLE_TO_DOWNLOAD;
 }
 
 int download_status_get_n_failures(const download_status_t *dls);
+int download_status_get_n_attempts(const download_status_t *dls);
+time_t download_status_get_next_attempt_at(const download_status_t *dls);
 
 #ifdef TOR_UNIT_TESTS
 /* Used only by directory.c and test_dir.c */
@@ -127,6 +141,21 @@ STATIC int purpose_needs_anonymity(uint8_t dir_purpose,
                                    uint8_t router_purpose);
 STATIC dirinfo_type_t dir_fetch_type(int dir_purpose, int router_purpose,
                                      const char *resource);
+STATIC int directory_handle_command_get(dir_connection_t *conn,
+                                        const char *headers,
+                                        const char *req_body,
+                                        size_t req_body_len);
+STATIC int connection_dir_would_close_consensus_conn_helper(void);
+STATIC int download_status_schedule_get_delay(download_status_t *dls,
+                                              const smartlist_t *schedule,
+                                              time_t now);
+
+STATIC char* authdir_type_to_string(dirinfo_type_t auth);
+STATIC const char * dir_conn_purpose_to_string(int purpose);
+STATIC int should_use_directory_guards(const or_options_t *options);
+STATIC zlib_compression_level_t choose_compression_level(ssize_t n_bytes);
+STATIC const smartlist_t *find_dl_schedule(download_status_t *dls,
+                                           const or_options_t *options);
 #endif
 
 #endif
diff --git a/src/or/dirserv.c b/src/or/dirserv.c
index 8d9f166..491557e 100644
--- a/src/or/dirserv.c
+++ b/src/or/dirserv.c
@@ -797,7 +797,7 @@ list_single_server_status(const routerinfo_t *desc, int is_live)
 }
 
 /* DOCDOC running_long_enough_to_decide_unreachable */
-static INLINE int
+static inline int
 running_long_enough_to_decide_unreachable(void)
 {
   return time_of_process_start
@@ -1091,13 +1091,13 @@ directory_fetches_from_authorities(const or_options_t *options)
     return 1; /* we don't know our IP address; ask an authority. */
   refuseunknown = ! router_my_exit_policy_is_reject_star() &&
     should_refuse_unknown_exits(options);
-  if (!options->DirPort_set && !refuseunknown)
+  if (!dir_server_mode(options) && !refuseunknown)
     return 0;
   if (!server_mode(options) || !advertised_server_mode())
     return 0;
   me = router_get_my_routerinfo();
-  if (!me || (!me->dir_port && !refuseunknown))
-    return 0; /* if dirport not advertised, return 0 too */
+  if (!me || (!me->supports_tunnelled_dir_requests && !refuseunknown))
+    return 0; /* if we don't service directory requests, return 0 too */
   return 1;
 }
 
@@ -1128,7 +1128,7 @@ directory_fetches_dir_info_later(const or_options_t *options)
 int
 directory_caches_unknown_auth_certs(const or_options_t *options)
 {
-  return options->DirPort_set || options->BridgeRelay;
+  return dir_server_mode(options) || options->BridgeRelay;
 }
 
 /** Return 1 if we want to keep descriptors, networkstatuses, etc around
@@ -1137,7 +1137,7 @@ directory_caches_unknown_auth_certs(const or_options_t *options)
 int
 directory_caches_dir_info(const or_options_t *options)
 {
-  if (options->BridgeRelay || options->DirPort_set)
+  if (options->BridgeRelay || dir_server_mode(options))
     return 1;
   if (!server_mode(options) || !advertised_server_mode())
     return 0;
@@ -1153,7 +1153,7 @@ directory_caches_dir_info(const or_options_t *options)
 int
 directory_permits_begindir_requests(const or_options_t *options)
 {
-  return options->BridgeRelay != 0 || options->DirPort_set;
+  return options->BridgeRelay != 0 || dir_server_mode(options);
 }
 
 /** Return 1 if we have no need to fetch new descriptors. This generally
@@ -1302,7 +1302,7 @@ static uint32_t guard_bandwidth_excluding_exits_kb = 0;
 
 /** Helper: estimate the uptime of a router given its stated uptime and the
  * amount of time since it last stated its stated uptime. */
-static INLINE long
+static inline long
 real_uptime(const routerinfo_t *router, time_t now)
 {
   if (now < router->cache_info.published_on)
@@ -1350,8 +1350,9 @@ dirserv_thinks_router_is_unreliable(time_t now,
 }
 
 /** Return true iff <b>router</b> should be assigned the "HSDir" flag.
+ *
  * Right now this means it advertises support for it, it has a high uptime,
- * it has a DirPort open, it has the Stable and Fast flag and it's currently
+ * it's a directory cache, it has the Stable and Fast flags, and it's currently
  * considered Running.
  *
  * This function needs to be called after router-\>is_running has
@@ -1378,7 +1379,8 @@ dirserv_thinks_router_is_hs_dir(const routerinfo_t *router,
   else
     uptime = real_uptime(router, now);
 
-  return (router->wants_to_be_hs_dir && router->dir_port &&
+  return (router->wants_to_be_hs_dir &&
+          router->supports_tunnelled_dir_requests &&
           node->is_stable && node->is_fast &&
           uptime >= get_options()->MinUptimeHidServDirectoryV2 &&
           router_is_active(router, node, now));
@@ -1921,7 +1923,7 @@ routerstatus_format_entry(const routerstatus_t *rs, const char *version,
                    rs->is_hs_dir?" HSDir":"",
                    rs->is_flagged_running?" Running":"",
                    rs->is_stable?" Stable":"",
-                   (rs->dir_port!=0)?" V2Dir":"",
+                   rs->is_v2_dir?" V2Dir":"",
                    rs->is_valid?" Valid":"");
 
   /* length of "opt v \n" */
@@ -2185,6 +2187,7 @@ set_routerstatus_from_routerinfo(routerstatus_t *rs,
   strlcpy(rs->nickname, ri->nickname, sizeof(rs->nickname));
   rs->or_port = ri->or_port;
   rs->dir_port = ri->dir_port;
+  rs->is_v2_dir = ri->supports_tunnelled_dir_requests;
   if (options->AuthDirHasIPv6Connectivity == 1 &&
       !tor_addr_is_null(&ri->ipv6_addr) &&
       node->last_reachable6 >= now - REACHABLE_TIMEOUT) {
@@ -3132,7 +3135,7 @@ dirserv_get_routerdescs(smartlist_t *descs_out, const char *key,
  * router listening at <b>address</b>:<b>or_port</b>, and has yielded
  * a certificate with digest <b>digest_rcvd</b>.
  *
- * Inform the reachability checker that we could get to this guy.
+ * Inform the reachability checker that we could get to this relay.
  */
 void
 dirserv_orconn_tls_done(const tor_addr_t *addr,
diff --git a/src/or/dirvote.c b/src/or/dirvote.c
index d8e6ee2..b61b33a 100644
--- a/src/or/dirvote.c
+++ b/src/or/dirvote.c
@@ -54,7 +54,6 @@ static int dirvote_perform_vote(void);
 static void dirvote_clear_votes(int all_votes);
 static int dirvote_compute_consensuses(void);
 static int dirvote_publish_consensus(void);
-static char *make_consensus_method_list(int low, int high, const char *sep);
 
 /* =====
  * Voting
@@ -564,7 +563,7 @@ consensus_method_is_supported(int method)
 
 /** Return a newly allocated string holding the numbers between low and high
  * (inclusive) that are supported consensus methods. */
-static char *
+STATIC char *
 make_consensus_method_list(int low, int high, const char *separator)
 {
   char *list;
@@ -3373,8 +3372,8 @@ dirvote_free_all(void)
  * ==== */
 
 /** Return the body of the consensus that we're currently trying to build. */
-const char *
-dirvote_get_pending_consensus(consensus_flavor_t flav)
+MOCK_IMPL(const char *,
+dirvote_get_pending_consensus, (consensus_flavor_t flav))
 {
   tor_assert(((int)flav) >= 0 && (int)flav < N_CONSENSUS_FLAVORS);
   return pending_consensuses[flav].body;
@@ -3382,8 +3381,8 @@ dirvote_get_pending_consensus(consensus_flavor_t flav)
 
 /** Return the signatures that we know for the consensus that we're currently
  * trying to build. */
-const char *
-dirvote_get_pending_detached_signatures(void)
+MOCK_IMPL(const char *,
+dirvote_get_pending_detached_signatures, (void))
 {
   return pending_consensus_signatures;
 }
diff --git a/src/or/dirvote.h b/src/or/dirvote.h
index dca8540..cc526ea 100644
--- a/src/or/dirvote.h
+++ b/src/or/dirvote.h
@@ -136,8 +136,10 @@ int dirvote_add_signatures(const char *detached_signatures_body,
                            const char **msg_out);
 
 /* Item access */
-const char *dirvote_get_pending_consensus(consensus_flavor_t flav);
-const char *dirvote_get_pending_detached_signatures(void);
+MOCK_DECL(const char*, dirvote_get_pending_consensus,
+          (consensus_flavor_t flav));
+MOCK_DECL(const char*, dirvote_get_pending_detached_signatures, (void));
+
 #define DGV_BY_ID 1
 #define DGV_INCLUDE_PENDING 2
 #define DGV_INCLUDE_PREVIOUS 4
@@ -175,6 +177,7 @@ STATIC char *format_networkstatus_vote(crypto_pk_t *private_key,
 STATIC char *dirvote_compute_params(smartlist_t *votes, int method,
                              int total_authorities);
 STATIC char *compute_consensus_package_lines(smartlist_t *votes);
+STATIC char *make_consensus_method_list(int low, int high, const char *sep);
 #endif
 
 #endif
diff --git a/src/or/dns.c b/src/or/dns.c
index d71246d..3f5dfd2 100644
--- a/src/or/dns.c
+++ b/src/or/dns.c
@@ -107,13 +107,9 @@ static void dns_found_answer(const char *address, uint8_t query_type,
                              const tor_addr_t *addr,
                              const char *hostname,
                              uint32_t ttl);
-static int launch_resolve(cached_resolve_t *resolve);
 static void add_wildcarded_test_address(const char *address);
 static int configure_nameservers(int force);
 static int answer_is_wildcarded(const char *ip);
-static int set_exitconn_info_from_resolve(edge_connection_t *exitconn,
-                                          const cached_resolve_t *resolve,
-                                          char **hostname_out);
 static int evdns_err_is_transient(int err);
 static void inform_pending_connections(cached_resolve_t *resolve);
 static void make_pending_resolve_cached(cached_resolve_t *cached);
@@ -138,7 +134,7 @@ static int dns_is_broken_for_ipv6 = 0;
 
 /** Function to compare hashed resolves on their addresses; used to
  * implement hash tables. */
-static INLINE int
+static inline int
 cached_resolves_eq(cached_resolve_t *a, cached_resolve_t *b)
 {
   /* make this smarter one day? */
@@ -147,7 +143,7 @@ cached_resolves_eq(cached_resolve_t *a, cached_resolve_t *b)
 }
 
 /** Hash function for cached_resolve objects */
-static INLINE unsigned int
+static inline unsigned int
 cached_resolve_hash(cached_resolve_t *a)
 {
   return (unsigned) siphash24g((const uint8_t*)a->address, strlen(a->address));
@@ -859,10 +855,10 @@ dns_resolve_impl,(edge_connection_t *exitconn, int is_resolve,
  * Return -2 on a transient error, -1 on a permenent error, and 1 on
  * a successful lookup.
  */
-static int
-set_exitconn_info_from_resolve(edge_connection_t *exitconn,
-                               const cached_resolve_t *resolve,
-                               char **hostname_out)
+MOCK_IMPL(STATIC int,
+set_exitconn_info_from_resolve,(edge_connection_t *exitconn,
+                                const cached_resolve_t *resolve,
+                                char **hostname_out))
 {
   int ipv4_ok, ipv6_ok, answer_with_ipv4, r;
   uint32_t begincell_flags;
@@ -1130,7 +1126,7 @@ dns_cancel_pending_resolve,(const char *address))
 
 /** Return true iff <b>address</b> is one of the addresses we use to verify
  * that well-known sites aren't being hijacked by our DNS servers. */
-static INLINE int
+static inline int
 is_test_address(const char *address)
 {
   const or_options_t *options = get_options();
@@ -1664,8 +1660,8 @@ launch_one_resolve(const char *address, uint8_t query_type,
 /** For eventdns: start resolving as necessary to find the target for
  * <b>exitconn</b>.  Returns -1 on error, -2 on transient error,
  * 0 on "resolve launched." */
-static int
-launch_resolve(cached_resolve_t *resolve)
+MOCK_IMPL(STATIC int,
+launch_resolve,(cached_resolve_t *resolve))
 {
   tor_addr_t a;
   int r;
@@ -2118,5 +2114,18 @@ assert_cache_ok_(void)
       }
     });
 }
+
 #endif
 
+cached_resolve_t
+*dns_get_cache_entry(cached_resolve_t *query)
+{
+  return HT_FIND(cache_map, &cache_root, query);
+}
+
+void
+dns_insert_cache_entry(cached_resolve_t *new_entry)
+{
+  HT_INSERT(cache_map, &cache_root, new_entry);
+}
+
diff --git a/src/or/dns.h b/src/or/dns.h
index 6af7796..c2778b2 100644
--- a/src/or/dns.h
+++ b/src/or/dns.h
@@ -42,6 +42,18 @@ uint8_t answer_type,const cached_resolve_t *resolved));
 
 MOCK_DECL(STATIC void,send_resolved_hostname_cell,(edge_connection_t *conn,
 const char *hostname));
+
+cached_resolve_t *dns_get_cache_entry(cached_resolve_t *query);
+void dns_insert_cache_entry(cached_resolve_t *new_entry);
+
+MOCK_DECL(STATIC int,
+set_exitconn_info_from_resolve,(edge_connection_t *exitconn,
+                                const cached_resolve_t *resolve,
+                                char **hostname_out));
+
+MOCK_DECL(STATIC int,
+launch_resolve,(cached_resolve_t *resolve));
+
 #endif
 
 #endif
diff --git a/src/or/dnsserv.c b/src/or/dnsserv.c
index f771090..ded0d84 100644
--- a/src/or/dnsserv.c
+++ b/src/or/dnsserv.c
@@ -125,6 +125,7 @@ evdns_server_callback(struct evdns_server_request *req, void *data_)
   /* Make a new dummy AP connection, and attach the request to it. */
   entry_conn = entry_connection_new(CONN_TYPE_AP, AF_INET);
   conn = ENTRY_TO_EDGE_CONN(entry_conn);
+  CONNECTION_AP_EXPECT_NONPENDING(entry_conn);
   TO_CONN(conn)->state = AP_CONN_STATE_RESOLVE_WAIT;
   conn->is_dns_request = 1;
 
@@ -199,6 +200,7 @@ dnsserv_launch_request(const char *name, int reverse,
   /* Make a new dummy AP connection, and attach the request to it. */
   entry_conn = entry_connection_new(CONN_TYPE_AP, AF_INET);
   conn = ENTRY_TO_EDGE_CONN(entry_conn);
+  CONNECTION_AP_EXPECT_NONPENDING(entry_conn);
   conn->base_.state = AP_CONN_STATE_RESOLVE_WAIT;
 
   tor_addr_copy(&TO_CONN(conn)->addr, &control_conn->base_.addr);
diff --git a/src/or/entrynodes.c b/src/or/entrynodes.c
index ebf6751..789c53d 100644
--- a/src/or/entrynodes.c
+++ b/src/or/entrynodes.c
@@ -1152,7 +1152,7 @@ choose_random_entry_impl(cpath_build_state_t *state, int for_directory,
   } else {
     /* Try to have at least 2 choices available. This way we don't
      * get stuck with a single live-but-crummy entry and just keep
-     * using him.
+     * using it.
      * (We might get 2 live-but-crummy entry guards, but so be it.) */
     preferred_min = 2;
   }
@@ -2205,7 +2205,7 @@ fetch_bridge_descriptors(const or_options_t *options, time_t now)
         log_info(LD_DIR, "Fetching bridge info '%s' from bridge authority.",
                  resource);
         directory_get_from_dirserver(DIR_PURPOSE_FETCH_SERVERDESC,
-                ROUTER_PURPOSE_BRIDGE, resource, 0);
+                ROUTER_PURPOSE_BRIDGE, resource, 0, DL_WANT_AUTHORITY);
       }
     }
   SMARTLIST_FOREACH_END(bridge);
diff --git a/src/or/eventdns_tor.h b/src/or/eventdns_tor.h
index 9d51f09..f41c5c0 100644
--- a/src/or/eventdns_tor.h
+++ b/src/or/eventdns_tor.h
@@ -12,9 +12,6 @@ typedef unsigned int uint;
 #ifndef HAVE_U_CHAR
 typedef unsigned char u_char;
 #endif
-#ifdef _WIN32
-#define inline __inline
-#endif
 #include "torint.h"
 
 /* These are for debugging possible memory leaks. */
diff --git a/src/or/ext_orport.c b/src/or/ext_orport.c
index e8c8aa6..810fa0d 100644
--- a/src/or/ext_orport.c
+++ b/src/or/ext_orport.c
@@ -151,7 +151,7 @@ init_ext_or_cookie_authentication(int is_enabled)
 }
 
 /** Read data from <b>conn</b> and see if the client sent us the
- *  authentication type that she prefers to use in this session.
+ *  authentication type that they prefer to use in this session.
  *
  *  Return -1 if we received corrupted data or if we don't support the
  *  authentication type. Return 0 if we need more data in
@@ -193,8 +193,7 @@ handle_client_auth_nonce(const char *client_nonce, size_t client_nonce_len,
     return -1;
 
   /* Get our nonce */
-  if (crypto_rand(server_nonce, EXT_OR_PORT_AUTH_NONCE_LEN) < 0)
-    return -1;
+  crypto_rand(server_nonce, EXT_OR_PORT_AUTH_NONCE_LEN);
 
   { /* set up macs */
     size_t hmac_s_msg_len = strlen(EXT_OR_PORT_AUTH_SERVER_TO_CLIENT_CONST) +
diff --git a/src/or/fallback_dirs.inc b/src/or/fallback_dirs.inc
new file mode 100644
index 0000000..d05f16f
--- /dev/null
+++ b/src/or/fallback_dirs.inc
@@ -0,0 +1,206 @@
+/* Trial fallbacks for 0.2.8.1-alpha with ADDRESS_AND_PORT_STABLE_DAYS = 30
+ * This works around an issue where relays post a descriptor without a DirPort
+ * when restarted. If these relays stay up, they will have been up for 120 days
+ * by the 0.2.8 stable release -- teor */
+/* Whitelist & blacklist excluded 1070 of 1091 candidates. */
+/*
+Fallback Directory Summary
+Final Count:  21 (Eligible 21, Usable 21, Target 290 (1454 * 0.200000), Clamped to 500)
+*/
+/* Ignore low fallback numbers in alpha builds -- teor
+#error Fallback Count 21 is too low. Must be at least 100 for diversity. Try adding entries to the whitelist, or setting INCLUDE_UNLISTED_ENTRIES = True.
+*/
+/*
+Final Weight: 491920 (Eligible 546000)
+Max Weight:   43680 (8.879%) (Clamped to 10.000%)
+Min Weight:   8080 (1.643%) (Clamped to 0.100%)
+Clamped:   54080 (10.994%) Excess Weight, 4 High Weight Fallbacks (19.0%)
+*/
+/*
+Onionoo Source: details Date: 2016-01-18 00:00:00 Version: 3.0
+URL: https://onionoo.torproject.org/details?fields=fingerprint%2Cnickname%2Ccontact%2Clast_changed_address_or_port%2Cconsensus_weight%2Cor_addresses%2Cdir_address%2Crecommended_version%2Cflags&flag=V2Dir&type=relay&last_seen_days=-7&first_seen_days=30-
+*/
+/*
+Onionoo Source: uptime Date: 2016-01-18 00:00:00 Version: 3.0
+URL: https://onionoo.torproject.org/uptime?first_seen_days=30-&flag=V2Dir&type=relay&last_seen_days=-7
+*/
+/*
+wagner
+Flags: Fast Guard Running Stable V2Dir Valid
+Fallback Weight: 43680 / 491920 (8.879%)
+Consensus Weight: 62600 / 546000 (11.465%)
+Rarely used email <trff914 AT gmail DOT com>
+*/
+"5.175.233.86:80 orport=443 id=5525D0429BFE5DC4F1B0E9DE47A4CFA169661E33"
+" weight=43680",
+/*
+kitten2
+Flags: Fast Guard HSDir Running Stable V2Dir Valid
+Fallback Weight: 43680 / 491920 (8.879%)
+Consensus Weight: 59100 / 546000 (10.824%)
+0xEFB74277ECE4E222 Aeris <aeris+tor AT imirhil DOT fr> - 1aerisnnLWPchhDSXpxWGYWwLiSFUVFnd
+*/
+"62.210.124.124:9130 orport=9101 id=2EBD117806EE43C3CC885A8F1E4DC60F207E7D3E"
+" ipv6=[2001:bc8:3f23:100::1]:9101"
+" weight=43680",
+/*
+kitten1
+Flags: Fast Guard HSDir Running Stable V2Dir Valid
+Fallback Weight: 43680 / 491920 (8.879%)
+Consensus Weight: 57600 / 546000 (10.549%)
+0xEFB74277ECE4E222 Aeris <aeris+tor AT imirhil DOT fr> - 1aerisnnLWPchhDSXpxWGYWwLiSFUVFnd
+*/
+"62.210.124.124:9030 orport=9001 id=86E78DD3720C78DA8673182EF96C54B162CD660C"
+" ipv6=[2001:bc8:3f23:100::1]:9001"
+" weight=43680",
+/*
+fluxe4
+Flags: Fast Guard HSDir Running Stable V2Dir Valid
+Fallback Weight: 43680 / 491920 (8.879%)
+Consensus Weight: 49500 / 546000 (9.066%)
+Sebastian <tor@sebastianhahn.net> - 12NbRAjAG5U3LLWETSF7fSTcdaz32Mu5CN
+*/
+"131.188.40.188:443 orport=80 id=EBE718E1A49EE229071702964F8DB1F318075FF8"
+" weight=43680",
+/*
+BabylonNetwork03
+Flags: Exit Fast Guard HSDir Running Stable V2Dir Valid
+Fallback Weight: 38700 / 491920 (7.867%)
+Babylon Network | noc <AT> babylon <DOT> network | PGP 0x2A540FA5 | 1HiSG8pia5DdDLUMyYNkF9sicGozojZLnH
+*/
+"193.111.136.162:80 orport=443 id=C79552275DFCD486B942510EF663ED36ACA1A84B"
+" ipv6=[2001:4ba0:cafe:10d0::1]:443"
+" weight=38700",
+/*
+tornoderdednl
+Flags: Fast Guard Running Stable V2Dir Valid
+Fallback Weight: 33000 / 491920 (6.708%)
+0x4871E82F Thom Wiggers <thom @AT@ RDED POINT NL> BTC 1DLyDFV13zhCWJYHMh5bk5C58yYvpxqxfQ
+*/
+"178.62.199.226:80 orport=443 id=CBEFF7BA4A4062045133C053F2D70524D8BBE5BE"
+" ipv6=[2a03:b0c0:2:d0::b7:5001]:443"
+" weight=33000",
+/*
+fluxe3
+Flags: Fast Guard HSDir Running Stable V2Dir Valid
+Fallback Weight: 31500 / 491920 (6.403%)
+Sebastian <tor@sebastianhahn.net> - 12NbRAjAG5U3LLWETSF7fSTcdaz32Mu5CN
+*/
+"78.47.18.110:443 orport=80 id=F8D27B163B9247B232A2EEE68DD8B698695C28DE"
+" weight=31500",
+/*
+BabylonNetwork02
+Flags: Exit Fast Guard HSDir Running Stable V2Dir Valid
+Fallback Weight: 27300 / 491920 (5.550%)
+Babylon Network | noc <AT> babylon <DOT> network | PGP 0x2A540FA5 | 1HiSG8pia5DdDLUMyYNkF9sicGozojZLnH
+*/
+"149.202.98.161:80 orport=443 id=54660C671B47E6986B465B80444414BD19E5A34B"
+" ipv6=[2001:41d0:8:4528::161]:443"
+" weight=27300",
+/*
+coby
+Flags: Fast Guard HSDir Running Stable V2Dir Valid
+Fallback Weight: 20400 / 491920 (4.147%)
+c0by <coby AT 127001 dot ovh>
+*/
+"51.255.33.237:9091 orport=9001 id=A360C21FA87FFA2046D92C17086A6B47E5C68109"
+" weight=20400",
+/*
+kili
+Flags: Fast Guard HSDir Running Stable V2Dir Valid
+Fallback Weight: 19300 / 491920 (3.923%)
+0x49CBC553 Joost Rijneveld <joost AT joostrijneveld dot nl>
+*/
+"178.62.173.203:9030 orport=9001 id=DD85503F2D1F52EF9EAD621E942298F46CD2FC10"
+" ipv6=[2a03:b0c0:0:1010::a4:b001]:9001"
+" weight=19300",
+/*
+Logforme
+Flags: Fast Guard HSDir Running Stable V2Dir Valid
+Fallback Weight: 18600 / 491920 (3.781%)
+Logforme <m7527 AT abc dot se>
+*/
+"84.219.173.60:9030 orport=443 id=855BC2DABE24C861CD887DB9B2E950424B49FC34"
+" weight=18600",
+/*
+eriador
+Flags: Fast Guard HSDir Running Stable V2Dir Valid
+Fallback Weight: 17400 / 491920 (3.537%)
+hwertiout695@safe-mail.net
+*/
+"85.25.138.93:9030 orport=4029 id=6DE61A6F72C1E5418A66BFED80DFB63E4C77668F"
+" weight=17400",
+/*
+Doedel24
+Flags: Fast Guard HSDir Running Stable V2Dir Valid
+Fallback Weight: 17000 / 491920 (3.456%)
+Felix <zwiebel ta quantentunnel tod de>
+*/
+"178.254.20.134:9030 orport=9001 id=2CE96A8A1DA032664C90F574AFFBECE18A6E8DFC"
+" weight=17000",
+/*
+GrmmlLitavis
+Flags: Fast Guard HSDir Running Stable V2Dir Valid
+Fallback Weight: 15500 / 491920 (3.151%)
+<tor AT grmml DOT eu>
+*/
+"5.39.88.19:9030 orport=9001 id=7CB8C31432A796731EA7B6BF4025548DFEB25E0C"
+" ipv6=[2001:41d0:8:9a13::1]:9050"
+" weight=15500",
+/*
+Doedel21
+Flags: Fast Guard HSDir Running Stable V2Dir Valid
+Fallback Weight: 13800 / 491920 (2.805%)
+Felix <zwiebel ta quantentunnel tod de>
+*/
+"178.254.44.135:80 orport=443 id=AE6A8C18E7499B586CD36246AC4BCAFFBBF93AB2"
+" weight=13800",
+/*
+Unnamed
+Flags: Fast Guard HSDir Running Stable V2Dir Valid
+Fallback Weight: 13400 / 491920 (2.724%)
+monitor0penmailbox0rg
+*/
+"217.12.199.208:80 orport=443 id=DF3AED4322B1824BF5539AE54B2D1B38E080FF05"
+" weight=13400",
+/*
+Doedel26
+Flags: Fast Guard HSDir Running Stable V2Dir Valid
+Fallback Weight: 12800 / 491920 (2.602%)
+Felix <zwiebel ta quantentunnel tod de>
+*/
+"178.254.20.134:80 orport=443 id=9F5068310818ED7C70B0BC4087AB55CB12CB4377"
+" weight=12800",
+/*
+Doedel22
+Flags: Fast Guard HSDir Running Stable V2Dir Valid
+Fallback Weight: 12000 / 491920 (2.439%)
+Felix <zwiebel ta quantentunnel tod de>
+*/
+"178.254.44.135:9030 orport=9001 id=8FA37B93397015B2BC5A525C908485260BE9F422"
+" weight=12000",
+/*
+kitten4
+Flags: Fast Guard HSDir Running Stable V2Dir Valid
+Fallback Weight: 10100 / 491920 (2.053%)
+0xEFB74277ECE4E222 Aeris <aeris+tor AT imirhil DOT fr> - 1aerisnnLWPchhDSXpxWGYWwLiSFUVFnd
+*/
+"212.47.237.95:9130 orport=9101 id=6FB38EB22E57EF7ED5EF00238F6A48E553735D88"
+" weight=10100",
+/*
+Binnacle
+Flags: Fast Guard HSDir Running Stable V2Dir Valid
+Fallback Weight: 8320 / 491920 (1.691%)
+starlight dot YYYYqQ at binnacle dot cx
+*/
+"108.53.208.157:80 orport=443 id=4F0DB7E687FC7C0AE55C8F243DA8B0EB27FBF1F2"
+" weight=8320",
+/*
+PedicaboMundi
+Flags: Fast Guard HSDir Running Stable V2Dir Valid
+Fallback Weight: 8080 / 491920 (1.643%)
+0x43DE8191 - 12LiRiasTEL346ZFjgCh5e3nBexQuvDBTg
+*/
+"144.76.14.145:110 orport=143 id=14419131033443AE6E21DA82B0D307F7CAE42BDB"
+" ipv6=[2a01:4f8:190:9490::dead]:443"
+" weight=8080",
diff --git a/src/or/fp_pair.c b/src/or/fp_pair.c
index 42bebcd..c863d41 100644
--- a/src/or/fp_pair.c
+++ b/src/or/fp_pair.c
@@ -21,7 +21,7 @@ struct fp_pair_map_s {
  */
 
 /** Compare fp_pair_entry_t objects by key value. */
-static INLINE int
+static inline int
 fp_pair_map_entries_eq(const fp_pair_map_entry_t *a,
                        const fp_pair_map_entry_t *b)
 {
@@ -29,7 +29,7 @@ fp_pair_map_entries_eq(const fp_pair_map_entry_t *a,
 }
 
 /** Return a hash value for an fp_pair_entry_t. */
-static INLINE unsigned int
+static inline unsigned int
 fp_pair_map_entry_hash(const fp_pair_map_entry_t *a)
 {
   tor_assert(sizeof(a->key) == DIGEST_LEN*2);
diff --git a/src/or/geoip.c b/src/or/geoip.c
index 120ce47..26030ae 100644
--- a/src/or/geoip.c
+++ b/src/or/geoip.c
@@ -18,7 +18,6 @@
 #include "geoip.h"
 #include "routerlist.h"
 
-static void clear_geoip_db(void);
 static void init_geoip_countries(void);
 
 /** An entry from the GeoIP IPv4 file: maps an IPv4 range to a country. */
@@ -483,7 +482,7 @@ static HT_HEAD(clientmap, clientmap_entry_t) client_history =
      HT_INITIALIZER();
 
 /** Hashtable helper: compute a hash of a clientmap_entry_t. */
-static INLINE unsigned
+static inline unsigned
 clientmap_entry_hash(const clientmap_entry_t *a)
 {
   unsigned h = (unsigned) tor_addr_hash(&a->addr);
@@ -494,7 +493,7 @@ clientmap_entry_hash(const clientmap_entry_t *a)
   return h;
 }
 /** Hashtable helper: compare two clientmap_entry_t values for equality. */
-static INLINE int
+static inline int
 clientmap_entries_eq(const clientmap_entry_t *a, const clientmap_entry_t *b)
 {
   if (strcmp_opt(a->transport_name, b->transport_name))
@@ -970,7 +969,7 @@ geoip_get_dirreq_history(dirreq_type_t type)
                                                &ent->completion_time);
       if (time_diff == 0)
         time_diff = 1; /* Avoid DIV/0; "instant" answers are impossible
-                        * by law of nature or something, but a milisecond
+                        * by law of nature or something, but a millisecond
                         * is a bit greater than "instantly" */
       bytes_per_second = (uint32_t)(1000 * ent->response_size / time_diff);
       dltimes[ent_sl_idx] = bytes_per_second;
@@ -1207,9 +1206,9 @@ geoip_format_dirreq_stats(time_t now)
 {
   char t[ISO_TIME_LEN+1];
   int i;
-  char *v3_ips_string, *v3_reqs_string, *v3_direct_dl_string,
-       *v3_tunneled_dl_string;
-  char *result;
+  char *v3_ips_string = NULL, *v3_reqs_string = NULL,
+       *v3_direct_dl_string = NULL, *v3_tunneled_dl_string = NULL;
+  char *result = NULL;
 
   if (!start_of_dirreq_stats_interval)
     return NULL; /* Not initialized. */
@@ -1280,6 +1279,8 @@ geoip_dirreq_stats_write(time_t now)
 
   /* Generate history string .*/
   str = geoip_format_dirreq_stats(now);
+  if (! str)
+    goto done;
 
   /* Write dirreq-stats string to disk. */
   if (!check_or_create_data_subdir("stats")) {
@@ -1666,7 +1667,7 @@ getinfo_helper_geoip(control_connection_t *control_conn,
 }
 
 /** Release all storage held by the GeoIP databases and country list. */
-static void
+STATIC void
 clear_geoip_db(void)
 {
   if (geoip_countries) {
diff --git a/src/or/geoip.h b/src/or/geoip.h
index 8a3486c..3f1bba0 100644
--- a/src/or/geoip.h
+++ b/src/or/geoip.h
@@ -18,6 +18,7 @@
 STATIC int geoip_parse_entry(const char *line, sa_family_t family);
 STATIC int geoip_get_country_by_ipv4(uint32_t ipaddr);
 STATIC int geoip_get_country_by_ipv6(const struct in6_addr *addr);
+STATIC void clear_geoip_db(void);
 #endif
 int should_record_bridge_info(const or_options_t *options);
 int geoip_load_file(sa_family_t family, const char *filename);
diff --git a/src/or/hibernate.c b/src/or/hibernate.c
index 356e11f..7f8530b 100644
--- a/src/or/hibernate.c
+++ b/src/or/hibernate.c
@@ -412,11 +412,15 @@ configure_accounting(time_t now)
 
 /** Return the relevant number of bytes sent/received this interval
  * based on the set AccountingRule */
-static uint64_t
+uint64_t
 get_accounting_bytes(void)
 {
   if (get_options()->AccountingRule == ACCT_SUM)
     return n_bytes_read_in_interval+n_bytes_written_in_interval;
+  else if (get_options()->AccountingRule == ACCT_IN)
+    return n_bytes_read_in_interval;
+  else if (get_options()->AccountingRule == ACCT_OUT)
+    return n_bytes_written_in_interval;
   else
     return MAX(n_bytes_read_in_interval, n_bytes_written_in_interval);
 }
@@ -490,7 +494,7 @@ reset_accounting(time_t now)
 }
 
 /** Return true iff we should save our bandwidth usage to disk. */
-static INLINE int
+static inline int
 time_to_record_bandwidth_usage(time_t now)
 {
   /* Note every 600 sec */
@@ -1010,7 +1014,7 @@ getinfo_helper_accounting(control_connection_t *conn,
     else
       *answer = tor_strdup("awake");
   } else if (!strcmp(question, "accounting/bytes")) {
-    tor_asprintf(answer, U64_FORMAT" "U64_FORMAT,
+      tor_asprintf(answer, U64_FORMAT" "U64_FORMAT,
                  U64_PRINTF_ARG(n_bytes_read_in_interval),
                  U64_PRINTF_ARG(n_bytes_written_in_interval));
   } else if (!strcmp(question, "accounting/bytes-left")) {
@@ -1022,6 +1026,18 @@ getinfo_helper_accounting(control_connection_t *conn,
         total_left = limit - total_bytes;
       tor_asprintf(answer, U64_FORMAT" "U64_FORMAT,
                    U64_PRINTF_ARG(total_left), U64_PRINTF_ARG(total_left));
+    } else if (get_options()->AccountingRule == ACCT_IN) {
+      uint64_t read_left = 0;
+      if (n_bytes_read_in_interval < limit)
+        read_left = limit - n_bytes_read_in_interval;
+      tor_asprintf(answer, U64_FORMAT" "U64_FORMAT,
+                   U64_PRINTF_ARG(read_left), U64_PRINTF_ARG(limit));
+    } else if (get_options()->AccountingRule == ACCT_OUT) {
+      uint64_t write_left = 0;
+      if (n_bytes_written_in_interval < limit)
+        write_left = limit - n_bytes_written_in_interval;
+      tor_asprintf(answer, U64_FORMAT" "U64_FORMAT,
+                   U64_PRINTF_ARG(limit), U64_PRINTF_ARG(write_left));
     } else {
       uint64_t read_left = 0, write_left = 0;
       if (n_bytes_read_in_interval < limit)
diff --git a/src/or/hibernate.h b/src/or/hibernate.h
index b9e619c..e0d0c29 100644
--- a/src/or/hibernate.h
+++ b/src/or/hibernate.h
@@ -19,6 +19,7 @@ MOCK_DECL(int, accounting_is_enabled, (const or_options_t *options));
 int accounting_get_interval_length(void);
 MOCK_DECL(time_t, accounting_get_end_time, (void));
 void configure_accounting(time_t now);
+uint64_t get_accounting_bytes(void);
 void accounting_run_housekeeping(time_t now);
 void accounting_add_bytes(size_t n_read, size_t n_written, int seconds);
 int accounting_record_bandwidth_usage(time_t now, or_state_t *state);
diff --git a/src/or/include.am b/src/or/include.am
index d0e955f..712ae18 100644
--- a/src/or/include.am
+++ b/src/or/include.am
@@ -63,6 +63,7 @@ LIBTOR_A_SOURCES = \
 	src/or/onion_fast.c				\
 	src/or/onion_tap.c				\
 	src/or/transports.c				\
+	src/or/periodic.c				\
 	src/or/policies.c				\
 	src/or/reasons.c				\
 	src/or/relay.c					\
@@ -92,7 +93,8 @@ src_or_libtor_testing_a_SOURCES = $(LIBTOR_A_SOURCES)
 src_or_tor_SOURCES = src/or/tor_main.c
 AM_CPPFLAGS += -I$(srcdir)/src/or -Isrc/or
 
-src/or/tor_main.o: micro-revision.i
+src/or/tor_main.$(OBJEXT) \
+  src/or/src_or_tor_cov-tor_main.$(OBJEXT): micro-revision.i
 
 AM_CPPFLAGS += -DSHARE_DATADIR="\"$(datadir)\""		\
 		-DLOCALSTATEDIR="\"$(localstatedir)\""	\
@@ -108,7 +110,7 @@ src_or_libtor_testing_a_CFLAGS = $(AM_CFLAGS) $(TEST_CFLAGS)
 
 src_or_tor_LDFLAGS = @TOR_LDFLAGS_zlib@ @TOR_LDFLAGS_openssl@ @TOR_LDFLAGS_libevent@
 src_or_tor_LDADD = src/or/libtor.a src/common/libor.a \
-	src/common/libor-crypto.a $(LIBDONNA) \
+	src/common/libor-crypto.a $(LIBKECCAK_TINY) $(LIBDONNA) \
 	src/common/libor-event.a src/trunnel/libor-trunnel.a \
 	@TOR_ZLIB_LIBS@ @TOR_LIB_MATH@ @TOR_LIBEVENT_LIBS@ @TOR_OPENSSL_LIBS@ \
 	@TOR_LIB_WS32@ @TOR_LIB_GDI@ @CURVE25519_LIBS@ @TOR_SYSTEMD_LIBS@
@@ -119,13 +121,10 @@ src_or_tor_cov_CPPFLAGS = $(AM_CPPFLAGS) $(TEST_CPPFLAGS)
 src_or_tor_cov_CFLAGS = $(AM_CFLAGS) $(TEST_CFLAGS)
 src_or_tor_cov_LDFLAGS = @TOR_LDFLAGS_zlib@ @TOR_LDFLAGS_openssl@ @TOR_LDFLAGS_libevent@
 src_or_tor_cov_LDADD = src/or/libtor-testing.a src/common/libor-testing.a \
-	src/common/libor-crypto-testing.a $(LIBDONNA) \
+	src/common/libor-crypto-testing.a $(LIBKECCAK_TINY) $(LIBDONNA) \
 	src/common/libor-event-testing.a src/trunnel/libor-trunnel-testing.a \
 	@TOR_ZLIB_LIBS@ @TOR_LIB_MATH@ @TOR_LIBEVENT_LIBS@ @TOR_OPENSSL_LIBS@ \
 	@TOR_LIB_WS32@ @TOR_LIB_GDI@ @CURVE25519_LIBS@ @TOR_SYSTEMD_LIBS@
-export TESTING_TOR_BINARY=$(top_builddir)/src/or/tor-cov
-else
-export TESTING_TOR_BINARY=$(top_builddir)/src/or/tor
 endif
 
 ORHEADERS = \
@@ -157,6 +156,7 @@ ORHEADERS = \
 	src/or/dnsserv.h				\
 	src/or/eventdns_tor.h				\
 	src/or/ext_orport.h				\
+	src/or/fallback_dirs.inc			\
 	src/or/fp_pair.h				\
 	src/or/geoip.h					\
 	src/or/entrynodes.h				\
@@ -173,6 +173,7 @@ ORHEADERS = \
 	src/or/onion_tap.h				\
 	src/or/or.h					\
 	src/or/transports.h				\
+	src/or/periodic.h				\
 	src/or/policies.h				\
 	src/or/reasons.h				\
 	src/or/relay.h					\
diff --git a/src/or/keypin.c b/src/or/keypin.c
index 047d2b0..574a76d 100644
--- a/src/or/keypin.c
+++ b/src/or/keypin.c
@@ -57,14 +57,14 @@ static HT_HEAD(edmap, keypin_ent_st) the_ed_map = HT_INITIALIZER();
 
 /** Hashtable helper: compare two keypin table entries and return true iff
  * they have the same RSA key IDs. */
-static INLINE int
+static inline int
 keypin_ents_eq_rsa(const keypin_ent_t *a, const keypin_ent_t *b)
 {
   return tor_memeq(a->rsa_id, b->rsa_id, sizeof(a->rsa_id));
 }
 
 /** Hashtable helper: hash a keypin table entries based on its RSA key ID */
-static INLINE unsigned
+static inline unsigned
 keypin_ent_hash_rsa(const keypin_ent_t *a)
 {
 return (unsigned) siphash24g(a->rsa_id, sizeof(a->rsa_id));
@@ -72,14 +72,14 @@ return (unsigned) siphash24g(a->rsa_id, sizeof(a->rsa_id));
 
 /** Hashtable helper: compare two keypin table entries and return true iff
  * they have the same ed25519 keys */
-static INLINE int
+static inline int
 keypin_ents_eq_ed(const keypin_ent_t *a, const keypin_ent_t *b)
 {
   return tor_memeq(a->ed25519_key, b->ed25519_key, sizeof(a->ed25519_key));
 }
 
 /** Hashtable helper: hash a keypin table entries based on its ed25519 key */
-static INLINE unsigned
+static inline unsigned
 keypin_ent_hash_ed(const keypin_ent_t *a)
 {
 return (unsigned) siphash24g(a->ed25519_key, sizeof(a->ed25519_key));
diff --git a/src/or/main.c b/src/or/main.c
index 9b3dbb5..8c3e6a7 100644
--- a/src/or/main.c
+++ b/src/or/main.c
@@ -44,6 +44,7 @@
 #include "nodelist.h"
 #include "ntmain.h"
 #include "onion.h"
+#include "periodic.h"
 #include "policies.h"
 #include "transports.h"
 #include "relay.h"
@@ -87,6 +88,7 @@
 #include <systemd/sd-daemon.h>
 #endif
 
+
 void evdns_shutdown(int);
 
 /********* PROTOTYPES **********/
@@ -190,32 +192,6 @@ int quiet_level = 0;
  *
  ****************************************************************************/
 
-#if 0 && defined(USE_BUFFEREVENTS)
-static void
-free_old_inbuf(connection_t *conn)
-{
-  if (! conn->inbuf)
-    return;
-
-  tor_assert(conn->outbuf);
-  tor_assert(buf_datalen(conn->inbuf) == 0);
-  tor_assert(buf_datalen(conn->outbuf) == 0);
-  buf_free(conn->inbuf);
-  buf_free(conn->outbuf);
-  conn->inbuf = conn->outbuf = NULL;
-
-  if (conn->read_event) {
-    event_del(conn->read_event);
-    tor_event_free(conn->read_event);
-  }
-  if (conn->write_event) {
-    event_del(conn->read_event);
-    tor_event_free(conn->write_event);
-  }
-  conn->read_event = conn->write_event = NULL;
-}
-#endif
-
 #if defined(_WIN32) && defined(USE_BUFFEREVENTS)
 /** Remove the kernel-space send and receive buffers for <b>s</b>. For use
  * with IOCP only. */
@@ -224,11 +200,13 @@ set_buffer_lengths_to_zero(tor_socket_t s)
 {
   int zero = 0;
   int r = 0;
-  if (setsockopt(s, SOL_SOCKET, SO_SNDBUF, (void*)&zero, sizeof(zero))) {
+  if (setsockopt(s, SOL_SOCKET, SO_SNDBUF, (void*)&zero,
+                 (socklen_t)sizeof(zero))) {
     log_warn(LD_NET, "Unable to clear SO_SNDBUF");
     r = -1;
   }
-  if (setsockopt(s, SOL_SOCKET, SO_RCVBUF, (void*)&zero, sizeof(zero))) {
+  if (setsockopt(s, SOL_SOCKET, SO_RCVBUF, (void*)&zero,
+                 (socklen_t)sizeof(zero))) {
     log_warn(LD_NET, "Unable to clear SO_RCVBUF");
     r = -1;
   }
@@ -499,8 +477,7 @@ connection_in_array(connection_t *conn)
   return smartlist_contains(connection_array, conn);
 }
 
-/** Set <b>*array</b> to an array of all connections, and <b>*n</b>
- * to the length of the array. <b>*array</b> and <b>*n</b> must not
+/** Set <b>*array</b> to an array of all connections. <b>*array</b> must not
  * be modified.
  */
 smartlist_t *
@@ -944,18 +921,6 @@ conn_close_if_marked(int i)
            * would make much more sense to react in
            * connection_handle_read_impl, or to just stop reading in
            * mark_and_flush */
-#if 0
-#define MARKED_READING_RATE 180
-          static ratelim_t marked_read_lim = RATELIM_INIT(MARKED_READING_RATE);
-          char *m;
-          if ((m = rate_limit_log(&marked_read_lim, now))) {
-            log_warn(LD_BUG, "Marked connection (fd %d, type %s, state %s) "
-                     "is still reading; that shouldn't happen.%s",
-                     (int)conn->s, conn_type_to_string(conn->type),
-                     conn_state_to_string(conn->type, conn->state), m);
-            tor_free(m);
-          }
-#endif
           conn->read_blocked_on_bw = 1;
           connection_stop_reading(conn);
         }
@@ -1227,39 +1192,85 @@ get_signewnym_epoch(void)
   return newnym_epoch;
 }
 
-typedef struct {
-  time_t last_rotated_x509_certificate;
-  time_t check_v3_certificate;
-  time_t check_listeners;
-  time_t download_networkstatus;
-  time_t try_getting_descriptors;
-  time_t reset_descriptor_failures;
-  time_t add_entropy;
-  time_t write_bridge_status_file;
-  time_t downrate_stability;
-  time_t save_stability;
-  time_t clean_caches;
-  time_t recheck_bandwidth;
-  time_t check_for_expired_networkstatus;
-  time_t write_stats_files;
-  time_t write_bridge_stats;
-  time_t check_port_forwarding;
-  time_t launch_reachability_tests;
-  time_t retry_dns_init;
-  time_t next_heartbeat;
-  time_t check_descriptor;
-  /** When do we next launch DNS wildcarding checks? */
-  time_t check_for_correct_dns;
-  /** When do we next make sure our Ed25519 keys aren't about to expire? */
-  time_t check_ed_keys;
-
-} time_to_t;
-
-static time_to_t time_to = {
-  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
+/** True iff we have initialized all the members of <b>periodic_events</b>.
+ * Used to prevent double-initialization. */
+static int periodic_events_initialized = 0;
+
+/* Declare all the timer callback functions... */
+#undef CALLBACK
+#define CALLBACK(name) \
+  static int name ## _callback(time_t, const or_options_t *)
+CALLBACK(rotate_onion_key);
+CALLBACK(check_ed_keys);
+CALLBACK(launch_descriptor_fetches);
+CALLBACK(reset_descriptor_failures);
+CALLBACK(rotate_x509_certificate);
+CALLBACK(add_entropy);
+CALLBACK(launch_reachability_tests);
+CALLBACK(downrate_stability);
+CALLBACK(save_stability);
+CALLBACK(check_authority_cert);
+CALLBACK(check_expired_networkstatus);
+CALLBACK(write_stats_file);
+CALLBACK(record_bridge_stats);
+CALLBACK(clean_caches);
+CALLBACK(rend_cache_failure_clean);
+CALLBACK(retry_dns);
+CALLBACK(check_descriptor);
+CALLBACK(check_for_reachability_bw);
+CALLBACK(fetch_networkstatus);
+CALLBACK(retry_listeners);
+CALLBACK(expire_old_ciruits_serverside);
+CALLBACK(check_dns_honesty);
+CALLBACK(write_bridge_ns);
+CALLBACK(check_fw_helper_app);
+CALLBACK(heartbeat);
+
+#undef CALLBACK
+
+/* Now we declare an array of periodic_event_item_t for each periodic event */
+#define CALLBACK(name) PERIODIC_EVENT(name)
+
+static periodic_event_item_t periodic_events[] = {
+  CALLBACK(rotate_onion_key),
+  CALLBACK(check_ed_keys),
+  CALLBACK(launch_descriptor_fetches),
+  CALLBACK(reset_descriptor_failures),
+  CALLBACK(rotate_x509_certificate),
+  CALLBACK(add_entropy),
+  CALLBACK(launch_reachability_tests),
+  CALLBACK(downrate_stability),
+  CALLBACK(save_stability),
+  CALLBACK(check_authority_cert),
+  CALLBACK(check_expired_networkstatus),
+  CALLBACK(write_stats_file),
+  CALLBACK(record_bridge_stats),
+  CALLBACK(clean_caches),
+  CALLBACK(rend_cache_failure_clean),
+  CALLBACK(retry_dns),
+  CALLBACK(check_descriptor),
+  CALLBACK(check_for_reachability_bw),
+  CALLBACK(fetch_networkstatus),
+  CALLBACK(retry_listeners),
+  CALLBACK(expire_old_ciruits_serverside),
+  CALLBACK(check_dns_honesty),
+  CALLBACK(write_bridge_ns),
+  CALLBACK(check_fw_helper_app),
+  CALLBACK(heartbeat),
+  END_OF_PERIODIC_EVENTS
 };
-
-/** Reset all the time_to's so we'll do all our actions again as if we
+#undef CALLBACK
+
+/* These are pointers to members of periodic_events[] that are used to
+ * implement particular callbacks.  We keep them separate here so that we
+ * can access them by name.  We also keep them inside periodic_events[]
+ * so that we can implement "reset all timers" in a reasonable way. */
+static periodic_event_item_t *check_descriptor_event=NULL;
+static periodic_event_item_t *fetch_networkstatus_event=NULL;
+static periodic_event_item_t *launch_descriptor_fetches_event=NULL;
+static periodic_event_item_t *check_dns_honesty_event=NULL;
+
+/** Reset all the periodic events so we'll do all our actions again as if we
  * just started up.
  * Useful if our clock just moved back a long time from the future,
  * so we don't wait until that future arrives again before acting.
@@ -1267,7 +1278,77 @@ static time_to_t time_to = {
 void
 reset_all_main_loop_timers(void)
 {
-  memset(&time_to, 0, sizeof(time_to));
+  int i;
+  for (i = 0; periodic_events[i].name; ++i) {
+    periodic_event_reschedule(&periodic_events[i]);
+  }
+}
+
+/** Return the member of periodic_events[] whose name is <b>name</b>.
+ * Return NULL if no such event is found.
+ */
+static periodic_event_item_t *
+find_periodic_event(const char *name)
+{
+  int i;
+  for (i = 0; periodic_events[i].name; ++i) {
+    if (strcmp(name, periodic_events[i].name) == 0)
+      return &periodic_events[i];
+  }
+  return NULL;
+}
+
+/** Helper, run one second after setup:
+ * Initializes all members of periodic_events and starts them running.
+ *
+ * (We do this one second after setup for backward-compatibility reasons;
+ * it might not actually be necessary.) */
+static void
+initialize_periodic_events_cb(evutil_socket_t fd, short events, void *data)
+{
+  (void) fd;
+  (void) events;
+  (void) data;
+  int i;
+  for (i = 0; periodic_events[i].name; ++i) {
+    periodic_event_launch(&periodic_events[i]);
+  }
+}
+
+/** Set up all the members of periodic_events[], and configure them all to be
+ * launched from a callback. */
+STATIC void
+initialize_periodic_events(void)
+{
+  tor_assert(periodic_events_initialized == 0);
+  periodic_events_initialized = 1;
+
+  int i;
+  for (i = 0; periodic_events[i].name; ++i) {
+    periodic_event_setup(&periodic_events[i]);
+  }
+
+#define NAMED_CALLBACK(name) \
+  STMT_BEGIN name ## _event = find_periodic_event( #name ); STMT_END
+
+  NAMED_CALLBACK(check_descriptor);
+  NAMED_CALLBACK(fetch_networkstatus);
+  NAMED_CALLBACK(launch_descriptor_fetches);
+  NAMED_CALLBACK(check_dns_honesty);
+
+  struct timeval one_second = { 1, 0 };
+  event_base_once(tor_libevent_get_base(), -1, EV_TIMEOUT,
+                  initialize_periodic_events_cb, NULL,
+                  &one_second);
+}
+
+STATIC void
+teardown_periodic_events(void)
+{
+  int i;
+  for (i = 0; periodic_events[i].name; ++i) {
+    periodic_event_destroy(&periodic_events[i]);
+  }
 }
 
 /**
@@ -1278,7 +1359,8 @@ reset_all_main_loop_timers(void)
 void
 reschedule_descriptor_update_check(void)
 {
-  time_to.check_descriptor = 0;
+  tor_assert(check_descriptor_event);
+  periodic_event_reschedule(check_descriptor_event);
 }
 
 /**
@@ -1288,8 +1370,22 @@ reschedule_descriptor_update_check(void)
 void
 reschedule_directory_downloads(void)
 {
-  time_to.download_networkstatus = 0;
-  time_to.try_getting_descriptors = 0;
+  tor_assert(fetch_networkstatus_event);
+  tor_assert(launch_descriptor_fetches_event);
+
+  periodic_event_reschedule(fetch_networkstatus_event);
+  periodic_event_reschedule(launch_descriptor_fetches_event);
+}
+
+static inline int
+safe_timer_diff(time_t now, time_t next)
+{
+  if (next > now) {
+    tor_assert(next - now <= INT_MAX);
+    return (int)(next - now);
+  } else {
+    return 1;
+  }
 }
 
 /** Perform regular maintenance tasks.  This function gets run once per
@@ -1298,13 +1394,8 @@ reschedule_directory_downloads(void)
 static void
 run_scheduled_events(time_t now)
 {
-  static int should_init_bridge_stats = 1;
   const or_options_t *options = get_options();
 
-  int is_server = server_mode(options);
-  int i;
-  int have_dir_info;
-
   /* 0. See if we've been asked to shut down and our timeout has
    * expired; or if our bandwidth limits are exhausted and we
    * should hibernate; or if it's time to wake up from hibernation.
@@ -1322,12 +1413,103 @@ run_scheduled_events(time_t now)
   /* 0c. If we've deferred log messages for the controller, handle them now */
   flush_pending_log_callbacks();
 
+  if (options->UseBridges && !options->DisableNetwork) {
+    fetch_bridge_descriptors(options, now);
+  }
+
+  if (accounting_is_enabled(options)) {
+    accounting_run_housekeeping(now);
+  }
+
+  if (authdir_mode_v3(options)) {
+    dirvote_act(options, now);
+  }
+
+  /* 2d. Cleanup excess consensus bootstrap connections every second.
+   * connection_dir_close_consensus_conn_if_extra() will close connections
+   * that are clearly excess, but this check is more thorough. */
+  connection_dir_close_extra_consensus_conns();
+
+  /* 3a. Every second, we examine pending circuits and prune the
+   *    ones which have been pending for more than a few seconds.
+   *    We do this before step 4, so it can try building more if
+   *    it's not comfortable with the number of available circuits.
+   */
+  /* (If our circuit build timeout can ever become lower than a second (which
+   * it can't, currently), we should do this more often.) */
+  circuit_expire_building();
+
+  /* 3b. Also look at pending streams and prune the ones that 'began'
+   *     a long time ago but haven't gotten a 'connected' yet.
+   *     Do this before step 4, so we can put them back into pending
+   *     state to be picked up by the new circuit.
+   */
+  connection_ap_expire_beginning();
+
+  /* 3c. And expire connections that we've held open for too long.
+   */
+  connection_expire_held_open();
+
+  /* 4. Every second, we try a new circuit if there are no valid
+   *    circuits. Every NewCircuitPeriod seconds, we expire circuits
+   *    that became dirty more than MaxCircuitDirtiness seconds ago,
+   *    and we make a new circ if there are no clean circuits.
+   */
+  const int have_dir_info = router_have_minimum_dir_info();
+  if (have_dir_info && !net_is_disabled()) {
+    circuit_build_needed_circs(now);
+  } else {
+    circuit_expire_old_circs_as_needed(now);
+  }
+
+  /* 5. We do housekeeping for each connection... */
+  connection_or_set_bad_connections(NULL, 0);
+  int i;
+  for (i=0;i<smartlist_len(connection_array);i++) {
+    run_connection_housekeeping(i, now);
+  }
+
+  /* 6. And remove any marked circuits... */
+  circuit_close_all_marked();
+
+  /* 7. And upload service descriptors if necessary. */
+  if (have_completed_a_circuit() && !net_is_disabled()) {
+    rend_consider_services_upload(now);
+    rend_consider_descriptor_republication();
+  }
+
+  /* 8. and blow away any connections that need to die. have to do this now,
+   * because if we marked a conn for close and left its socket -1, then
+   * we'll pass it to poll/select and bad things will happen.
+   */
+  close_closeable_connections();
+
+  /* 8b. And if anything in our state is ready to get flushed to disk, we
+   * flush it. */
+  or_state_save(now);
+
+  /* 8c. Do channel cleanup just like for connections */
+  channel_run_cleanup();
+  channel_listener_run_cleanup();
+
+  /* 11b. check pending unconfigured managed proxies */
+  if (!net_is_disabled() && pt_proxies_configuration_pending())
+    pt_configure_remaining_proxies();
+}
+
+static int
+rotate_onion_key_callback(time_t now, const or_options_t *options)
+{
   /* 1a. Every MIN_ONION_KEY_LIFETIME seconds, rotate the onion keys,
    *  shut down and restart all cpuworkers, and update the directory if
    *  necessary.
    */
-  if (is_server &&
-      get_onion_key_set_at()+MIN_ONION_KEY_LIFETIME < now) {
+  if (server_mode(options)) {
+    time_t rotation_time = get_onion_key_set_at()+MIN_ONION_KEY_LIFETIME;
+    if (rotation_time > now) {
+      return safe_timer_diff(now, rotation_time);
+    }
+
     log_info(LD_GENERAL,"Rotating onion key.");
     rotate_onion_key();
     cpuworkers_rotate_keyinfo();
@@ -1336,9 +1518,15 @@ run_scheduled_events(time_t now)
     }
     if (advertised_server_mode() && !options->DisableNetwork)
       router_upload_dir_desc_to_dirservers(0);
+    return MIN_ONION_KEY_LIFETIME;
   }
+  return PERIODIC_EVENT_NO_UPDATE;
+}
 
-  if (is_server && time_to.check_ed_keys < now) {
+static int
+check_ed_keys_callback(time_t now, const or_options_t *options)
+{
+  if (server_mode(options)) {
     if (should_make_new_ed_keys(options, now)) {
       if (load_ed_keys(options, now) < 0 ||
           generate_ed_link_cert(options, now)) {
@@ -1347,199 +1535,255 @@ run_scheduled_events(time_t now)
         exit(0);
       }
     }
-    time_to.check_ed_keys = now + 30;
+    return 30;
   }
+  return PERIODIC_EVENT_NO_UPDATE;
+}
 
-  if (!should_delay_dir_fetches(options, NULL) &&
-      time_to.try_getting_descriptors < now) {
-    update_all_descriptor_downloads(now);
-    update_extrainfo_downloads(now);
-    if (router_have_minimum_dir_info())
-      time_to.try_getting_descriptors = now + LAZY_DESCRIPTOR_RETRY_INTERVAL;
-    else
-      time_to.try_getting_descriptors = now + GREEDY_DESCRIPTOR_RETRY_INTERVAL;
-  }
+static int
+launch_descriptor_fetches_callback(time_t now, const or_options_t *options)
+{
+  if (should_delay_dir_fetches(options, NULL))
+      return PERIODIC_EVENT_NO_UPDATE;
 
-  if (time_to.reset_descriptor_failures < now) {
-    router_reset_descriptor_download_failures();
-    time_to.reset_descriptor_failures =
-      now + DESCRIPTOR_FAILURE_RESET_INTERVAL;
-  }
+  update_all_descriptor_downloads(now);
+  update_extrainfo_downloads(now);
+  if (router_have_minimum_dir_info())
+    return LAZY_DESCRIPTOR_RETRY_INTERVAL;
+  else
+    return GREEDY_DESCRIPTOR_RETRY_INTERVAL;
+}
 
-  if (options->UseBridges && !options->DisableNetwork)
-    fetch_bridge_descriptors(options, now);
+static int
+reset_descriptor_failures_callback(time_t now, const or_options_t *options)
+{
+  (void)now;
+  (void)options;
+  router_reset_descriptor_download_failures();
+  return DESCRIPTOR_FAILURE_RESET_INTERVAL;
+}
+
+static int
+rotate_x509_certificate_callback(time_t now, const or_options_t *options)
+{
+  static int first = 1;
+  (void)now;
+  (void)options;
+  if (first) {
+    first = 0;
+    return MAX_SSL_KEY_LIFETIME_INTERNAL;
+  }
 
   /* 1b. Every MAX_SSL_KEY_LIFETIME_INTERNAL seconds, we change our
    * TLS context. */
-  if (!time_to.last_rotated_x509_certificate)
-    time_to.last_rotated_x509_certificate = now;
-  if (time_to.last_rotated_x509_certificate +
-      MAX_SSL_KEY_LIFETIME_INTERNAL < now) {
-    log_info(LD_GENERAL,"Rotating tls context.");
-    if (router_initialize_tls_context() < 0) {
-      log_warn(LD_BUG, "Error reinitializing TLS context");
-      /* XXX is it a bug here, that we just keep going? -RD */
-    }
-    time_to.last_rotated_x509_certificate = now;
-    /* We also make sure to rotate the TLS connections themselves if they've
-     * been up for too long -- but that's done via is_bad_for_new_circs in
-     * connection_run_housekeeping() above. */
+  log_info(LD_GENERAL,"Rotating tls context.");
+  if (router_initialize_tls_context() < 0) {
+    log_warn(LD_BUG, "Error reinitializing TLS context");
+    tor_assert(0);
   }
 
-  if (time_to.add_entropy < now) {
-    if (time_to.add_entropy) {
-      /* We already seeded once, so don't die on failure. */
-      crypto_seed_rng();
-    }
-/** How often do we add more entropy to OpenSSL's RNG pool? */
-#define ENTROPY_INTERVAL (60*60)
-    time_to.add_entropy = now + ENTROPY_INTERVAL;
+  /* We also make sure to rotate the TLS connections themselves if they've
+   * been up for too long -- but that's done via is_bad_for_new_circs in
+   * run_connection_housekeeping() above. */
+  return MAX_SSL_KEY_LIFETIME_INTERNAL;
+}
+
+static int
+add_entropy_callback(time_t now, const or_options_t *options)
+{
+  (void)now;
+  (void)options;
+  /* We already seeded once, so don't die on failure. */
+  if (crypto_seed_rng() < 0) {
+    log_warn(LD_GENERAL, "Tried to re-seed RNG, but failed. We already "
+             "seeded once, though, so we won't exit here.");
   }
 
-  /* 1c. If we have to change the accounting interval or record
-   * bandwidth used in this accounting interval, do so. */
-  if (accounting_is_enabled(options))
-    accounting_run_housekeeping(now);
+  /** How often do we add more entropy to OpenSSL's RNG pool? */
+#define ENTROPY_INTERVAL (60*60)
+  return ENTROPY_INTERVAL;
+}
 
-  if (time_to.launch_reachability_tests < now &&
-      (authdir_mode_tests_reachability(options)) &&
-       !net_is_disabled()) {
-    time_to.launch_reachability_tests = now + REACHABILITY_TEST_INTERVAL;
+static int
+launch_reachability_tests_callback(time_t now, const or_options_t *options)
+{
+  if (authdir_mode_tests_reachability(options) &&
+      !net_is_disabled()) {
     /* try to determine reachability of the other Tor relays */
     dirserv_test_reachability(now);
   }
+  return REACHABILITY_TEST_INTERVAL;
+}
 
+static int
+downrate_stability_callback(time_t now, const or_options_t *options)
+{
+  (void)options;
   /* 1d. Periodically, we discount older stability information so that new
    * stability info counts more, and save the stability information to disk as
    * appropriate. */
-  if (time_to.downrate_stability < now)
-    time_to.downrate_stability = rep_hist_downrate_old_runs(now);
+  time_t next = rep_hist_downrate_old_runs(now);
+  return safe_timer_diff(now, next);
+}
+
+static int
+save_stability_callback(time_t now, const or_options_t *options)
+{
   if (authdir_mode_tests_reachability(options)) {
-    if (time_to.save_stability < now) {
-      if (time_to.save_stability && rep_hist_record_mtbf_data(now, 1)<0) {
-        log_warn(LD_GENERAL, "Couldn't store mtbf data.");
-      }
-#define SAVE_STABILITY_INTERVAL (30*60)
-      time_to.save_stability = now + SAVE_STABILITY_INTERVAL;
+    if (rep_hist_record_mtbf_data(now, 1)<0) {
+      log_warn(LD_GENERAL, "Couldn't store mtbf data.");
     }
   }
+#define SAVE_STABILITY_INTERVAL (30*60)
+  return SAVE_STABILITY_INTERVAL;
+}
 
+static int
+check_authority_cert_callback(time_t now, const or_options_t *options)
+{
+  (void)now;
+  (void)options;
   /* 1e. Periodically, if we're a v3 authority, we check whether our cert is
    * close to expiring and warn the admin if it is. */
-  if (time_to.check_v3_certificate < now) {
-    v3_authority_check_key_expiry();
+  v3_authority_check_key_expiry();
 #define CHECK_V3_CERTIFICATE_INTERVAL (5*60)
-    time_to.check_v3_certificate = now + CHECK_V3_CERTIFICATE_INTERVAL;
-  }
+  return CHECK_V3_CERTIFICATE_INTERVAL;
+}
 
+static int
+check_expired_networkstatus_callback(time_t now, const or_options_t *options)
+{
+  (void)options;
   /* 1f. Check whether our networkstatus has expired.
    */
-  if (time_to.check_for_expired_networkstatus < now) {
-    networkstatus_t *ns = networkstatus_get_latest_consensus();
-    /*XXXX RD: This value needs to be the same as REASONABLY_LIVE_TIME in
-     * networkstatus_get_reasonably_live_consensus(), but that value is way
-     * way too high.  Arma: is the bridge issue there resolved yet? -NM */
+  networkstatus_t *ns = networkstatus_get_latest_consensus();
+  /*XXXX RD: This value needs to be the same as REASONABLY_LIVE_TIME in
+   * networkstatus_get_reasonably_live_consensus(), but that value is way
+   * way too high.  Arma: is the bridge issue there resolved yet? -NM */
 #define NS_EXPIRY_SLOP (24*60*60)
-    if (ns && ns->valid_until < now+NS_EXPIRY_SLOP &&
-        router_have_minimum_dir_info()) {
-      router_dir_info_changed();
-    }
-#define CHECK_EXPIRED_NS_INTERVAL (2*60)
-    time_to.check_for_expired_networkstatus = now + CHECK_EXPIRED_NS_INTERVAL;
+  if (ns && ns->valid_until < now+NS_EXPIRY_SLOP &&
+      router_have_minimum_dir_info()) {
+    router_dir_info_changed();
   }
+#define CHECK_EXPIRED_NS_INTERVAL (2*60)
+  return CHECK_EXPIRED_NS_INTERVAL;
+}
 
+static int
+write_stats_file_callback(time_t now, const or_options_t *options)
+{
   /* 1g. Check whether we should write statistics to disk.
    */
-  if (time_to.write_stats_files < now) {
 #define CHECK_WRITE_STATS_INTERVAL (60*60)
-    time_t next_time_to_write_stats_files = (time_to.write_stats_files > 0 ?
-           time_to.write_stats_files : now) + CHECK_WRITE_STATS_INTERVAL;
-    if (options->CellStatistics) {
-      time_t next_write =
-          rep_hist_buffer_stats_write(time_to.write_stats_files);
-      if (next_write && next_write < next_time_to_write_stats_files)
-        next_time_to_write_stats_files = next_write;
-    }
-    if (options->DirReqStatistics) {
-      time_t next_write = geoip_dirreq_stats_write(time_to.write_stats_files);
-      if (next_write && next_write < next_time_to_write_stats_files)
-        next_time_to_write_stats_files = next_write;
-    }
-    if (options->EntryStatistics) {
-      time_t next_write = geoip_entry_stats_write(time_to.write_stats_files);
-      if (next_write && next_write < next_time_to_write_stats_files)
-        next_time_to_write_stats_files = next_write;
-    }
-    if (options->HiddenServiceStatistics) {
-      time_t next_write = rep_hist_hs_stats_write(time_to.write_stats_files);
-      if (next_write && next_write < next_time_to_write_stats_files)
-        next_time_to_write_stats_files = next_write;
-    }
-    if (options->ExitPortStatistics) {
-      time_t next_write = rep_hist_exit_stats_write(time_to.write_stats_files);
-      if (next_write && next_write < next_time_to_write_stats_files)
-        next_time_to_write_stats_files = next_write;
-    }
-    if (options->ConnDirectionStatistics) {
-      time_t next_write = rep_hist_conn_stats_write(time_to.write_stats_files);
-      if (next_write && next_write < next_time_to_write_stats_files)
-        next_time_to_write_stats_files = next_write;
-    }
-    if (options->BridgeAuthoritativeDir) {
-      time_t next_write = rep_hist_desc_stats_write(time_to.write_stats_files);
-      if (next_write && next_write < next_time_to_write_stats_files)
-        next_time_to_write_stats_files = next_write;
-    }
-    time_to.write_stats_files = next_time_to_write_stats_files;
+  time_t next_time_to_write_stats_files = now + CHECK_WRITE_STATS_INTERVAL;
+  if (options->CellStatistics) {
+    time_t next_write =
+      rep_hist_buffer_stats_write(now);
+    if (next_write && next_write < next_time_to_write_stats_files)
+      next_time_to_write_stats_files = next_write;
+  }
+  if (options->DirReqStatistics) {
+    time_t next_write = geoip_dirreq_stats_write(now);
+    if (next_write && next_write < next_time_to_write_stats_files)
+      next_time_to_write_stats_files = next_write;
+  }
+  if (options->EntryStatistics) {
+    time_t next_write = geoip_entry_stats_write(now);
+    if (next_write && next_write < next_time_to_write_stats_files)
+      next_time_to_write_stats_files = next_write;
+  }
+  if (options->HiddenServiceStatistics) {
+    time_t next_write = rep_hist_hs_stats_write(now);
+    if (next_write && next_write < next_time_to_write_stats_files)
+      next_time_to_write_stats_files = next_write;
+  }
+  if (options->ExitPortStatistics) {
+    time_t next_write = rep_hist_exit_stats_write(now);
+    if (next_write && next_write < next_time_to_write_stats_files)
+      next_time_to_write_stats_files = next_write;
   }
+  if (options->ConnDirectionStatistics) {
+    time_t next_write = rep_hist_conn_stats_write(now);
+    if (next_write && next_write < next_time_to_write_stats_files)
+      next_time_to_write_stats_files = next_write;
+  }
+  if (options->BridgeAuthoritativeDir) {
+    time_t next_write = rep_hist_desc_stats_write(now);
+    if (next_write && next_write < next_time_to_write_stats_files)
+      next_time_to_write_stats_files = next_write;
+  }
+
+  return safe_timer_diff(now, next_time_to_write_stats_files);
+}
+
+static int
+record_bridge_stats_callback(time_t now, const or_options_t *options)
+{
+  static int should_init_bridge_stats = 1;
 
   /* 1h. Check whether we should write bridge statistics to disk.
    */
   if (should_record_bridge_info(options)) {
-    if (time_to.write_bridge_stats < now) {
-      if (should_init_bridge_stats) {
-        /* (Re-)initialize bridge statistics. */
+    if (should_init_bridge_stats) {
+      /* (Re-)initialize bridge statistics. */
         geoip_bridge_stats_init(now);
-        time_to.write_bridge_stats = now + WRITE_STATS_INTERVAL;
         should_init_bridge_stats = 0;
-      } else {
-        /* Possibly write bridge statistics to disk and ask when to write
-         * them next time. */
-        time_to.write_bridge_stats = geoip_bridge_stats_write(
-                                           time_to.write_bridge_stats);
-      }
+        return WRITE_STATS_INTERVAL;
+    } else {
+      /* Possibly write bridge statistics to disk and ask when to write
+       * them next time. */
+      time_t next = geoip_bridge_stats_write(now);
+      return safe_timer_diff(now, next);
     }
   } else if (!should_init_bridge_stats) {
     /* Bridge mode was turned off. Ensure that stats are re-initialized
      * next time bridge mode is turned on. */
     should_init_bridge_stats = 1;
   }
+  return PERIODIC_EVENT_NO_UPDATE;
+}
 
+static int
+clean_caches_callback(time_t now, const or_options_t *options)
+{
   /* Remove old information from rephist and the rend cache. */
-  if (time_to.clean_caches < now) {
-    rep_history_clean(now - options->RephistTrackTime);
-    rend_cache_clean(now);
-    rend_cache_clean_v2_descs_as_dir(now, 0);
-    microdesc_cache_rebuild(NULL, 0);
+  rep_history_clean(now - options->RephistTrackTime);
+  rend_cache_clean(now, REND_CACHE_TYPE_CLIENT);
+  rend_cache_clean(now, REND_CACHE_TYPE_SERVICE);
+  rend_cache_clean_v2_descs_as_dir(now, 0);
+  microdesc_cache_rebuild(NULL, 0);
 #define CLEAN_CACHES_INTERVAL (30*60)
-    time_to.clean_caches = now + CLEAN_CACHES_INTERVAL;
-  }
+  return CLEAN_CACHES_INTERVAL;
+}
+
+static int
+rend_cache_failure_clean_callback(time_t now, const or_options_t *options)
+{
+  (void)options;
   /* We don't keep entries that are more than five minutes old so we try to
    * clean it as soon as we can since we want to make sure the client waits
    * as little as possible for reachability reasons. */
   rend_cache_failure_clean(now);
+  return 30;
+}
 
+static int
+retry_dns_callback(time_t now, const or_options_t *options)
+{
+  (void)now;
 #define RETRY_DNS_INTERVAL (10*60)
   /* If we're a server and initializing dns failed, retry periodically. */
-  if (time_to.retry_dns_init < now) {
-    time_to.retry_dns_init = now + RETRY_DNS_INTERVAL;
-    if (is_server && has_dns_init_failed())
-      dns_init();
-  }
+  if (server_mode(options) && has_dns_init_failed())
+    dns_init();
+  return RETRY_DNS_INTERVAL;
+}
 
   /* 2. Periodically, we consider force-uploading our descriptor
    * (if we've passed our internal checks). */
 
+static int
+check_descriptor_callback(time_t now, const or_options_t *options)
+{
 /** How often do we check whether part of our router info has changed in a
  * way that would require an upload? That includes checking whether our IP
  * address has changed. */
@@ -1547,185 +1791,178 @@ run_scheduled_events(time_t now)
 
   /* 2b. Once per minute, regenerate and upload the descriptor if the old
    * one is inaccurate. */
-  if (time_to.check_descriptor < now && !options->DisableNetwork) {
-    static int dirport_reachability_count = 0;
-    time_to.check_descriptor = now + CHECK_DESCRIPTOR_INTERVAL;
+  if (!options->DisableNetwork) {
     check_descriptor_bandwidth_changed(now);
     check_descriptor_ipaddress_changed(now);
     mark_my_descriptor_dirty_if_too_old(now);
     consider_publishable_server(0);
-    /* also, check religiously for reachability, if it's within the first
-     * 20 minutes of our uptime. */
-    if (is_server &&
-        (have_completed_a_circuit() || !any_predicted_circuits(now)) &&
-        !we_are_hibernating()) {
-      if (stats_n_seconds_working < TIMEOUT_UNTIL_UNREACHABILITY_COMPLAINT) {
-        consider_testing_reachability(1, dirport_reachability_count==0);
-        if (++dirport_reachability_count > 5)
-          dirport_reachability_count = 0;
-      } else if (time_to.recheck_bandwidth < now) {
-        /* If we haven't checked for 12 hours and our bandwidth estimate is
-         * low, do another bandwidth test. This is especially important for
-         * bridges, since they might go long periods without much use. */
-        const routerinfo_t *me = router_get_my_routerinfo();
-        if (time_to.recheck_bandwidth && me &&
-            me->bandwidthcapacity < me->bandwidthrate &&
-            me->bandwidthcapacity < 51200) {
-          reset_bandwidth_test();
-        }
-#define BANDWIDTH_RECHECK_INTERVAL (12*60*60)
-        time_to.recheck_bandwidth = now + BANDWIDTH_RECHECK_INTERVAL;
-      }
-    }
-
     /* If any networkstatus documents are no longer recent, we need to
      * update all the descriptors' running status. */
     /* Remove dead routers. */
+    /* XXXX This doesn't belong here, but it was here in the pre-
+     * XXXX refactoring code. */
     routerlist_remove_old_routers();
   }
 
-  /* 2c. Every minute (or every second if TestingTorNetwork), check
-   * whether we want to download any networkstatus documents. */
+  return CHECK_DESCRIPTOR_INTERVAL;
+}
 
-/* How often do we check whether we should download network status
- * documents? */
-#define networkstatus_dl_check_interval(o) ((o)->TestingTorNetwork ? 1 : 60)
+static int
+check_for_reachability_bw_callback(time_t now, const or_options_t *options)
+{
+  /* XXXX This whole thing was stuck in the middle of what is now
+   * XXXX check_descriptor_callback.  I'm not sure it's right. */
 
-  if (!should_delay_dir_fetches(options, NULL) &&
-      time_to.download_networkstatus < now) {
-    time_to.download_networkstatus =
-      now + networkstatus_dl_check_interval(options);
-    update_networkstatus_downloads(now);
+  static int dirport_reachability_count = 0;
+  /* also, check religiously for reachability, if it's within the first
+   * 20 minutes of our uptime. */
+  if (server_mode(options) &&
+      (have_completed_a_circuit() || !any_predicted_circuits(now)) &&
+      !we_are_hibernating()) {
+    if (stats_n_seconds_working < TIMEOUT_UNTIL_UNREACHABILITY_COMPLAINT) {
+      consider_testing_reachability(1, dirport_reachability_count==0);
+      if (++dirport_reachability_count > 5)
+        dirport_reachability_count = 0;
+      return 1;
+    } else {
+      /* If we haven't checked for 12 hours and our bandwidth estimate is
+       * low, do another bandwidth test. This is especially important for
+       * bridges, since they might go long periods without much use. */
+      const routerinfo_t *me = router_get_my_routerinfo();
+      static int first_time = 1;
+      if (!first_time && me &&
+          me->bandwidthcapacity < me->bandwidthrate &&
+          me->bandwidthcapacity < 51200) {
+        reset_bandwidth_test();
+      }
+      first_time = 0;
+#define BANDWIDTH_RECHECK_INTERVAL (12*60*60)
+      return BANDWIDTH_RECHECK_INTERVAL;
+    }
   }
+  return CHECK_DESCRIPTOR_INTERVAL;
+}
 
-  /* 2c. Let directory voting happen. */
-  if (authdir_mode_v3(options))
-    dirvote_act(options, now);
+static int
+fetch_networkstatus_callback(time_t now, const or_options_t *options)
+{
+  /* 2c. Every minute (or every second if TestingTorNetwork, or during
+   * client bootstrap), check whether we want to download any networkstatus
+   * documents. */
 
-  /* 3a. Every second, we examine pending circuits and prune the
-   *    ones which have been pending for more than a few seconds.
-   *    We do this before step 4, so it can try building more if
-   *    it's not comfortable with the number of available circuits.
-   */
-  /* (If our circuit build timeout can ever become lower than a second (which
-   * it can't, currently), we should do this more often.) */
-  circuit_expire_building();
+  /* How often do we check whether we should download network status
+   * documents? */
+  const int we_are_bootstrapping = networkstatus_consensus_is_boostrapping(
+                                                                        now);
+  const int prefer_mirrors = !directory_fetches_from_authorities(
+                                                              get_options());
+  int networkstatus_dl_check_interval = 60;
+  /* check more often when testing, or when bootstrapping from mirrors
+   * (connection limits prevent too many connections being made) */
+  if (options->TestingTorNetwork
+      || (we_are_bootstrapping && prefer_mirrors)) {
+    networkstatus_dl_check_interval = 1;
+  }
 
-  /* 3b. Also look at pending streams and prune the ones that 'began'
-   *     a long time ago but haven't gotten a 'connected' yet.
-   *     Do this before step 4, so we can put them back into pending
-   *     state to be picked up by the new circuit.
-   */
-  connection_ap_expire_beginning();
+  if (should_delay_dir_fetches(options, NULL))
+    return PERIODIC_EVENT_NO_UPDATE;
 
-  /* 3c. And expire connections that we've held open for too long.
-   */
-  connection_expire_held_open();
+  update_networkstatus_downloads(now);
+  return networkstatus_dl_check_interval;
+}
 
+static int
+retry_listeners_callback(time_t now, const or_options_t *options)
+{
+  (void)now;
+  (void)options;
   /* 3d. And every 60 seconds, we relaunch listeners if any died. */
-  if (!net_is_disabled() && time_to.check_listeners < now) {
+  if (!net_is_disabled()) {
     retry_all_listeners(NULL, NULL, 0);
-    time_to.check_listeners = now+60;
-  }
-
-  /* 4. Every second, we try a new circuit if there are no valid
-   *    circuits. Every NewCircuitPeriod seconds, we expire circuits
-   *    that became dirty more than MaxCircuitDirtiness seconds ago,
-   *    and we make a new circ if there are no clean circuits.
-   */
-  have_dir_info = router_have_minimum_dir_info();
-  if (have_dir_info && !net_is_disabled()) {
-    circuit_build_needed_circs(now);
-  } else {
-    circuit_expire_old_circs_as_needed(now);
-  }
-
-  /* every 10 seconds, but not at the same second as other such events */
-  if (now % 10 == 5)
-    circuit_expire_old_circuits_serverside(now);
-
-  /* 5. We do housekeeping for each connection... */
-  connection_or_set_bad_connections(NULL, 0);
-  for (i=0;i<smartlist_len(connection_array);i++) {
-    run_connection_housekeeping(i, now);
-  }
-
-  /* 6. And remove any marked circuits... */
-  circuit_close_all_marked();
-
-  /* 7. And upload service descriptors if necessary. */
-  if (have_completed_a_circuit() && !net_is_disabled()) {
-    rend_consider_services_upload(now);
-    rend_consider_descriptor_republication();
+    return 60;
   }
+  return PERIODIC_EVENT_NO_UPDATE;
+}
 
-  /* 8. and blow away any connections that need to die. have to do this now,
-   * because if we marked a conn for close and left its socket -1, then
-   * we'll pass it to poll/select and bad things will happen.
-   */
-  close_closeable_connections();
-
-  /* 8b. And if anything in our state is ready to get flushed to disk, we
-   * flush it. */
-  or_state_save(now);
-
-  /* 8c. Do channel cleanup just like for connections */
-  channel_run_cleanup();
-  channel_listener_run_cleanup();
+static int
+expire_old_ciruits_serverside_callback(time_t now, const or_options_t *options)
+{
+  (void)options;
+  /* every 11 seconds, so not usually the same second as other such events */
+  circuit_expire_old_circuits_serverside(now);
+  return 11;
+}
 
+static int
+check_dns_honesty_callback(time_t now, const or_options_t *options)
+{
+  (void)now;
   /* 9. and if we're an exit node, check whether our DNS is telling stories
    * to us. */
-  if (!net_is_disabled() &&
-      public_server_mode(options) &&
-      time_to.check_for_correct_dns < now &&
-      ! router_my_exit_policy_is_reject_star()) {
-    if (!time_to.check_for_correct_dns) {
-      time_to.check_for_correct_dns =
-        crypto_rand_time_range(now + 60, now + 180);
-    } else {
-      dns_launch_correctness_checks();
-      time_to.check_for_correct_dns = now + 12*3600 +
-        crypto_rand_int(12*3600);
-    }
+  if (net_is_disabled() ||
+      ! public_server_mode(options) ||
+      router_my_exit_policy_is_reject_star())
+    return PERIODIC_EVENT_NO_UPDATE;
+
+  static int first_time = 1;
+  if (first_time) {
+    /* Don't launch right when we start */
+    first_time = 0;
+    return crypto_rand_int_range(60, 180);
   }
 
+  dns_launch_correctness_checks();
+  return 12*3600 + crypto_rand_int(12*3600);
+}
+
+static int
+write_bridge_ns_callback(time_t now, const or_options_t *options)
+{
   /* 10. write bridge networkstatus file to disk */
-  if (options->BridgeAuthoritativeDir &&
-      time_to.write_bridge_status_file < now) {
+  if (options->BridgeAuthoritativeDir) {
     networkstatus_dump_bridge_status_to_file(now);
 #define BRIDGE_STATUSFILE_INTERVAL (30*60)
-    time_to.write_bridge_status_file = now+BRIDGE_STATUSFILE_INTERVAL;
+     return BRIDGE_STATUSFILE_INTERVAL;
   }
+  return PERIODIC_EVENT_NO_UPDATE;
+}
 
+static int
+check_fw_helper_app_callback(time_t now, const or_options_t *options)
+{
+  if (net_is_disabled() ||
+      ! server_mode(options) ||
+      ! options->PortForwarding) {
+    return PERIODIC_EVENT_NO_UPDATE;
+  }
   /* 11. check the port forwarding app */
-  if (!net_is_disabled() &&
-      time_to.check_port_forwarding < now &&
-      options->PortForwarding &&
-      is_server) {
+
 #define PORT_FORWARDING_CHECK_INTERVAL 5
-    smartlist_t *ports_to_forward = get_list_of_ports_to_forward();
-    if (ports_to_forward) {
-      tor_check_port_forwarding(options->PortForwardingHelper,
-                                ports_to_forward,
-                                now);
-
-      SMARTLIST_FOREACH(ports_to_forward, char *, cp, tor_free(cp));
-      smartlist_free(ports_to_forward);
-    }
-    time_to.check_port_forwarding = now+PORT_FORWARDING_CHECK_INTERVAL;
-  }
+  smartlist_t *ports_to_forward = get_list_of_ports_to_forward();
+  if (ports_to_forward) {
+    tor_check_port_forwarding(options->PortForwardingHelper,
+                              ports_to_forward,
+                              now);
 
-  /* 11b. check pending unconfigured managed proxies */
-  if (!net_is_disabled() && pt_proxies_configuration_pending())
-    pt_configure_remaining_proxies();
+    SMARTLIST_FOREACH(ports_to_forward, char *, cp, tor_free(cp));
+    smartlist_free(ports_to_forward);
+  }
+  return PORT_FORWARDING_CHECK_INTERVAL;
+}
 
+static int
+heartbeat_callback(time_t now, const or_options_t *options)
+{
+  static int first = 1;
   /* 12. write the heartbeat message */
-  if (options->HeartbeatPeriod &&
-      time_to.next_heartbeat <= now) {
-    if (time_to.next_heartbeat) /* don't log the first heartbeat */
-      log_heartbeat(now);
-    time_to.next_heartbeat = now+options->HeartbeatPeriod;
+  if (first) {
+    first = 0; /* Skip the first one. */
+  } else {
+    log_heartbeat(now);
   }
+  /* XXXX This isn't such a good way to handle possible changes in the
+   * callback event */
+  return options->HeartbeatPeriod;
 }
 
 /** Timer: used to invoke second_elapsed_callback() once per second. */
@@ -1795,8 +2032,9 @@ second_elapsed_callback(periodic_timer_t *timer, void *arg)
     if (me && !check_whether_orport_reachable()) {
       char *address = tor_dup_ip(me->addr);
       log_warn(LD_CONFIG,"Your server (%s:%d) has not managed to confirm that "
-               "its ORPort is reachable. Please check your firewalls, ports, "
-               "address, /etc/hosts file, etc.",
+               "its ORPort is reachable. Relays do not publish descriptors "
+               "until their ORPort and DirPort are reachable. Please check "
+               "your firewalls, ports, address, /etc/hosts file, etc.",
                address, me->or_port);
       control_event_server_status(LOG_WARN,
                                   "REACHABILITY_FAILED ORADDRESS=%s:%d",
@@ -1808,8 +2046,9 @@ second_elapsed_callback(periodic_timer_t *timer, void *arg)
       char *address = tor_dup_ip(me->addr);
       log_warn(LD_CONFIG,
                "Your server (%s:%d) has not managed to confirm that its "
-               "DirPort is reachable. Please check your firewalls, ports, "
-               "address, /etc/hosts file, etc.",
+               "DirPort is reachable. Relays do not publish descriptors "
+               "until their ORPort and DirPort are reachable. Please check "
+               "your firewalls, ports, address, /etc/hosts file, etc.",
                address, me->dir_port);
       control_event_server_status(LOG_WARN,
                                   "REACHABILITY_FAILED DIRADDRESS=%s:%d",
@@ -1947,7 +2186,10 @@ dns_servers_relaunch_checks(void)
 {
   if (server_mode(get_options())) {
     dns_reset_correctness_checks();
-    time_to.check_for_correct_dns = 0;
+    if (periodic_events_initialized) {
+      tor_assert(check_dns_honesty_event);
+      periodic_event_reschedule(check_dns_honesty_event);
+    }
   }
 }
 
@@ -2041,6 +2283,13 @@ do_main_loop(void)
 {
   time_t now;
 
+  /* initialize the periodic events first, so that code that depends on the
+   * events being present does not assert.
+   */
+  if (! periodic_events_initialized) {
+    initialize_periodic_events();
+  }
+
   /* initialize dns resolve map, spawn workers if needed */
   if (dns_init() < 0) {
     if (get_options()->ServerDNSAllowBrokenConfig)
@@ -2207,9 +2456,13 @@ run_main_loop_once(void)
 {
   int loop_result;
 
+  printf("Once...\n");
+
   if (nt_service_is_stopping())
     return 0;
 
+  printf("A...\n");
+
 #ifndef _WIN32
   /* Make it easier to tell whether libevent failure is our fault or not. */
   errno = 0;
@@ -2223,9 +2476,11 @@ run_main_loop_once(void)
 
   /* poll until we have an event, or the second ends, or until we have
    * some active linked connections to trigger events for. */
+  printf("C...\n");
   loop_result = event_base_loop(tor_libevent_get_base(),
                                 called_loop_once ? EVLOOP_ONCE : 0);
 
+  printf("D...\n");
   /* let catch() handle things like ^c, and otherwise don't worry about it */
   if (loop_result < 0) {
     int e = tor_socket_errno(-1);
@@ -2250,6 +2505,12 @@ run_main_loop_once(void)
       return 1;
     }
   }
+  printf("E...\n");
+
+  /* This will be pretty fast if nothing new is pending. Note that this gets
+   * called once per libevent loop, which will make it happen once per group
+   * of events that fire, or once per second. */
+  connection_ap_attach_pending(0);
 
   return 1;
 }
@@ -2804,6 +3065,7 @@ release_lockfile(void)
 void
 tor_free_all(int postfork)
 {
+  printf("Tor free all...%d\n", postfork);
   if (!postfork) {
     evdns_shutdown(1);
   }
@@ -2825,6 +3087,7 @@ tor_free_all(int postfork)
   channel_tls_free_all();
   channel_free_all();
   connection_free_all();
+  connection_edge_free_all();
   scheduler_free_all();
   memarea_clear_freelist();
   nodelist_free_all();
@@ -2851,6 +3114,7 @@ tor_free_all(int postfork)
   smartlist_free(closeable_connection_lst);
   smartlist_free(active_linked_connection_lst);
   periodic_timer_free(second_timer);
+  teardown_periodic_events();
 #ifndef USE_BUFFEREVENTS
   periodic_timer_free(refill_timer);
 #endif
@@ -2870,6 +3134,7 @@ tor_free_all(int postfork)
 void
 tor_cleanup(void)
 {
+  printf("TOR cleanup starting...\n");
   const or_options_t *options = get_options();
   if (options->command == CMD_RUN_TOR) {
     time_t now = time(NULL);
@@ -2899,7 +3164,7 @@ tor_cleanup(void)
 #ifdef USE_DMALLOC
   dmalloc_log_stats();
 #endif
-  tor_free_all(0); /* We could move tor_free_all back into the ifdef below
+  tor_free_all(1); /* We could move tor_free_all back into the ifdef below
                       later, if it makes shutdown unacceptably slow.  But for
                       now, leave it here: it's helped us catch bugs in the
                       past. */
@@ -2908,6 +3173,7 @@ tor_cleanup(void)
   dmalloc_log_unfreed();
   dmalloc_shutdown();
 #endif
+  printf("TOR cleanup done...\n");
 }
 
 /** Read/create keys as needed, and echo our fingerprint to stdout. */
@@ -3171,6 +3437,9 @@ sandbox_init_filter(void)
                          ".tmp");
     OPEN_DATADIR2_SUFFIX("keys", "ed25519_master_id_public_key", ".tmp");
     OPEN_DATADIR2_SUFFIX("keys", "ed25519_signing_secret_key", ".tmp");
+    OPEN_DATADIR2_SUFFIX("keys", "ed25519_signing_secret_key_encrypted",
+                         ".tmp");
+    OPEN_DATADIR2_SUFFIX("keys", "ed25519_signing_public_key", ".tmp");
     OPEN_DATADIR2_SUFFIX("keys", "ed25519_signing_cert", ".tmp");
 
     OPEN_DATADIR2_SUFFIX("stats", "bridge-stats", ".tmp");
@@ -3227,6 +3496,62 @@ sandbox_init_filter(void)
   return cfg;
 }
 
+void
+tor_reload(void)
+{
+  const or_options_t *options = get_options();
+
+#ifdef USE_DMALLOC
+  dmalloc_log_stats();
+  dmalloc_log_changed(0, 1, 0, 0);
+#endif
+
+  if (accounting_is_enabled(options))
+    accounting_record_bandwidth_usage(time(NULL), get_or_state());
+
+  router_reset_warnings();
+  routerlist_reset_warnings();
+  if (options_init_from_torrc(0, NULL) < 0) {
+      return;
+  }
+  options = get_options();
+  if (authdir_mode_handles_descs(options, -1)) {
+    if (dirserv_load_fingerprint_file() < 0) {
+      log_info(LD_GENERAL, "Error reloading fingerprints. "
+               "Continuing with old list.");
+    }
+  }
+
+  circuit_mark_all_dirty_circs_as_unusable();
+  router_reset_status_download_failures();
+  router_reset_descriptor_download_failures();
+  if (!options->DisableNetwork)
+    update_networkstatus_downloads(time(NULL));
+
+  if (server_mode(options)) {
+    time_t now = approx_time();
+    if (load_ed_keys(options, now) < 0 ||
+         generate_ed_link_cert(options, now)) {
+      log_warn(LD_OR, "Problem reloading Ed25519 keys; still using old keys.");
+    }
+
+    cpuworkers_rotate_keyinfo();
+    dns_reset();
+  }
+}
+
+void *killer_thread(void *argument)
+{
+    printf("Killer thread starting...\n");
+    sleep(8);
+    printf("Restarting tor now...\n");
+    tor_reload();
+    // Schedule self-reload again
+    pthread_t kill_thread;
+    int result_code = pthread_create(&kill_thread, NULL, killer_thread, NULL);
+    return NULL;
+}
+
 /** Main entry point for the Tor process.  Called from main(). */
 /* This function is distinct from main() only so we can link main.c into
  * the unittest binary without conflicting with the unittests' main. */
@@ -3268,6 +3593,7 @@ tor_main(int argc, char *argv[])
      if (done) return result;
   }
 #endif
+  while(1) {
   if (tor_init(argc, argv)<0)
     return -1;
 
@@ -3286,14 +3612,22 @@ tor_main(int argc, char *argv[])
 #endif
   }
 
+  pthread_t kill_thread;
+  int result_code = pthread_create(&kill_thread, NULL, killer_thread, NULL);
+
+  printf("About to start TOR...%d \n", result_code);
+
   switch (get_options()->command) {
   case CMD_RUN_TOR:
+    printf("Tor start CMD, switching to running...\n");
 #ifdef NT_SERVICE
     nt_service_set_state(SERVICE_RUNNING);
 #endif
     result = do_main_loop();
+    printf("End of main loop!\n");
     break;
   case CMD_KEYGEN:
+    printf("KEY GEN!\n");
     result = load_ed_keys(get_options(), time(NULL));
     break;
   case CMD_LIST_FINGERPRINT:
@@ -3317,7 +3651,12 @@ tor_main(int argc, char *argv[])
              get_options()->command);
     result = -1;
   }
+
+  printf("Main cleanup!\n");
   tor_cleanup();
-  return result;
+  printf("Sleeping 5s and starting again...\n");
+  }
+
+  return 0;
 }
 
diff --git a/src/or/main.h b/src/or/main.h
index 447d3f4..1380d0c 100644
--- a/src/or/main.h
+++ b/src/or/main.h
@@ -72,12 +72,16 @@ void tor_free_all(int postfork);
 
 int tor_main(int argc, char *argv[]);
 
+void tor_reload(void);
+
 int do_main_loop(void);
 int tor_init(int argc, char **argv);
 
 #ifdef MAIN_PRIVATE
 STATIC void init_connection_lists(void);
 STATIC void close_closeable_connections(void);
+STATIC void initialize_periodic_events(void);
+STATIC void teardown_periodic_events(void);
 #endif
 
 #endif
diff --git a/src/or/microdesc.c b/src/or/microdesc.c
index a9bab3d..dc23bcb 100644
--- a/src/or/microdesc.c
+++ b/src/or/microdesc.c
@@ -47,14 +47,14 @@ struct microdesc_cache_t {
 static microdesc_cache_t *get_microdesc_cache_noload(void);
 
 /** Helper: computes a hash of <b>md</b> to place it in a hash table. */
-static INLINE unsigned int
+static inline unsigned int
 microdesc_hash_(microdesc_t *md)
 {
   return (unsigned) siphash24g(md->digest, sizeof(md->digest));
 }
 
 /** Helper: compares <b>a</b> and </b> for equality for hash-table purposes. */
-static INLINE int
+static inline int
 microdesc_eq_(microdesc_t *a, microdesc_t *b)
 {
   return tor_memeq(a->digest, b->digest, DIGEST256_LEN);
diff --git a/src/or/networkstatus.c b/src/or/networkstatus.c
index 71a2c0f..f3a8276 100644
--- a/src/or/networkstatus.c
+++ b/src/or/networkstatus.c
@@ -85,8 +85,30 @@ static time_t time_to_download_next_consensus[N_CONSENSUS_FLAVORS];
 /** Download status for the current consensus networkstatus. */
 static download_status_t consensus_dl_status[N_CONSENSUS_FLAVORS] =
   {
-    { 0, 0, DL_SCHED_CONSENSUS },
-    { 0, 0, DL_SCHED_CONSENSUS },
+    { 0, 0, 0, DL_SCHED_CONSENSUS, DL_WANT_ANY_DIRSERVER,
+                                   DL_SCHED_INCREMENT_FAILURE },
+    { 0, 0, 0, DL_SCHED_CONSENSUS, DL_WANT_ANY_DIRSERVER,
+                                   DL_SCHED_INCREMENT_FAILURE },
+  };
+
+#define N_CONSENSUS_BOOTSTRAP_SCHEDULES 2
+#define CONSENSUS_BOOTSTRAP_SOURCE_AUTHORITY 0
+#define CONSENSUS_BOOTSTRAP_SOURCE_ANY_DIRSERVER  1
+
+/* Using DL_SCHED_INCREMENT_ATTEMPT on these schedules means that
+ * download_status_increment_failure won't increment these entries.
+ * However, any bootstrap connection failures that occur after we have
+ * a valid consensus will count against the failure counts on the non-bootstrap
+ * schedules. There should only be one of these, as all the others will have
+ * been cancelled. (This doesn't seem to be a significant issue.) */
+static download_status_t
+              consensus_bootstrap_dl_status[N_CONSENSUS_BOOTSTRAP_SCHEDULES] =
+  {
+    { 0, 0, 0, DL_SCHED_CONSENSUS, DL_WANT_AUTHORITY,
+                                   DL_SCHED_INCREMENT_ATTEMPT },
+    /* During bootstrap, DL_WANT_ANY_DIRSERVER means "use fallbacks". */
+    { 0, 0, 0, DL_SCHED_CONSENSUS, DL_WANT_ANY_DIRSERVER,
+                                   DL_SCHED_INCREMENT_ATTEMPT },
   };
 
 /** True iff we have logged a warning about this OR's version being older than
@@ -97,6 +119,10 @@ static int have_warned_about_old_version = 0;
 static int have_warned_about_new_version = 0;
 
 static void routerstatus_list_update_named_server_map(void);
+static void update_consensus_bootstrap_multiple_downloads(
+                                                  time_t now,
+                                                  const or_options_t *options,
+                                                  int we_are_bootstrapping);
 
 /** Forget that we've warned about anything networkstatus-related, so we will
  * give fresh warnings if the same behavior happens again. */
@@ -122,6 +148,9 @@ networkstatus_reset_download_failures(void)
 
   for (i=0; i < N_CONSENSUS_FLAVORS; ++i)
     download_status_reset(&consensus_dl_status[i]);
+
+  for (i=0; i < N_CONSENSUS_BOOTSTRAP_SCHEDULES; ++i)
+    download_status_reset(&consensus_bootstrap_dl_status[i]);
 }
 
 /** Read every cached v3 consensus networkstatus from the disk. */
@@ -734,6 +763,55 @@ we_want_to_fetch_flavor(const or_options_t *options, int flavor)
  * fetching certs before we check whether there is a better one? */
 #define DELAY_WHILE_FETCHING_CERTS (20*60)
 
+/* Check if a downloaded consensus flavor should still wait for certificates
+ * to download now.
+ * If so, return 1. If not, fail dls and return 0. */
+static int
+check_consensus_waiting_for_certs(int flavor, time_t now,
+                                  download_status_t *dls)
+{
+  consensus_waiting_for_certs_t *waiting;
+
+  /* We should always have a known flavor, because we_want_to_fetch_flavor()
+   * filters out unknown flavors. */
+  tor_assert(flavor >= 0 && flavor < N_CONSENSUS_FLAVORS);
+
+  waiting = &consensus_waiting_for_certs[flavor];
+  if (waiting->consensus) {
+    /* XXXX make sure this doesn't delay sane downloads. */
+    if (waiting->set_at + DELAY_WHILE_FETCHING_CERTS > now) {
+      return 1;
+    } else {
+      if (!waiting->dl_failed) {
+        download_status_failed(dls, 0);
+        waiting->dl_failed=1;
+      }
+    }
+  }
+
+  return 0;
+}
+
+/* Return the maximum download tries for a consensus, based on options and
+ * whether we_are_bootstrapping. */
+static int
+consensus_max_download_tries(const or_options_t *options,
+                                        int we_are_bootstrapping)
+{
+  int use_fallbacks = networkstatus_consensus_can_use_extra_fallbacks(options);
+
+  if (we_are_bootstrapping) {
+    if (use_fallbacks) {
+      return options->TestingClientBootstrapConsensusMaxDownloadTries;
+    } else {
+      return
+      options->TestingClientBootstrapConsensusAuthorityOnlyMaxDownloadTries;
+    }
+  }
+
+  return options->TestingConsensusMaxDownloadTries;
+}
+
 /** If we want to download a fresh consensus, launch a new download as
  * appropriate. */
 static void
@@ -741,12 +819,19 @@ update_consensus_networkstatus_downloads(time_t now)
 {
   int i;
   const or_options_t *options = get_options();
+  const int we_are_bootstrapping = networkstatus_consensus_is_boostrapping(
+                                                                        now);
+  const int use_multi_conn =
+    networkstatus_consensus_can_use_multiple_directories(options);
+
+  if (should_delay_dir_fetches(options, NULL))
+    return;
 
   for (i=0; i < N_CONSENSUS_FLAVORS; ++i) {
     /* XXXX need some way to download unknown flavors if we are caching. */
     const char *resource;
-    consensus_waiting_for_certs_t *waiting;
     networkstatus_t *c;
+    int max_in_progress_conns = 1;
 
     if (! we_want_to_fetch_flavor(options, i))
       continue;
@@ -762,35 +847,166 @@ update_consensus_networkstatus_downloads(time_t now)
 
     resource = networkstatus_get_flavor_name(i);
 
-    /* Let's make sure we remembered to update consensus_dl_status */
-    tor_assert(consensus_dl_status[i].schedule == DL_SCHED_CONSENSUS);
+    /* Check if we already have enough connections in progress */
+    if (we_are_bootstrapping) {
+      max_in_progress_conns =
+        options->TestingClientBootstrapConsensusMaxInProgressTries;
+    }
+    if (connection_dir_count_by_purpose_and_resource(
+                                                  DIR_PURPOSE_FETCH_CONSENSUS,
+                                                  resource)
+        >= max_in_progress_conns) {
+      continue;
+    }
 
-    if (!download_status_is_ready(&consensus_dl_status[i], now,
-                             options->TestingConsensusMaxDownloadTries))
-      continue; /* We failed downloading a consensus too recently. */
-    if (connection_dir_get_by_purpose_and_resource(
-                                DIR_PURPOSE_FETCH_CONSENSUS, resource))
-      continue; /* There's an in-progress download.*/
+    /* Check if we want to launch another download for a usable consensus.
+     * Only used during bootstrap. */
+    if (we_are_bootstrapping && use_multi_conn
+        && i == usable_consensus_flavor()) {
+
+      /* Check if we're already downloading a usable consensus */
+      int consens_conn_count =
+        connection_dir_count_by_purpose_and_resource(
+                                                   DIR_PURPOSE_FETCH_CONSENSUS,
+                                                   resource);
+      int connect_consens_conn_count =
+        connection_dir_count_by_purpose_resource_and_state(
+                                                   DIR_PURPOSE_FETCH_CONSENSUS,
+                                                   resource,
+                                                   DIR_CONN_STATE_CONNECTING);
+
+      if (i == usable_consensus_flavor()
+          && connect_consens_conn_count < consens_conn_count) {
+        continue;
+      }
 
-    waiting = &consensus_waiting_for_certs[i];
-    if (waiting->consensus) {
-      /* XXXX make sure this doesn't delay sane downloads. */
-      if (waiting->set_at + DELAY_WHILE_FETCHING_CERTS > now) {
-        continue; /* We're still getting certs for this one. */
-      } else {
-        if (!waiting->dl_failed) {
-          download_status_failed(&consensus_dl_status[i], 0);
-          waiting->dl_failed=1;
-        }
+      /* Make multiple connections for a bootstrap consensus download */
+      update_consensus_bootstrap_multiple_downloads(now, options,
+                                                    we_are_bootstrapping);
+    } else {
+      /* Check if we failed downloading a consensus too recently */
+      int max_dl_tries = consensus_max_download_tries(options,
+                                                      we_are_bootstrapping);
+
+      /* Let's make sure we remembered to update consensus_dl_status */
+      tor_assert(consensus_dl_status[i].schedule == DL_SCHED_CONSENSUS);
+
+      if (!download_status_is_ready(&consensus_dl_status[i],
+                                    now,
+                                    max_dl_tries)) {
+        continue;
       }
+
+      /* Check if we're waiting for certificates to download */
+      if (check_consensus_waiting_for_certs(i, now, &consensus_dl_status[i]))
+        continue;
+
+      /* Try the requested attempt */
+      log_info(LD_DIR, "Launching %s standard networkstatus consensus "
+               "download.", networkstatus_get_flavor_name(i));
+      directory_get_from_dirserver(DIR_PURPOSE_FETCH_CONSENSUS,
+                                   ROUTER_PURPOSE_GENERAL, resource,
+                                   PDS_RETRY_IF_NO_SERVERS,
+                                   consensus_dl_status[i].want_authority);
     }
+  }
+}
 
-    log_info(LD_DIR, "Launching %s networkstatus consensus download.",
-             networkstatus_get_flavor_name(i));
+/** When we're bootstrapping, launch one or more consensus download
+ * connections, if schedule indicates connection(s) should be made after now.
+ * If is_authority, connect to an authority, otherwise, use a fallback
+ * directory mirror.
+ */
+static void
+update_consensus_bootstrap_attempt_downloads(
+                                      time_t now,
+                                      const or_options_t *options,
+                                      int we_are_bootstrapping,
+                                      download_status_t *dls,
+                                      download_want_authority_t want_authority)
+{
+  int max_dl_tries = consensus_max_download_tries(options,
+                                                  we_are_bootstrapping);
+  const char *resource = networkstatus_get_flavor_name(
+                                                  usable_consensus_flavor());
+
+  /* Let's make sure we remembered to update schedule */
+  tor_assert(dls->schedule == DL_SCHED_CONSENSUS);
+
+  /* Allow for multiple connections in the same second, if the schedule value
+   * is 0. */
+  while (download_status_is_ready(dls, now, max_dl_tries)) {
+    log_info(LD_DIR, "Launching %s bootstrap %s networkstatus consensus "
+             "download.", resource, (want_authority == DL_WANT_AUTHORITY
+                                     ? "authority"
+                                     : "mirror"));
 
     directory_get_from_dirserver(DIR_PURPOSE_FETCH_CONSENSUS,
                                  ROUTER_PURPOSE_GENERAL, resource,
-                                 PDS_RETRY_IF_NO_SERVERS);
+                                 PDS_RETRY_IF_NO_SERVERS, want_authority);
+    /* schedule the next attempt */
+    download_status_increment_attempt(dls, resource, now);
+  }
+}
+
+/** If we're bootstrapping, check the connection schedules and see if we want
+ * to make additional, potentially concurrent, consensus download
+ * connections.
+ * Only call when bootstrapping, and when we want to make additional
+ * connections. Only nodes that satisfy
+ * networkstatus_consensus_can_use_multiple_directories make additonal
+ * connections.
+ */
+static void
+update_consensus_bootstrap_multiple_downloads(time_t now,
+                                              const or_options_t *options,
+                                              int we_are_bootstrapping)
+{
+  const int usable_flavor = usable_consensus_flavor();
+
+  /* make sure we can use multiple connections */
+  if (!networkstatus_consensus_can_use_multiple_directories(options)) {
+    return;
+  }
+
+  /* If we've managed to validate a usable consensus, don't make additonal
+   * connections. */
+  if (!we_are_bootstrapping) {
+    return;
+  }
+
+  /* Launch concurrent consensus download attempt(s) based on the mirror and
+   * authority schedules. Try the mirror first - this makes it slightly more
+   * likely that we'll connect to the fallback first, and then end the
+   * authority connection attempt. */
+
+  /* If a consensus download fails because it's waiting for certificates,
+   * we'll fail both the authority and fallback schedules. This is better than
+   * failing only one of the schedules, and having the other continue
+   * unchecked.
+   */
+
+  /* If we don't have or can't use extra fallbacks, don't try them. */
+  if (networkstatus_consensus_can_use_extra_fallbacks(options)) {
+    download_status_t *dls_f =
+      &consensus_bootstrap_dl_status[CONSENSUS_BOOTSTRAP_SOURCE_ANY_DIRSERVER];
+
+    if (!check_consensus_waiting_for_certs(usable_flavor, now, dls_f)) {
+      /* During bootstrap, DL_WANT_ANY_DIRSERVER means "use fallbacks". */
+      update_consensus_bootstrap_attempt_downloads(now, options,
+                                                   we_are_bootstrapping, dls_f,
+                                                   DL_WANT_ANY_DIRSERVER);
+    }
+  }
+
+  /* Now try an authority. */
+  download_status_t *dls_a =
+    &consensus_bootstrap_dl_status[CONSENSUS_BOOTSTRAP_SOURCE_AUTHORITY];
+
+  if (!check_consensus_waiting_for_certs(usable_flavor, now, dls_a)) {
+    update_consensus_bootstrap_attempt_downloads(now, options,
+                                                 we_are_bootstrapping, dls_a,
+                                                 DL_WANT_AUTHORITY);
   }
 }
 
@@ -1057,6 +1273,104 @@ networkstatus_get_reasonably_live_consensus(time_t now, int flavor)
     return NULL;
 }
 
+/** Check if we're bootstrapping a consensus download. This means that we are
+ *  only using the authorities and fallback directory mirrors to download the
+ * consensus flavour we'll use. */
+int
+networkstatus_consensus_is_boostrapping(time_t now)
+{
+  /* If we don't have a consensus, we must still be bootstrapping */
+  return !networkstatus_get_reasonably_live_consensus(
+                                                  now,
+                                                  usable_consensus_flavor());
+}
+
+/** Check if we can use multiple directories for a consensus download.
+ * Only clients (including bridge relays, which act like clients) benefit
+ * from multiple simultaneous consensus downloads. */
+int
+networkstatus_consensus_can_use_multiple_directories(
+                                                  const or_options_t *options)
+{
+  /* If we are a client, bridge, bridge client, or hidden service */
+  return !public_server_mode(options);
+}
+
+/** Check if we can use fallback directory mirrors for a consensus download.
+ * If we have fallbacks and don't want to fetch from the authorities,
+ * we can use them. */
+int
+networkstatus_consensus_can_use_extra_fallbacks(const or_options_t *options)
+{
+  /* The list length comparisons are a quick way to check if we have any
+   * non-authority fallback directories. If we ever have any authorities that
+   * aren't fallback directories, we will need to change this code. */
+  tor_assert(smartlist_len(router_get_fallback_dir_servers())
+             >= smartlist_len(router_get_trusted_dir_servers()));
+  /* If we don't fetch from the authorities, and we have additional mirrors,
+   * we can use them. */
+  return (!directory_fetches_from_authorities(options)
+          && (smartlist_len(router_get_fallback_dir_servers())
+              > smartlist_len(router_get_trusted_dir_servers())));
+}
+
+/* Check if there is more than 1 consensus connection retrieving the usable
+ * consensus flavor. If so, return 1, if not, return 0.
+ *
+ * During normal operation, Tor only makes one consensus download
+ * connection. But clients can make multiple simultaneous consensus
+ * connections to improve bootstrap speed and reliability.
+ *
+ * If there is more than one connection, we must have connections left
+ * over from bootstrapping. However, some of the connections may have
+ * completed and been cleaned up, so it is not sufficient to check the
+ * return value of this function to see if a client could make multiple
+ * bootstrap connections. Use
+ * networkstatus_consensus_can_use_multiple_directories()
+ * and networkstatus_consensus_is_boostrapping(). */
+int
+networkstatus_consensus_has_excess_connections(void)
+{
+  const char *usable_resource = networkstatus_get_flavor_name(
+                                                  usable_consensus_flavor());
+  const int consens_conn_usable_count =
+              connection_dir_count_by_purpose_and_resource(
+                                               DIR_PURPOSE_FETCH_CONSENSUS,
+                                               usable_resource);
+  /* The maximum number of connections we want downloading a usable consensus
+   * Always 1, whether bootstrapping or not. */
+  const int max_expected_consens_conn_usable_count = 1;
+
+  if (consens_conn_usable_count > max_expected_consens_conn_usable_count) {
+    return 1;
+  }
+
+  return 0;
+}
+
+/* Is tor currently downloading a consensus of the usable flavor? */
+int
+networkstatus_consensus_is_downloading_usable_flavor(void)
+{
+  const char *usable_resource = networkstatus_get_flavor_name(
+                                                  usable_consensus_flavor());
+  const int consens_conn_usable_count =
+              connection_dir_count_by_purpose_and_resource(
+                                               DIR_PURPOSE_FETCH_CONSENSUS,
+                                               usable_resource);
+
+  const int connect_consens_conn_usable_count =
+              connection_dir_count_by_purpose_resource_and_state(
+                                                DIR_PURPOSE_FETCH_CONSENSUS,
+                                                usable_resource,
+                                                DIR_CONN_STATE_CONNECTING);
+  if (connect_consens_conn_usable_count < consens_conn_usable_count) {
+    return 1;
+  }
+
+  return 0;
+}
+
 /** Given two router status entries for the same router identity, return 1 if
  * if the contents have changed between them. Otherwise, return 0. */
 static int
@@ -1147,6 +1461,38 @@ networkstatus_copy_old_consensus_info(networkstatus_t *new_c,
   } SMARTLIST_FOREACH_JOIN_END(rs_old, rs_new);
 }
 
+#ifdef TOR_UNIT_TESTS
+/**Accept a <b>flavor</b> consensus <b>c</b> without any additional
+ * validation. This is exclusively for unit tests.
+ * We copy any ancillary information from a pre-existing consensus
+ * and then free the current one and replace it with the newly
+ * provided instance. Returns -1 on unrecognized flavor, 0 otherwise.
+ */
+int
+networkstatus_set_current_consensus_from_ns(networkstatus_t *c,
+                                            const char *flavor)
+{
+  int flav = networkstatus_parse_flavor_name(flavor);
+  switch (flav) {
+    case FLAV_NS:
+      if (current_ns_consensus) {
+        networkstatus_copy_old_consensus_info(c, current_ns_consensus);
+        networkstatus_vote_free(current_ns_consensus);
+      }
+      current_ns_consensus = c;
+      break;
+    case FLAV_MICRODESC:
+      if (current_md_consensus) {
+        networkstatus_copy_old_consensus_info(c, current_md_consensus);
+        networkstatus_vote_free(current_md_consensus);
+      }
+      current_md_consensus = c;
+      break;
+  }
+  return current_md_consensus ? 0 : -1;
+}
+#endif //TOR_UNIT_TESTS
+
 /** Try to replace the current cached v3 networkstatus with the one in
  * <b>consensus</b>.  If we don't have enough certificates to validate it,
  * store it in consensus_waiting_for_certs and launch a certificate fetch.
diff --git a/src/or/networkstatus.h b/src/or/networkstatus.h
index d6e9e37..4eab4d8 100644
--- a/src/or/networkstatus.h
+++ b/src/or/networkstatus.h
@@ -70,6 +70,14 @@ MOCK_DECL(networkstatus_t *,networkstatus_get_latest_consensus_by_flavor,
 networkstatus_t *networkstatus_get_live_consensus(time_t now);
 networkstatus_t *networkstatus_get_reasonably_live_consensus(time_t now,
                                                              int flavor);
+int networkstatus_consensus_is_boostrapping(time_t now);
+int networkstatus_consensus_can_use_multiple_directories(
+                                                const or_options_t *options);
+int networkstatus_consensus_can_use_extra_fallbacks(
+                                                const or_options_t *options);
+int networkstatus_consensus_has_excess_connections(void);
+int networkstatus_consensus_is_downloading_usable_flavor(void);
+
 #define NSSET_FROM_CACHE 1
 #define NSSET_WAS_WAITING_FOR_CERTS 2
 #define NSSET_DONT_DOWNLOAD_CERTS 4
@@ -106,6 +114,10 @@ int networkstatus_get_weight_scale_param(networkstatus_t *ns);
 
 #ifdef NETWORKSTATUS_PRIVATE
 STATIC void vote_routerstatus_free(vote_routerstatus_t *rs);
+#ifdef TOR_UNIT_TESTS
+STATIC int networkstatus_set_current_consensus_from_ns(networkstatus_t *c,
+                                                const char *flavor);
+#endif // TOR_UNIT_TESTS
 #endif
 
 #endif
diff --git a/src/or/nodelist.c b/src/or/nodelist.c
index 2f272a1..056d5e8 100644
--- a/src/or/nodelist.c
+++ b/src/or/nodelist.c
@@ -57,13 +57,13 @@ typedef struct nodelist_t {
 
 } nodelist_t;
 
-static INLINE unsigned int
+static inline unsigned int
 node_id_hash(const node_t *node)
 {
   return (unsigned) siphash24g(node->identity, DIGEST_LEN);
 }
 
-static INLINE unsigned int
+static inline unsigned int
 node_id_eq(const node_t *node1, const node_t *node2)
 {
   return tor_memeq(node1->identity, node2->identity, DIGEST_LEN);
@@ -291,7 +291,7 @@ nodelist_set_consensus(networkstatus_t *ns)
 }
 
 /** Helper: return true iff a node has a usable amount of information*/
-static INLINE int
+static inline int
 node_is_usable(const node_t *node)
 {
   return (node->rs) || (node->ri);
@@ -644,12 +644,19 @@ node_is_named(const node_t *node)
 int
 node_is_dir(const node_t *node)
 {
-  if (node->rs)
-    return node->rs->dir_port != 0;
-  else if (node->ri)
-    return node->ri->dir_port != 0;
-  else
+  if (node->rs) {
+    routerstatus_t * rs = node->rs;
+    /* This is true if supports_tunnelled_dir_requests is true which
+     * indicates that we support directory request tunnelled or through the
+     * DirPort. */
+    return rs->is_v2_dir;
+  } else if (node->ri) {
+    routerinfo_t * ri = node->ri;
+    /* Both tunnelled request is supported or DirPort is set. */
+    return ri->supports_tunnelled_dir_requests;
+  } else {
     return 0;
+  }
 }
 
 /** Return true iff <b>node</b> has either kind of usable descriptor -- that
@@ -1021,7 +1028,7 @@ nodelist_refresh_countries(void)
 
 /** Return true iff router1 and router2 have similar enough network addresses
  * that we should treat them as being in the same family */
-static INLINE int
+static inline int
 addrs_in_same_network_family(const tor_addr_t *a1,
                              const tor_addr_t *a2)
 {
@@ -1045,7 +1052,7 @@ node_nickname_matches(const node_t *node, const char *nickname)
 }
 
 /** Return true iff <b>node</b> is named by some nickname in <b>lst</b>. */
-static INLINE int
+static inline int
 node_in_nickname_smartlist(const smartlist_t *lst, const node_t *node)
 {
   if (!lst) return 0;
diff --git a/src/or/onion_fast.c b/src/or/onion_fast.c
index 7584112..22bef4e 100644
--- a/src/or/onion_fast.c
+++ b/src/or/onion_fast.c
@@ -30,10 +30,7 @@ fast_onionskin_create(fast_handshake_state_t **handshake_state_out,
 {
   fast_handshake_state_t *s;
   *handshake_state_out = s = tor_malloc(sizeof(fast_handshake_state_t));
-  if (crypto_rand((char*)s->state, sizeof(s->state)) < 0) {
-    tor_free(s);
-    return -1;
-  }
+  crypto_rand((char*)s->state, sizeof(s->state));
   memcpy(handshake_out, s->state, DIGEST_LEN);
   return 0;
 }
@@ -56,8 +53,7 @@ fast_server_handshake(const uint8_t *key_in, /* DIGEST_LEN bytes */
   size_t out_len;
   int r = -1;
 
-  if (crypto_rand((char*)handshake_reply_out, DIGEST_LEN)<0)
-    return -1;
+  crypto_rand((char*)handshake_reply_out, DIGEST_LEN);
 
   memcpy(tmp, key_in, DIGEST_LEN);
   memcpy(tmp+DIGEST_LEN, handshake_reply_out, DIGEST_LEN);
diff --git a/src/or/or.h b/src/or/or.h
index 4496cbc..6faeb34 100644
--- a/src/or/or.h
+++ b/src/or/or.h
@@ -458,9 +458,11 @@ typedef enum {
 #define CIRCUIT_PURPOSE_OR_MIN_ 1
 /** OR-side circuit purpose: normal circuit, at OR. */
 #define CIRCUIT_PURPOSE_OR 1
-/** OR-side circuit purpose: At OR, from Bob, waiting for intro from Alices. */
+/** OR-side circuit purpose: At OR, from the service, waiting for intro from
+ * clients. */
 #define CIRCUIT_PURPOSE_INTRO_POINT 2
-/** OR-side circuit purpose: At OR, from Alice, waiting for Bob. */
+/** OR-side circuit purpose: At OR, from the client, waiting for the service.
+ */
 #define CIRCUIT_PURPOSE_REND_POINT_WAITING 3
 /** OR-side circuit purpose: At OR, both circuits have this purpose. */
 #define CIRCUIT_PURPOSE_REND_ESTABLISHED 4
@@ -479,43 +481,47 @@ typedef enum {
  *     to becoming open, or they are open and have sent the
  *     establish_rendezvous cell but haven't received an ack.
  *   circuits that are c_rend_ready are open and have received a
- *     rend ack, but haven't heard from bob yet. if they have a
+ *     rend ack, but haven't heard from the service yet. if they have a
  *     buildstate->pending_final_cpath then they're expecting a
- *     cell from bob, else they're not.
+ *     cell from the service, else they're not.
  *   circuits that are c_rend_ready_intro_acked are open, and
  *     some intro circ has sent its intro and received an ack.
  *   circuits that are c_rend_joined are open, have heard from
- *     bob, and are talking to him.
+ *     the service, and are talking to it.
  */
 /** Client-side circuit purpose: Normal circuit, with cpath. */
 #define CIRCUIT_PURPOSE_C_GENERAL 5
-/** Client-side circuit purpose: at Alice, connecting to intro point. */
+/** Client-side circuit purpose: at the client, connecting to intro point. */
 #define CIRCUIT_PURPOSE_C_INTRODUCING 6
-/** Client-side circuit purpose: at Alice, sent INTRODUCE1 to intro point,
+/** Client-side circuit purpose: at the client, sent INTRODUCE1 to intro point,
  * waiting for ACK/NAK. */
 #define CIRCUIT_PURPOSE_C_INTRODUCE_ACK_WAIT 7
-/** Client-side circuit purpose: at Alice, introduced and acked, closing. */
+/** Client-side circuit purpose: at the client, introduced and acked, closing.
+ */
 #define CIRCUIT_PURPOSE_C_INTRODUCE_ACKED 8
-/** Client-side circuit purpose: at Alice, waiting for ack. */
+/** Client-side circuit purpose: at the client, waiting for ack. */
 #define CIRCUIT_PURPOSE_C_ESTABLISH_REND 9
-/** Client-side circuit purpose: at Alice, waiting for Bob. */
+/** Client-side circuit purpose: at the client, waiting for the service. */
 #define CIRCUIT_PURPOSE_C_REND_READY 10
-/** Client-side circuit purpose: at Alice, waiting for Bob, INTRODUCE
- * has been acknowledged. */
+/** Client-side circuit purpose: at the client, waiting for the service,
+ * INTRODUCE has been acknowledged. */
 #define CIRCUIT_PURPOSE_C_REND_READY_INTRO_ACKED 11
-/** Client-side circuit purpose: at Alice, rendezvous established. */
+/** Client-side circuit purpose: at the client, rendezvous established. */
 #define CIRCUIT_PURPOSE_C_REND_JOINED 12
 /** This circuit is used for build time measurement only */
 #define CIRCUIT_PURPOSE_C_MEASURE_TIMEOUT 13
 #define CIRCUIT_PURPOSE_C_MAX_ 13
-/** Hidden-service-side circuit purpose: at Bob, waiting for introductions. */
+/** Hidden-service-side circuit purpose: at the service, waiting for
+ * introductions. */
 #define CIRCUIT_PURPOSE_S_ESTABLISH_INTRO 14
-/** Hidden-service-side circuit purpose: at Bob, successfully established
- * intro. */
+/** Hidden-service-side circuit purpose: at the service, successfully
+ * established intro. */
 #define CIRCUIT_PURPOSE_S_INTRO 15
-/** Hidden-service-side circuit purpose: at Bob, connecting to rend point. */
+/** Hidden-service-side circuit purpose: at the service, connecting to rend
+ * point. */
 #define CIRCUIT_PURPOSE_S_CONNECT_REND 16
-/** Hidden-service-side circuit purpose: at Bob, rendezvous established. */
+/** Hidden-service-side circuit purpose: at the service, rendezvous
+ * established. */
 #define CIRCUIT_PURPOSE_S_REND_JOINED 17
 /** A testing circuit; not meant to be used for actual traffic. */
 #define CIRCUIT_PURPOSE_TESTING 18
@@ -915,18 +921,18 @@ typedef enum {
 #define VAR_CELL_MAX_HEADER_SIZE 7
 
 static int get_cell_network_size(int wide_circ_ids);
-static INLINE int get_cell_network_size(int wide_circ_ids)
+static inline int get_cell_network_size(int wide_circ_ids)
 {
   return wide_circ_ids ? CELL_MAX_NETWORK_SIZE : CELL_MAX_NETWORK_SIZE - 2;
 }
 static int get_var_cell_header_size(int wide_circ_ids);
-static INLINE int get_var_cell_header_size(int wide_circ_ids)
+static inline int get_var_cell_header_size(int wide_circ_ids)
 {
   return wide_circ_ids ? VAR_CELL_MAX_HEADER_SIZE :
     VAR_CELL_MAX_HEADER_SIZE - 2;
 }
 static int get_circ_id_size(int wide_circ_ids);
-static INLINE int get_circ_id_size(int wide_circ_ids)
+static inline int get_circ_id_size(int wide_circ_ids)
 {
   return wide_circ_ids ? 4 : 2;
 }
@@ -1302,7 +1308,7 @@ typedef struct connection_t {
                               * marked.) */
   const char *marked_for_close_file; /**< For debugging: in which file were
                                       * we marked for close? */
-  char *address; /**< FQDN (or IP) of the guy on the other end.
+  char *address; /**< FQDN (or IP) of the other end.
                   * strdup into this, because free_connection() frees it. */
   /** Another connection that's connected to this one in lieu of a socket. */
   struct connection_t *linked_conn;
@@ -1646,6 +1652,13 @@ typedef struct entry_connection_t {
    * request that we're going to try to answer.  */
   struct evdns_server_request *dns_server_request;
 
+#define DEBUGGING_17659
+
+#ifdef DEBUGGING_17659
+  uint16_t marked_pending_circ_line;
+  const char *marked_pending_circ_file;
+#endif
+
 #define NUM_CIRCUITS_LAUNCHED_THRESHOLD 10
   /** Number of times we've launched a circuit to handle this stream. If
     * it gets too high, that could indicate an inconsistency between our
@@ -1799,38 +1812,38 @@ static control_connection_t *TO_CONTROL_CONN(connection_t *);
  * invalid. */
 static listener_connection_t *TO_LISTENER_CONN(connection_t *);
 
-static INLINE or_connection_t *TO_OR_CONN(connection_t *c)
+static inline or_connection_t *TO_OR_CONN(connection_t *c)
 {
   tor_assert(c->magic == OR_CONNECTION_MAGIC);
   return DOWNCAST(or_connection_t, c);
 }
-static INLINE dir_connection_t *TO_DIR_CONN(connection_t *c)
+static inline dir_connection_t *TO_DIR_CONN(connection_t *c)
 {
   tor_assert(c->magic == DIR_CONNECTION_MAGIC);
   return DOWNCAST(dir_connection_t, c);
 }
-static INLINE edge_connection_t *TO_EDGE_CONN(connection_t *c)
+static inline edge_connection_t *TO_EDGE_CONN(connection_t *c)
 {
   tor_assert(c->magic == EDGE_CONNECTION_MAGIC ||
              c->magic == ENTRY_CONNECTION_MAGIC);
   return DOWNCAST(edge_connection_t, c);
 }
-static INLINE entry_connection_t *TO_ENTRY_CONN(connection_t *c)
+static inline entry_connection_t *TO_ENTRY_CONN(connection_t *c)
 {
   tor_assert(c->magic == ENTRY_CONNECTION_MAGIC);
   return (entry_connection_t*) SUBTYPE_P(c, entry_connection_t, edge_.base_);
 }
-static INLINE entry_connection_t *EDGE_TO_ENTRY_CONN(edge_connection_t *c)
+static inline entry_connection_t *EDGE_TO_ENTRY_CONN(edge_connection_t *c)
 {
   tor_assert(c->base_.magic == ENTRY_CONNECTION_MAGIC);
   return (entry_connection_t*) SUBTYPE_P(c, entry_connection_t, edge_);
 }
-static INLINE control_connection_t *TO_CONTROL_CONN(connection_t *c)
+static inline control_connection_t *TO_CONTROL_CONN(connection_t *c)
 {
   tor_assert(c->magic == CONTROL_CONNECTION_MAGIC);
   return DOWNCAST(control_connection_t, c);
 }
-static INLINE listener_connection_t *TO_LISTENER_CONN(connection_t *c)
+static inline listener_connection_t *TO_LISTENER_CONN(connection_t *c)
 {
   tor_assert(c->magic == LISTENER_CONNECTION_MAGIC);
   return DOWNCAST(listener_connection_t, c);
@@ -1946,8 +1959,8 @@ typedef enum {
 } saved_location_t;
 #define saved_location_bitfield_t ENUM_BF(saved_location_t)
 
-/** Enumeration: what kind of download schedule are we using for a given
- * object? */
+/** Enumeration: what directory object is being downloaded?
+ * This determines which schedule is selected to perform the download. */
 typedef enum {
   DL_SCHED_GENERIC = 0,
   DL_SCHED_CONSENSUS = 1,
@@ -1955,15 +1968,74 @@ typedef enum {
 } download_schedule_t;
 #define download_schedule_bitfield_t ENUM_BF(download_schedule_t)
 
+/** Enumeration: is the download schedule for downloading from an authority,
+ * or from any available directory mirror?
+ * During bootstrap, "any" means a fallback (or an authority, if there
+ * are no fallbacks).
+ * When we have a valid consensus, "any" means any directory server. */
+typedef enum {
+  DL_WANT_ANY_DIRSERVER = 0,
+  DL_WANT_AUTHORITY = 1,
+} download_want_authority_t;
+#define download_want_authority_bitfield_t \
+                                        ENUM_BF(download_want_authority_t)
+
+/** Enumeration: do we want to increment the schedule position each time a
+ * connection is attempted (these attempts can be concurrent), or do we want
+ * to increment the schedule position after a connection fails? */
+typedef enum {
+  DL_SCHED_INCREMENT_FAILURE = 0,
+  DL_SCHED_INCREMENT_ATTEMPT = 1,
+} download_schedule_increment_t;
+#define download_schedule_increment_bitfield_t \
+                                        ENUM_BF(download_schedule_increment_t)
+
 /** Information about our plans for retrying downloads for a downloadable
- * object. */
+ * directory object.
+ * Each type of downloadable directory object has a corresponding retry
+ * <b>schedule</b>, which can be different depending on whether the object is
+ * being downloaded from an authority or a mirror (<b>want_authority</b>).
+ * <b>next_attempt_at</b> contains the next time we will attempt to download
+ * the object.
+ * For schedules that <b>increment_on</b> failure, <b>n_download_failures</b>
+ * is used to determine the position in the schedule. (Each schedule is a
+ * smartlist of integer delays, parsed from a CSV option.) Every time a
+ * connection attempt fails, <b>n_download_failures</b> is incremented,
+ * the new delay value is looked up from the schedule, and
+ * <b>next_attempt_at</b> is set delay seconds from the time the previous
+ * connection failed. Therefore, at most one failure-based connection can be
+ * in progress for each download_status_t.
+ * For schedules that <b>increment_on</b> attempt, <b>n_download_attempts</b>
+ * is used to determine the position in the schedule. Every time a
+ * connection attempt is made, <b>n_download_attempts</b> is incremented,
+ * the new delay value is looked up from the schedule, and
+ * <b>next_attempt_at</b> is set delay seconds from the time the previous
+ * connection was attempted. Therefore, multiple concurrent attempted-based
+ * connections can be in progress for each download_status_t.
+ * After an object is successfully downloaded, any other concurrent connections
+ * are terminated. A new schedule which starts at position 0 is used for
+ * subsequent downloads of the same object.
+ */
 typedef struct download_status_t {
-  time_t next_attempt_at; /**< When should we try downloading this descriptor
+  time_t next_attempt_at; /**< When should we try downloading this object
                            * again? */
-  uint8_t n_download_failures; /**< Number of failures trying to download the
-                                * most recent descriptor. */
-  download_schedule_bitfield_t schedule : 8;
-
+  uint8_t n_download_failures; /**< Number of failed downloads of the most
+                                * recent object, since the last success. */
+  uint8_t n_download_attempts; /**< Number of (potentially concurrent) attempts
+                                * to download the most recent object, since
+                                * the last success. */
+  download_schedule_bitfield_t schedule : 8; /**< What kind of object is being
+                                              * downloaded? This determines the
+                                              * schedule used for the download.
+                                              */
+  download_want_authority_bitfield_t want_authority : 1; /**< Is the download
+                                              * happening from an authority
+                                              * or a mirror? This determines
+                                              * the schedule used for the
+                                              * download. */
+  download_schedule_increment_bitfield_t increment_on : 1; /**< does this
+                                        * schedule increment on each attempt,
+                                        * or after each failure? */
 } download_status_t;
 
 /** If n_download_failures is this high, the download can never happen. */
@@ -2081,6 +2153,11 @@ typedef struct {
    * tests for it. */
   unsigned int needs_retest_if_added:1;
 
+  /** True iff this router included "tunnelled-dir-server" in its descriptor,
+   * implying it accepts tunnelled directory requests, or it advertised
+   * dir_port > 0. */
+  unsigned int supports_tunnelled_dir_requests:1;
+
 /** Tor can use this router for general positions in circuits; we got it
  * from a directory server as usual, or we're an authority and a server
  * uploaded it. */
@@ -2158,6 +2235,9 @@ typedef struct routerstatus_t {
                                * an exit node. */
   unsigned int is_hs_dir:1; /**< True iff this router is a v2-or-later hidden
                              * service directory. */
+  unsigned int is_v2_dir:1; /** True iff this router publishes an open DirPort
+                             * or it claims to accept tunnelled dir requests.
+                             */
   /** True iff we know version info for this router. (i.e., a "v" entry was
    * included.)  We'll replace all these with a big tor_version_t or a char[]
    * if the number of traits we care about ever becomes incredibly big. */
@@ -2259,7 +2339,7 @@ typedef struct microdesc_t {
   curve25519_public_key_t *onion_curve25519_pkey;
   /** Ed25519 identity key, if included. */
   ed25519_public_key_t *ed25519_identity_pkey;
-  /** As routerinfo_t.ipv6_add */
+  /** As routerinfo_t.ipv6_addr */
   tor_addr_t ipv6_addr;
   /** As routerinfo_t.ipv6_orport */
   uint16_t ipv6_orport;
@@ -2277,7 +2357,7 @@ typedef struct microdesc_t {
  * Specifically, a node_t is a Tor router as we are using it: a router that
  * we are considering for circuits, connections, and so on.  A node_t is a
  * thin wrapper around the routerstatus, routerinfo, and microdesc for a
- * single wrapper, and provides a consistent interface for all of them.
+ * single router, and provides a consistent interface for all of them.
  *
  * Also, a node_t has mutable state.  While a routerinfo, a routerstatus,
  * and a microdesc have[*] only the information read from a router
@@ -2892,6 +2972,14 @@ typedef struct circuit_t {
                               * where this circuit was marked.) */
   const char *marked_for_close_file; /**< For debugging: in which file was this
                                       * circuit marked for close? */
+  /** For what reason (See END_CIRC_REASON...) is this circuit being closed?
+   * This field is set in circuit_mark_for_close and used later in
+   * circuit_about_to_free. */
+  uint16_t marked_for_close_reason;
+  /** As marked_for_close_reason, but reflects the underlying reason for
+   * closing this circuit.
+   */
+  uint16_t marked_for_close_orig_reason;
 
   /** Unique ID for measuring tunneled network status requests. */
   uint64_t dirreq_id;
@@ -3281,27 +3369,27 @@ static const origin_circuit_t *CONST_TO_ORIGIN_CIRCUIT(const circuit_t *);
 /** Return 1 iff <b>node</b> has Exit flag and no BadExit flag.
  * Otherwise, return 0.
  */
-static INLINE int node_is_good_exit(const node_t *node)
+static inline int node_is_good_exit(const node_t *node)
 {
   return node->is_exit && ! node->is_bad_exit;
 }
 
-static INLINE or_circuit_t *TO_OR_CIRCUIT(circuit_t *x)
+static inline or_circuit_t *TO_OR_CIRCUIT(circuit_t *x)
 {
   tor_assert(x->magic == OR_CIRCUIT_MAGIC);
   return DOWNCAST(or_circuit_t, x);
 }
-static INLINE const or_circuit_t *CONST_TO_OR_CIRCUIT(const circuit_t *x)
+static inline const or_circuit_t *CONST_TO_OR_CIRCUIT(const circuit_t *x)
 {
   tor_assert(x->magic == OR_CIRCUIT_MAGIC);
   return DOWNCAST(or_circuit_t, x);
 }
-static INLINE origin_circuit_t *TO_ORIGIN_CIRCUIT(circuit_t *x)
+static inline origin_circuit_t *TO_ORIGIN_CIRCUIT(circuit_t *x)
 {
   tor_assert(x->magic == ORIGIN_CIRCUIT_MAGIC);
   return DOWNCAST(origin_circuit_t, x);
 }
-static INLINE const origin_circuit_t *CONST_TO_ORIGIN_CIRCUIT(
+static inline const origin_circuit_t *CONST_TO_ORIGIN_CIRCUIT(
     const circuit_t *x)
 {
   tor_assert(x->magic == ORIGIN_CIRCUIT_MAGIC);
@@ -3424,9 +3512,11 @@ typedef struct {
                           * each log message occurs? */
   int TruncateLogFile; /**< Boolean: Should we truncate the log file
                             before we start writing? */
+  char *SyslogIdentityTag; /**< Identity tag to add for syslog logging. */
 
   char *DebugLogFile; /**< Where to send verbose log messages. */
   char *DataDirectory; /**< OR only: where to store long-term data. */
+  int DataDirectoryGroupReadable; /**< Boolean: Is the DataDirectory g+r? */
   char *Nickname; /**< OR only: nickname of this onion router. */
   char *Address; /**< OR only: configured address for this onion router. */
   char *PidFile; /**< Where to store PID of Tor process. */
@@ -3748,6 +3838,8 @@ typedef struct {
 
   /** List of fallback directory servers */
   config_line_t *FallbackDir;
+  /** Whether to use the default hard-coded FallbackDirs */
+  int UseDefaultFallbackDirs;
 
   /** Weight to apply to all directory authority rates if considering them
    * along with fallbackdirs */
@@ -3807,9 +3899,11 @@ typedef struct {
                            * hibernate." */
   /** How do we determine when our AccountingMax has been reached?
    * "max" for when in or out reaches AccountingMax
-   * "sum for when in plus out reaches AccountingMax */
+   * "sum" for when in plus out reaches AccountingMax
+   * "in"  for when in reaches AccountingMax
+   * "out" for when out reaches AccountingMax */
   char *AccountingRule_option;
-  enum { ACCT_MAX, ACCT_SUM } AccountingRule;
+  enum { ACCT_MAX, ACCT_SUM, ACCT_IN, ACCT_OUT } AccountingRule;
 
   /** Base64-encoded hash of accepted passwords for the control system. */
   config_line_t *HashedControlPassword;
@@ -3883,6 +3977,10 @@ typedef struct {
   /** Should we fetch our dir info at the start of the consensus period? */
   int FetchDirInfoExtraEarly;
 
+  int DirCache; /**< Cache all directory documents and accept requests via
+                 * tunnelled dir conns from clients. If 1, enabled (default);
+                 * If 0, disabled. */
+
   char *VirtualAddrNetworkIPv4; /**< Address and mask to hand out for virtual
                                  * MAPADDRESS requests for IPv4 addresses */
   char *VirtualAddrNetworkIPv6; /**< Address and mask to hand out for virtual
@@ -4014,7 +4112,7 @@ typedef struct {
   char *ConsensusParams;
 
   /** Authority only: minimum number of measured bandwidths we must see
-   * before we only beliee measured bandwidths to assign flags. */
+   * before we only believe measured bandwidths to assign flags. */
   int MinMeasuredBWsForAuthToIgnoreAdvertised;
 
   /** The length of time that we think an initial consensus should be fresh.
@@ -4059,6 +4157,36 @@ typedef struct {
    * on testing networks. */
   smartlist_t *TestingClientConsensusDownloadSchedule;
 
+  /** Schedule for when clients should download consensuses from authorities
+   * if they are bootstrapping (that is, they don't have a usable, reasonably
+   * live consensus).  Only used by clients fetching from a list of fallback
+   * directory mirrors.
+   *
+   * This schedule is incremented by (potentially concurrent) connection
+   * attempts, unlike other schedules, which are incremented by connection
+   * failures.  Only altered on testing networks. */
+  smartlist_t *TestingClientBootstrapConsensusAuthorityDownloadSchedule;
+
+  /** Schedule for when clients should download consensuses from fallback
+   * directory mirrors if they are bootstrapping (that is, they don't have a
+   * usable, reasonably live consensus). Only used by clients fetching from a
+   * list of fallback directory mirrors.
+   *
+   * This schedule is incremented by (potentially concurrent) connection
+   * attempts, unlike other schedules, which are incremented by connection
+   * failures.  Only altered on testing networks. */
+  smartlist_t *TestingClientBootstrapConsensusFallbackDownloadSchedule;
+
+  /** Schedule for when clients should download consensuses from authorities
+   * if they are bootstrapping (that is, they don't have a usable, reasonably
+   * live consensus).  Only used by clients which don't have or won't fetch
+   * from a list of fallback directory mirrors.
+   *
+   * This schedule is incremented by (potentially concurrent) connection
+   * attempts, unlike other schedules, which are incremented by connection
+   * failures.  Only altered on testing networks. */
+  smartlist_t *TestingClientBootstrapConsensusAuthorityOnlyDownloadSchedule;
+
   /** Schedule for when clients should download bridge descriptors.  Only
    * altered on testing networks. */
   smartlist_t *TestingBridgeDownloadSchedule;
@@ -4076,6 +4204,21 @@ typedef struct {
    * up?  Only altered on testing networks. */
   int TestingConsensusMaxDownloadTries;
 
+  /** How many times will a client try to fetch a consensus while
+   * bootstrapping using a list of fallback directories, before it gives up?
+   * Only altered on testing networks. */
+  int TestingClientBootstrapConsensusMaxDownloadTries;
+
+  /** How many times will a client try to fetch a consensus while
+   * bootstrapping using only a list of authorities, before it gives up?
+   * Only altered on testing networks. */
+  int TestingClientBootstrapConsensusAuthorityOnlyMaxDownloadTries;
+
+  /** How many simultaneous in-progress connections will we make when trying
+   * to fetch a consensus before we wait for one to complete, timeout, or
+   * error out?  Only altered on testing networks. */
+  int TestingClientBootstrapConsensusMaxInProgressTries;
+
   /** How many times will we try to download a router's descriptor before
    * giving up?  Only altered on testing networks. */
   int TestingDescriptorMaxDownloadTries;
@@ -4316,6 +4459,9 @@ typedef struct {
   int keygen_passphrase_fd;
   int change_key_passphrase;
   char *master_key_fname;
+
+  /** Autobool: Do we try to retain capabilities if we can? */
+  int KeepBindCapabilities;
 } or_options_t;
 
 /** Persistent state for an onion router, as saved to disk. */
@@ -4388,7 +4534,7 @@ typedef struct {
 /** Change the next_write time of <b>state</b> to <b>when</b>, unless the
  * state is already scheduled to be written to disk earlier than <b>when</b>.
  */
-static INLINE void or_state_mark_dirty(or_state_t *state, time_t when)
+static inline void or_state_mark_dirty(or_state_t *state, time_t when)
 {
   if (state->next_write > when)
     state->next_write = when;
@@ -4999,9 +5145,11 @@ typedef struct dir_server_t {
   char *description;
   char *nickname;
   char *address; /**< Hostname. */
+  tor_addr_t ipv6_addr; /**< IPv6 address if present; AF_UNSPEC if not */
   uint32_t addr; /**< IPv4 address. */
   uint16_t dir_port; /**< Directory port. */
   uint16_t or_port; /**< OR port: Used for tunneling connections. */
+  uint16_t ipv6_orport; /**< OR port corresponding to ipv6_addr. */
   double weight; /** Weight used when selecting this node at random */
   char digest[DIGEST_LEN]; /**< Digest of identity key. */
   char v3_identity_digest[DIGEST_LEN]; /**< Digest of v3 (authority only,
diff --git a/src/or/periodic.c b/src/or/periodic.c
new file mode 100644
index 0000000..109717f
--- /dev/null
+++ b/src/or/periodic.c
@@ -0,0 +1,120 @@
+/* Copyright (c) 2015, The Tor Project, Inc. */
+/* See LICENSE for licensing information */
+
+#include "or.h"
+#include "compat_libevent.h"
+#include "config.h"
+#include "periodic.h"
+
+#ifdef HAVE_EVENT2_EVENT_H
+#include <event2/event.h>
+#else
+#include <event.h>
+#endif
+
+/** We disable any interval greater than this number of seconds, on the
+ * grounds that it is probably an absolute time mistakenly passed in as a
+ * relative time.
+ */
+static const int MAX_INTERVAL = 10 * 365 * 86400;
+
+/** Set the event <b>event</b> to run in <b>next_interval</b> seconds from
+ * now. */
+static void
+periodic_event_set_interval(periodic_event_item_t *event,
+                            time_t next_interval)
+{
+  tor_assert(next_interval < MAX_INTERVAL);
+  struct timeval tv;
+  tv.tv_sec = next_interval;
+  tv.tv_usec = 0;
+  event_add(event->ev, &tv);
+}
+
+/** Wraps dispatches for periodic events, <b>data</b> will be a pointer to the
+ * event that needs to be called */
+static void
+periodic_event_dispatch(evutil_socket_t fd, short what, void *data)
+{
+  (void)fd;
+  (void)what;
+  periodic_event_item_t *event = data;
+
+  time_t now = time(NULL);
+  const or_options_t *options = get_options();
+  log_debug(LD_GENERAL, "Dispatching %s", event->name);
+  int r = event->fn(now, options);
+  int next_interval = 0;
+
+  /* update the last run time if action was taken */
+  if (r==0) {
+    log_err(LD_BUG, "Invalid return value for periodic event from %s.",
+                      event->name);
+    tor_assert(r != 0);
+  } else if (r > 0) {
+    event->last_action_time = now;
+    /* If the event is meant to happen after ten years, that's likely
+     * a bug, and somebody gave an absolute time rather than an interval.
+     */
+    tor_assert(r < MAX_INTERVAL);
+    next_interval = r;
+  } else {
+    /* no action was taken, it is likely a precondition failed,
+     * we should reschedule for next second incase the precondition
+     * passes then */
+    next_interval = 1;
+  }
+
+  log_debug(LD_GENERAL, "Scheduling %s for %d seconds", event->name,
+           next_interval);
+  struct timeval tv = { next_interval , 0 };
+  event_add(event->ev, &tv);
+}
+
+/** Schedules <b>event</b> to run as soon as possible from now. */
+void
+periodic_event_reschedule(periodic_event_item_t *event)
+{
+  periodic_event_set_interval(event, 1);
+}
+
+/** Initializes the libevent backend for a periodic event. */
+void
+periodic_event_setup(periodic_event_item_t *event)
+{
+  if (event->ev) { /* Already setup? This is a bug */
+    log_err(LD_BUG, "Initial dispatch should only be done once.");
+    tor_assert(0);
+  }
+
+  event->ev = tor_event_new(tor_libevent_get_base(),
+                            -1, 0,
+                            periodic_event_dispatch,
+                            event);
+  tor_assert(event->ev);
+}
+
+/** Handles initial dispatch for periodic events. It should happen 1 second
+ * after the events are created to mimic behaviour before #3199's refactor */
+void
+periodic_event_launch(periodic_event_item_t *event)
+{
+  if (! event->ev) { /* Not setup? This is a bug */
+    log_err(LD_BUG, "periodic_event_launch without periodic_event_setup");
+    tor_assert(0);
+  }
+
+  // Initial dispatch
+  periodic_event_dispatch(-1, EV_TIMEOUT, event);
+}
+
+/** Release all storage associated with <b>event</b> */
+void
+periodic_event_destroy(periodic_event_item_t *event)
+{
+  if (!event)
+    return;
+  tor_event_free(event->ev);
+  event->last_action_time = 0;
+}
+
diff --git a/src/or/periodic.h b/src/or/periodic.h
new file mode 100644
index 0000000..bab0c91
--- /dev/null
+++ b/src/or/periodic.h
@@ -0,0 +1,37 @@
+/* Copyright (c) 2015, The Tor Project, Inc. */
+/* See LICENSE for licensing information */
+
+#ifndef TOR_PERIODIC_H
+#define TOR_PERIODIC_H
+
+#define PERIODIC_EVENT_NO_UPDATE (-1)
+
+/** Callback function for a periodic event to take action.  The return value
+* influences the next time the function will get called.  Return
+* PERIODIC_EVENT_NO_UPDATE to not update <b>last_action_time</b> and be polled
+* again in the next second. If a positive value is returned it will update the
+* interval time. */
+typedef int (*periodic_event_helper_t)(time_t now,
+                                      const or_options_t *options);
+
+struct event;
+
+/** A single item for the periodic-events-function table. */
+typedef struct periodic_event_item_t {
+  periodic_event_helper_t fn; /**< The function to run the event */
+  time_t last_action_time; /**< The last time the function did something */
+  struct event *ev; /**< Libevent callback we're using to implement this */
+  const char *name; /**< Name of the function -- for debug */
+} periodic_event_item_t;
+
+/** events will get their interval from first execution */
+#define PERIODIC_EVENT(fn) { fn##_callback, 0, NULL, #fn }
+#define END_OF_PERIODIC_EVENTS { NULL, 0, NULL, NULL }
+
+void periodic_event_launch(periodic_event_item_t *event);
+void periodic_event_setup(periodic_event_item_t *event);
+void periodic_event_destroy(periodic_event_item_t *event);
+void periodic_event_reschedule(periodic_event_item_t *event);
+
+#endif
+
diff --git a/src/or/policies.c b/src/or/policies.c
index 9c858ec..4706a9d 100644
--- a/src/or/policies.c
+++ b/src/or/policies.c
@@ -8,6 +8,8 @@
  * \brief Code to parse and use address policies and exit policies.
  **/
 
+#define POLICIES_PRIVATE
+
 #include "or.h"
 #include "config.h"
 #include "dirserv.h"
@@ -62,14 +64,15 @@ static const char *private_nets[] = {
   NULL
 };
 
-static int policies_parse_exit_policy_internal(config_line_t *cfg,
-                                               smartlist_t **dest,
-                                               int ipv6_exit,
-                                               int rejectprivate,
-                                               uint32_t local_address,
-                                               tor_addr_t *ipv6_local_address,
-                                               int reject_interface_addresses,
-                                               int add_default_policy);
+static int policies_parse_exit_policy_internal(
+                                      config_line_t *cfg,
+                                      smartlist_t **dest,
+                                      int ipv6_exit,
+                                      int rejectprivate,
+                                      const smartlist_t *configured_addresses,
+                                      int reject_interface_addresses,
+                                      int reject_configured_port_addresses,
+                                      int add_default_policy);
 
 /** Replace all "private" entries in *<b>policy</b> with their expanded
  * equivalents. */
@@ -443,7 +446,7 @@ validate_addr_policies(const or_options_t *options, char **msg)
   smartlist_t *addr_policy=NULL;
   *msg = NULL;
 
-  if (policies_parse_exit_policy_from_options(options,0,NULL,0,&addr_policy)) {
+  if (policies_parse_exit_policy_from_options(options,0,NULL,&addr_policy)) {
     REJECT("Error in ExitPolicy entry.");
   }
 
@@ -625,7 +628,7 @@ typedef struct policy_map_ent_t {
 static HT_HEAD(policy_map, policy_map_ent_t) policy_root = HT_INITIALIZER();
 
 /** Return true iff a and b are equal. */
-static INLINE int
+static inline int
 policy_eq(policy_map_ent_t *a, policy_map_ent_t *b)
 {
   return cmp_single_addr_policy(a->policy, b->policy) == 0;
@@ -693,6 +696,10 @@ compare_known_tor_addr_to_addr_policy(const tor_addr_t *addr, uint16_t port,
   /* We know the address and port, and we know the policy, so we can just
    * compute an exact match. */
   SMARTLIST_FOREACH_BEGIN(policy, addr_policy_t *, tmpe) {
+    if (tmpe->addr.family == AF_UNSPEC) {
+      log_warn(LD_BUG, "Policy contains an AF_UNSPEC address, which only "
+               "matches other AF_UNSPEC addresses.");
+    }
     /* Address is known */
     if (!tor_addr_compare_masked(addr, &tmpe->addr, tmpe->maskbits,
                                  CMP_EXACT)) {
@@ -720,6 +727,10 @@ compare_known_tor_addr_to_addr_policy_noport(const tor_addr_t *addr,
   int maybe_accept = 0, maybe_reject = 0;
 
   SMARTLIST_FOREACH_BEGIN(policy, addr_policy_t *, tmpe) {
+    if (tmpe->addr.family == AF_UNSPEC) {
+      log_warn(LD_BUG, "Policy contains an AF_UNSPEC address, which only "
+               "matches other AF_UNSPEC addresses.");
+    }
     if (!tor_addr_compare_masked(addr, &tmpe->addr, tmpe->maskbits,
                                  CMP_EXACT)) {
       if (tmpe->prt_min <= 1 && tmpe->prt_max >= 65535) {
@@ -759,6 +770,10 @@ compare_unknown_tor_addr_to_addr_policy(uint16_t port,
   int maybe_accept = 0, maybe_reject = 0;
 
   SMARTLIST_FOREACH_BEGIN(policy, addr_policy_t *, tmpe) {
+    if (tmpe->addr.family == AF_UNSPEC) {
+      log_warn(LD_BUG, "Policy contains an AF_UNSPEC address, which only "
+               "matches other AF_UNSPEC addresses.");
+    }
     if (tmpe->prt_min <= port && port <= tmpe->prt_max) {
       if (tmpe->maskbits == 0) {
         /* Definitely matches, since it covers all addresses. */
@@ -864,7 +879,7 @@ addr_policy_intersects(addr_policy_t *a, addr_policy_t *b)
 
 /** Add the exit policy described by <b>more</b> to <b>policy</b>.
  */
-static void
+STATIC void
 append_exit_policy_string(smartlist_t **policy, const char *more)
 {
   config_line_t tmp;
@@ -881,6 +896,9 @@ append_exit_policy_string(smartlist_t **policy, const char *more)
 void
 addr_policy_append_reject_addr(smartlist_t **dest, const tor_addr_t *addr)
 {
+  tor_assert(dest);
+  tor_assert(addr);
+
   addr_policy_t p, *add;
   memset(&p, 0, sizeof(p));
   p.policy_type = ADDR_POLICY_REJECT;
@@ -893,6 +911,71 @@ addr_policy_append_reject_addr(smartlist_t **dest, const tor_addr_t *addr)
   if (!*dest)
     *dest = smartlist_new();
   smartlist_add(*dest, add);
+  log_debug(LD_CONFIG, "Adding a reject ExitPolicy 'reject %s:*'",
+            fmt_addr(addr));
+}
+
+/* Is addr public for the purposes of rejection? */
+static int
+tor_addr_is_public_for_reject(const tor_addr_t *addr)
+{
+  return (!tor_addr_is_null(addr) && !tor_addr_is_internal(addr, 0)
+          && !tor_addr_is_multicast(addr));
+}
+
+/* Add "reject <b>addr</b>:*" to <b>dest</b>, creating the list as needed.
+ * Filter the address, only adding an IPv4 reject rule if ipv4_rules
+ * is true, and similarly for ipv6_rules. Check each address returns true for
+ * tor_addr_is_public_for_reject before adding it.
+ */
+static void
+addr_policy_append_reject_addr_filter(smartlist_t **dest,
+                                      const tor_addr_t *addr,
+                                      int ipv4_rules,
+                                      int ipv6_rules)
+{
+  tor_assert(dest);
+  tor_assert(addr);
+
+  /* Only reject IP addresses which are public */
+  if (tor_addr_is_public_for_reject(addr)) {
+
+    /* Reject IPv4 addresses and IPv6 addresses based on the filters */
+    int is_ipv4 = tor_addr_is_v4(addr);
+    if ((is_ipv4 && ipv4_rules) || (!is_ipv4 && ipv6_rules)) {
+      addr_policy_append_reject_addr(dest, addr);
+    }
+  }
+}
+
+/** Add "reject addr:*" to <b>dest</b>, for each addr in addrs, creating the
+  * list as needed. */
+void
+addr_policy_append_reject_addr_list(smartlist_t **dest,
+                                    const smartlist_t *addrs)
+{
+  tor_assert(dest);
+  tor_assert(addrs);
+
+  SMARTLIST_FOREACH_BEGIN(addrs, tor_addr_t *, addr) {
+    addr_policy_append_reject_addr(dest, addr);
+  } SMARTLIST_FOREACH_END(addr);
+}
+
+/** Add "reject addr:*" to <b>dest</b>, for each addr in addrs, creating the
+ * list as needed. Filter using */
+static void
+addr_policy_append_reject_addr_list_filter(smartlist_t **dest,
+                                           const smartlist_t *addrs,
+                                           int ipv4_rules,
+                                           int ipv6_rules)
+{
+  tor_assert(dest);
+  tor_assert(addrs);
+
+  SMARTLIST_FOREACH_BEGIN(addrs, tor_addr_t *, addr) {
+    addr_policy_append_reject_addr_filter(dest, addr, ipv4_rules, ipv6_rules);
+  } SMARTLIST_FOREACH_END(addr);
 }
 
 /** Detect and excise "dead code" from the policy *<b>dest</b>. */
@@ -979,127 +1062,90 @@ exit_policy_remove_redundancies(smartlist_t *dest)
   }
 }
 
-#define DEFAULT_EXIT_POLICY                                         \
-  "reject *:25,reject *:119,reject *:135-139,reject *:445,"         \
-  "reject *:563,reject *:1214,reject *:4661-4666,"                  \
-  "reject *:6346-6429,reject *:6699,reject *:6881-6999,accept *:*"
-
-/** Parse the exit policy <b>cfg</b> into the linked list *<b>dest</b>.
- *
- * If <b>ipv6_exit</b> is true, prepend "reject *6:*" to the policy.
+/** Reject private helper for policies_parse_exit_policy_internal: rejects
+ * publicly routable addresses on this exit relay.
  *
- * If <b>rejectprivate</b> is true:
- *   - prepend "reject private:*" to the policy.
- *   - if local_address is non-zero, treat it as a host-order IPv4 address,
- *     and prepend an entry that rejects it as a destination.
- *   - if ipv6_local_address is non-NULL, prepend an entry that rejects it as
- *     a destination.
- *   - if reject_interface_addresses is true, prepend entries that reject each
+ * Add reject entries to the linked list *dest:
+ *   - if configured_addresses is non-NULL, add entries that reject each
+ *     tor_addr_t* in the list as a destination.
+ *   - if reject_interface_addresses is true, add entries that reject each
  *     public IPv4 and IPv6 address of each interface on this machine.
+ *   - if reject_configured_port_addresses is true, add entries that reject
+ *     each IPv4 and IPv6 address configured for a port.
  *
- * If cfg doesn't end in an absolute accept or reject and if
- * <b>add_default_policy</b> is true, add the default exit
- * policy afterwards.
- *
- * Return -1 if we can't parse cfg, else return 0.
+ * IPv6 entries are only added if ipv6_exit is true. (All IPv6 addresses are
+ * already blocked by policies_parse_exit_policy_internal if ipv6_exit is
+ * false.)
  *
- * This function is used to parse the exit policy from our torrc. For
- * the functions used to parse the exit policy from a router descriptor,
- * see router_add_exit_policy.
+ * The list *dest is created as needed.
  */
-static int
-policies_parse_exit_policy_internal(config_line_t *cfg, smartlist_t **dest,
-                                    int ipv6_exit,
-                                    int rejectprivate,
-                                    uint32_t local_address,
-                                    tor_addr_t *ipv6_local_address,
-                                    int reject_interface_addresses,
-                                    int add_default_policy)
+void
+policies_parse_exit_policy_reject_private(
+                                      smartlist_t **dest,
+                                      int ipv6_exit,
+                                      const smartlist_t *configured_addresses,
+                                      int reject_interface_addresses,
+                                      int reject_configured_port_addresses)
 {
-  if (!ipv6_exit) {
-    append_exit_policy_string(dest, "reject *6:*");
+  tor_assert(dest);
+
+  /* Reject configured addresses, if they are from public netblocks. */
+  if (configured_addresses) {
+    addr_policy_append_reject_addr_list_filter(dest, configured_addresses,
+                                               1, ipv6_exit);
   }
-  if (rejectprivate) {
-    /* Reject IPv4 and IPv6 reserved private netblocks */
-    append_exit_policy_string(dest, "reject private:*");
-    /* Reject our local IPv4 address */
-    if (local_address) {
-      char buf[POLICY_BUF_LEN];
-      tor_snprintf(buf, sizeof(buf), "reject %s:*", fmt_addr32(local_address));
-      append_exit_policy_string(dest, buf);
-      log_info(LD_CONFIG, "Adding a reject ExitPolicy '%s' for our published "
-               "IPv4 address", buf);
-    }
-    /* Reject our local IPv6 address */
-    if (ipv6_exit && ipv6_local_address != NULL) {
-      if (tor_addr_is_v4(ipv6_local_address)) {
-        log_warn(LD_CONFIG, "IPv4 address '%s' provided as our IPv6 local "
-                 "address", fmt_addr(ipv6_local_address));
-      } else {
-        char buf6[POLICY_BUF_LEN];
-        tor_snprintf(buf6, sizeof(buf6), "reject [%s]:*",
-                     fmt_addr(ipv6_local_address));
-        append_exit_policy_string(dest, buf6);
-        log_info(LD_CONFIG, "Adding a reject ExitPolicy '%s' for our "
-                 "published IPv6 address", buf6);
-      }
-    }
-    /* Reject local addresses from public netblocks on any interface,
-     * but don't reject our published addresses twice */
-    if (reject_interface_addresses) {
-      smartlist_t *public_addresses = NULL;
-      char bufif[POLICY_BUF_LEN];
-
-      /* Reject public IPv4 addresses on any interface,
-       * but don't reject our published IPv4 address twice */
-      public_addresses = get_interface_address6_list(LOG_INFO, AF_INET, 0);
-      SMARTLIST_FOREACH_BEGIN(public_addresses, tor_addr_t *, a) {
-        if (!tor_addr_eq_ipv4h(a, local_address)) {
-          tor_snprintf(bufif, sizeof(bufif), "reject %s:*",
-                       fmt_addr(a));
-          append_exit_policy_string(dest, bufif);
-          log_info(LD_CONFIG, "Adding a reject ExitPolicy '%s' for a local "
-                   "interface's public IPv4 address", bufif);
-        }
-      } SMARTLIST_FOREACH_END(a);
-      free_interface_address6_list(public_addresses);
 
-      if (ipv6_exit) {
-        /* Reject public IPv6 addresses on any interface,
-         * but don't reject our published IPv6 address (if any) twice */
-        public_addresses = get_interface_address6_list(LOG_INFO, AF_INET6, 0);
-        SMARTLIST_FOREACH_BEGIN(public_addresses, tor_addr_t *, a) {
-          /* if we don't have an IPv6 local address, we won't have rejected
-           * it above. This could happen if a future release does IPv6
-           * autodiscovery, and we are waiting to discover our external IPv6
-           * address */
-          if (ipv6_local_address == NULL
-              || !tor_addr_eq(ipv6_local_address, a)) {
-            tor_snprintf(bufif, sizeof(bufif), "reject6 [%s]:*",
-                         fmt_addr(a));
-            append_exit_policy_string(dest, bufif);
-            log_info(LD_CONFIG, "Adding a reject ExitPolicy '%s' for a local "
-                     "interface's public IPv6 address", bufif);
-          }
-        } SMARTLIST_FOREACH_END(a);
-        free_interface_address6_list(public_addresses);
+  /* Reject configured port addresses, if they are from public netblocks. */
+  if (reject_configured_port_addresses) {
+    const smartlist_t *port_addrs = get_configured_ports();
+
+    SMARTLIST_FOREACH_BEGIN(port_addrs, port_cfg_t *, port) {
+
+      /* Only reject port IP addresses, not port unix sockets */
+      if (!port->is_unix_addr) {
+        addr_policy_append_reject_addr_filter(dest, &port->addr, 1, ipv6_exit);
       }
+    } SMARTLIST_FOREACH_END(port);
+  }
+
+  /* Reject local addresses from public netblocks on any interface. */
+  if (reject_interface_addresses) {
+    smartlist_t *public_addresses = NULL;
+
+    /* Reject public IPv4 addresses on any interface */
+    public_addresses = get_interface_address6_list(LOG_INFO, AF_INET, 0);
+    addr_policy_append_reject_addr_list_filter(dest, public_addresses, 1, 0);
+    free_interface_address6_list(public_addresses);
+
+    /* Don't look for IPv6 addresses if we're configured as IPv4-only */
+    if (ipv6_exit) {
+      /* Reject public IPv6 addresses on any interface */
+      public_addresses = get_interface_address6_list(LOG_INFO, AF_INET6, 0);
+      addr_policy_append_reject_addr_list_filter(dest, public_addresses, 0, 1);
+      free_interface_address6_list(public_addresses);
     }
   }
-  if (parse_addr_policy(cfg, dest, -1))
-    return -1;
 
-  /* Before we add the default policy and final rejects, check to see if
-   * there are any lines after accept *:* or reject *:*. These lines have no
-   * effect, and are most likely an error. */
+  /* If addresses were added multiple times, remove all but one of them. */
+  if (*dest) {
+    exit_policy_remove_redundancies(*dest);
+  }
+}
+
+/**
+ * Iterate through <b>policy</b> looking for redundant entries. Log a
+ * warning message with the first redundant entry, if any is found.
+ */
+static void
+policies_log_first_redundant_entry(const smartlist_t *policy)
+{
   int found_final_effective_entry = 0;
   int first_redundant_entry = 0;
-  for (int i = 0; i < smartlist_len(*dest); ++i) {
+  tor_assert(policy);
+  SMARTLIST_FOREACH_BEGIN(policy, const addr_policy_t *, p) {
     sa_family_t family;
-    addr_policy_t *p;
     int found_ipv4_wildcard = 0, found_ipv6_wildcard = 0;
-
-    p = smartlist_get(*dest, i);
+    const int i = p_sl_idx;
 
     /* Look for accept/reject *[4|6|]:* entires */
     if (p->prt_min <= 1 && p->prt_max == 65535 && p->maskbits == 0) {
@@ -1122,22 +1168,23 @@ policies_parse_exit_policy_internal(config_line_t *cfg, smartlist_t **dest,
     if (found_ipv4_wildcard && found_ipv6_wildcard) {
       found_final_effective_entry = 1;
       /* if we're not on the final entry in the list */
-      if (i < smartlist_len(*dest) - 1) {
+      if (i < smartlist_len(policy) - 1) {
         first_redundant_entry = i + 1;
       }
       break;
     }
-  }
+  } SMARTLIST_FOREACH_END(p);
+
   /* Work out if there are redundant trailing entries in the policy list */
   if (found_final_effective_entry && first_redundant_entry > 0) {
-    addr_policy_t *p;
+    const addr_policy_t *p;
     /* Longest possible policy is
      * "accept6 ffff:ffff:..255/128:10000-65535",
      * which contains a max-length IPv6 address, plus 24 characters. */
     char line[TOR_ADDR_BUF_LEN + 32];
 
-    tor_assert(first_redundant_entry < smartlist_len(*dest));
-    p = smartlist_get(*dest, first_redundant_entry);
+    tor_assert(first_redundant_entry < smartlist_len(policy));
+    p = smartlist_get(policy, first_redundant_entry);
     /* since we've already parsed the policy into an addr_policy_t struct,
      * we might not log exactly what the user typed in */
     policy_write_item(line, TOR_ADDR_BUF_LEN + 32, p, 0);
@@ -1147,6 +1194,62 @@ policies_parse_exit_policy_internal(config_line_t *cfg, smartlist_t **dest,
              "accept/reject *:* as the last entry in any exit policy.)",
              line);
   }
+}
+
+#define DEFAULT_EXIT_POLICY                                         \
+  "reject *:25,reject *:119,reject *:135-139,reject *:445,"         \
+  "reject *:563,reject *:1214,reject *:4661-4666,"                  \
+  "reject *:6346-6429,reject *:6699,reject *:6881-6999,accept *:*"
+
+/** Parse the exit policy <b>cfg</b> into the linked list *<b>dest</b>.
+ *
+ * If <b>ipv6_exit</b> is false, prepend "reject *6:*" to the policy.
+ *
+ * If <b>rejectprivate</b> is true:
+ *   - prepend "reject private:*" to the policy.
+ *   - prepend entries that reject publicly routable addresses on this exit
+ *     relay by calling policies_parse_exit_policy_reject_private
+ *
+ * If cfg doesn't end in an absolute accept or reject and if
+ * <b>add_default_policy</b> is true, add the default exit
+ * policy afterwards.
+ *
+ * Return -1 if we can't parse cfg, else return 0.
+ *
+ * This function is used to parse the exit policy from our torrc. For
+ * the functions used to parse the exit policy from a router descriptor,
+ * see router_add_exit_policy.
+ */
+static int
+policies_parse_exit_policy_internal(config_line_t *cfg,
+                                    smartlist_t **dest,
+                                    int ipv6_exit,
+                                    int rejectprivate,
+                                    const smartlist_t *configured_addresses,
+                                    int reject_interface_addresses,
+                                    int reject_configured_port_addresses,
+                                    int add_default_policy)
+{
+  if (!ipv6_exit) {
+    append_exit_policy_string(dest, "reject *6:*");
+  }
+  if (rejectprivate) {
+    /* Reject IPv4 and IPv6 reserved private netblocks */
+    append_exit_policy_string(dest, "reject private:*");
+    /* Reject IPv4 and IPv6 publicly routable addresses on this exit relay */
+    policies_parse_exit_policy_reject_private(
+                                            dest, ipv6_exit,
+                                            configured_addresses,
+                                            reject_interface_addresses,
+                                            reject_configured_port_addresses);
+  }
+  if (parse_addr_policy(cfg, dest, -1))
+    return -1;
+
+  /* Before we add the default policy and final rejects, check to see if
+   * there are any lines after accept *:* or reject *:*. These lines have no
+   * effect, and are most likely an error. */
+  policies_log_first_redundant_entry(*dest);
 
   if (add_default_policy) {
     append_exit_policy_string(dest, DEFAULT_EXIT_POLICY);
@@ -1167,12 +1270,8 @@ policies_parse_exit_policy_internal(config_line_t *cfg, smartlist_t **dest,
  * If <b>EXIT_POLICY_REJECT_PRIVATE</b> bit is set in <b>options</b>:
  *   - prepend an entry that rejects all destinations in all netblocks
  *     reserved for private use.
- *   - if local_address is non-zero, treat it as a host-order IPv4 address,
- *     and prepend an entry that rejects it as a destination.
- *   - if ipv6_local_address is non-NULL, prepend an entry that rejects it as
- *     a destination.
- *   - if reject_interface_addresses is true, prepend entries that reject each
- *     public IPv4 and IPv6 address of each interface on this machine.
+ *   - prepend entries that reject publicly routable addresses on this exit
+ *     relay by calling policies_parse_exit_policy_internal
  *
  * If <b>EXIT_POLICY_ADD_DEFAULT</b> bit is set in <b>options</b>, append
  * default exit policy entries to <b>result</b> smartlist.
@@ -1180,9 +1279,7 @@ policies_parse_exit_policy_internal(config_line_t *cfg, smartlist_t **dest,
 int
 policies_parse_exit_policy(config_line_t *cfg, smartlist_t **dest,
                            exit_policy_parser_cfg_t options,
-                           uint32_t local_address,
-                           tor_addr_t *ipv6_local_address,
-                           int reject_interface_addresses)
+                           const smartlist_t *configured_addresses)
 {
   int ipv6_enabled = (options & EXIT_POLICY_IPV6_ENABLED) ? 1 : 0;
   int reject_private = (options & EXIT_POLICY_REJECT_PRIVATE) ? 1 : 0;
@@ -1190,12 +1287,62 @@ policies_parse_exit_policy(config_line_t *cfg, smartlist_t **dest,
 
   return policies_parse_exit_policy_internal(cfg,dest,ipv6_enabled,
                                              reject_private,
-                                             local_address,
-                                             ipv6_local_address,
-                                             reject_interface_addresses,
+                                             configured_addresses,
+                                             reject_private,
+                                             reject_private,
                                              add_default);
 }
 
+/** Helper function that adds a copy of addr to a smartlist as long as it is
+ * non-NULL and not tor_addr_is_null().
+ *
+ * The caller is responsible for freeing all the tor_addr_t* in the smartlist.
+ */
+static void
+policies_copy_addr_to_smartlist(smartlist_t *addr_list, const tor_addr_t *addr)
+{
+  if (addr && !tor_addr_is_null(addr)) {
+    tor_addr_t *addr_copy = tor_malloc(sizeof(tor_addr_t));
+    tor_addr_copy(addr_copy, addr);
+    smartlist_add(addr_list, addr_copy);
+  }
+}
+
+/** Helper function that adds ipv4h_addr to a smartlist as a tor_addr_t *,
+ * as long as it is not tor_addr_is_null(), by converting it to a tor_addr_t
+ * and passing it to policies_add_addr_to_smartlist.
+ *
+ * The caller is responsible for freeing all the tor_addr_t* in the smartlist.
+ */
+static void
+policies_copy_ipv4h_to_smartlist(smartlist_t *addr_list, uint32_t ipv4h_addr)
+{
+  if (ipv4h_addr) {
+    tor_addr_t ipv4_tor_addr;
+    tor_addr_from_ipv4h(&ipv4_tor_addr, ipv4h_addr);
+    policies_copy_addr_to_smartlist(addr_list, &ipv4_tor_addr);
+  }
+}
+
+/** Helper function that adds copies of
+ * or_options->OutboundBindAddressIPv[4|6]_ to a smartlist as tor_addr_t *, as
+ * long as or_options is non-NULL, and the addresses are not
+ * tor_addr_is_null(), by passing them to policies_add_addr_to_smartlist.
+ *
+ * The caller is responsible for freeing all the tor_addr_t* in the smartlist.
+ */
+static void
+policies_copy_outbound_addresses_to_smartlist(smartlist_t *addr_list,
+                                              const or_options_t *or_options)
+{
+  if (or_options) {
+    policies_copy_addr_to_smartlist(addr_list,
+                                    &or_options->OutboundBindAddressIPv4_);
+    policies_copy_addr_to_smartlist(addr_list,
+                                    &or_options->OutboundBindAddressIPv6_);
+  }
+}
+
 /** Parse <b>ExitPolicy</b> member of <b>or_options</b> into <b>result</b>
  * smartlist.
  * If <b>or_options->IPv6Exit</b> is false, prepend an entry that
@@ -1205,11 +1352,13 @@ policies_parse_exit_policy(config_line_t *cfg, smartlist_t **dest,
  *  - prepend an entry that rejects all destinations in all netblocks reserved
  *    for private use.
  *  - if local_address is non-zero, treat it as a host-order IPv4 address, and
- *    prepend an entry that rejects it as a destination.
- *  - if ipv6_local_address is non-NULL, prepend an entry that rejects it as a
- *    destination.
- *  - if reject_interface_addresses is true, prepend entries that reject each
- *    public IPv4 and IPv6 address of each interface on this machine.
+ *    add it to the list of configured addresses.
+ *  - if ipv6_local_address is non-NULL, and not the null tor_addr_t, add it
+ *    to the list of configured addresses.
+ *  - if or_options->OutboundBindAddressIPv4_ is not the null tor_addr_t, add
+ *    it to the list of configured addresses.
+ *  - if or_options->OutboundBindAddressIPv6_ is not the null tor_addr_t, add
+ *    it to the list of configured addresses.
  *
  * If <b>or_options->BridgeRelay</b> is false, append entries of default
  * Tor exit policy into <b>result</b> smartlist.
@@ -1220,18 +1369,23 @@ policies_parse_exit_policy(config_line_t *cfg, smartlist_t **dest,
 int
 policies_parse_exit_policy_from_options(const or_options_t *or_options,
                                         uint32_t local_address,
-                                        tor_addr_t *ipv6_local_address,
-                                        int reject_interface_addresses,
+                                        const tor_addr_t *ipv6_local_address,
                                         smartlist_t **result)
 {
   exit_policy_parser_cfg_t parser_cfg = 0;
+  smartlist_t *configured_addresses = NULL;
+  int rv = 0;
 
+  /* Short-circuit for non-exit relays */
   if (or_options->ExitRelay == 0) {
     append_exit_policy_string(result, "reject *4:*");
     append_exit_policy_string(result, "reject *6:*");
     return 0;
   }
 
+  configured_addresses = smartlist_new();
+
+  /* Configure the parser */
   if (or_options->IPv6Exit) {
     parser_cfg |= EXIT_POLICY_IPV6_ENABLED;
   }
@@ -1244,10 +1398,19 @@ policies_parse_exit_policy_from_options(const or_options_t *or_options,
     parser_cfg |= EXIT_POLICY_ADD_DEFAULT;
   }
 
-  return policies_parse_exit_policy(or_options->ExitPolicy,result,
-                                    parser_cfg,local_address,
-                                    ipv6_local_address,
-                                    reject_interface_addresses);
+  /* Copy the configured addresses into the tor_addr_t* list */
+  policies_copy_ipv4h_to_smartlist(configured_addresses, local_address);
+  policies_copy_addr_to_smartlist(configured_addresses, ipv6_local_address);
+  policies_copy_outbound_addresses_to_smartlist(configured_addresses,
+                                                or_options);
+
+  rv = policies_parse_exit_policy(or_options->ExitPolicy, result, parser_cfg,
+                                  configured_addresses);
+
+  SMARTLIST_FOREACH(configured_addresses, tor_addr_t *, a, tor_free(a));
+  smartlist_free(configured_addresses);
+
+  return rv;
 }
 
 /** Add "reject *:*" to the end of the policy in *<b>dest</b>, allocating
@@ -1355,7 +1518,7 @@ policy_is_reject_star(const smartlist_t *policy, sa_family_t family)
 /** Write a single address policy to the buf_len byte buffer at buf.  Return
  * the number of characters written, or -1 on failure. */
 int
-policy_write_item(char *buf, size_t buflen, addr_policy_t *policy,
+policy_write_item(char *buf, size_t buflen, const addr_policy_t *policy,
                   int format_for_desc)
 {
   size_t written = 0;
@@ -1391,9 +1554,9 @@ policy_write_item(char *buf, size_t buflen, addr_policy_t *policy,
   if (result < 0)
     return -1;
   written += strlen(buf);
-  /* If the maskbits is 32 we don't need to give it.  If the mask is 0,
-   * we already wrote "*". */
-  if (policy->maskbits < 32 && policy->maskbits > 0) {
+  /* If the maskbits is 32 (IPv4) or 128 (IPv6) we don't need to give it.  If
+     the mask is 0, we already wrote "*". */
+  if (policy->maskbits < (is_ip6?128:32) && policy->maskbits > 0) {
     if (tor_snprintf(buf+written, buflen-written, "/%d", policy->maskbits)<0)
       return -1;
     written += strlen(buf+written);
@@ -1873,7 +2036,7 @@ compare_tor_addr_to_short_policy(const tor_addr_t *addr, uint16_t port,
    * allows exit enclaving. Trying it anyway would open up a cool attack
    * where the node refuses due to exitpolicy, the client reacts in
    * surprise by rewriting the node's exitpolicy to reject *:*, and then
-   * a bad guy targets users by causing them to attempt such connections
+   * an adversary targets users by causing them to attempt such connections
    * to 98% of the exits.
    *
    * Once microdescriptors can handle addresses in special cases (e.g. if
@@ -1934,6 +2097,53 @@ compare_tor_addr_to_node_policy(const tor_addr_t *addr, uint16_t port,
   }
 }
 
+/**
+ * Given <b>policy_list</b>, a list of addr_policy_t, produce a string
+ * representation of the list.
+ * If <b>include_ipv4</b> is true, include IPv4 entries.
+ * If <b>include_ipv6</b> is true, include IPv6 entries.
+ */
+char *
+policy_dump_to_string(const smartlist_t *policy_list,
+                      int include_ipv4,
+                      int include_ipv6)
+{
+  smartlist_t *policy_string_list;
+  char *policy_string = NULL;
+
+  policy_string_list = smartlist_new();
+
+  SMARTLIST_FOREACH_BEGIN(policy_list, addr_policy_t *, tmpe) {
+    char *pbuf;
+    int bytes_written_to_pbuf;
+    if ((tor_addr_family(&tmpe->addr) == AF_INET6) && (!include_ipv6)) {
+      continue; /* Don't include IPv6 parts of address policy */
+    }
+    if ((tor_addr_family(&tmpe->addr) == AF_INET) && (!include_ipv4)) {
+      continue; /* Don't include IPv4 parts of address policy */
+    }
+
+    pbuf = tor_malloc(POLICY_BUF_LEN);
+    bytes_written_to_pbuf = policy_write_item(pbuf,POLICY_BUF_LEN, tmpe, 1);
+
+    if (bytes_written_to_pbuf < 0) {
+      log_warn(LD_BUG, "policy_dump_to_string ran out of room!");
+      tor_free(pbuf);
+      goto done;
+    }
+
+    smartlist_add(policy_string_list,pbuf);
+  } SMARTLIST_FOREACH_END(tmpe);
+
+  policy_string = smartlist_join_strings(policy_string_list, "\n", 0, NULL);
+
+ done:
+  SMARTLIST_FOREACH(policy_string_list, char *, str, tor_free(str));
+  smartlist_free(policy_string_list);
+
+  return policy_string;
+}
+
 /** Implementation for GETINFO control command: knows the answer for questions
  * about "exit-policy/..." */
 int
@@ -1945,6 +2155,57 @@ getinfo_helper_policies(control_connection_t *conn,
   (void) errmsg;
   if (!strcmp(question, "exit-policy/default")) {
     *answer = tor_strdup(DEFAULT_EXIT_POLICY);
+  } else if (!strcmp(question, "exit-policy/reject-private/default")) {
+    smartlist_t *private_policy_strings;
+    const char **priv = private_nets;
+
+    private_policy_strings = smartlist_new();
+
+    while (*priv != NULL) {
+      /* IPv6 addresses are in "[]" and contain ":",
+       * IPv4 addresses are not in "[]" and contain "." */
+      smartlist_add_asprintf(private_policy_strings, "reject %s:*", *priv);
+      priv++;
+    }
+
+    *answer = smartlist_join_strings(private_policy_strings,
+                                     ",", 0, NULL);
+
+    SMARTLIST_FOREACH(private_policy_strings, char *, str, tor_free(str));
+    smartlist_free(private_policy_strings);
+  } else if (!strcmp(question, "exit-policy/reject-private/relay")) {
+    const or_options_t *options = get_options();
+    const routerinfo_t *me = router_get_my_routerinfo();
+
+    if (!me) {
+      *errmsg = "router_get_my_routerinfo returned NULL";
+      return -1;
+    }
+
+    if (!options->ExitPolicyRejectPrivate) {
+      *answer = tor_strdup("");
+      return 0;
+    }
+
+    smartlist_t *private_policy_list = smartlist_new();
+    smartlist_t *configured_addresses = smartlist_new();
+
+    /* Copy the configured addresses into the tor_addr_t* list */
+    policies_copy_ipv4h_to_smartlist(configured_addresses, me->addr);
+    policies_copy_addr_to_smartlist(configured_addresses, &me->ipv6_addr);
+    policies_copy_outbound_addresses_to_smartlist(configured_addresses,
+                                                  options);
+
+    policies_parse_exit_policy_reject_private(
+                                            &private_policy_list,
+                                            options->IPv6Exit,
+                                            configured_addresses,
+                                            1, 1);
+    *answer = policy_dump_to_string(private_policy_list, 1, 1);
+
+    addr_policy_list_free(private_policy_list);
+    SMARTLIST_FOREACH(configured_addresses, tor_addr_t *, a, tor_free(a));
+    smartlist_free(configured_addresses);
   } else if (!strcmpstart(question, "exit-policy/")) {
     const routerinfo_t *me = router_get_my_routerinfo();
 
diff --git a/src/or/policies.h b/src/or/policies.h
index f200d7b..007f494 100644
--- a/src/or/policies.h
+++ b/src/or/policies.h
@@ -44,30 +44,38 @@ addr_policy_t *addr_policy_get_canonical_entry(addr_policy_t *ent);
 int cmp_addr_policies(smartlist_t *a, smartlist_t *b);
 MOCK_DECL(addr_policy_result_t, compare_tor_addr_to_addr_policy,
     (const tor_addr_t *addr, uint16_t port, const smartlist_t *policy));
-
 addr_policy_result_t compare_tor_addr_to_node_policy(const tor_addr_t *addr,
                               uint16_t port, const node_t *node);
 
-int policies_parse_exit_policy_from_options(const or_options_t *or_options,
-                                            uint32_t local_address,
-                                            tor_addr_t *ipv6_local_address,
-                                            int reject_interface_addresses,
-                                            smartlist_t **result);
+int policies_parse_exit_policy_from_options(
+                                          const or_options_t *or_options,
+                                          uint32_t local_address,
+                                          const tor_addr_t *ipv6_local_address,
+                                          smartlist_t **result);
 int policies_parse_exit_policy(config_line_t *cfg, smartlist_t **dest,
                                exit_policy_parser_cfg_t options,
-                               uint32_t local_address,
-                               tor_addr_t *ipv6_local_address,
-                               int reject_interface_addresses);
+                               const smartlist_t *configured_addresses);
+void policies_parse_exit_policy_reject_private(
+                                      smartlist_t **dest,
+                                      int ipv6_exit,
+                                      const smartlist_t *configured_addresses,
+                                      int reject_interface_addresses,
+                                      int reject_configured_port_addresses);
 void policies_exit_policy_append_reject_star(smartlist_t **dest);
 void addr_policy_append_reject_addr(smartlist_t **dest,
                                     const tor_addr_t *addr);
+void addr_policy_append_reject_addr_list(smartlist_t **dest,
+                                         const smartlist_t *addrs);
 void policies_set_node_exitpolicy_to_reject_all(node_t *exitrouter);
 int exit_policy_is_general_exit(smartlist_t *policy);
 int policy_is_reject_star(const smartlist_t *policy, sa_family_t family);
+char * policy_dump_to_string(const smartlist_t *policy_list,
+                             int include_ipv4,
+                             int include_ipv6);
 int getinfo_helper_policies(control_connection_t *conn,
                             const char *question, char **answer,
                             const char **errmsg);
-int policy_write_item(char *buf, size_t buflen, addr_policy_t *item,
+int policy_write_item(char *buf, size_t buflen, const addr_policy_t *item,
                       int format_for_desc);
 
 void addr_policy_list_free(smartlist_t *p);
@@ -84,5 +92,9 @@ addr_policy_result_t compare_tor_addr_to_short_policy(
                           const tor_addr_t *addr, uint16_t port,
                           const short_policy_t *policy);
 
+#ifdef POLICIES_PRIVATE
+STATIC void append_exit_policy_string(smartlist_t **policy, const char *more);
+#endif
+
 #endif
 
diff --git a/src/or/relay.c b/src/or/relay.c
index eddad6a..9d44428 100644
--- a/src/or/relay.c
+++ b/src/or/relay.c
@@ -148,20 +148,15 @@ relay_digest_matches(crypto_digest_t *digest, cell_t *cell)
  *
  * If <b>encrypt_mode</b> is 1 then encrypt, else decrypt.
  *
- * Return -1 if the crypto fails, else return 0.
+ * Returns 0.
  */
 static int
 relay_crypt_one_payload(crypto_cipher_t *cipher, uint8_t *in,
                         int encrypt_mode)
 {
-  int r;
   (void)encrypt_mode;
-  r = crypto_cipher_crypt_inplace(cipher, (char*) in, CELL_PAYLOAD_SIZE);
+  crypto_cipher_crypt_inplace(cipher, (char*) in, CELL_PAYLOAD_SIZE);
 
-  if (r) {
-    log_warn(LD_BUG,"Error during relay encryption");
-    return -1;
-  }
   return 0;
 }
 
@@ -833,7 +828,7 @@ connection_ap_process_end_not_open(
             }
           }
         }
-        /* check if he *ought* to have allowed it */
+        /* check if the exit *ought* to have allowed it */
 
         adjust_exit_policy_from_exitpolicy_failure(circ,
                                                    conn,
@@ -1304,6 +1299,7 @@ connection_edge_process_relay_cell_not_open(
              "Got 'connected' while not in state connect_wait. Dropping.");
       return 0;
     }
+    CONNECTION_AP_EXPECT_NONPENDING(entry_conn);
     conn->base_.state = AP_CONN_STATE_OPEN;
     log_info(LD_APP,"'connected' received for circid %u streamid %d "
              "after %d seconds.",
@@ -2255,7 +2251,7 @@ circuit_consider_sending_sendme(circuit_t *circ, crypt_path_t *layer_hint)
 static size_t total_cells_allocated = 0;
 
 /** Release storage held by <b>cell</b>. */
-static INLINE void
+static inline void
 packed_cell_free_unchecked(packed_cell_t *cell)
 {
   --total_cells_allocated;
@@ -2299,7 +2295,7 @@ dump_cell_pool_usage(int severity)
 }
 
 /** Allocate a new copy of packed <b>cell</b>. */
-static INLINE packed_cell_t *
+static inline packed_cell_t *
 packed_cell_copy(const cell_t *cell, int wide_circ_ids)
 {
   packed_cell_t *c = packed_cell_new();
diff --git a/src/or/rendcache.c b/src/or/rendcache.c
index d4bdd68..c69671e 100644
--- a/src/or/rendcache.c
+++ b/src/or/rendcache.c
@@ -3,9 +3,10 @@
 
 /**
  * \file rendcache.c
- * \brief Hidden service desriptor cache.
+ * \brief Hidden service descriptor cache.
  **/
 
+#define RENDCACHE_PRIVATE
 #include "rendcache.h"
 
 #include "config.h"
@@ -15,11 +16,14 @@
 
 /** Map from service id (as generated by rend_get_service_id) to
  * rend_cache_entry_t. */
-static strmap_t *rend_cache = NULL;
+STATIC strmap_t *rend_cache = NULL;
+
+/** Map from service id to rend_cache_entry_t; only for hidden services. */
+static strmap_t *rend_cache_local_service = NULL;
 
 /** Map from descriptor id to rend_cache_entry_t; only for hidden service
  * directories. */
-static digestmap_t *rend_cache_v2_dir = NULL;
+STATIC digestmap_t *rend_cache_v2_dir = NULL;
 
 /** (Client side only) Map from service id to rend_cache_failure_t. This
  * cache is used to track intro point(IP) failures so we know when to keep
@@ -46,10 +50,10 @@ static digestmap_t *rend_cache_v2_dir = NULL;
  * This scheme allows us to not realy on the descriptor's timestamp (which
  * is rounded down to the hour) to know if we have a newer descriptor. We
  * only rely on the usability of intro points from an internal state. */
-static strmap_t *rend_cache_failure = NULL;
+STATIC strmap_t *rend_cache_failure = NULL;
 
 /** DOCDOC */
-static size_t rend_cache_total_allocation = 0;
+STATIC size_t rend_cache_total_allocation = 0;
 
 /** Initializes the service descriptor cache.
 */
@@ -58,11 +62,12 @@ rend_cache_init(void)
 {
   rend_cache = strmap_new();
   rend_cache_v2_dir = digestmap_new();
+  rend_cache_local_service = strmap_new();
   rend_cache_failure = strmap_new();
 }
 
 /** Return the approximate number of bytes needed to hold <b>e</b>. */
-static size_t
+STATIC size_t
 rend_cache_entry_allocation(const rend_cache_entry_t *e)
 {
   if (!e)
@@ -80,7 +85,7 @@ rend_cache_get_total_allocation(void)
 }
 
 /** Decrement the total bytes attributed to the rendezvous cache by n. */
-static void
+STATIC void
 rend_cache_decrement_allocation(size_t n)
 {
   static int have_underflowed = 0;
@@ -97,7 +102,7 @@ rend_cache_decrement_allocation(size_t n)
 }
 
 /** Increase the total bytes attributed to the rendezvous cache by n. */
-static void
+STATIC void
 rend_cache_increment_allocation(size_t n)
 {
   static int have_overflowed = 0;
@@ -113,7 +118,7 @@ rend_cache_increment_allocation(size_t n)
 }
 
 /** Helper: free a rend cache failure intro object. */
-static void
+STATIC void
 rend_cache_failure_intro_entry_free(rend_cache_failure_intro_t *entry)
 {
   if (entry == NULL) {
@@ -130,7 +135,7 @@ rend_cache_failure_intro_entry_free_(void *entry)
 
 /** Allocate a rend cache failure intro object and return it. <b>failure</b>
  * is set into the object. This function can not fail. */
-static rend_cache_failure_intro_t *
+STATIC rend_cache_failure_intro_t *
 rend_cache_failure_intro_entry_new(rend_intro_point_failure_t failure)
 {
   rend_cache_failure_intro_t *entry = tor_malloc(sizeof(*entry));
@@ -140,7 +145,7 @@ rend_cache_failure_intro_entry_new(rend_intro_point_failure_t failure)
 }
 
 /** Helper: free a rend cache failure object. */
-static void
+STATIC void
 rend_cache_failure_entry_free(rend_cache_failure_t *entry)
 {
   if (entry == NULL) {
@@ -156,7 +161,7 @@ rend_cache_failure_entry_free(rend_cache_failure_t *entry)
 
 /** Helper: deallocate a rend_cache_failure_t. (Used with strmap_free(),
  * which requires a function pointer whose argument is void*). */
-static void
+STATIC void
 rend_cache_failure_entry_free_(void *entry)
 {
   rend_cache_failure_entry_free(entry);
@@ -164,7 +169,7 @@ rend_cache_failure_entry_free_(void *entry)
 
 /** Allocate a rend cache failure object and return it. This function can
  * not fail. */
-static rend_cache_failure_t *
+STATIC rend_cache_failure_t *
 rend_cache_failure_entry_new(void)
 {
   rend_cache_failure_t *entry = tor_malloc(sizeof(*entry));
@@ -174,7 +179,7 @@ rend_cache_failure_entry_new(void)
 
 /** Remove failure cache entry for the service ID in the given descriptor
  * <b>desc</b>. */
-static void
+STATIC void
 rend_cache_failure_remove(rend_service_descriptor_t *desc)
 {
   char service_id[REND_SERVICE_ID_LEN_BASE32 + 1];
@@ -194,7 +199,7 @@ rend_cache_failure_remove(rend_service_descriptor_t *desc)
 }
 
 /** Helper: free storage held by a single service descriptor cache entry. */
-static void
+STATIC void
 rend_cache_entry_free(rend_cache_entry_t *e)
 {
   if (!e)
@@ -222,9 +227,11 @@ rend_cache_free_all(void)
 {
   strmap_free(rend_cache, rend_cache_entry_free_);
   digestmap_free(rend_cache_v2_dir, rend_cache_entry_free_);
+  strmap_free(rend_cache_local_service, rend_cache_entry_free_);
   strmap_free(rend_cache_failure, rend_cache_failure_entry_free_);
   rend_cache = NULL;
   rend_cache_v2_dir = NULL;
+  rend_cache_local_service = NULL;
   rend_cache_failure = NULL;
   rend_cache_total_allocation = 0;
 }
@@ -258,24 +265,33 @@ rend_cache_failure_clean(time_t now)
   } STRMAP_FOREACH_END;
 }
 
-/** Removes all old entries from the service descriptor cache.
+/** Removes all old entries from the client or service descriptor cache.
 */
 void
-rend_cache_clean(time_t now)
+rend_cache_clean(time_t now, rend_cache_type_t cache_type)
 {
   strmap_iter_t *iter;
   const char *key;
   void *val;
   rend_cache_entry_t *ent;
   time_t cutoff = now - REND_CACHE_MAX_AGE - REND_CACHE_MAX_SKEW;
-  for (iter = strmap_iter_init(rend_cache); !strmap_iter_done(iter); ) {
+  strmap_t *cache = NULL;
+
+  if (cache_type == REND_CACHE_TYPE_CLIENT) {
+    cache = rend_cache;
+  } else if (cache_type == REND_CACHE_TYPE_SERVICE)  {
+    cache = rend_cache_local_service;
+  }
+  tor_assert(cache);
+
+  for (iter = strmap_iter_init(cache); !strmap_iter_done(iter); ) {
     strmap_iter_get(iter, &key, &val);
     ent = (rend_cache_entry_t*)val;
     if (ent->parsed->timestamp < cutoff) {
-      iter = strmap_iter_next_rmv(rend_cache, iter);
+      iter = strmap_iter_next_rmv(cache, iter);
       rend_cache_entry_free(ent);
     } else {
-      iter = strmap_iter_next(rend_cache, iter);
+      iter = strmap_iter_next(cache, iter);
     }
   }
 }
@@ -305,10 +321,10 @@ rend_cache_failure_purge(void)
 }
 
 /** Lookup the rend failure cache using a relay identity digest in
- * <b>identity</b> and service ID <b>service_id</b>. If found, the intro
- * failure is set in <b>intro_entry</b> else it stays untouched. Return 1
- * iff found else 0. */
-static int
+ * <b>identity</b> which has DIGEST_LEN bytes and service ID <b>service_id</b>
+ * which is a null-terminated string. If found, the intro failure is set in
+ * <b>intro_entry</b> else it stays untouched. Return 1 iff found else 0. */
+STATIC int
 cache_failure_intro_lookup(const uint8_t *identity, const char *service_id,
                            rend_cache_failure_intro_t **intro_entry)
 {
@@ -352,7 +368,7 @@ cache_failure_intro_dup(const rend_cache_failure_intro_t *entry)
 /** Add an intro point failure to the failure cache using the relay
  * <b>identity</b> and service ID <b>service_id</b>. Record the
  * <b>failure</b> in that object. */
-static void
+STATIC void
 cache_failure_intro_add(const uint8_t *identity, const char *service_id,
                         rend_intro_point_failure_t failure)
 {
@@ -379,7 +395,7 @@ cache_failure_intro_add(const uint8_t *identity, const char *service_id,
  * descriptor and kept into the failure cache. Then, each intro points that
  * are NOT in the descriptor but in the failure cache for the given
  * <b>service_id</b> are removed from the failure cache. */
-static void
+STATIC void
 validate_intro_point_failure(const rend_service_descriptor_t *desc,
                              const char *service_id)
 {
@@ -535,6 +551,42 @@ rend_cache_lookup_entry(const char *query, int version, rend_cache_entry_t **e)
   return ret;
 }
 
+/*
+ * Lookup the v2 service descriptor with the service ID <b>query</b> in the
+ * local service descriptor cache. Return 0 if found and if <b>e</b> is
+ * non NULL, set it with the entry found. Else, a negative value is returned
+ * and <b>e</b> is untouched.
+ * -EINVAL means that <b>query</b> is not a valid service id.
+ * -ENOENT means that no entry in the cache was found. */
+int
+rend_cache_lookup_v2_desc_as_service(const char *query, rend_cache_entry_t **e)
+{
+  int ret = 0;
+  rend_cache_entry_t *entry = NULL;
+
+  tor_assert(rend_cache_local_service);
+  tor_assert(query);
+
+  if (!rend_valid_service_id(query)) {
+    ret = -EINVAL;
+    goto end;
+  }
+
+  /* Lookup descriptor and return. */
+  entry = strmap_get_lc(rend_cache_local_service, query);
+  if (!entry) {
+    ret = -ENOENT;
+    goto end;
+  }
+
+  if (e) {
+    *e = entry;
+  }
+
+ end:
+  return ret;
+}
+
 /** Lookup the v2 service descriptor with base32-encoded <b>desc_id</b> and
  * copy the pointer to it to *<b>desc</b>.  Return 1 on success, 0 on
  * well-formed-but-not-found, and -1 on failure.
@@ -660,7 +712,6 @@ rend_cache_store_v2_desc_as_dir(const char *desc)
     log_info(LD_REND, "Successfully stored service descriptor with desc ID "
              "'%s' and len %d.",
              safe_str(desc_id_base32), (int)encoded_size);
-
     /* Statistics: Note down this potentially new HS. */
     if (options->HiddenServiceStatistics) {
       rep_hist_stored_maybe_new_hs(e->parsed->pk);
@@ -687,6 +738,80 @@ rend_cache_store_v2_desc_as_dir(const char *desc)
   return RCS_OKAY;
 }
 
+/** Parse the v2 service descriptor in <b>desc</b> and store it to the
+* local service rend cache. Don't attempt to decrypt the included list of
+* introduction points.
+*
+* If we have a newer descriptor with the same ID, ignore this one.
+* If we have an older descriptor with the same ID, replace it.
+*
+* Return an appropriate rend_cache_store_status_t.
+*/
+rend_cache_store_status_t
+rend_cache_store_v2_desc_as_service(const char *desc)
+{
+  rend_service_descriptor_t *parsed = NULL;
+  char desc_id[DIGEST_LEN];
+  char *intro_content = NULL;
+  size_t intro_size;
+  size_t encoded_size;
+  const char *next_desc;
+  char service_id[REND_SERVICE_ID_LEN_BASE32+1];
+  rend_cache_entry_t *e;
+  rend_cache_store_status_t retval = RCS_BADDESC;
+  tor_assert(rend_cache_local_service);
+  tor_assert(desc);
+
+  /* Parse the descriptor. */
+  if (rend_parse_v2_service_descriptor(&parsed, desc_id, &intro_content,
+                                       &intro_size, &encoded_size,
+                                       &next_desc, desc, 0) < 0) {
+    log_warn(LD_REND, "Could not parse descriptor.");
+    goto err;
+  }
+  /* Compute service ID from public key. */
+  if (rend_get_service_id(parsed->pk, service_id)<0) {
+    log_warn(LD_REND, "Couldn't compute service ID.");
+    goto err;
+  }
+
+  /* Do we already have a newer descriptor? Allow new descriptors with a
+     rounded timestamp equal to or newer than the current descriptor */
+  e = (rend_cache_entry_t*) strmap_get_lc(rend_cache_local_service,
+                                          service_id);
+  if (e && e->parsed->timestamp > parsed->timestamp) {
+    log_info(LD_REND, "We already have a newer service descriptor for "
+             "service ID %s.", safe_str_client(service_id));
+    goto okay;
+  }
+  /* We don't care about the introduction points. */
+  tor_free(intro_content);
+  if (!e) {
+    e = tor_malloc_zero(sizeof(rend_cache_entry_t));
+    strmap_set_lc(rend_cache_local_service, service_id, e);
+  } else {
+    rend_cache_decrement_allocation(rend_cache_entry_allocation(e));
+    rend_service_descriptor_free(e->parsed);
+    tor_free(e->desc);
+  }
+  e->parsed = parsed;
+  e->desc = tor_malloc_zero(encoded_size + 1);
+  strlcpy(e->desc, desc, encoded_size + 1);
+  e->len = encoded_size;
+  rend_cache_increment_allocation(rend_cache_entry_allocation(e));
+  log_debug(LD_REND,"Successfully stored rend desc '%s', len %d.",
+            safe_str_client(service_id), (int)encoded_size);
+  return RCS_OKAY;
+
+ okay:
+  retval = RCS_OKAY;
+
+ err:
+  rend_service_descriptor_free(parsed);
+  tor_free(intro_content);
+  return retval;
+}
+
 /** Parse the v2 service descriptor in <b>desc</b>, decrypt the included list
  * of introduction points with <b>descriptor_cookie</b> (which may also be
  * <b>NULL</b> if decryption is not necessary), and store the descriptor to
diff --git a/src/or/rendcache.h b/src/or/rendcache.h
index 0512058..decb040 100644
--- a/src/or/rendcache.h
+++ b/src/or/rendcache.h
@@ -48,14 +48,21 @@ typedef struct rend_cache_failure_t {
   digestmap_t *intro_failures;
 } rend_cache_failure_t;
 
+typedef enum {
+  REND_CACHE_TYPE_CLIENT  = 1,
+  REND_CACHE_TYPE_SERVICE = 2,
+} rend_cache_type_t;
+
 void rend_cache_init(void);
-void rend_cache_clean(time_t now);
+void rend_cache_clean(time_t now, rend_cache_type_t cache_type);
 void rend_cache_failure_clean(time_t now);
 void rend_cache_clean_v2_descs_as_dir(time_t now, size_t min_to_remove);
 void rend_cache_purge(void);
 void rend_cache_free_all(void);
 int rend_cache_lookup_entry(const char *query, int version,
                             rend_cache_entry_t **entry_out);
+int rend_cache_lookup_v2_desc_as_service(const char *query,
+                                         rend_cache_entry_t **entry_out);
 int rend_cache_lookup_v2_desc_as_dir(const char *query, const char **desc);
 /** Return value from rend_cache_store_v2_desc_as_{dir,client}. */
 typedef enum {
@@ -65,6 +72,8 @@ typedef enum {
 } rend_cache_store_status_t;
 
 rend_cache_store_status_t rend_cache_store_v2_desc_as_dir(const char *desc);
+rend_cache_store_status_t rend_cache_store_v2_desc_as_service(
+                                                const char *desc);
 rend_cache_store_status_t rend_cache_store_v2_desc_as_client(const char *desc,
                                                 const char *desc_id_base32,
                                                 const rend_data_t *rend_query,
@@ -76,5 +85,31 @@ void rend_cache_intro_failure_note(rend_intro_point_failure_t failure,
                                    const char *service_id);
 void rend_cache_failure_purge(void);
 
+#ifdef RENDCACHE_PRIVATE
+
+STATIC size_t rend_cache_entry_allocation(const rend_cache_entry_t *e);
+STATIC void rend_cache_entry_free(rend_cache_entry_t *e);
+STATIC void rend_cache_failure_intro_entry_free(rend_cache_failure_intro_t
+                                                *entry);
+STATIC void rend_cache_failure_entry_free(rend_cache_failure_t *entry);
+STATIC int cache_failure_intro_lookup(const uint8_t *identity,
+                                      const char *service_id,
+                                      rend_cache_failure_intro_t
+                                      **intro_entry);
+STATIC void rend_cache_decrement_allocation(size_t n);
+STATIC void rend_cache_increment_allocation(size_t n);
+STATIC rend_cache_failure_intro_t *rend_cache_failure_intro_entry_new(
+                                      rend_intro_point_failure_t failure);
+STATIC rend_cache_failure_t *rend_cache_failure_entry_new(void);
+STATIC void rend_cache_failure_remove(rend_service_descriptor_t *desc);
+STATIC void cache_failure_intro_add(const uint8_t *identity,
+                                    const char *service_id,
+                                    rend_intro_point_failure_t failure);
+STATIC void validate_intro_point_failure(const rend_service_descriptor_t *desc,
+                                        const char *service_id);
+
+STATIC void rend_cache_failure_entry_free_(void *entry);
+#endif
+
 #endif /* TOR_RENDCACHE_H */
 
diff --git a/src/or/rendclient.c b/src/or/rendclient.c
index a39e518..e812a06 100644
--- a/src/or/rendclient.c
+++ b/src/or/rendclient.c
@@ -52,7 +52,7 @@ rend_client_introcirc_has_opened(origin_circuit_t *circ)
   tor_assert(circ->cpath);
 
   log_info(LD_REND,"introcirc is open");
-  connection_ap_attach_pending();
+  connection_ap_attach_pending(1);
 }
 
 /** Send the establish-rendezvous cell along a rendezvous circuit. if
@@ -65,11 +65,7 @@ rend_client_send_establish_rendezvous(origin_circuit_t *circ)
   tor_assert(circ->rend_data);
   log_info(LD_REND, "Sending an ESTABLISH_RENDEZVOUS cell");
 
-  if (crypto_rand(circ->rend_data->rend_cookie, REND_COOKIE_LEN) < 0) {
-    log_warn(LD_BUG, "Internal error: Couldn't produce random cookie.");
-    circuit_mark_for_close(TO_CIRCUIT(circ), END_CIRC_REASON_INTERNAL);
-    return -1;
-  }
+  crypto_rand(circ->rend_data->rend_cookie, REND_COOKIE_LEN);
 
   /* Set timestamp_dirty, because circuit_expire_building expects it,
    * and the rend cookie also means we've used the circ. */
@@ -177,6 +173,7 @@ rend_client_send_introduction(origin_circuit_t *introcirc,
       while ((conn = connection_get_by_type_state_rendquery(CONN_TYPE_AP,
                        AP_CONN_STATE_CIRCUIT_WAIT,
                        introcirc->rend_data->onion_address))) {
+        connection_ap_mark_as_non_pending_circuit(TO_ENTRY_CONN(conn));
         conn->state = AP_CONN_STATE_RENDDESC_WAIT;
       }
     }
@@ -185,7 +182,7 @@ rend_client_send_introduction(origin_circuit_t *introcirc,
     goto cleanup;
   }
 
-  /* first 20 bytes of payload are the hash of Bob's pk */
+  /* first 20 bytes of payload are the hash of the service's pk */
   intro_key = NULL;
   SMARTLIST_FOREACH(entry->parsed->intro_nodes, rend_intro_point_t *,
                     intro, {
@@ -1059,9 +1056,11 @@ rend_client_report_intro_point_failure(extend_info_t *failed_intro,
     rend_client_refetch_v2_renddesc(rend_query);
 
     /* move all pending streams back to renddesc_wait */
+    /* NOTE: We can now do this faster, if we use pending_entry_connections */
     while ((conn = connection_get_by_type_state_rendquery(CONN_TYPE_AP,
                                    AP_CONN_STATE_CIRCUIT_WAIT,
                                    rend_query->onion_address))) {
+      connection_ap_mark_as_non_pending_circuit(TO_ENTRY_CONN(conn));
       conn->state = AP_CONN_STATE_RENDDESC_WAIT;
     }
 
@@ -1097,9 +1096,9 @@ rend_client_rendezvous_acked(origin_circuit_t *circ, const uint8_t *request,
   circ->base_.timestamp_dirty = time(NULL);
 
   /* From a path bias point of view, this circuit is now successfully used.
-   * Waiting any longer opens us up to attacks from Bob. He could induce
-   * Alice to attempt to connect to his hidden service and never reply
-   * to her rend requests */
+   * Waiting any longer opens us up to attacks from malicious hidden services.
+   * They could induce the client to attempt to connect to their hidden
+   * service and never reply to the client's rend requests */
   pathbias_mark_use_success(circ);
 
   /* XXXX This is a pretty brute-force approach. It'd be better to
@@ -1107,11 +1106,11 @@ rend_client_rendezvous_acked(origin_circuit_t *circ, const uint8_t *request,
    * than trying to attach them all. See comments bug 743. */
   /* If we already have the introduction circuit built, make sure we send
    * the INTRODUCE cell _now_ */
-  connection_ap_attach_pending();
+  connection_ap_attach_pending(1);
   return 0;
 }
 
-/** Bob sent us a rendezvous cell; join the circuits. */
+/** The service sent us a rendezvous cell; join the circuits. */
 int
 rend_client_receive_rendezvous(origin_circuit_t *circ, const uint8_t *request,
                                size_t request_len)
@@ -1136,7 +1135,8 @@ rend_client_receive_rendezvous(origin_circuit_t *circ, const uint8_t *request,
 
   log_info(LD_REND,"Got RENDEZVOUS2 cell from hidden service.");
 
-  /* first DH_KEY_LEN bytes are g^y from bob. Finish the dh handshake...*/
+  /* first DH_KEY_LEN bytes are g^y from the service. Finish the dh
+   * handshake...*/
   tor_assert(circ->build_state);
   tor_assert(circ->build_state->pending_final_cpath);
   hop = circ->build_state->pending_final_cpath;
@@ -1165,7 +1165,7 @@ rend_client_receive_rendezvous(origin_circuit_t *circ, const uint8_t *request,
   circuit_change_purpose(TO_CIRCUIT(circ), CIRCUIT_PURPOSE_C_REND_JOINED);
   hop->state = CPATH_STATE_OPEN;
   /* set the windows to default. these are the windows
-   * that alice thinks bob has.
+   * that the client thinks the service has.
    */
   hop->package_window = circuit_initial_package_window();
   hop->deliver_window = CIRCWINDOW_START;
@@ -1226,12 +1226,7 @@ rend_client_desc_trynow(const char *query)
       base_conn->timestamp_lastread = now;
       base_conn->timestamp_lastwritten = now;
 
-      if (connection_ap_handshake_attach_circuit(conn) < 0) {
-        /* it will never work */
-        log_warn(LD_REND,"Rendezvous attempt failed. Closing.");
-        if (!base_conn->marked_for_close)
-          connection_mark_unattached_ap(conn, END_STREAM_REASON_CANT_ATTACH);
-      }
+      connection_ap_mark_as_pending_circuit(conn);
     } else { /* 404, or fetch didn't get that far */
       log_notice(LD_REND,"Closing stream for '%s.onion': hidden service is "
                  "unavailable (try again later).",
diff --git a/src/or/rendcommon.c b/src/or/rendcommon.c
index 22599e9..8c02b67 100644
--- a/src/or/rendcommon.c
+++ b/src/or/rendcommon.c
@@ -11,6 +11,7 @@
 #include "or.h"
 #include "circuitbuild.h"
 #include "config.h"
+#include "control.h"
 #include "rendclient.h"
 #include "rendcommon.h"
 #include "rendmid.h"
@@ -268,11 +269,7 @@ rend_encrypt_v2_intro_points_basic(char **encrypted_out,
   tor_assert(client_cookies && smartlist_len(client_cookies) > 0);
 
   /* Generate session key. */
-  if (crypto_rand(session_key, CIPHER_KEY_LEN) < 0) {
-    log_warn(LD_REND, "Unable to generate random session key to encrypt "
-                      "introduction point string.");
-    goto done;
-  }
+  crypto_rand(session_key, CIPHER_KEY_LEN);
 
   /* Determine length of encrypted introduction points including session
    * keys. */
@@ -334,11 +331,7 @@ rend_encrypt_v2_intro_points_basic(char **encrypted_out,
            REND_BASIC_AUTH_CLIENT_MULTIPLE;
        i < REND_BASIC_AUTH_CLIENT_MULTIPLE - 1; i++) {
     client_part = tor_malloc_zero(REND_BASIC_AUTH_CLIENT_ENTRY_LEN);
-    if (crypto_rand(client_part, REND_BASIC_AUTH_CLIENT_ENTRY_LEN) < 0) {
-      log_warn(LD_REND, "Unable to generate fake client entry.");
-      tor_free(client_part);
-      goto done;
-    }
+    crypto_rand(client_part, REND_BASIC_AUTH_CLIENT_ENTRY_LEN);
     smartlist_add(encrypted_session_keys, client_part);
   }
   /* Sort smartlist and put elements in result in order. */
@@ -461,6 +454,7 @@ rend_encode_v2_descriptors(smartlist_t *descs_out,
                            smartlist_t *client_cookies)
 {
   char service_id[DIGEST_LEN];
+  char service_id_base32[REND_SERVICE_ID_LEN_BASE32+1];
   uint32_t time_period;
   char *ipos_base64 = NULL, *ipos = NULL, *ipos_encrypted = NULL,
        *descriptor_cookie = NULL;
@@ -655,6 +649,11 @@ rend_encode_v2_descriptors(smartlist_t *descs_out,
       goto err;
     }
     smartlist_add(descs_out, enc);
+    /* Add the uploaded descriptor to the local service's descriptor cache */
+    rend_cache_store_v2_desc_as_service(enc->desc_str);
+    base32_encode(service_id_base32, sizeof(service_id_base32),
+          service_id, REND_SERVICE_ID_LEN);
+    control_event_hs_descriptor_created(service_id_base32, desc_id_base32, k);
   }
 
   log_info(LD_REND, "Successfully encoded a v2 descriptor and "
diff --git a/src/or/rendcommon.h b/src/or/rendcommon.h
index 3b2f86d..04e34af 100644
--- a/src/or/rendcommon.h
+++ b/src/or/rendcommon.h
@@ -19,7 +19,7 @@ typedef enum rend_intro_point_failure_t {
 } rend_intro_point_failure_t;
 
 /** Free all storage associated with <b>data</b> */
-static INLINE void
+static inline void
 rend_data_free(rend_data_t *data)
 {
   if (!data) {
diff --git a/src/or/rendmid.c b/src/or/rendmid.c
index 2451acb..cbfbcbe 100644
--- a/src/or/rendmid.c
+++ b/src/or/rendmid.c
@@ -80,7 +80,7 @@ rend_mid_establish_intro(or_circuit_t *circ, const uint8_t *request,
     goto err;
   }
 
-  /* The request is valid.  First, compute the hash of Bob's PK.*/
+  /* The request is valid.  First, compute the hash of the service's PK.*/
   if (crypto_pk_get_digest(pk, pk_digest)<0) {
     log_warn(LD_BUG, "Internal error: couldn't hash public key.");
     goto err;
@@ -178,7 +178,8 @@ rend_mid_introduce(or_circuit_t *circ, const uint8_t *request,
   base32_encode(serviceid, REND_SERVICE_ID_LEN_BASE32+1,
                 (char*)request, REND_SERVICE_ID_LEN);
 
-  /* The first 20 bytes are all we look at: they have a hash of Bob's PK. */
+  /* The first 20 bytes are all we look at: they have a hash of the service's
+   * PK. */
   intro_circ = circuit_get_intro_point((const uint8_t*)request);
   if (!intro_circ) {
     log_info(LD_REND,
@@ -202,7 +203,7 @@ rend_mid_introduce(or_circuit_t *circ, const uint8_t *request,
              "Unable to send INTRODUCE2 cell to Tor client.");
     goto err;
   }
-  /* And send an ack down Alice's circuit.  Empty body means succeeded. */
+  /* And send an ack down the client's circuit.  Empty body means succeeded. */
   if (relay_send_command_from_edge(0,TO_CIRCUIT(circ),
                                    RELAY_COMMAND_INTRODUCE_ACK,
                                    NULL,0,NULL)) {
@@ -337,7 +338,7 @@ rend_mid_rendezvous(or_circuit_t *circ, const uint8_t *request,
     circ->circuit_carries_hs_traffic_stats = 1;
   }
 
-  /* Send the RENDEZVOUS2 cell to Alice. */
+  /* Send the RENDEZVOUS2 cell to the client. */
   if (relay_send_command_from_edge(0, TO_CIRCUIT(rend_circ),
                                    RELAY_COMMAND_RENDEZVOUS2,
                                    (char*)(request+REND_COOKIE_LEN),
diff --git a/src/or/rendservice.c b/src/or/rendservice.c
index 8ba5327..7471c62 100644
--- a/src/or/rendservice.c
+++ b/src/or/rendservice.c
@@ -1676,7 +1676,7 @@ rend_service_receive_introduction(origin_circuit_t *circuit,
   /* help predict this next time */
   rep_hist_note_used_internal(now, circ_needs_uptime, 1);
 
-  /* Launch a circuit to alice's chosen rendezvous point.
+  /* Launch a circuit to the client's chosen rendezvous point.
    */
   for (i=0;i<MAX_REND_FAILURES;i++) {
     int flags = CIRCLAUNCH_NEED_CAPACITY | CIRCLAUNCH_IS_INTERNAL;
@@ -2970,7 +2970,7 @@ rend_service_rendezvous_has_opened(origin_circuit_t *circuit)
   /* Append the cpath entry. */
   hop->state = CPATH_STATE_OPEN;
   /* set the windows to default. these are the windows
-   * that bob thinks alice has.
+   * that the service thinks the client has.
    */
   hop->package_window = circuit_initial_package_window();
   hop->deliver_window = CIRCWINDOW_START;
@@ -3038,7 +3038,8 @@ find_expiring_intro_point(rend_service_t *service, origin_circuit_t *circ)
   tor_assert(TO_CIRCUIT(circ)->purpose == CIRCUIT_PURPOSE_S_ESTABLISH_INTRO ||
              TO_CIRCUIT(circ)->purpose == CIRCUIT_PURPOSE_S_INTRO);
 
-  SMARTLIST_FOREACH(service->intro_nodes, rend_intro_point_t *, intro_point,
+  SMARTLIST_FOREACH(service->expiring_nodes, rend_intro_point_t *,
+                    intro_point,
     if (crypto_pk_eq_keys(intro_point->intro_key, circ->intro_key)) {
       return intro_point;
   });
@@ -3202,39 +3203,72 @@ upload_service_descriptor(rend_service_t *service)
 
   rendpostperiod = get_options()->RendPostPeriod;
 
-  /* Upload descriptor? */
-  if (get_options()->PublishHidServDescriptors) {
-    networkstatus_t *c = networkstatus_get_latest_consensus();
-    if (c && smartlist_len(c->routerstatus_list) > 0) {
-      int seconds_valid, i, j, num_descs;
-      smartlist_t *descs = smartlist_new();
-      smartlist_t *client_cookies = smartlist_new();
-      /* Either upload a single descriptor (including replicas) or one
-       * descriptor for each authorized client in case of authorization
-       * type 'stealth'. */
-      num_descs = service->auth_type == REND_STEALTH_AUTH ?
-                      smartlist_len(service->clients) : 1;
-      for (j = 0; j < num_descs; j++) {
-        crypto_pk_t *client_key = NULL;
-        rend_authorized_client_t *client = NULL;
-        smartlist_clear(client_cookies);
-        switch (service->auth_type) {
-          case REND_NO_AUTH:
-            /* Do nothing here. */
-            break;
-          case REND_BASIC_AUTH:
-            SMARTLIST_FOREACH(service->clients, rend_authorized_client_t *,
-                cl, smartlist_add(client_cookies, cl->descriptor_cookie));
-            break;
-          case REND_STEALTH_AUTH:
-            client = smartlist_get(service->clients, j);
-            client_key = client->client_key;
-            smartlist_add(client_cookies, client->descriptor_cookie);
-            break;
-        }
-        /* Encode the current descriptor. */
+  networkstatus_t *c = networkstatus_get_latest_consensus();
+  if (c && smartlist_len(c->routerstatus_list) > 0) {
+    int seconds_valid, i, j, num_descs;
+    smartlist_t *descs = smartlist_new();
+    smartlist_t *client_cookies = smartlist_new();
+    /* Either upload a single descriptor (including replicas) or one
+     * descriptor for each authorized client in case of authorization
+     * type 'stealth'. */
+    num_descs = service->auth_type == REND_STEALTH_AUTH ?
+                    smartlist_len(service->clients) : 1;
+    for (j = 0; j < num_descs; j++) {
+      crypto_pk_t *client_key = NULL;
+      rend_authorized_client_t *client = NULL;
+      smartlist_clear(client_cookies);
+      switch (service->auth_type) {
+        case REND_NO_AUTH:
+          /* Do nothing here. */
+          break;
+        case REND_BASIC_AUTH:
+          SMARTLIST_FOREACH(service->clients, rend_authorized_client_t *,
+              cl, smartlist_add(client_cookies, cl->descriptor_cookie));
+          break;
+        case REND_STEALTH_AUTH:
+          client = smartlist_get(service->clients, j);
+          client_key = client->client_key;
+          smartlist_add(client_cookies, client->descriptor_cookie);
+          break;
+      }
+      /* Encode the current descriptor. */
+      seconds_valid = rend_encode_v2_descriptors(descs, service->desc,
+                                                 now, 0,
+                                                 service->auth_type,
+                                                 client_key,
+                                                 client_cookies);
+      if (seconds_valid < 0) {
+        log_warn(LD_BUG, "Internal error: couldn't encode service "
+                 "descriptor; not uploading.");
+        smartlist_free(descs);
+        smartlist_free(client_cookies);
+        return;
+      }
+      rend_get_service_id(service->desc->pk, serviceid);
+      if (get_options()->PublishHidServDescriptors) {
+        /* Post the current descriptors to the hidden service directories. */
+        log_info(LD_REND, "Launching upload for hidden service %s",
+                     serviceid);
+        directory_post_to_hs_dir(service->desc, descs, NULL, serviceid,
+                                 seconds_valid);
+      }
+      /* Free memory for descriptors. */
+      for (i = 0; i < smartlist_len(descs); i++)
+        rend_encoded_v2_service_descriptor_free(smartlist_get(descs, i));
+      smartlist_clear(descs);
+      /* Update next upload time. */
+      if (seconds_valid - REND_TIME_PERIOD_OVERLAPPING_V2_DESCS
+          > rendpostperiod)
+        service->next_upload_time = now + rendpostperiod;
+      else if (seconds_valid < REND_TIME_PERIOD_OVERLAPPING_V2_DESCS)
+        service->next_upload_time = now + seconds_valid + 1;
+      else
+        service->next_upload_time = now + seconds_valid -
+            REND_TIME_PERIOD_OVERLAPPING_V2_DESCS + 1;
+      /* Post also the next descriptors, if necessary. */
+      if (seconds_valid < REND_TIME_PERIOD_OVERLAPPING_V2_DESCS) {
         seconds_valid = rend_encode_v2_descriptors(descs, service->desc,
-                                                   now, 0,
+                                                   now, 1,
                                                    service->auth_type,
                                                    client_key,
                                                    client_cookies);
@@ -3245,51 +3279,23 @@ upload_service_descriptor(rend_service_t *service)
           smartlist_free(client_cookies);
           return;
         }
-        /* Post the current descriptors to the hidden service directories. */
-        rend_get_service_id(service->desc->pk, serviceid);
-        log_info(LD_REND, "Launching upload for hidden service %s",
-                     serviceid);
-        directory_post_to_hs_dir(service->desc, descs, NULL, serviceid,
-                                 seconds_valid);
+        if (get_options()->PublishHidServDescriptors) {
+          directory_post_to_hs_dir(service->desc, descs, NULL, serviceid,
+                                   seconds_valid);
+        }
         /* Free memory for descriptors. */
         for (i = 0; i < smartlist_len(descs); i++)
           rend_encoded_v2_service_descriptor_free(smartlist_get(descs, i));
         smartlist_clear(descs);
-        /* Update next upload time. */
-        if (seconds_valid - REND_TIME_PERIOD_OVERLAPPING_V2_DESCS
-            > rendpostperiod)
-          service->next_upload_time = now + rendpostperiod;
-        else if (seconds_valid < REND_TIME_PERIOD_OVERLAPPING_V2_DESCS)
-          service->next_upload_time = now + seconds_valid + 1;
-        else
-          service->next_upload_time = now + seconds_valid -
-              REND_TIME_PERIOD_OVERLAPPING_V2_DESCS + 1;
-        /* Post also the next descriptors, if necessary. */
-        if (seconds_valid < REND_TIME_PERIOD_OVERLAPPING_V2_DESCS) {
-          seconds_valid = rend_encode_v2_descriptors(descs, service->desc,
-                                                     now, 1,
-                                                     service->auth_type,
-                                                     client_key,
-                                                     client_cookies);
-          if (seconds_valid < 0) {
-            log_warn(LD_BUG, "Internal error: couldn't encode service "
-                     "descriptor; not uploading.");
-            smartlist_free(descs);
-            smartlist_free(client_cookies);
-            return;
-          }
-          directory_post_to_hs_dir(service->desc, descs, NULL, serviceid,
-                                   seconds_valid);
-          /* Free memory for descriptors. */
-          for (i = 0; i < smartlist_len(descs); i++)
-            rend_encoded_v2_service_descriptor_free(smartlist_get(descs, i));
-          smartlist_clear(descs);
-        }
       }
-      smartlist_free(descs);
-      smartlist_free(client_cookies);
-      uploaded = 1;
+    }
+    smartlist_free(descs);
+    smartlist_free(client_cookies);
+    uploaded = 1;
+    if (get_options()->PublishHidServDescriptors) {
       log_info(LD_REND, "Successfully uploaded v2 rend descriptors!");
+    } else {
+      log_info(LD_REND, "Successfully stored created v2 rend descriptors!");
     }
   }
 
@@ -3634,9 +3640,6 @@ rend_consider_services_upload(time_t now)
                               MIN_REND_INITIAL_POST_DELAY_TESTING :
                               MIN_REND_INITIAL_POST_DELAY);
 
-  if (!get_options()->PublishHidServDescriptors)
-    return;
-
   for (i=0; i < smartlist_len(rend_service_list); ++i) {
     service = smartlist_get(rend_service_list, i);
     if (!service->next_upload_time) { /* never been uploaded yet */
diff --git a/src/or/rephist.c b/src/or/rephist.c
index fe0997c..d553179 100644
--- a/src/or/rephist.c
+++ b/src/or/rephist.c
@@ -148,7 +148,7 @@ get_link_history(const char *from_id, const char *to_id)
     return NULL;
   if (tor_digest_is_zero(to_id))
     return NULL;
-  lhist = (link_history_t*) digestmap_get(orhist->link_history_map, to_id);
+  lhist = digestmap_get(orhist->link_history_map, to_id);
   if (!lhist) {
     lhist = tor_malloc_zero(sizeof(link_history_t));
     rephist_total_alloc += sizeof(link_history_t);
@@ -920,7 +920,7 @@ parse_possibly_bad_iso_time(const char *s, time_t *time_out)
  * that's about as much before <b>now</b> as <b>t</b> was before
  * <b>stored_at</b>.
  */
-static INLINE time_t
+static inline time_t
 correct_time(time_t t, time_t now, time_t stored_at, time_t started_measuring)
 {
   if (t < started_measuring - 24*60*60*365)
@@ -1190,7 +1190,7 @@ commit_max(bw_array_t *b)
 }
 
 /** Shift the current observation time of <b>b</b> forward by one second. */
-static INLINE void
+static inline void
 advance_obs(bw_array_t *b)
 {
   int nextidx;
@@ -1216,7 +1216,7 @@ advance_obs(bw_array_t *b)
 
 /** Add <b>n</b> bytes to the number of bytes in <b>b</b> for second
  * <b>when</b>. */
-static INLINE void
+static inline void
 add_obs(bw_array_t *b, time_t when, uint64_t n)
 {
   if (when < b->cur_obs_time)
@@ -1250,6 +1250,18 @@ bw_array_new(void)
   return b;
 }
 
+/** Free storage held by bandwidth array <b>b</b>. */
+static void
+bw_array_free(bw_array_t *b)
+{
+  if (!b) {
+    return;
+  }
+
+  rephist_total_alloc -= sizeof(bw_array_t);
+  tor_free(b);
+}
+
 /** Recent history of bandwidth observations for read operations. */
 static bw_array_t *read_array = NULL;
 /** Recent history of bandwidth observations for write operations. */
@@ -1266,10 +1278,11 @@ static bw_array_t *dir_write_array = NULL;
 static void
 bw_arrays_init(void)
 {
-  tor_free(read_array);
-  tor_free(write_array);
-  tor_free(dir_read_array);
-  tor_free(dir_write_array);
+  bw_array_free(read_array);
+  bw_array_free(write_array);
+  bw_array_free(dir_read_array);
+  bw_array_free(dir_write_array);
+
   read_array = bw_array_new();
   write_array = bw_array_new();
   dir_read_array = bw_array_new();
@@ -3026,21 +3039,21 @@ rep_hist_stored_maybe_new_hs(const crypto_pk_t *pubkey)
 
 /* The number of cells that are supposed to be hidden from the adversary
  * by adding noise from the Laplace distribution.  This value, divided by
- * EPSILON, is Laplace parameter b. */
+ * EPSILON, is Laplace parameter b. It must be greather than 0. */
 #define REND_CELLS_DELTA_F 2048
 /* Security parameter for obfuscating number of cells with a value between
- * 0 and 1.  Smaller values obfuscate observations more, but at the same
+ * ]0.0, 1.0]. Smaller values obfuscate observations more, but at the same
  * time make statistics less usable. */
 #define REND_CELLS_EPSILON 0.3
 /* The number of cells that are supposed to be hidden from the adversary
  * by rounding up to the next multiple of this number. */
 #define REND_CELLS_BIN_SIZE 1024
-/* The number of service identities that are supposed to be hidden from
- * the adversary by adding noise from the Laplace distribution.  This
- * value, divided by EPSILON, is Laplace parameter b. */
+/* The number of service identities that are supposed to be hidden from the
+ * adversary by adding noise from the Laplace distribution. This value,
+ * divided by EPSILON, is Laplace parameter b. It must be greater than 0. */
 #define ONIONS_SEEN_DELTA_F 8
 /* Security parameter for obfuscating number of service identities with a
- * value between 0 and 1.  Smaller values obfuscate observations more, but
+ * value between ]0.0, 1.0]. Smaller values obfuscate observations more, but
  * at the same time make statistics less usable. */
 #define ONIONS_SEEN_EPSILON 0.3
 /* The number of service identities that are supposed to be hidden from
@@ -3172,10 +3185,19 @@ rep_hist_free_all(void)
 {
   hs_stats_free(hs_stats);
   digestmap_free(history_map, free_or_history);
-  tor_free(read_array);
-  tor_free(write_array);
-  tor_free(dir_read_array);
-  tor_free(dir_write_array);
+
+  bw_array_free(read_array);
+  read_array = NULL;
+
+  bw_array_free(write_array);
+  write_array = NULL;
+
+  bw_array_free(dir_read_array);
+  dir_read_array = NULL;
+
+  bw_array_free(dir_write_array);
+  dir_write_array = NULL;
+
   tor_free(exit_bytes_read);
   tor_free(exit_bytes_written);
   tor_free(exit_streams);
@@ -3190,5 +3212,8 @@ rep_hist_free_all(void)
   }
   rep_hist_desc_stats_term();
   total_descriptor_downloads = 0;
+
+  tor_assert(rephist_total_alloc == 0);
+  tor_assert(rephist_total_num == 0);
 }
 
diff --git a/src/or/replaycache.c b/src/or/replaycache.c
index 569e073..82e5c44 100644
--- a/src/or/replaycache.c
+++ b/src/or/replaycache.c
@@ -23,7 +23,7 @@ replaycache_free(replaycache_t *r)
     return;
   }
 
-  if (r->digests_seen) digestmap_free(r->digests_seen, tor_free_);
+  if (r->digests_seen) digest256map_free(r->digests_seen, tor_free_);
 
   tor_free(r);
 }
@@ -54,7 +54,7 @@ replaycache_new(time_t horizon, time_t interval)
   r->scrub_interval = interval;
   r->scrubbed = 0;
   r->horizon = horizon;
-  r->digests_seen = digestmap_new();
+  r->digests_seen = digest256map_new();
 
  err:
   return r;
@@ -69,7 +69,7 @@ replaycache_add_and_test_internal(
     time_t *elapsed)
 {
   int rv = 0;
-  char digest[DIGEST_LEN];
+  uint8_t digest[DIGEST256_LEN];
   time_t *access_time;
 
   /* sanity check */
@@ -80,10 +80,10 @@ replaycache_add_and_test_internal(
   }
 
   /* compute digest */
-  crypto_digest(digest, (const char *)data, len);
+  crypto_digest256((char *)digest, (const char *)data, len, DIGEST_SHA256);
 
   /* check map */
-  access_time = digestmap_get(r->digests_seen, digest);
+  access_time = digest256map_get(r->digests_seen, digest);
 
   /* seen before? */
   if (access_time != NULL) {
@@ -114,7 +114,7 @@ replaycache_add_and_test_internal(
     /* No, so no hit and update the digest map with the current time */
     access_time = tor_malloc(sizeof(*access_time));
     *access_time = present;
-    digestmap_set(r->digests_seen, digest, access_time);
+    digest256map_set(r->digests_seen, digest, access_time);
   }
 
   /* now scrub the cache if it's time */
@@ -130,8 +130,8 @@ replaycache_add_and_test_internal(
 STATIC void
 replaycache_scrub_if_needed_internal(time_t present, replaycache_t *r)
 {
-  digestmap_iter_t *itr = NULL;
-  const char *digest;
+  digest256map_iter_t *itr = NULL;
+  const uint8_t *digest;
   void *valp;
   time_t *access_time;
 
@@ -149,19 +149,19 @@ replaycache_scrub_if_needed_internal(time_t present, replaycache_t *r)
   if (r->horizon == 0) return;
 
   /* okay, scrub time */
-  itr = digestmap_iter_init(r->digests_seen);
-  while (!digestmap_iter_done(itr)) {
-    digestmap_iter_get(itr, &digest, &valp);
+  itr = digest256map_iter_init(r->digests_seen);
+  while (!digest256map_iter_done(itr)) {
+    digest256map_iter_get(itr, &digest, &valp);
     access_time = (time_t *)valp;
     /* aged out yet? */
     if (*access_time < present - r->horizon) {
       /* Advance the iterator and remove this one */
-      itr = digestmap_iter_next_rmv(r->digests_seen, itr);
+      itr = digest256map_iter_next_rmv(r->digests_seen, itr);
       /* Free the value removed */
       tor_free(access_time);
     } else {
       /* Just advance the iterator */
-      itr = digestmap_iter_next(r->digests_seen, itr);
+      itr = digest256map_iter_next(r->digests_seen, itr);
     }
   }
 
diff --git a/src/or/replaycache.h b/src/or/replaycache.h
index 9b9daf3..9c409f2 100644
--- a/src/or/replaycache.h
+++ b/src/or/replaycache.h
@@ -26,7 +26,7 @@ struct replaycache_s {
   /*
    * Digest map: keys are digests, values are times the digest was last seen
    */
-  digestmap_t *digests_seen;
+  digest256map_t *digests_seen;
 };
 
 #endif /* REPLAYCACHE_PRIVATE */
diff --git a/src/or/router.c b/src/or/router.c
index 8fdad9a..741e1ed 100644
--- a/src/or/router.c
+++ b/src/or/router.c
@@ -269,8 +269,8 @@ client_identity_key_is_set(void)
 
 /** Return the key certificate for this v3 (voting) authority, or NULL
  * if we have no such certificate. */
-authority_cert_t *
-get_my_v3_authority_cert(void)
+MOCK_IMPL(authority_cert_t *,
+get_my_v3_authority_cert, (void))
 {
   return authority_key_certificate;
 }
@@ -1026,6 +1026,7 @@ init_keys(void)
     ds = trusted_dir_server_new(options->Nickname, NULL,
                                 router_get_advertised_dir_port(options, 0),
                                 router_get_advertised_or_port(options),
+                                NULL,
                                 digest,
                                 v3_digest,
                                 type, 0.0);
@@ -1098,43 +1099,47 @@ check_whether_dirport_reachable(void)
          can_reach_dir_port;
 }
 
-/** Look at a variety of factors, and return 0 if we don't want to
- * advertise the fact that we have a DirPort open. Else return the
- * DirPort we want to advertise.
- *
- * Log a helpful message if we change our mind about whether to publish
- * a DirPort.
+/** The lower threshold of remaining bandwidth required to advertise (or
+ * automatically provide) directory services */
+/* XXX Should this be increased? */
+#define MIN_BW_TO_ADVERTISE_DIRSERVER 51200
+
+/** Return true iff we have enough configured bandwidth to cache directory
+ * information. */
+static int
+router_has_bandwidth_to_be_dirserver(const or_options_t *options)
+{
+  if (options->BandwidthRate < MIN_BW_TO_ADVERTISE_DIRSERVER) {
+    return 0;
+  }
+  if (options->RelayBandwidthRate > 0 &&
+      options->RelayBandwidthRate < MIN_BW_TO_ADVERTISE_DIRSERVER) {
+    return 0;
+  }
+  return 1;
+}
+
+/** Helper: Return 1 if we have sufficient resources for serving directory
+ * requests, return 0 otherwise.
+ * dir_port is either 0 or the configured DirPort number.
+ * If AccountingMax is set less than our advertised bandwidth, then don't
+ * serve requests. Likewise, if our advertised bandwidth is less than
+ * MIN_BW_TO_ADVERTISE_DIRSERVER, don't bother trying to serve requests.
  */
 static int
-decide_to_advertise_dirport(const or_options_t *options, uint16_t dir_port)
+router_should_be_directory_server(const or_options_t *options, int dir_port)
 {
   static int advertising=1; /* start out assuming we will advertise */
   int new_choice=1;
   const char *reason = NULL;
 
-  /* Section one: reasons to publish or not publish that aren't
-   * worth mentioning to the user, either because they're obvious
-   * or because they're normal behavior. */
-
-  if (!dir_port) /* short circuit the rest of the function */
-    return 0;
-  if (authdir_mode(options)) /* always publish */
-    return dir_port;
-  if (net_is_disabled())
-    return 0;
-  if (!check_whether_dirport_reachable())
-    return 0;
-  if (!router_get_advertised_dir_port(options, dir_port))
-    return 0;
-
-  /* Section two: reasons to publish or not publish that the user
-   * might find surprising. These are generally config options that
-   * make us choose not to publish. */
-
-  if (accounting_is_enabled(options)) {
+  if (accounting_is_enabled(options) &&
+    get_options()->AccountingRule != ACCT_IN) {
     /* Don't spend bytes for directory traffic if we could end up hibernating,
      * but allow DirPort otherwise. Some people set AccountingMax because
-     * they're confused or to get statistics. */
+     * they're confused or to get statistics. Directory traffic has a much
+     * larger effect on output than input so there is no reason to turn it
+     * off if using AccountingRule in. */
     int interval_length = accounting_get_interval_length();
     uint32_t effective_bw = get_effective_bwrate(options);
     uint64_t acc_bytes;
@@ -1157,10 +1162,7 @@ decide_to_advertise_dirport(const or_options_t *options, uint16_t dir_port)
       new_choice = 0;
       reason = "AccountingMax enabled";
     }
-#define MIN_BW_TO_ADVERTISE_DIRPORT 51200
-  } else if (options->BandwidthRate < MIN_BW_TO_ADVERTISE_DIRPORT ||
-             (options->RelayBandwidthRate > 0 &&
-              options->RelayBandwidthRate < MIN_BW_TO_ADVERTISE_DIRPORT)) {
+  } else if (! router_has_bandwidth_to_be_dirserver(options)) {
     /* if we're advertising a small amount */
     new_choice = 0;
     reason = "BandwidthRate under 50KB";
@@ -1168,15 +1170,63 @@ decide_to_advertise_dirport(const or_options_t *options, uint16_t dir_port)
 
   if (advertising != new_choice) {
     if (new_choice == 1) {
-      log_notice(LD_DIR, "Advertising DirPort as %d", dir_port);
+      if (dir_port > 0)
+        log_notice(LD_DIR, "Advertising DirPort as %d", dir_port);
+      else
+        log_notice(LD_DIR, "Advertising directory service support");
     } else {
       tor_assert(reason);
-      log_notice(LD_DIR, "Not advertising DirPort (Reason: %s)", reason);
+      log_notice(LD_DIR, "Not advertising Dir%s (Reason: %s)",
+                 dir_port ? "Port" : "ectory Service support", reason);
     }
     advertising = new_choice;
   }
 
-  return advertising ? dir_port : 0;
+  return advertising;
+}
+
+/** Return 1 if we are configured to accept either relay or directory requests
+ * from clients and we aren't at risk of exceeding our bandwidth limits, thus
+ * we should be a directory server. If not, return 0.
+ */
+int
+dir_server_mode(const or_options_t *options)
+{
+  if (!options->DirCache)
+    return 0;
+  return options->DirPort_set ||
+    (server_mode(options) && router_has_bandwidth_to_be_dirserver(options));
+}
+
+/** Look at a variety of factors, and return 0 if we don't want to
+ * advertise the fact that we have a DirPort open, else return the
+ * DirPort we want to advertise.
+ *
+ * Log a helpful message if we change our mind about whether to publish
+ * a DirPort.
+ */
+static int
+decide_to_advertise_dirport(const or_options_t *options, uint16_t dir_port)
+{
+  /* Part one: reasons to publish or not publish that aren't
+   * worth mentioning to the user, either because they're obvious
+   * or because they're normal behavior. */
+
+  if (!dir_port) /* short circuit the rest of the function */
+    return 0;
+  if (authdir_mode(options)) /* always publish */
+    return dir_port;
+  if (net_is_disabled())
+    return 0;
+  if (!check_whether_dirport_reachable())
+    return 0;
+  if (!router_get_advertised_dir_port(options, dir_port))
+    return 0;
+
+  /* Part two: reasons to publish or not publish that the user
+   * might find surprising. router_should_be_directory_server()
+   * considers config options that make us choose not to publish. */
+  return router_should_be_directory_server(options, dir_port) ? dir_port : 0;
 }
 
 /** Allocate and return a new extend_info_t that can be used to build
@@ -1267,7 +1317,8 @@ router_orport_found_reachable(void)
     char *address = tor_dup_ip(me->addr);
     log_notice(LD_OR,"Self-testing indicates your ORPort is reachable from "
                "the outside. Excellent.%s",
-               get_options()->PublishServerDescriptor_ != NO_DIRINFO ?
+               get_options()->PublishServerDescriptor_ != NO_DIRINFO
+               && check_whether_dirport_reachable() ?
                  " Publishing server descriptor." : "");
     can_reach_or_port = 1;
     mark_my_descriptor_dirty("ORPort found reachable");
@@ -1291,7 +1342,10 @@ router_dirport_found_reachable(void)
   if (!can_reach_dir_port && me) {
     char *address = tor_dup_ip(me->addr);
     log_notice(LD_DIRSERV,"Self-testing indicates your DirPort is reachable "
-               "from the outside. Excellent.");
+               "from the outside. Excellent.%s",
+               get_options()->PublishServerDescriptor_ != NO_DIRINFO
+               && check_whether_orport_reachable() ?
+               " Publishing server descriptor." : "");
     can_reach_dir_port = 1;
     if (decide_to_advertise_dirport(get_options(), me->dir_port)) {
       mark_my_descriptor_dirty("DirPort found reachable");
@@ -1456,8 +1510,8 @@ static int server_is_advertised=0;
 
 /** Return true iff we have published our descriptor lately.
  */
-int
-advertised_server_mode(void)
+MOCK_IMPL(int,
+advertised_server_mode,(void))
 {
   return server_is_advertised;
 }
@@ -1494,7 +1548,8 @@ proxy_mode(const or_options_t *options)
  * and
  * - We have ORPort set
  * and
- * - We believe we are reachable from the outside; or
+ * - We believe both our ORPort and DirPort (if present) are reachable from
+ *   the outside; or
  * - We are an authoritative directory server.
  */
 static int
@@ -1513,7 +1568,7 @@ decide_if_publishable_server(void)
   if (!router_get_advertised_or_port(options))
     return 0;
 
-  return check_whether_orport_reachable();
+  return check_whether_orport_reachable() && check_whether_dirport_reachable();
 }
 
 /** Initiate server descriptor upload as reasonable (if server is publishable,
@@ -1714,8 +1769,8 @@ router_compare_to_my_exit_policy(const tor_addr_t *addr, uint16_t port)
 
 /** Return true iff my exit policy is reject *:*.  Return -1 if we don't
  * have a descriptor */
-int
-router_my_exit_policy_is_reject_star(void)
+MOCK_IMPL(int,
+router_my_exit_policy_is_reject_star,(void))
 {
   if (!router_get_my_routerinfo()) /* make sure desc_routerinfo exists */
     return -1;
@@ -1781,9 +1836,9 @@ router_get_my_descriptor(void)
   const char *body;
   if (!router_get_my_routerinfo())
     return NULL;
-  /* Make sure this is nul-terminated. */
   tor_assert(desc_routerinfo->cache_info.saved_location == SAVED_NOWHERE);
   body = signed_descriptor_get_body(&desc_routerinfo->cache_info);
+  /* Make sure this is nul-terminated. */
   tor_assert(!body[desc_routerinfo->cache_info.signed_descriptor_len]);
   log_debug(LD_GENERAL,"my desc is '%s'", body);
   return body;
@@ -1819,8 +1874,8 @@ static int router_guess_address_from_dir_headers(uint32_t *guess);
  * it's configured in torrc, or because we've learned it from
  * dirserver headers. Place the answer in *<b>addr</b> and return
  * 0 on success, else return -1 if we have no guess. */
-int
-router_pick_published_address(const or_options_t *options, uint32_t *addr)
+MOCK_IMPL(int,
+router_pick_published_address,(const or_options_t *options, uint32_t *addr))
 {
   *addr = get_last_resolved_addr();
   if (!*addr &&
@@ -1865,6 +1920,8 @@ router_build_fresh_descriptor(routerinfo_t **r, extrainfo_t **e)
   ri->addr = addr;
   ri->or_port = router_get_advertised_or_port(options);
   ri->dir_port = router_get_advertised_dir_port(options, 0);
+  ri->supports_tunnelled_dir_requests = dir_server_mode(options) &&
+    router_should_be_directory_server(options, ri->dir_port);
   ri->cache_info.published_on = time(NULL);
   ri->onion_pkey = crypto_pk_dup_key(get_onion_key()); /* must invoke from
                                                         * main thread */
@@ -1922,7 +1979,7 @@ router_build_fresh_descriptor(routerinfo_t **r, extrainfo_t **e)
     /* DNS is screwed up; don't claim to be an exit. */
     policies_exit_policy_append_reject_star(&ri->exit_policy);
   } else {
-    policies_parse_exit_policy_from_options(options,ri->addr,&ri->ipv6_addr,1,
+    policies_parse_exit_policy_from_options(options,ri->addr,&ri->ipv6_addr,
                                             &ri->exit_policy);
   }
   ri->policy_is_reject_star =
@@ -2318,7 +2375,7 @@ router_new_address_suggestion(const char *suggestion,
   if (tor_addr_eq(&d_conn->base_.addr, &addr)) {
     /* Don't believe anybody who says our IP is their IP. */
     log_debug(LD_DIR, "A directory server told us our IP address is %s, "
-              "but he's just reporting his own IP address. Ignoring.",
+              "but they are just reporting their own IP address. Ignoring.",
               suggestion);
     return;
   }
@@ -2641,6 +2698,10 @@ router_dump_router_to_string(routerinfo_t *router,
     tor_free(p6);
   }
 
+  if (router->supports_tunnelled_dir_requests) {
+    smartlist_add(chunks, tor_strdup("tunnelled-dir-server\n"));
+  }
+
   /* Sign the descriptor with Ed25519 */
   if (emit_ed_sigs)  {
     smartlist_add(chunks, tor_strdup("router-sig-ed25519 "));
@@ -2728,44 +2789,13 @@ router_dump_exit_policy_to_string(const routerinfo_t *router,
                                   int include_ipv4,
                                   int include_ipv6)
 {
-  smartlist_t *exit_policy_strings;
-  char *policy_string = NULL;
-
   if ((!router->exit_policy) || (router->policy_is_reject_star)) {
     return tor_strdup("reject *:*");
   }
 
-  exit_policy_strings = smartlist_new();
-
-  SMARTLIST_FOREACH_BEGIN(router->exit_policy, addr_policy_t *, tmpe) {
-    char *pbuf;
-    int bytes_written_to_pbuf;
-    if ((tor_addr_family(&tmpe->addr) == AF_INET6) && (!include_ipv6)) {
-      continue; /* Don't include IPv6 parts of address policy */
-    }
-    if ((tor_addr_family(&tmpe->addr) == AF_INET) && (!include_ipv4)) {
-      continue; /* Don't include IPv4 parts of address policy */
-    }
-
-    pbuf = tor_malloc(POLICY_BUF_LEN);
-    bytes_written_to_pbuf = policy_write_item(pbuf,POLICY_BUF_LEN, tmpe, 1);
-
-    if (bytes_written_to_pbuf < 0) {
-      log_warn(LD_BUG, "router_dump_exit_policy_to_string ran out of room!");
-      tor_free(pbuf);
-      goto done;
-    }
-
-    smartlist_add(exit_policy_strings,pbuf);
-  } SMARTLIST_FOREACH_END(tmpe);
-
-  policy_string = smartlist_join_strings(exit_policy_strings, "\n", 0, NULL);
-
- done:
-  SMARTLIST_FOREACH(exit_policy_strings, char *, str, tor_free(str));
-  smartlist_free(exit_policy_strings);
-
-  return policy_string;
+  return policy_dump_to_string(router->exit_policy,
+                               include_ipv4,
+                               include_ipv6);
 }
 
 /** Copy the primary (IPv4) OR port (IP address and TCP port) for
diff --git a/src/or/router.h b/src/or/router.h
index d8fcf0a..ca590e3 100644
--- a/src/or/router.h
+++ b/src/or/router.h
@@ -22,7 +22,7 @@ int server_identity_key_is_set(void);
 void set_client_identity_key(crypto_pk_t *k);
 crypto_pk_t *get_tlsclient_identity_key(void);
 int client_identity_key_is_set(void);
-authority_cert_t *get_my_v3_authority_cert(void);
+MOCK_DECL(authority_cert_t *, get_my_v3_authority_cert, (void));
 crypto_pk_t *get_my_v3_authority_signing_key(void);
 authority_cert_t *get_my_v3_legacy_cert(void);
 crypto_pk_t *get_my_v3_legacy_signing_key(void);
@@ -41,6 +41,7 @@ int init_keys_client(void);
 
 int check_whether_orport_reachable(void);
 int check_whether_dirport_reachable(void);
+int dir_server_mode(const or_options_t *options);
 void consider_testing_reachability(int test_or, int test_dir);
 void router_orport_found_reachable(void);
 void router_dirport_found_reachable(void);
@@ -67,7 +68,7 @@ uint16_t router_get_advertised_dir_port(const or_options_t *options,
 
 MOCK_DECL(int, server_mode, (const or_options_t *options));
 MOCK_DECL(int, public_server_mode, (const or_options_t *options));
-int advertised_server_mode(void);
+MOCK_DECL(int, advertised_server_mode, (void));
 int proxy_mode(const or_options_t *options);
 void consider_publishable_server(int force);
 int should_refuse_unknown_exits(const or_options_t *options);
@@ -80,7 +81,7 @@ void check_descriptor_ipaddress_changed(time_t now);
 void router_new_address_suggestion(const char *suggestion,
                                    const dir_connection_t *d_conn);
 int router_compare_to_my_exit_policy(const tor_addr_t *addr, uint16_t port);
-int router_my_exit_policy_is_reject_star(void);
+MOCK_DECL(int, router_my_exit_policy_is_reject_star,(void));
 MOCK_DECL(const routerinfo_t *, router_get_my_routerinfo, (void));
 extrainfo_t *router_get_my_extrainfo(void);
 const char *router_get_my_descriptor(void);
@@ -89,7 +90,8 @@ int router_digest_is_me(const char *digest);
 const uint8_t *router_get_my_id_digest(void);
 int router_extrainfo_digest_is_me(const char *digest);
 int router_is_me(const routerinfo_t *router);
-int router_pick_published_address(const or_options_t *options, uint32_t *addr);
+MOCK_DECL(int,router_pick_published_address,(const or_options_t *options,
+                                             uint32_t *addr));
 int router_build_fresh_descriptor(routerinfo_t **r, extrainfo_t **e);
 int router_rebuild_descriptor(int force);
 char *router_dump_router_to_string(routerinfo_t *router,
diff --git a/src/or/routerlist.c b/src/or/routerlist.c
index 03729bd..139a292 100644
--- a/src/or/routerlist.c
+++ b/src/or/routerlist.c
@@ -67,8 +67,6 @@ typedef struct cert_list_t cert_list_t;
 static int compute_weighted_bandwidths(const smartlist_t *sl,
                                        bandwidth_weight_rule_t rule,
                                        u64_dbl_t **bandwidths_out);
-static const routerstatus_t *router_pick_directory_server_impl(
-                              dirinfo_type_t auth, int flags, int *n_busy_out);
 static const routerstatus_t *router_pick_trusteddirserver_impl(
                 const smartlist_t *sourcelist, dirinfo_type_t auth,
                 int flags, int *n_busy_out);
@@ -278,7 +276,7 @@ trusted_dirs_reload_certs(void)
 
 /** Helper: return true iff we already have loaded the exact cert
  * <b>cert</b>. */
-static INLINE int
+static inline int
 already_have_cert(authority_cert_t *cert)
 {
   cert_list_t *cl = get_cert_list(cert->cache_info.identity_digest);
@@ -897,8 +895,10 @@ authority_certs_fetch_missing(networkstatus_t *status, time_t now)
 
     if (smartlist_len(fps) > 1) {
       resource = smartlist_join_strings(fps, "", 0, NULL);
+      /* XXX - do we want certs from authorities or mirrors? - teor */
       directory_get_from_dirserver(DIR_PURPOSE_FETCH_CERTIFICATE, 0,
-                                   resource, PDS_RETRY_IF_NO_SERVERS);
+                                   resource, PDS_RETRY_IF_NO_SERVERS,
+                                   DL_WANT_ANY_DIRSERVER);
       tor_free(resource);
     }
     /* else we didn't add any: they were all pending */
@@ -941,8 +941,10 @@ authority_certs_fetch_missing(networkstatus_t *status, time_t now)
 
     if (smartlist_len(fp_pairs) > 1) {
       resource = smartlist_join_strings(fp_pairs, "", 0, NULL);
+      /* XXX - do we want certs from authorities or mirrors? - teor */
       directory_get_from_dirserver(DIR_PURPOSE_FETCH_CERTIFICATE, 0,
-                                   resource, PDS_RETRY_IF_NO_SERVERS);
+                                   resource, PDS_RETRY_IF_NO_SERVERS,
+                                   DL_WANT_ANY_DIRSERVER);
       tor_free(resource);
     }
     /* else they were all pending */
@@ -985,7 +987,7 @@ router_should_rebuild_store(desc_store_t *store)
 
 /** Return the desc_store_t in <b>rl</b> that should be used to store
  * <b>sd</b>. */
-static INLINE desc_store_t *
+static inline desc_store_t *
 desc_get_store(routerlist_t *rl, const signed_descriptor_t *sd)
 {
   if (sd->is_extrainfo)
@@ -1295,8 +1297,8 @@ router_get_fallback_dir_servers(void)
 /** Try to find a running dirserver that supports operations of <b>type</b>.
  *
  * If there are no running dirservers in our routerlist and the
- * <b>PDS_RETRY_IF_NO_SERVERS</b> flag is set, set all the authoritative ones
- * as running again, and pick one.
+ * <b>PDS_RETRY_IF_NO_SERVERS</b> flag is set, set all the fallback ones
+ * (including authorities) as running again, and pick one.
  *
  * If the <b>PDS_IGNORE_FASCISTFIREWALL</b> flag is set, then include
  * dirservers that we can't reach.
@@ -1304,8 +1306,9 @@ router_get_fallback_dir_servers(void)
  * If the <b>PDS_ALLOW_SELF</b> flag is not set, then don't include ourself
  * (if we're a dirserver).
  *
- * Don't pick an authority if any non-authority is viable; try to avoid using
- * servers that have returned 503 recently.
+ * Don't pick a fallback directory mirror if any non-fallback is viable;
+ * (the fallback directory mirrors include the authorities)
+ * try to avoid using servers that have returned 503 recently.
  */
 const routerstatus_t *
 router_pick_directory_server(dirinfo_type_t type, int flags)
@@ -1332,7 +1335,7 @@ router_pick_directory_server(dirinfo_type_t type, int flags)
   log_info(LD_DIR,
            "No reachable router entries for dirservers. "
            "Trying them all again.");
-  /* mark all authdirservers as up again */
+  /* mark all fallback directory mirrors as up again */
   mark_all_dirservers_up(fallback_dir_servers);
   /* try again */
   choice = router_pick_directory_server_impl(type, flags, NULL);
@@ -1358,15 +1361,20 @@ router_get_trusteddirserver_by_digest(const char *digest)
 }
 
 /** Return the dir_server_t for the fallback dirserver whose identity
- * key hashes to <b>digest</b>, or NULL if no such authority is known.
+ * key hashes to <b>digest</b>, or NULL if no such fallback is in the list of
+ * fallback_dir_servers. (fallback_dir_servers is affected by the FallbackDir
+ * and UseDefaultFallbackDirs torrc options.)
  */
 dir_server_t *
 router_get_fallback_dirserver_by_digest(const char *digest)
 {
-  if (!trusted_dir_servers)
+  if (!fallback_dir_servers)
     return NULL;
 
-  SMARTLIST_FOREACH(trusted_dir_servers, dir_server_t *, ds,
+  if (!digest)
+    return NULL;
+
+  SMARTLIST_FOREACH(fallback_dir_servers, dir_server_t *, ds,
      {
        if (tor_memeq(ds->digest, digest, DIGEST_LEN))
          return ds;
@@ -1375,6 +1383,17 @@ router_get_fallback_dirserver_by_digest(const char *digest)
   return NULL;
 }
 
+/** Return 1 if any fallback dirserver's identity key hashes to <b>digest</b>,
+ * or 0 if no such fallback is in the list of fallback_dir_servers.
+ * (fallback_dir_servers is affected by the FallbackDir and
+ * UseDefaultFallbackDirs torrc options.)
+ */
+int
+router_digest_is_fallback_dir(const char *digest)
+{
+  return (router_get_fallback_dirserver_by_digest(digest) != NULL);
+}
+
 /** Return the dir_server_t for the directory authority whose
  * v3 identity key hashes to <b>digest</b>, or NULL if no such authority
  * is known.
@@ -1451,7 +1470,7 @@ router_pick_dirserver_generic(smartlist_t *sourcelist,
  * directories that we excluded for no other reason than
  * PDS_NO_EXISTING_SERVERDESC_FETCH or PDS_NO_EXISTING_MICRODESC_FETCH.
  */
-static const routerstatus_t *
+STATIC const routerstatus_t *
 router_pick_directory_server_impl(dirinfo_type_t type, int flags,
                                   int *n_busy_out)
 {
@@ -1491,7 +1510,7 @@ router_pick_directory_server_impl(dirinfo_type_t type, int flags,
     if (!status)
       continue;
 
-    if (!node->is_running || !status->dir_port || !node->is_valid)
+    if (!node->is_running || !node_is_dir(node) || !node->is_valid)
       continue;
     if (requireother && router_digest_is_me(node->identity))
       continue;
@@ -1501,8 +1520,14 @@ router_pick_directory_server_impl(dirinfo_type_t type, int flags,
     if ((type & EXTRAINFO_DIRINFO) &&
         !router_supports_extrainfo(node->identity, is_trusted_extrainfo))
       continue;
-    if (for_guard && node->using_as_guard)
-      continue; /* Don't make the same node a guard twice. */
+    /* Don't make the same node a guard twice */
+    if (for_guard && node->using_as_guard) {
+      continue;
+    }
+    /* Ensure that a directory guard is actually a guard node. */
+    if (for_guard && !node->is_possible_guard) {
+      continue;
+    }
     if (try_excluding &&
         routerset_contains_routerstatus(options->ExcludeNodes, status,
                                         country)) {
@@ -1712,22 +1737,24 @@ router_pick_trusteddirserver_impl(const smartlist_t *sourcelist,
       result = &selection->fake_status;
   }
 
-  if (n_busy_out)
-    *n_busy_out = n_busy;
-
   smartlist_free(direct);
   smartlist_free(tunnel);
   smartlist_free(overloaded_direct);
   smartlist_free(overloaded_tunnel);
 
-  if (result == NULL && try_excluding && !options->StrictNodes && n_excluded) {
+  if (result == NULL && try_excluding && !options->StrictNodes && n_excluded
+      && !n_busy) {
     /* If we got no result, and we are excluding nodes, and StrictNodes is
      * not set, try again without excluding nodes. */
     try_excluding = 0;
     n_excluded = 0;
+    n_busy = 0;
     goto retry_without_exclude;
   }
 
+  if (n_busy_out)
+    *n_busy_out = n_busy;
+
   return result;
 }
 
@@ -1891,7 +1918,7 @@ scale_array_elements_to_u64(u64_dbl_t *entries, int n_entries,
 #if SIZEOF_VOID_P == 8
 #define gt_i64_timei(a,b) ((a) > (b))
 #else
-static INLINE int
+static inline int
 gt_i64_timei(uint64_t a, uint64_t b)
 {
   int64_t diff = (int64_t) (b - a);
@@ -1969,7 +1996,7 @@ bridge_get_advertised_bandwidth_bounded(routerinfo_t *router)
 
 /** Return bw*1000, unless bw*1000 would overflow, in which case return
  * INT32_MAX. */
-static INLINE int32_t
+static inline int32_t
 kb_to_bytes(uint32_t bw)
 {
   return (bw > (INT32_MAX/1000)) ? INT32_MAX : bw*1000;
@@ -2784,7 +2811,7 @@ dump_routerlist_mem_usage(int severity)
  * in <b>sl</b> at position <b>idx</b>. Otherwise, search <b>sl</b> for
  * <b>ri</b>.  Return the index of <b>ri</b> in <b>sl</b>, or -1 if <b>ri</b>
  * is not in <b>sl</b>. */
-static INLINE int
+static inline int
 routerlist_find_elt_(smartlist_t *sl, void *ri, int idx)
 {
   if (idx < 0) {
@@ -3209,7 +3236,11 @@ routerlist_reparse_old(routerlist_t *rl, signed_descriptor_t *sd)
   return ri;
 }
 
-/** Free all memory held by the routerlist module. */
+/** Free all memory held by the routerlist module.
+ * Note: Calling routerlist_free_all() should always be paired with
+ * a call to nodelist_free_all(). These should only be called during
+ * cleanup.
+ */
 void
 routerlist_free_all(void)
 {
@@ -4028,15 +4059,16 @@ router_exit_policy_rejects_all(const routerinfo_t *router)
 }
 
 /** Create an directory server at <b>address</b>:<b>port</b>, with OR identity
- * key <b>digest</b>.  If <b>address</b> is NULL, add ourself.  If
- * <b>is_authority</b>, this is a directory authority.  Return the new
- * directory server entry on success or NULL on failure. */
+ * key <b>digest</b> which has DIGEST_LEN bytes.  If <b>address</b> is NULL,
+ * add ourself.  If <b>is_authority</b>, this is a directory authority.  Return
+ * the new directory server entry on success or NULL on failure. */
 static dir_server_t *
 dir_server_new(int is_authority,
                const char *nickname,
                const tor_addr_t *addr,
                const char *hostname,
                uint16_t dir_port, uint16_t or_port,
+               const tor_addr_port_t *addrport_ipv6,
                const char *digest, const char *v3_auth_digest,
                dirinfo_type_t type,
                double weight)
@@ -4045,13 +4077,15 @@ dir_server_new(int is_authority,
   uint32_t a;
   char *hostname_ = NULL;
 
+  tor_assert(digest);
+
   if (weight < 0)
     return NULL;
 
   if (tor_addr_family(addr) == AF_INET)
     a = tor_addr_to_ipv4h(addr);
   else
-    return NULL; /*XXXX Support IPv6 */
+    return NULL;
 
   if (!hostname)
     hostname_ = tor_dup_addr(addr);
@@ -4068,6 +4102,18 @@ dir_server_new(int is_authority,
   ent->is_authority = is_authority;
   ent->type = type;
   ent->weight = weight;
+  if (addrport_ipv6) {
+    if (tor_addr_family(&addrport_ipv6->addr) != AF_INET6) {
+      log_warn(LD_BUG, "Hey, I got a non-ipv6 addr as addrport_ipv6.");
+      tor_addr_make_unspec(&ent->ipv6_addr);
+    } else {
+      tor_addr_copy(&ent->ipv6_addr, &addrport_ipv6->addr);
+      ent->ipv6_orport = addrport_ipv6->port;
+    }
+  } else {
+    tor_addr_make_unspec(&ent->ipv6_addr);
+  }
+
   memcpy(ent->digest, digest, DIGEST_LEN);
   if (v3_auth_digest && (type & V3_DIRINFO))
     memcpy(ent->v3_identity_digest, v3_auth_digest, DIGEST_LEN);
@@ -4080,6 +4126,7 @@ dir_server_new(int is_authority,
                  hostname, (int)dir_port);
 
   ent->fake_status.addr = ent->addr;
+  tor_addr_copy(&ent->fake_status.ipv6_addr, &ent->ipv6_addr);
   memcpy(ent->fake_status.identity_digest, digest, DIGEST_LEN);
   if (nickname)
     strlcpy(ent->fake_status.nickname, nickname,
@@ -4088,6 +4135,7 @@ dir_server_new(int is_authority,
     ent->fake_status.nickname[0] = '\0';
   ent->fake_status.dir_port = ent->dir_port;
   ent->fake_status.or_port = ent->or_port;
+  ent->fake_status.ipv6_orport = ent->ipv6_orport;
 
   return ent;
 }
@@ -4099,6 +4147,7 @@ dir_server_new(int is_authority,
 dir_server_t *
 trusted_dir_server_new(const char *nickname, const char *address,
                        uint16_t dir_port, uint16_t or_port,
+                       const tor_addr_port_t *ipv6_addrport,
                        const char *digest, const char *v3_auth_digest,
                        dirinfo_type_t type, double weight)
 {
@@ -4129,7 +4178,9 @@ trusted_dir_server_new(const char *nickname, const char *address,
   tor_addr_from_ipv4h(&addr, a);
 
   result = dir_server_new(1, nickname, &addr, hostname,
-                          dir_port, or_port, digest,
+                          dir_port, or_port,
+                          ipv6_addrport,
+                          digest,
                           v3_auth_digest, type, weight);
   tor_free(hostname);
   return result;
@@ -4141,9 +4192,12 @@ trusted_dir_server_new(const char *nickname, const char *address,
 dir_server_t *
 fallback_dir_server_new(const tor_addr_t *addr,
                         uint16_t dir_port, uint16_t or_port,
+                        const tor_addr_port_t *addrport_ipv6,
                         const char *id_digest, double weight)
 {
-  return dir_server_new(0, NULL, addr, NULL, dir_port, or_port, id_digest,
+  return dir_server_new(0, NULL, addr, NULL, dir_port, or_port,
+                        addrport_ipv6,
+                        id_digest,
                         NULL, ALL_DIRINFO, weight);
 }
 
@@ -4368,14 +4422,14 @@ MOCK_IMPL(STATIC void, initiate_descriptor_downloads,
   tor_free(cp);
 
   if (source) {
-    /* We know which authority we want. */
+    /* We know which authority or directory mirror we want. */
     directory_initiate_command_routerstatus(source, purpose,
                                             ROUTER_PURPOSE_GENERAL,
                                             DIRIND_ONEHOP,
                                             resource, NULL, 0, 0);
   } else {
     directory_get_from_dirserver(purpose, ROUTER_PURPOSE_GENERAL, resource,
-                                 pds_flags);
+                                 pds_flags, DL_WANT_ANY_DIRSERVER);
   }
   tor_free(resource);
 }
@@ -4386,13 +4440,20 @@ static int
 max_dl_per_request(const or_options_t *options, int purpose)
 {
   /* Since squid does not like URLs >= 4096 bytes we limit it to 96.
-   *   4096 - strlen(http://255.255.255.255/tor/server/d/.z) == 4058
-   *   4058/41 (40 for the hash and 1 for the + that separates them) => 98
+   *   4096 - strlen(http://[ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff]:65535
+   *                 /tor/server/d/.z) == 4026
+   *   4026/41 (40 for the hash and 1 for the + that separates them) => 98
    *   So use 96 because it's a nice number.
+   *
+   * For microdescriptors, the calculation is
+   *   4096 - strlen(http://[ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff]:65535
+   *                 /tor/micro/d/.z) == 4027
+   *   4027/44 (43 for the hash and 1 for the - that separates them) => 91
+   *   So use 90 because it's a nice number.
    */
   int max = 96;
   if (purpose == DIR_PURPOSE_FETCH_MICRODESC) {
-    max = 92;
+    max = 90;
   }
   /* If we're going to tunnel our connections, we can ask for a lot more
    * in a request. */
@@ -4657,9 +4718,14 @@ launch_dummy_descriptor_download_as_needed(time_t now,
       last_descriptor_download_attempted + DUMMY_DOWNLOAD_INTERVAL < now &&
       last_dummy_download + DUMMY_DOWNLOAD_INTERVAL < now) {
     last_dummy_download = now;
+    /* XX/teor - do we want an authority here, because they are less likely
+     * to give us the wrong address? (See #17782)
+     * I'm leaving the previous behaviour intact, because I don't like
+     * the idea of some relays contacting an authority every 20 minutes. */
     directory_get_from_dirserver(DIR_PURPOSE_FETCH_SERVERDESC,
                                  ROUTER_PURPOSE_GENERAL, "authority.z",
-                                 PDS_RETRY_IF_NO_SERVERS);
+                                 PDS_RETRY_IF_NO_SERVERS,
+                                 DL_WANT_ANY_DIRSERVER);
   }
 }
 
@@ -4845,7 +4911,9 @@ router_differences_are_cosmetic(const routerinfo_t *r1, const routerinfo_t *r2)
       (r1->contact_info && r2->contact_info &&
        strcasecmp(r1->contact_info, r2->contact_info)) ||
       r1->is_hibernating != r2->is_hibernating ||
-      cmp_addr_policies(r1->exit_policy, r2->exit_policy))
+      cmp_addr_policies(r1->exit_policy, r2->exit_policy) ||
+      (r1->supports_tunnelled_dir_requests !=
+       r2->supports_tunnelled_dir_requests))
     return 0;
   if ((r1->declared_family == NULL) != (r2->declared_family == NULL))
     return 0;
@@ -5190,8 +5258,8 @@ hid_serv_acting_as_directory(void)
 
 /** Return true if this node is responsible for storing the descriptor ID
  * in <b>query</b> and false otherwise. */
-int
-hid_serv_responsible_for_desc_id(const char *query)
+MOCK_IMPL(int, hid_serv_responsible_for_desc_id,
+          (const char *query))
 {
   const routerinfo_t *me;
   routerstatus_t *last_rs;
diff --git a/src/or/routerlist.h b/src/or/routerlist.h
index 200533f..dd88aeb 100644
--- a/src/or/routerlist.h
+++ b/src/or/routerlist.h
@@ -50,6 +50,7 @@ const routerstatus_t *router_pick_directory_server(dirinfo_type_t type,
 dir_server_t *router_get_trusteddirserver_by_digest(const char *d);
 dir_server_t *router_get_fallback_dirserver_by_digest(
                                                    const char *digest);
+int router_digest_is_fallback_dir(const char *digest);
 dir_server_t *trusteddirserver_get_by_v3_auth_digest(const char *d);
 const routerstatus_t *router_pick_trusteddirserver(dirinfo_type_t type,
                                                    int flags);
@@ -109,7 +110,7 @@ static int WRA_NEVER_DOWNLOADABLE(was_router_added_t s);
  * was added. It might still be necessary to check whether the descriptor
  * generator should be notified.
  */
-static INLINE int
+static inline int
 WRA_WAS_ADDED(was_router_added_t s) {
   return s == ROUTER_ADDED_SUCCESSFULLY || s == ROUTER_ADDED_NOTIFY_GENERATOR;
 }
@@ -120,7 +121,7 @@ WRA_WAS_ADDED(was_router_added_t s) {
  * - it was outdated.
  * - its certificates were expired.
  */
-static INLINE int WRA_WAS_OUTDATED(was_router_added_t s)
+static inline int WRA_WAS_OUTDATED(was_router_added_t s)
 {
   return (s == ROUTER_WAS_TOO_OLD ||
           s == ROUTER_IS_ALREADY_KNOWN ||
@@ -130,13 +131,13 @@ static INLINE int WRA_WAS_OUTDATED(was_router_added_t s)
 }
 /** Return true iff the outcome code in <b>s</b> indicates that the descriptor
  * was flat-out rejected. */
-static INLINE int WRA_WAS_REJECTED(was_router_added_t s)
+static inline int WRA_WAS_REJECTED(was_router_added_t s)
 {
   return (s == ROUTER_AUTHDIR_REJECTS);
 }
 /** Return true iff the outcome code in <b>s</b> indicates that the descriptor
  * was flat-out rejected. */
-static INLINE int WRA_NEVER_DOWNLOADABLE(was_router_added_t s)
+static inline int WRA_NEVER_DOWNLOADABLE(was_router_added_t s)
 {
   return (s == ROUTER_AUTHDIR_REJECTS ||
           s == ROUTER_BAD_EI ||
@@ -170,10 +171,12 @@ int router_exit_policy_rejects_all(const routerinfo_t *router);
 
 dir_server_t *trusted_dir_server_new(const char *nickname, const char *address,
                        uint16_t dir_port, uint16_t or_port,
+                       const tor_addr_port_t *addrport_ipv6,
                        const char *digest, const char *v3_auth_digest,
                        dirinfo_type_t type, double weight);
 dir_server_t *fallback_dir_server_new(const tor_addr_t *addr,
                                       uint16_t dir_port, uint16_t or_port,
+                                      const tor_addr_port_t *addrport_ipv6,
                                       const char *id_digest, double weight);
 void dir_server_add(dir_server_t *ent);
 
@@ -201,7 +204,7 @@ void refresh_all_country_info(void);
 int hid_serv_get_responsible_directories(smartlist_t *responsible_dirs,
                                          const char *id);
 int hid_serv_acting_as_directory(void);
-int hid_serv_responsible_for_desc_id(const char *id);
+MOCK_DECL(int, hid_serv_responsible_for_desc_id, (const char *id));
 
 void list_pending_microdesc_downloads(digest256map_t *result);
 void launch_descriptor_downloads(int purpose,
@@ -230,6 +233,9 @@ STATIC int choose_array_element_by_weight(const u64_dbl_t *entries,
                                           int n_entries);
 STATIC void scale_array_elements_to_u64(u64_dbl_t *entries, int n_entries,
                                         uint64_t *total_out);
+STATIC const routerstatus_t *router_pick_directory_server_impl(
+                                           dirinfo_type_t auth, int flags,
+                                           int *n_busy_out);
 
 MOCK_DECL(int, router_descriptor_is_older_than, (const routerinfo_t *router,
                                                  int seconds));
diff --git a/src/or/routerparse.c b/src/or/routerparse.c
index f898ef8..fafba96 100644
--- a/src/or/routerparse.c
+++ b/src/or/routerparse.c
@@ -35,8 +35,9 @@
 /****************************************************************************/
 
 /** Enumeration of possible token types.  The ones starting with K_ correspond
- * to directory 'keywords'. ERR_ is an error in the tokenizing process, EOF_
- * is an end-of-file marker, and NIL_ is used to encode not-a-token.
+ * to directory 'keywords'. A_ is for an annotation, R or C is related to
+ * hidden services, ERR_ is an error in the tokenizing process, EOF_ is an
+ * end-of-file marker, and NIL_ is used to encode not-a-token.
  */
 typedef enum {
   K_ACCEPT = 0,
@@ -125,6 +126,7 @@ typedef enum {
   K_DIR_KEY_CERTIFICATION,
   K_DIR_KEY_CROSSCERT,
   K_DIR_ADDRESS,
+  K_DIR_TUNNELLED,
 
   K_VOTE_STATUS,
   K_VALID_AFTER,
@@ -318,6 +320,7 @@ static token_rule_t routerdesc_token_table[] = {
   T0N("opt",                 K_OPT,             CONCAT_ARGS, OBJ_OK ),
   T1( "bandwidth",           K_BANDWIDTH,           GE(3),   NO_OBJ ),
   A01("@purpose",            A_PURPOSE,             GE(1),   NO_OBJ ),
+  T01("tunnelled-dir-server",K_DIR_TUNNELLED,       NO_ARGS, NO_OBJ ),
 
   END_OF_TABLE
 };
@@ -1609,6 +1612,12 @@ router_parse_entry_from_string(const char *s, const char *end,
     router->wants_to_be_hs_dir = 1;
   }
 
+  /* This router accepts tunnelled directory requests via begindir if it has
+   * an open dirport or it included "tunnelled-dir-server". */
+  if (find_opt_by_keyword(tokens, K_DIR_TUNNELLED) || router->dir_port > 0) {
+    router->supports_tunnelled_dir_requests = 1;
+  }
+
   tok = find_by_keyword(tokens, K_ROUTER_SIGNATURE);
   note_crypto_pk_op(VERIFY_RTR);
 #ifdef COUNT_DISTINCT_DIGESTS
@@ -2061,7 +2070,7 @@ authority_cert_parse_from_string(const char *s, const char **end_of_string)
  * object (starting with "r " at the start of a line).  If none is found,
  * return the start of the directory footer, or the next directory signature.
  * If none is found, return the end of the string. */
-static INLINE const char *
+static inline const char *
 find_start_of_next_routerstatus(const char *s)
 {
   const char *eos, *footer, *sig;
@@ -2294,6 +2303,8 @@ routerstatus_parse_entry_from_string(memarea_t *area,
         rs->is_unnamed = 1;
       } else if (!strcmp(tok->args[i], "HSDir")) {
         rs->is_hs_dir = 1;
+      } else if (!strcmp(tok->args[i], "V2Dir")) {
+        rs->is_v2_dir = 1;
       }
     }
   }
@@ -3668,10 +3679,10 @@ networkstatus_parse_detached_signatures(const char *s, const char *eos)
  *
  * Returns NULL on policy errors.
  *
- * If there is a policy error, malformed_list is set to true if the entire
- * policy list should be discarded. Otherwise, it is set to false, and only
- * this item should be ignored - the rest of the policy list can continue to
- * be processed and used.
+ * Set *<b>malformed_list>/b> to true if the entire policy list should be
+ * discarded. Otherwise, set it to false, and only this item should be ignored
+ * on error - the rest of the policy list can continue to be processed and
+ * used.
  *
  * The addr_policy_t returned by this function can have its address set to
  * AF_UNSPEC for '*'.  Use policy_expand_unspec() to turn this into a pair
@@ -3684,8 +3695,8 @@ router_parse_addr_policy_item_from_string,(const char *s, int assume_action,
   directory_token_t *tok = NULL;
   const char *cp, *eos;
   /* Longest possible policy is
-   * "accept6 ffff:ffff:..255/128:10000-65535",
-   * which contains a max-length IPv6 address, plus 24 characters.
+   * "accept6 [ffff:ffff:..255]/128:10000-65535",
+   * which contains a max-length IPv6 address, plus 26 characters.
    * But note that there can be an arbitrary amount of space between the
    * accept and the address:mask/port element.
    * We don't need to multiply TOR_ADDR_BUF_LEN by 2, as there is only one
@@ -3697,9 +3708,12 @@ router_parse_addr_policy_item_from_string,(const char *s, int assume_action,
   memarea_t *area = NULL;
 
   tor_assert(malformed_list);
+  *malformed_list = 0;
 
   s = eat_whitespace(s);
-  if ((*s == '*' || TOR_ISDIGIT(*s)) && assume_action >= 0) {
+  /* We can only do assume_action on []-quoted IPv6, as "a" (accept)
+   * and ":" (port separator) are ambiguous */
+  if ((*s == '*' || *s == '[' || TOR_ISDIGIT(*s)) && assume_action >= 0) {
     if (tor_snprintf(line, sizeof(line), "%s %s",
                assume_action == ADDR_POLICY_ACCEPT?"accept":"reject", s)<0) {
       log_warn(LD_DIR, "Policy %s is too long.", escaped(s));
@@ -3930,7 +3944,7 @@ token_clear(directory_token_t *tok)
  * Return <b>tok</b> on success, or a new ERR_ token if the token didn't
  * conform to the syntax we wanted.
  **/
-static INLINE directory_token_t *
+static inline directory_token_t *
 token_check_object(memarea_t *area, const char *kwd,
                    directory_token_t *tok, obj_syntax o_syn)
 {
@@ -3995,7 +4009,7 @@ token_check_object(memarea_t *area, const char *kwd,
  * number of parsed elements into the n_args field of <b>tok</b>.  Allocate
  * all storage in <b>area</b>.  Return the number of arguments parsed, or
  * return -1 if there was an insanely high number of arguments. */
-static INLINE int
+static inline int
 get_token_arguments(memarea_t *area, directory_token_t *tok,
                     const char *s, const char *eol)
 {
diff --git a/src/or/routerset.c b/src/or/routerset.c
index 3be55d3..debe9ec 100644
--- a/src/or/routerset.c
+++ b/src/or/routerset.c
@@ -107,10 +107,12 @@ routerset_parse(routerset_t *target, const char *s, const char *description)
                   description);
         smartlist_add(target->country_names, countryname);
         added_countries = 1;
-      } else if ((strchr(nick,'.') || strchr(nick, '*')) &&
-                 (p = router_parse_addr_policy_item_from_string(
+      } else if ((strchr(nick,'.') || strchr(nick, ':') ||  strchr(nick, '*'))
+                 && (p = router_parse_addr_policy_item_from_string(
                                      nick, ADDR_POLICY_REJECT,
                                      &malformed_list))) {
+        /* IPv4 addresses contain '.', IPv6 addresses contain ':',
+         * and wildcard addresses contain '*'. */
         log_debug(LD_CONFIG, "Adding address %s to %s", nick, description);
         smartlist_add(target->policies, p);
       } else if (malformed_list) {
diff --git a/src/or/statefile.c b/src/or/statefile.c
index dd1894b..7fe8dc5 100644
--- a/src/or/statefile.c
+++ b/src/or/statefile.c
@@ -9,6 +9,7 @@
 #include "circuitstats.h"
 #include "config.h"
 #include "confparse.h"
+#include "connection.h"
 #include "entrynodes.h"
 #include "hibernate.h"
 #include "rephist.h"
@@ -372,6 +373,12 @@ or_state_load(void)
     new_state = or_state_new();
   } else if (contents) {
     log_info(LD_GENERAL, "Loaded state from \"%s\"", fname);
+    /* Warn the user if their clock has been set backwards,
+     * they could be tricked into using old consensuses */
+    time_t apparent_skew = new_state->LastWritten - time(NULL);
+    if (apparent_skew > 0)
+      clock_skew_warning(NULL, (long)apparent_skew, 1, LD_GENERAL,
+                         "local state file", fname);
   } else {
     log_info(LD_GENERAL, "Initialized state");
   }
diff --git a/src/or/status.c b/src/or/status.c
index 8f7be0a..69d1072 100644
--- a/src/or/status.c
+++ b/src/or/status.c
@@ -164,24 +164,38 @@ log_accounting(const time_t now, const or_options_t *options)
   or_state_t *state = get_or_state();
   char *acc_rcvd = bytes_to_usage(state->AccountingBytesReadInInterval);
   char *acc_sent = bytes_to_usage(state->AccountingBytesWrittenInInterval);
+  char *acc_used = bytes_to_usage(get_accounting_bytes());
   uint64_t acc_bytes = options->AccountingMax;
   char *acc_max;
   time_t interval_end = accounting_get_end_time();
   char end_buf[ISO_TIME_LEN + 1];
   char *remaining = NULL;
-  if (options->AccountingRule == ACCT_SUM)
-    acc_bytes *= 2;
   acc_max = bytes_to_usage(acc_bytes);
   format_local_iso_time(end_buf, interval_end);
   remaining = secs_to_uptime(interval_end - now);
 
+  const char *acc_rule;
+  switch (options->AccountingRule) {
+    case ACCT_MAX: acc_rule = "max";
+    break;
+    case ACCT_SUM: acc_rule = "sum";
+    break;
+    case ACCT_OUT: acc_rule = "out";
+    break;
+    case ACCT_IN: acc_rule = "in";
+    break;
+    default: acc_rule = "max";
+    break;
+  }
+
   log_notice(LD_HEARTBEAT, "Heartbeat: Accounting enabled. "
-      "Sent: %s / %s, Received: %s / %s. The "
+      "Sent: %s, Received: %s, Used: %s / %s, Rule: %s. The "
       "current accounting interval ends on %s, in %s.",
-      acc_sent, acc_max, acc_rcvd, acc_max, end_buf, remaining);
+      acc_sent, acc_rcvd, acc_used, acc_max, acc_rule, end_buf, remaining);
 
   tor_free(acc_rcvd);
   tor_free(acc_sent);
+  tor_free(acc_used);
   tor_free(acc_max);
   tor_free(remaining);
 }
diff --git a/src/or/torcert.c b/src/or/torcert.c
index 596cd2b..ef5b4c0 100644
--- a/src/or/torcert.c
+++ b/src/or/torcert.c
@@ -206,7 +206,11 @@ tor_cert_checksig(tor_cert_t *cert,
     return -1;
   } else {
     cert->sig_ok = 1;
-    memcpy(cert->signing_key.pubkey, checkable.pubkey->pubkey, 32);
+    /* Only copy the checkable public key when it is different from the signing
+     * key of the certificate to avoid undefined behavior. */
+    if (cert->signing_key.pubkey != checkable.pubkey->pubkey) {
+      memcpy(cert->signing_key.pubkey, checkable.pubkey->pubkey, 32);
+    }
     cert->cert_valid = 1;
     return 0;
   }
diff --git a/src/or/transports.c b/src/or/transports.c
index ba2c784..5a3af85 100644
--- a/src/or/transports.c
+++ b/src/or/transports.c
@@ -105,7 +105,7 @@
 static process_environment_t *
 create_managed_proxy_environment(const managed_proxy_t *mp);
 
-static INLINE int proxy_configuration_finished(const managed_proxy_t *mp);
+static inline int proxy_configuration_finished(const managed_proxy_t *mp);
 
 static void handle_finished_proxy(managed_proxy_t *mp);
 static void parse_method_error(const char *line, int is_server_method);
@@ -713,7 +713,7 @@ register_client_proxy(const managed_proxy_t *mp)
 }
 
 /** Register the transports of managed proxy <b>mp</b>. */
-static INLINE void
+static inline void
 register_proxy(const managed_proxy_t *mp)
 {
   if (mp->is_server)
@@ -828,7 +828,7 @@ handle_finished_proxy(managed_proxy_t *mp)
 
 /** Return true if the configuration of the managed proxy <b>mp</b> is
     finished. */
-static INLINE int
+static inline int
 proxy_configuration_finished(const managed_proxy_t *mp)
 {
   return (mp->conf_state == PT_PROTO_CONFIGURED ||
@@ -1100,7 +1100,7 @@ parse_smethod_line(const char *line, managed_proxy_t *mp)
 
   smartlist_add(mp->transports, transport);
 
-  /* For now, notify the user so that he knows where the server
+  /* For now, notify the user so that they know where the server
      transport is listening. */
   log_info(LD_CONFIG, "Server transport %s at %s:%d.",
            method_name, address, (int)port);
diff --git a/src/test/Makefile.nmake b/src/test/Makefile.nmake
index 0435617..0ba56d7 100644
--- a/src/test/Makefile.nmake
+++ b/src/test/Makefile.nmake
@@ -14,7 +14,8 @@ LIBS = ..\..\..\build-alpha\lib\libevent.lib \
 TEST_OBJECTS = test.obj test_addr.obj test_channel.obj test_channeltls.obj \
         test_containers.obj \
 	test_controller_events.obj test_crypto.obj test_data.obj test_dir.obj \
-	test_checkdir.obj test_microdesc.obj test_pt.obj test_util.obj test_config.obj \
+	test_checkdir.obj test_microdesc.obj test_pt.obj test_util.obj \
+        test_config.obj test_connection.obj \
 	test_cell_formats.obj test_relay.obj test_replay.obj \
 	test_scheduler.obj test_introduce.obj test_hs.obj tinytest.obj
 
diff --git a/src/test/bench.c b/src/test/bench.c
index 2a27377..1ef5404 100644
--- a/src/test/bench.c
+++ b/src/test/bench.c
@@ -443,6 +443,45 @@ bench_siphash(void)
 }
 
 static void
+bench_digest(void)
+{
+  char buf[8192];
+  char out[DIGEST512_LEN];
+  const int lens[] = { 1, 16, 32, 64, 128, 512, 1024, 2048, -1 };
+  const int N = 300000;
+  uint64_t start, end;
+  crypto_rand(buf, sizeof(buf));
+
+  for (int alg = 0; alg < N_DIGEST_ALGORITHMS; alg++) {
+    for (int i = 0; lens[i] > 0; ++i) {
+      reset_perftime();
+      start = perftime();
+      for (int j = 0; j < N; ++j) {
+        switch (alg) {
+          case DIGEST_SHA1:
+            crypto_digest(out, buf, lens[i]);
+            break;
+          case DIGEST_SHA256:
+          case DIGEST_SHA3_256:
+            crypto_digest256(out, buf, lens[i], alg);
+            break;
+          case DIGEST_SHA512:
+          case DIGEST_SHA3_512:
+            crypto_digest512(out, buf, lens[i], alg);
+            break;
+          default:
+            tor_assert(0);
+        }
+      }
+      end = perftime();
+      printf("%s(%d): %.2f ns per call\n",
+             crypto_digest_algorithm_get_name(alg),
+             lens[i], NANOCOUNT(start,end,N));
+    }
+  }
+}
+
+static void
 bench_cell_ops(void)
 {
   const int iters = 1<<16;
@@ -589,6 +628,7 @@ typedef struct benchmark_t {
 static struct benchmark_t benchmarks[] = {
   ENT(dmap),
   ENT(siphash),
+  ENT(digest),
   ENT(aes),
   ENT(onion_TAP),
   ENT(onion_ntor),
@@ -643,7 +683,10 @@ main(int argc, const char **argv)
 
   reset_perftime();
 
-  crypto_seed_rng();
+  if (crypto_seed_rng() < 0) {
+    printf("Couldn't seed RNG; exiting.\n");
+    return 1;
+  }
   crypto_init_siphash_key();
   options = options_new();
   init_logging(1);
diff --git a/src/test/bt_test.py b/src/test/bt_test.py
index e694361..dab02d7 100755
--- a/src/test/bt_test.py
+++ b/src/test/bt_test.py
@@ -15,6 +15,7 @@ OK
 
 """
 
+from __future__ import print_function
 import sys
 
 
@@ -37,6 +38,8 @@ for I in range(len(LINES)):
     if matches(LINES[I:], FUNCNAMES):
         print("OK")
         sys.exit(0)
-else:
-    print("BAD")
-    sys.exit(1)
+
+for l in LINES:
+    print("{}".format(l), end="")
+
+sys.exit(1)
diff --git a/src/test/include.am b/src/test/include.am
index a37fe23..786fb77 100644
--- a/src/test/include.am
+++ b/src/test/include.am
@@ -1,17 +1,23 @@
-
-export PYTHON=@PYTHON@
-export SHELL=@SHELL@
-export abs_top_srcdir=@abs_top_srcdir@
-export builddir=@builddir@
-
-TESTSCRIPTS = src/test/test_zero_length_keys.sh
+# When the day comes that Tor requires Automake >= 1.12 change
+# TESTS_ENVIRONMENT to AM_TESTS_ENVIRONMENT because the former is reserved for
+# users while the later is reserved for developers.
+TESTS_ENVIRONMENT = \
+	export PYTHON="$(PYTHON)"; \
+	export SHELL="$(SHELL)"; \
+	export abs_top_srcdir="$(abs_top_srcdir)"; \
+	export builddir="$(builddir)"; \
+	export TESTING_TOR_BINARY="$(TESTING_TOR_BINARY)";
+
+TESTSCRIPTS = src/test/test_zero_length_keys.sh \
+	src/test/test_switch_id.sh
 
 if USEPYTHON
 TESTSCRIPTS += src/test/test_ntor.sh src/test/test_bt.sh
 endif
 
 TESTS += src/test/test src/test/test-slow src/test/test-memwipe \
-	src/test/test_workqueue src/test/test_keygen.sh $(TESTSCRIPTS)
+	src/test/test_workqueue src/test/test_keygen.sh \
+	$(TESTSCRIPTS)
 
 # These flavors are run using automake's test-driver and test-network.sh
 TEST_CHUTNEY_FLAVORS = basic-min bridges-min hs-min bridges+hs
@@ -33,7 +39,8 @@ noinst_PROGRAMS+= \
 	src/test/test-slow \
 	src/test/test-memwipe \
 	src/test/test-child \
-	src/test/test_workqueue
+	src/test/test_workqueue \
+	src/test/test-switch-id
 endif
 
 src_test_AM_CPPFLAGS = -DSHARE_DATADIR="\"$(datadir)\"" \
@@ -49,6 +56,8 @@ src_test_AM_CPPFLAGS = -DSHARE_DATADIR="\"$(datadir)\"" \
 # matters a lot there, and is quite hard to debug if you forget to do it.
 
 src_test_test_SOURCES = \
+	src/test/log_test_helpers.c \
+	src/test/rend_test_helpers.c \
 	src/test/test.c \
 	src/test/test_accounting.c \
 	src/test/test_addr.c \
@@ -61,13 +70,17 @@ src_test_test_SOURCES = \
 	src/test/test_checkdir.c \
 	src/test/test_circuitlist.c \
 	src/test/test_circuitmux.c \
+	src/test/test_compat_libevent.c \
 	src/test/test_config.c \
+	src/test/test_connection.c \
 	src/test/test_containers.c \
 	src/test/test_controller.c \
 	src/test/test_controller_events.c \
 	src/test/test_crypto.c \
 	src/test/test_data.c \
 	src/test/test_dir.c \
+	src/test/test_dir_common.c \
+	src/test/test_dir_handle_get.c \
 	src/test/test_entryconn.c \
 	src/test/test_entrynodes.c \
 	src/test/test_guardfraction.c \
@@ -82,9 +95,11 @@ src_test_test_SOURCES = \
 	src/test/test_oom.c \
 	src/test/test_options.c \
 	src/test/test_policy.c \
+	src/test/test_procmon.c \
 	src/test/test_pt.c \
 	src/test/test_relay.c \
 	src/test/test_relaycell.c \
+	src/test/test_rendcache.c \
 	src/test/test_replay.c \
 	src/test/test_routerkeys.c \
 	src/test/test_routerlist.c \
@@ -93,9 +108,12 @@ src_test_test_SOURCES = \
 	src/test/test_socks.c \
 	src/test/test_status.c \
 	src/test/test_threads.c \
+	src/test/test_tortls.c \
 	src/test/test_util.c \
+	src/test/test_util_format.c \
+	src/test/test_util_process.c \
 	src/test/test_helpers.c \
-        src/test/test_dns.c \
+	src/test/test_dns.c \
 	src/test/testing_common.c \
 	src/ext/tinytest.c
 
@@ -122,11 +140,21 @@ src_test_test_workqueue_SOURCES = \
 src_test_test_workqueue_CPPFLAGS= $(src_test_AM_CPPFLAGS)
 src_test_test_workqueue_CFLAGS = $(AM_CFLAGS) $(TEST_CFLAGS)
 
+src_test_test_switch_id_SOURCES = \
+	src/test/test_switch_id.c
+src_test_test_switch_id_CPPFLAGS= $(src_test_AM_CPPFLAGS)
+src_test_test_switch_id_CFLAGS = $(AM_CFLAGS) $(TEST_CFLAGS)
+src_test_test_switch_id_LDFLAGS = @TOR_LDFLAGS_zlib@
+src_test_test_switch_id_LDADD = \
+	src/common/libor-testing.a \
+	@TOR_ZLIB_LIBS@ @TOR_LIB_MATH@
+
 src_test_test_LDFLAGS = @TOR_LDFLAGS_zlib@ @TOR_LDFLAGS_openssl@ \
         @TOR_LDFLAGS_libevent@
 src_test_test_LDADD = src/or/libtor-testing.a src/common/libor-testing.a \
-	src/common/libor-crypto-testing.a $(LIBDONNA) src/common/libor.a \
-	src/common/libor-event-testing.a src/trunnel/libor-trunnel-testing.a \
+	src/common/libor-crypto-testing.a $(LIBKECCAK_TINY) $(LIBDONNA) \
+	src/common/libor.a src/common/libor-event-testing.a \
+	src/trunnel/libor-trunnel-testing.a \
 	@TOR_ZLIB_LIBS@ @TOR_LIB_MATH@ @TOR_LIBEVENT_LIBS@ \
 	@TOR_OPENSSL_LIBS@ @TOR_LIB_WS32@ @TOR_LIB_GDI@ @CURVE25519_LIBS@ \
 	@TOR_SYSTEMD_LIBS@
@@ -144,7 +172,7 @@ src_test_test_memwipe_LDFLAGS = $(src_test_test_LDFLAGS)
 src_test_bench_LDFLAGS = @TOR_LDFLAGS_zlib@ @TOR_LDFLAGS_openssl@ \
         @TOR_LDFLAGS_libevent@
 src_test_bench_LDADD = src/or/libtor.a src/common/libor.a \
-	src/common/libor-crypto.a $(LIBDONNA) \
+	src/common/libor-crypto.a $(LIBKECCAK_TINY) $(LIBDONNA) \
 	src/common/libor-event.a src/trunnel/libor-trunnel.a \
 	@TOR_ZLIB_LIBS@ @TOR_LIB_MATH@ @TOR_LIBEVENT_LIBS@ \
 	@TOR_OPENSSL_LIBS@ @TOR_LIB_WS32@ @TOR_LIB_GDI@ @CURVE25519_LIBS@ \
@@ -154,26 +182,30 @@ src_test_test_workqueue_LDFLAGS = @TOR_LDFLAGS_zlib@ @TOR_LDFLAGS_openssl@ \
         @TOR_LDFLAGS_libevent@
 src_test_test_workqueue_LDADD = src/or/libtor-testing.a \
 	src/common/libor-testing.a \
-	src/common/libor-crypto-testing.a $(LIBDONNA) \
+	src/common/libor-crypto-testing.a $(LIBKECCAK_TINY) $(LIBDONNA) \
 	src/common/libor-event-testing.a \
 	@TOR_ZLIB_LIBS@ @TOR_LIB_MATH@ @TOR_LIBEVENT_LIBS@ \
 	@TOR_OPENSSL_LIBS@ @TOR_LIB_WS32@ @TOR_LIB_GDI@ @CURVE25519_LIBS@
 
 noinst_HEADERS+= \
 	src/test/fakechans.h \
+	src/test/log_test_helpers.h \
+	src/test/rend_test_helpers.h \
 	src/test/test.h \
 	src/test/test_helpers.h \
+	src/test/test_dir_common.h \
 	src/test/test_descriptors.inc \
 	src/test/example_extrainfo.inc \
 	src/test/failing_routerdescs.inc \
 	src/test/ed25519_vectors.inc \
-	src/test/test_descriptors.inc
+	src/test/test_descriptors.inc \
+	src/test/vote_descriptors.inc
 
 noinst_PROGRAMS+= src/test/test-ntor-cl
 src_test_test_ntor_cl_SOURCES  = src/test/test_ntor_cl.c
 src_test_test_ntor_cl_LDFLAGS = @TOR_LDFLAGS_zlib@ @TOR_LDFLAGS_openssl@
 src_test_test_ntor_cl_LDADD = src/or/libtor.a src/common/libor.a \
-	src/common/libor-crypto.a $(LIBDONNA) \
+	src/common/libor-crypto.a $(LIBKECCAK_TINY) $(LIBDONNA) \
 	@TOR_ZLIB_LIBS@ @TOR_LIB_MATH@ \
 	@TOR_OPENSSL_LIBS@ @TOR_LIB_WS32@ @TOR_LIB_GDI@ @CURVE25519_LIBS@
 src_test_test_ntor_cl_AM_CPPFLAGS =	       \
@@ -195,4 +227,5 @@ EXTRA_DIST += \
 	src/test/test_keygen.sh \
         src/test/test_zero_length_keys.sh \
         src/test/test_ntor.sh src/test/test_bt.sh \
-	src/test/test-network.sh
+	src/test/test-network.sh \
+	src/test/test_switch_id.sh
diff --git a/src/test/log_test_helpers.c b/src/test/log_test_helpers.c
new file mode 100644
index 0000000..bcf73a8
--- /dev/null
+++ b/src/test/log_test_helpers.c
@@ -0,0 +1,113 @@
+/* Copyright (c) 2015, The Tor Project, Inc. */
+/* See LICENSE for licensing information */
+#define LOG_PRIVATE
+#include "torlog.h"
+#include "log_test_helpers.h"
+
+static smartlist_t *saved_logs = NULL;
+
+int
+setup_capture_of_logs(int new_level)
+{
+  int previous_log = log_global_min_severity_;
+  log_global_min_severity_ = new_level;
+  mock_clean_saved_logs();
+  MOCK(logv, mock_saving_logv);
+  return previous_log;
+}
+
+void
+teardown_capture_of_logs(int prev)
+{
+  UNMOCK(logv);
+  log_global_min_severity_ = prev;
+  mock_clean_saved_logs();
+}
+
+void
+mock_clean_saved_logs(void)
+{
+  if (!saved_logs)
+    return;
+  SMARTLIST_FOREACH(saved_logs, mock_saved_log_entry_t *, m,
+                    { tor_free(m->generated_msg); tor_free(m); });
+  smartlist_free(saved_logs);
+  saved_logs = NULL;
+}
+
+const smartlist_t *
+mock_saved_logs(void)
+{
+  return saved_logs;
+}
+
+int
+mock_saved_log_has_message(const char *msg)
+{
+  int has_msg = 0;
+  if (saved_logs) {
+    SMARTLIST_FOREACH(saved_logs, mock_saved_log_entry_t *, m,
+                      {
+                        if (msg && m->generated_msg &&
+                            !strcmp(msg, m->generated_msg)) {
+                          has_msg = 1;
+                        }
+                      });
+  }
+
+  return has_msg;
+}
+
+/* Do the saved logs have any messages with severity? */
+int
+mock_saved_log_has_severity(int severity)
+{
+  int has_sev = 0;
+  if (saved_logs) {
+    SMARTLIST_FOREACH(saved_logs, mock_saved_log_entry_t *, m,
+                      {
+                        if (m->severity == severity) {
+                          has_sev = 1;
+                        }
+                      });
+  }
+
+  return has_sev;
+}
+
+/* Do the saved logs have any messages? */
+int
+mock_saved_log_has_entry(void)
+{
+  if (saved_logs) {
+    return smartlist_len(saved_logs) > 0;
+  }
+  return 0;
+}
+
+void
+mock_saving_logv(int severity, log_domain_mask_t domain,
+                 const char *funcname, const char *suffix,
+                 const char *format, va_list ap)
+{
+  (void)domain;
+  char *buf = tor_malloc_zero(10240);
+  int n;
+  n = tor_vsnprintf(buf,10240,format,ap);
+  tor_assert(n < 10240-1);
+  buf[n]='\n';
+  buf[n+1]='\0';
+
+  mock_saved_log_entry_t *e = tor_malloc_zero(sizeof(mock_saved_log_entry_t));
+  e->severity = severity;
+  e->funcname = funcname;
+  e->suffix = suffix;
+  e->format = format;
+  e->generated_msg = tor_strdup(buf);
+  tor_free(buf);
+
+  if (!saved_logs)
+    saved_logs = smartlist_new();
+  smartlist_add(saved_logs, e);
+}
+
diff --git a/src/test/log_test_helpers.h b/src/test/log_test_helpers.h
new file mode 100644
index 0000000..298237d
--- /dev/null
+++ b/src/test/log_test_helpers.h
@@ -0,0 +1,55 @@
+/* Copyright (c) 2014-2015, The Tor Project, Inc. */
+/* See LICENSE for licensing information */
+
+#include "or.h"
+
+#ifndef TOR_LOG_TEST_HELPERS_H
+#define TOR_LOG_TEST_HELPERS_H
+
+typedef struct mock_saved_log_entry_t {
+  int severity;
+  const char *funcname;
+  const char *suffix;
+  const char *format;
+  char *generated_msg;
+  struct mock_saved_log_entry_t *next;
+} mock_saved_log_entry_t;
+
+void mock_saving_logv(int severity, log_domain_mask_t domain,
+                      const char *funcname, const char *suffix,
+                      const char *format, va_list ap)
+  CHECK_PRINTF(5, 0);
+void mock_clean_saved_logs(void);
+const smartlist_t *mock_saved_logs(void);
+int setup_capture_of_logs(int new_level);
+void teardown_capture_of_logs(int prev);
+int mock_saved_log_has_message(const char *msg);
+int mock_saved_log_has_severity(int severity);
+int mock_saved_log_has_entry(void);
+
+#define expect_log_msg(str) \
+  tt_assert_msg(mock_saved_log_has_message(str), \
+                "expected log to contain " # str);
+
+#define expect_no_log_msg(str) \
+  tt_assert_msg(!mock_saved_log_has_message(str), \
+                "expected log to not contain " # str);
+
+#define expect_log_severity(severity) \
+  tt_assert_msg(mock_saved_log_has_severity(severity), \
+                "expected log to contain severity " # severity);
+
+#define expect_no_log_severity(severity) \
+  tt_assert_msg(!mock_saved_log_has_severity(severity), \
+                "expected log to not contain severity " # severity);
+
+#define expect_log_entry() \
+  tt_assert_msg(mock_saved_log_has_entry(), \
+                "expected log to contain entries");
+
+#define expect_no_log_entry() \
+  tt_assert_msg(!mock_saved_log_has_entry(), \
+                "expected log to not contain entries");
+
+#endif
+
diff --git a/src/test/rend_test_helpers.c b/src/test/rend_test_helpers.c
new file mode 100644
index 0000000..f16d67f
--- /dev/null
+++ b/src/test/rend_test_helpers.c
@@ -0,0 +1,73 @@
+/* Copyright (c) 2014-2015, The Tor Project, Inc. */
+/* See LICENSE for licensing information */
+
+#include "or.h"
+#include "test.h"
+#include "rendcommon.h"
+#include "rend_test_helpers.h"
+
+void
+generate_desc(int time_diff, rend_encoded_v2_service_descriptor_t **desc,
+              char **service_id, int intro_points)
+{
+  rend_service_descriptor_t *generated = NULL;
+  smartlist_t *descs = smartlist_new();
+  time_t now;
+
+  now = time(NULL) + time_diff;
+  create_descriptor(&generated, service_id, intro_points);
+  generated->timestamp = now;
+
+  rend_encode_v2_descriptors(descs, generated, now, 0, REND_NO_AUTH, NULL,
+                             NULL);
+  tor_assert(smartlist_len(descs) > 1);
+  *desc = smartlist_get(descs, 0);
+  smartlist_set(descs, 0, NULL);
+
+  SMARTLIST_FOREACH(descs, rend_encoded_v2_service_descriptor_t *, d,
+                    rend_encoded_v2_service_descriptor_free(d));
+  smartlist_free(descs);
+  rend_service_descriptor_free(generated);
+}
+
+void
+create_descriptor(rend_service_descriptor_t **generated, char **service_id,
+                  int intro_points)
+{
+  crypto_pk_t *pk1 = NULL;
+  crypto_pk_t *pk2 = NULL;
+  int i;
+
+  *service_id = tor_malloc(REND_SERVICE_ID_LEN_BASE32+1);
+  pk1 = pk_generate(0);
+  pk2 = pk_generate(1);
+
+  *generated = tor_malloc_zero(sizeof(rend_service_descriptor_t));
+  (*generated)->pk = crypto_pk_dup_key(pk1);
+  rend_get_service_id((*generated)->pk, *service_id);
+
+  (*generated)->version = 2;
+  (*generated)->protocols = 42;
+  (*generated)->intro_nodes = smartlist_new();
+
+  for (i = 0; i < intro_points; i++) {
+    rend_intro_point_t *intro = tor_malloc_zero(sizeof(rend_intro_point_t));
+    crypto_pk_t *okey = pk_generate(2 + i);
+    intro->extend_info = tor_malloc_zero(sizeof(extend_info_t));
+    intro->extend_info->onion_key = okey;
+    crypto_pk_get_digest(intro->extend_info->onion_key,
+                         intro->extend_info->identity_digest);
+    intro->extend_info->nickname[0] = '$';
+    base16_encode(intro->extend_info->nickname + 1,
+                  sizeof(intro->extend_info->nickname) - 1,
+                  intro->extend_info->identity_digest, DIGEST_LEN);
+    tor_addr_from_ipv4h(&intro->extend_info->addr, crypto_rand_int(65536));
+    intro->extend_info->port = 1 + crypto_rand_int(65535);
+    intro->intro_key = crypto_pk_dup_key(pk2);
+    smartlist_add((*generated)->intro_nodes, intro);
+  }
+
+  crypto_pk_free(pk1);
+  crypto_pk_free(pk2);
+}
+
diff --git a/src/test/rend_test_helpers.h b/src/test/rend_test_helpers.h
new file mode 100644
index 0000000..1ef0374
--- /dev/null
+++ b/src/test/rend_test_helpers.h
@@ -0,0 +1,15 @@
+/* Copyright (c) 2014-2015, The Tor Project, Inc. */
+/* See LICENSE for licensing information */
+
+#include "or.h"
+
+#ifndef TOR_REND_TEST_HELPERS_H
+#define TOR_REND_TEST_HELPERS_H
+
+void generate_desc(int time_diff, rend_encoded_v2_service_descriptor_t **desc,
+                   char **service_id, int intro_points);
+void create_descriptor(rend_service_descriptor_t **generated,
+                       char **service_id, int intro_points);
+
+#endif
+
diff --git a/src/test/test-memwipe.c b/src/test/test-memwipe.c
index a39bad1..5d4fcec 100644
--- a/src/test/test-memwipe.c
+++ b/src/test/test-memwipe.c
@@ -62,7 +62,7 @@ fill_a_buffer_nothing(void)
   return sum;
 }
 
-static INLINE int
+static inline int
 vmemeq(volatile char *a, const char *b, size_t n)
 {
   while (n--) {
diff --git a/src/test/test.c b/src/test/test.c
index e10e260..d671ac8 100644
--- a/src/test/test.c
+++ b/src/test/test.c
@@ -28,6 +28,7 @@
 #define ROUTER_PRIVATE
 #define CIRCUITSTATS_PRIVATE
 #define CIRCUITLIST_PRIVATE
+#define MAIN_PRIVATE
 #define STATEFILE_PRIVATE
 
 /*
@@ -47,8 +48,10 @@ double fabs(double x);
 #include "connection_edge.h"
 #include "geoip.h"
 #include "rendcommon.h"
+#include "rendcache.h"
 #include "test.h"
 #include "torgzip.h"
+#include "main.h"
 #include "memarea.h"
 #include "onion.h"
 #include "onion_ntor.h"
@@ -316,6 +319,9 @@ test_circuit_timeout(void *arg)
   int i, runs;
   double close_ms;
   (void)arg;
+
+  initialize_periodic_events();
+
   circuit_build_times_init(&initial);
   circuit_build_times_init(&estimate);
   circuit_build_times_init(&final);
@@ -455,6 +461,7 @@ test_circuit_timeout(void *arg)
   circuit_build_times_free_timeouts(&estimate);
   circuit_build_times_free_timeouts(&final);
   or_state_free(state);
+  teardown_periodic_events();
 }
 
 /** Test encoding and parsing of rendezvous service descriptors. */
@@ -494,6 +501,9 @@ test_rend_fns(void *arg)
   tt_str_op(address6,OP_EQ, "abcdefghijklmnop");
   tt_assert(BAD_HOSTNAME == parse_extended_hostname(address7));
 
+  /* Initialize the service cache. */
+  rend_cache_init();
+
   pk1 = pk_generate(0);
   pk2 = pk_generate(1);
   generated = tor_malloc_zero(sizeof(rend_service_descriptor_t));
@@ -1105,8 +1115,8 @@ static struct testcase_t test_array[] = {
   { "bad_onion_handshake", test_bad_onion_handshake, 0, NULL, NULL },
   ENT(onion_queues),
   { "ntor_handshake", test_ntor_handshake, 0, NULL, NULL },
-  ENT(circuit_timeout),
-  ENT(rend_fns),
+  FORK(circuit_timeout),
+  FORK(rend_fns),
   ENT(geoip),
   FORK(geoip_with_pt),
   FORK(stats),
@@ -1125,12 +1135,15 @@ extern struct testcase_t channeltls_tests[];
 extern struct testcase_t checkdir_tests[];
 extern struct testcase_t circuitlist_tests[];
 extern struct testcase_t circuitmux_tests[];
+extern struct testcase_t compat_libevent_tests[];
 extern struct testcase_t config_tests[];
+extern struct testcase_t connection_tests[];
 extern struct testcase_t container_tests[];
 extern struct testcase_t controller_tests[];
 extern struct testcase_t controller_event_tests[];
 extern struct testcase_t crypto_tests[];
 extern struct testcase_t dir_tests[];
+extern struct testcase_t dir_handle_get_tests[];
 extern struct testcase_t entryconn_tests[];
 extern struct testcase_t entrynodes_tests[];
 extern struct testcase_t guardfraction_tests[];
@@ -1145,9 +1158,11 @@ extern struct testcase_t nodelist_tests[];
 extern struct testcase_t oom_tests[];
 extern struct testcase_t options_tests[];
 extern struct testcase_t policy_tests[];
+extern struct testcase_t procmon_tests[];
 extern struct testcase_t pt_tests[];
 extern struct testcase_t relay_tests[];
 extern struct testcase_t relaycell_tests[];
+extern struct testcase_t rend_cache_tests[];
 extern struct testcase_t replaycache_tests[];
 extern struct testcase_t router_tests[];
 extern struct testcase_t routerkeys_tests[];
@@ -1157,7 +1172,10 @@ extern struct testcase_t scheduler_tests[];
 extern struct testcase_t socks_tests[];
 extern struct testcase_t status_tests[];
 extern struct testcase_t thread_tests[];
+extern struct testcase_t tortls_tests[];
 extern struct testcase_t util_tests[];
+extern struct testcase_t util_format_tests[];
+extern struct testcase_t util_process_tests[];
 extern struct testcase_t dns_tests[];
 
 struct testgroup_t testgroups[] = {
@@ -1173,12 +1191,15 @@ struct testgroup_t testgroups[] = {
   { "checkdir/", checkdir_tests },
   { "circuitlist/", circuitlist_tests },
   { "circuitmux/", circuitmux_tests },
+  { "compat/libevent/", compat_libevent_tests },
   { "config/", config_tests },
+  { "connection/", connection_tests },
   { "container/", container_tests },
   { "control/", controller_tests },
   { "control/event/", controller_event_tests },
   { "crypto/", crypto_tests },
   { "dir/", dir_tests },
+  { "dir_handle_get/", dir_handle_get_tests },
   { "dir/md/", microdesc_tests },
   { "entryconn/", entryconn_tests },
   { "entrynodes/", entrynodes_tests },
@@ -1192,9 +1213,11 @@ struct testgroup_t testgroups[] = {
   { "oom/", oom_tests },
   { "options/", options_tests },
   { "policy/" , policy_tests },
+  { "procmon/", procmon_tests },
   { "pt/", pt_tests },
   { "relay/" , relay_tests },
   { "relaycell/", relaycell_tests },
+  { "rend_cache/", rend_cache_tests },
   { "replaycache/", replaycache_tests },
   { "routerkeys/", routerkeys_tests },
   { "routerlist/", routerlist_tests },
@@ -1202,8 +1225,11 @@ struct testgroup_t testgroups[] = {
   { "scheduler/", scheduler_tests },
   { "socks/", socks_tests },
   { "status/" , status_tests },
+  { "tortls/", tortls_tests },
   { "util/", util_tests },
+  { "util/format/", util_format_tests },
   { "util/logging/", logging_tests },
+  { "util/process/", util_process_tests },
   { "util/thread/", thread_tests },
   { "dns/", dns_tests },
   END_OF_GROUPS
diff --git a/src/test/test_accounting.c b/src/test/test_accounting.c
index 25908e9..7edba98 100644
--- a/src/test/test_accounting.c
+++ b/src/test/test_accounting.c
@@ -61,6 +61,32 @@ test_accounting_limits(void *arg)
   fake_time += 1;
   consider_hibernation(fake_time);
   tor_assert(we_are_hibernating() == 1);
+
+  options->AccountingRule = ACCT_OUT;
+
+  accounting_add_bytes(100, 10, 1);
+  fake_time += 1;
+  consider_hibernation(fake_time);
+  tor_assert(we_are_hibernating() == 0);
+
+  accounting_add_bytes(0, 90, 1);
+  fake_time += 1;
+  consider_hibernation(fake_time);
+  tor_assert(we_are_hibernating() == 1);
+
+  options->AccountingMax = 300;
+  options->AccountingRule = ACCT_IN;
+
+  accounting_add_bytes(10, 100, 1);
+  fake_time += 1;
+  consider_hibernation(fake_time);
+  tor_assert(we_are_hibernating() == 0);
+
+  accounting_add_bytes(90, 0, 1);
+  fake_time += 1;
+  consider_hibernation(fake_time);
+  tor_assert(we_are_hibernating() == 1);
+
   goto done;
  done:
   NS_UNMOCK(get_or_state);
diff --git a/src/test/test_addr.c b/src/test/test_addr.c
index 2c25c1e..85130db 100644
--- a/src/test/test_addr.c
+++ b/src/test/test_addr.c
@@ -302,6 +302,7 @@ test_addr_ip6_helpers(void *arg)
 
   //test_ntop6_reduces("0:0:0:0:0:0:c0a8:0101", "::192.168.1.1");
   test_ntop6_reduces("0:0:0:0:0:ffff:c0a8:0101", "::ffff:192.168.1.1");
+  test_ntop6_reduces("0:0:0:0:0:0:c0a8:0101", "::192.168.1.1");
   test_ntop6_reduces("002:0:0000:0:3::4", "2::3:0:0:4");
   test_ntop6_reduces("0:0::1:0:3", "::1:0:3");
   test_ntop6_reduces("008:0::0", "8::");
diff --git a/src/test/test_address.c b/src/test/test_address.c
index 3e73c3e..3b17b23 100644
--- a/src/test/test_address.c
+++ b/src/test/test_address.c
@@ -119,6 +119,21 @@ smartlist_contains_internal_tor_addr(smartlist_t *smartlist)
 }
 
 /** Return 1 iff <b>smartlist</b> contains a tor_addr_t structure
+ * that is NULL or the null tor_addr_t. Otherwise, return 0.
+ */
+static int
+smartlist_contains_null_tor_addr(smartlist_t *smartlist)
+{
+  SMARTLIST_FOREACH_BEGIN(smartlist, tor_addr_t *, tor_addr) {
+    if (tor_addr == NULL || tor_addr_is_null(tor_addr)) {
+      return 1;
+    }
+  } SMARTLIST_FOREACH_END(tor_addr);
+
+  return 0;
+}
+
+/** Return 1 iff <b>smartlist</b> contains a tor_addr_t structure
  * that is an IPv4 address. Otherwise, return 0.
  */
 static int
@@ -205,7 +220,7 @@ test_address_ifaddrs_to_smartlist(void *arg)
    ifa_ipv6->ifa_dstaddr = NULL;
    ifa_ipv6->ifa_data = NULL;
 
-   smartlist = ifaddrs_to_smartlist(ifa);
+   smartlist = ifaddrs_to_smartlist(ifa, AF_UNSPEC);
 
    tt_assert(smartlist);
    tt_assert(smartlist_len(smartlist) == 3);
@@ -266,10 +281,20 @@ test_address_get_if_addrs_ifaddrs(void *arg)
 
   (void)arg;
 
-  results = get_interface_addresses_ifaddrs(LOG_ERR);
+  results = get_interface_addresses_ifaddrs(LOG_ERR, AF_UNSPEC);
 
-  tt_int_op(smartlist_len(results),>=,1);
-  tt_assert(smartlist_contains_localhost_tor_addr(results));
+  tt_assert(results);
+  /* Some FreeBSD jails don't have localhost IP address. Instead, they only
+   * have the address assigned to the jail (whatever that may be).
+   * And a jail without a network connection might not have any addresses at
+   * all. */
+  tt_assert(!smartlist_contains_null_tor_addr(results));
+
+  /* If there are addresses, they must be IPv4 or IPv6 */
+  if (smartlist_len(results) > 0) {
+    tt_assert(smartlist_contains_ipv4_tor_addr(results)
+              || smartlist_contains_ipv6_tor_addr(results));
+  }
 
   done:
   SMARTLIST_FOREACH(results, tor_addr_t *, t, tor_free(t));
@@ -289,10 +314,17 @@ test_address_get_if_addrs_win32(void *arg)
 
   (void)arg;
 
-  results = get_interface_addresses_win32(LOG_ERR);
+  results = get_interface_addresses_win32(LOG_ERR, AF_UNSPEC);
 
   tt_int_op(smartlist_len(results),>=,1);
   tt_assert(smartlist_contains_localhost_tor_addr(results));
+  tt_assert(!smartlist_contains_null_tor_addr(results));
+
+  /* If there are addresses, they must be IPv4 or IPv6 */
+  if (smartlist_len(results) > 0) {
+    tt_assert(smartlist_contains_ipv4_tor_addr(results)
+              || smartlist_contains_ipv6_tor_addr(results));
+  }
 
   done:
   SMARTLIST_FOREACH(results, tor_addr_t *, t, tor_free(t));
@@ -479,14 +511,28 @@ test_address_get_if_addrs_ioctl(void *arg)
 
   (void)arg;
 
-  result = get_interface_addresses_ioctl(LOG_ERR);
+  result = get_interface_addresses_ioctl(LOG_ERR, AF_INET);
 
+  /* On an IPv6-only system, this will fail and return NULL
   tt_assert(result);
-  tt_int_op(smartlist_len(result),>=,1);
+  */
+
+  /* Some FreeBSD jails don't have localhost IP address. Instead, they only
+   * have the address assigned to the jail (whatever that may be).
+   * And a jail without a network connection might not have any addresses at
+   * all. */
+  if (result) {
+    tt_assert(!smartlist_contains_null_tor_addr(result));
 
-  tt_assert(smartlist_contains_localhost_tor_addr(result));
+    /* If there are addresses, they must be IPv4 or IPv6.
+     * (AIX supports IPv6 from SIOCGIFCONF.) */
+    if (smartlist_len(result) > 0) {
+      tt_assert(smartlist_contains_ipv4_tor_addr(result)
+                || smartlist_contains_ipv6_tor_addr(result));
+    }
+  }
 
-  done:
+ done:
   if (result) {
     SMARTLIST_FOREACH(result, tor_addr_t *, t, tor_free(t));
     smartlist_free(result);
@@ -696,12 +742,13 @@ test_address_get_if_addrs_list_internal(void *arg)
   tt_assert(!smartlist_contains_localhost_tor_addr(results));
   tt_assert(!smartlist_contains_multicast_tor_addr(results));
   /* The list may or may not contain internal addresses */
+  tt_assert(!smartlist_contains_null_tor_addr(results));
 
-  /* Allow unit tests to pass on IPv6-only machines */
+  /* if there are any addresses, they must be IPv4 */
   if (smartlist_len(results) > 0) {
-    tt_assert(smartlist_contains_ipv4_tor_addr(results)
-              || smartlist_contains_ipv6_tor_addr(results));
+    tt_assert(smartlist_contains_ipv4_tor_addr(results));
   }
+  tt_assert(!smartlist_contains_ipv6_tor_addr(results));
 
  done:
   free_interface_address_list(results);
@@ -724,6 +771,7 @@ test_address_get_if_addrs_list_no_internal(void *arg)
   tt_assert(!smartlist_contains_localhost_tor_addr(results));
   tt_assert(!smartlist_contains_multicast_tor_addr(results));
   tt_assert(!smartlist_contains_internal_tor_addr(results));
+  tt_assert(!smartlist_contains_null_tor_addr(results));
 
   /* if there are any addresses, they must be IPv4 */
   if (smartlist_len(results) > 0) {
@@ -752,6 +800,7 @@ test_address_get_if_addrs6_list_internal(void *arg)
   tt_assert(!smartlist_contains_localhost_tor_addr(results));
   tt_assert(!smartlist_contains_multicast_tor_addr(results));
   /* The list may or may not contain internal addresses */
+  tt_assert(!smartlist_contains_null_tor_addr(results));
 
   /* if there are any addresses, they must be IPv6 */
   tt_assert(!smartlist_contains_ipv4_tor_addr(results));
@@ -780,7 +829,9 @@ test_address_get_if_addrs6_list_no_internal(void *arg)
   tt_assert(!smartlist_contains_localhost_tor_addr(results));
   tt_assert(!smartlist_contains_multicast_tor_addr(results));
   tt_assert(!smartlist_contains_internal_tor_addr(results));
+  tt_assert(!smartlist_contains_null_tor_addr(results));
 
+  /* if there are any addresses, they must be IPv6 */
   tt_assert(!smartlist_contains_ipv4_tor_addr(results));
   if (smartlist_len(results) > 0) {
     tt_assert(smartlist_contains_ipv6_tor_addr(results));
@@ -794,9 +845,10 @@ test_address_get_if_addrs6_list_no_internal(void *arg)
 static int called_get_interface_addresses_raw = 0;
 
 static smartlist_t *
-mock_get_interface_addresses_raw_fail(int severity)
+mock_get_interface_addresses_raw_fail(int severity, sa_family_t family)
 {
   (void)severity;
+  (void)family;
 
   called_get_interface_addresses_raw++;
   return smartlist_new();
@@ -848,7 +900,7 @@ test_address_get_if_addrs_internal_fail(void *arg)
   rv = get_interface_address(LOG_ERR, &ipv4h_addr);
   tt_assert(rv == -1);
 
-done:
+ done:
   UNMOCK(get_interface_addresses_raw);
   UNMOCK(get_interface_address6_via_udp_socket_hack);
   free_interface_address6_list(results1);
@@ -876,7 +928,7 @@ test_address_get_if_addrs_no_internal_fail(void *arg)
   tt_assert(results2 != NULL);
   tt_int_op(smartlist_len(results2),==,0);
 
-done:
+ done:
   UNMOCK(get_interface_addresses_raw);
   UNMOCK(get_interface_address6_via_udp_socket_hack);
   free_interface_address6_list(results1);
@@ -935,6 +987,118 @@ test_address_get_if_addrs6(void *arg)
   return;
 }
 
+static void
+test_address_tor_addr_to_in6(void *ignored)
+{
+  (void)ignored;
+  tor_addr_t *a = tor_malloc_zero(sizeof(tor_addr_t));
+  const struct in6_addr *res;
+  uint8_t expected[16] = {42, 1, 2, 3, 4, 5, 6, 7, 8, 9,
+                          10, 11, 12, 13, 14, 15};
+
+  a->family = AF_INET;
+  res = tor_addr_to_in6(a);
+  tt_assert(!res);
+
+  a->family = AF_INET6;
+  memcpy(a->addr.in6_addr.s6_addr, expected, 16);
+  res = tor_addr_to_in6(a);
+  tt_assert(res);
+  tt_mem_op(res->s6_addr, OP_EQ, expected, 16);
+
+ done:
+  tor_free(a);
+}
+
+static void
+test_address_tor_addr_to_in(void *ignored)
+{
+  (void)ignored;
+  tor_addr_t *a = tor_malloc_zero(sizeof(tor_addr_t));
+  const struct in_addr *res;
+
+  a->family = AF_INET6;
+  res = tor_addr_to_in(a);
+  tt_assert(!res);
+
+  a->family = AF_INET;
+  a->addr.in_addr.s_addr = 44;
+  res = tor_addr_to_in(a);
+  tt_assert(res);
+  tt_int_op(res->s_addr, OP_EQ, 44);
+
+ done:
+  tor_free(a);
+}
+
+static void
+test_address_tor_addr_to_ipv4n(void *ignored)
+{
+  (void)ignored;
+  tor_addr_t *a = tor_malloc_zero(sizeof(tor_addr_t));
+  uint32_t res;
+
+  a->family = AF_INET6;
+  res = tor_addr_to_ipv4n(a);
+  tt_assert(!res);
+
+  a->family = AF_INET;
+  a->addr.in_addr.s_addr = 43;
+  res = tor_addr_to_ipv4n(a);
+  tt_assert(res);
+  tt_int_op(res, OP_EQ, 43);
+
+ done:
+  tor_free(a);
+}
+
+static void
+test_address_tor_addr_to_mapped_ipv4h(void *ignored)
+{
+  (void)ignored;
+  tor_addr_t *a = tor_malloc_zero(sizeof(tor_addr_t));
+  uint32_t res;
+  uint8_t toset[16] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, 0, 0, 0, 42};
+
+  a->family = AF_INET;
+  res = tor_addr_to_mapped_ipv4h(a);
+  tt_assert(!res);
+
+  a->family = AF_INET6;
+
+  memcpy(a->addr.in6_addr.s6_addr, toset, 16);
+  res = tor_addr_to_mapped_ipv4h(a);
+  tt_assert(res);
+  tt_int_op(res, OP_EQ, 42);
+
+ done:
+  tor_free(a);
+}
+
+static void
+test_address_tor_addr_eq_ipv4h(void *ignored)
+{
+  (void)ignored;
+  tor_addr_t *a = tor_malloc_zero(sizeof(tor_addr_t));
+  int res;
+
+  a->family = AF_INET6;
+  res = tor_addr_eq_ipv4h(a, 42);
+  tt_assert(!res);
+
+  a->family = AF_INET;
+  a->addr.in_addr.s_addr = 52;
+  res = tor_addr_eq_ipv4h(a, 42);
+  tt_assert(!res);
+
+  a->addr.in_addr.s_addr = 52;
+  res = tor_addr_eq_ipv4h(a, ntohl(52));
+  tt_assert(res);
+
+ done:
+  tor_free(a);
+}
+
 #define ADDRESS_TEST(name, flags) \
   { #name, test_address_ ## name, flags, NULL, NULL }
 
@@ -961,6 +1125,11 @@ struct testcase_t address_tests[] = {
   ADDRESS_TEST(get_if_addrs_ioctl, TT_FORK),
   ADDRESS_TEST(ifreq_to_smartlist, 0),
 #endif
+  ADDRESS_TEST(tor_addr_to_in6, 0),
+  ADDRESS_TEST(tor_addr_to_in, 0),
+  ADDRESS_TEST(tor_addr_to_ipv4n, 0),
+  ADDRESS_TEST(tor_addr_to_mapped_ipv4h, 0),
+  ADDRESS_TEST(tor_addr_eq_ipv4h, 0),
   END_OF_TESTCASES
 };
 
diff --git a/src/test/test_bt_cl.c b/src/test/test_bt_cl.c
index dabaee6..c43143f 100644
--- a/src/test/test_bt_cl.c
+++ b/src/test/test_bt_cl.c
@@ -119,6 +119,7 @@ main(int argc, char **argv)
   printf("%d\n", we_weave(2));
 
   clean_up_backtrace_handler();
+  logs_free_all();
 
   return 0;
 }
diff --git a/src/test/test_channeltls.c b/src/test/test_channeltls.c
index 016e504..dff1dde 100644
--- a/src/test/test_channeltls.c
+++ b/src/test/test_channeltls.c
@@ -123,7 +123,7 @@ test_channeltls_num_bytes_queued(void *arg)
   /*
    * Next, we have to test ch->num_bytes_queued, which is
    * channel_tls_num_bytes_queued_method.  We can't mock
-   * connection_get_outbuf_len() directly because it's static INLINE
+   * connection_get_outbuf_len() directly because it's static inline
    * in connection.h, but we can mock buf_datalen().  Note that
    * if bufferevents ever work, this will break with them enabled.
    */
diff --git a/src/test/test_circuitmux.c b/src/test/test_circuitmux.c
index 6d93731..5c72fc6 100644
--- a/src/test/test_circuitmux.c
+++ b/src/test/test_circuitmux.c
@@ -36,11 +36,7 @@ test_cmux_destroy_cell_queue(void *arg)
   circuit_t *circ = NULL;
   cell_queue_t *cq = NULL;
   packed_cell_t *pc = NULL;
-  tor_libevent_cfg cfg;
 
-  memset(&cfg, 0, sizeof(cfg));
-
-  tor_libevent_initialize(&cfg);
   scheduler_init();
 
   (void) arg;
diff --git a/src/test/test_compat_libevent.c b/src/test/test_compat_libevent.c
new file mode 100644
index 0000000..f3fe113
--- /dev/null
+++ b/src/test/test_compat_libevent.c
@@ -0,0 +1,224 @@
+/* Copyright (c) 2010-2015, The Tor Project, Inc. */
+/* See LICENSE for licensing information */
+
+#define COMPAT_LIBEVENT_PRIVATE
+#include "orconfig.h"
+#include "or.h"
+
+#include "test.h"
+
+#include "compat_libevent.h"
+
+#ifdef HAVE_EVENT2_EVENT_H
+#include <event2/event.h>
+#include <event2/thread.h>
+#ifdef USE_BUFFEREVENTS
+#include <event2/bufferevent.h>
+#endif
+#else
+#include <event.h>
+#endif
+
+#include "log_test_helpers.h"
+
+#define NS_MODULE compat_libevent
+
+static void
+test_compat_libevent_logging_callback(void *ignored)
+{
+  (void)ignored;
+  int previous_log = setup_capture_of_logs(LOG_DEBUG);
+
+  libevent_logging_callback(_EVENT_LOG_DEBUG, "hello world");
+  expect_log_msg("Message from libevent: hello world\n");
+  expect_log_severity(LOG_DEBUG);
+
+  mock_clean_saved_logs();
+  libevent_logging_callback(_EVENT_LOG_MSG, "hello world another time");
+  expect_log_msg("Message from libevent: hello world another time\n");
+  expect_log_severity(LOG_INFO);
+
+  mock_clean_saved_logs();
+  libevent_logging_callback(_EVENT_LOG_WARN, "hello world a third time");
+  expect_log_msg("Warning from libevent: hello world a third time\n");
+  expect_log_severity(LOG_WARN);
+
+  mock_clean_saved_logs();
+  libevent_logging_callback(_EVENT_LOG_ERR, "hello world a fourth time");
+  expect_log_msg("Error from libevent: hello world a fourth time\n");
+  expect_log_severity(LOG_ERR);
+
+  mock_clean_saved_logs();
+  libevent_logging_callback(42, "hello world a fifth time");
+  expect_log_msg("Message [42] from libevent: hello world a fifth time\n");
+  expect_log_severity(LOG_WARN);
+
+  mock_clean_saved_logs();
+  libevent_logging_callback(_EVENT_LOG_DEBUG,
+                            "012345678901234567890123456789"
+                            "012345678901234567890123456789"
+                            "012345678901234567890123456789"
+                            "012345678901234567890123456789"
+                            "012345678901234567890123456789"
+                            "012345678901234567890123456789"
+                            "012345678901234567890123456789"
+                            "012345678901234567890123456789"
+                            "012345678901234567890123456789"
+                            "012345678901234567890123456789"
+                            "012345678901234567890123456789"
+                            "012345678901234567890123456789"
+                            );
+  expect_log_msg("Message from libevent: "
+                            "012345678901234567890123456789"
+                            "012345678901234567890123456789"
+                            "012345678901234567890123456789"
+                            "012345678901234567890123456789"
+                            "012345678901234567890123456789"
+                            "012345678901234567890123456789"
+                            "012345678901234567890123456789"
+                            "012345678901234567890123456789"
+                            "012345678901234567890123456789"
+                            "012345678901234567890123456789"
+                            "012345678901234567890123456789"
+            "012345678901234567890123456789\n");
+  expect_log_severity(LOG_DEBUG);
+
+  mock_clean_saved_logs();
+  libevent_logging_callback(42, "xxx\n");
+  expect_log_msg("Message [42] from libevent: xxx\n");
+  expect_log_severity(LOG_WARN);
+
+  suppress_libevent_log_msg("something");
+  mock_clean_saved_logs();
+  libevent_logging_callback(_EVENT_LOG_MSG, "hello there");
+  expect_log_msg("Message from libevent: hello there\n");
+  expect_log_severity(LOG_INFO);
+
+  mock_clean_saved_logs();
+  libevent_logging_callback(_EVENT_LOG_MSG, "hello there something else");
+  expect_no_log_msg("hello there something else");
+
+  // No way of verifying the result of this, it seems =/
+  configure_libevent_logging();
+
+ done:
+  suppress_libevent_log_msg(NULL);
+  teardown_capture_of_logs(previous_log);
+}
+
+static void
+test_compat_libevent_le_versions_compatibility(void *ignored)
+{
+  (void)ignored;
+  int res;
+
+  res = le_versions_compatibility(LE_OTHER);
+  tt_int_op(res, OP_EQ, 0);
+
+  res = le_versions_compatibility(V_OLD(0,9,'c'));
+  tt_int_op(res, OP_EQ, 1);
+
+  res = le_versions_compatibility(V(1,3,98));
+  tt_int_op(res, OP_EQ, 2);
+
+  res = le_versions_compatibility(V(1,4,98));
+  tt_int_op(res, OP_EQ, 3);
+
+  res = le_versions_compatibility(V(1,5,0));
+  tt_int_op(res, OP_EQ, 4);
+
+  res = le_versions_compatibility(V(2,0,0));
+  tt_int_op(res, OP_EQ, 4);
+
+  res = le_versions_compatibility(V(2,0,2));
+  tt_int_op(res, OP_EQ, 5);
+
+ done:
+  (void)0;
+}
+
+static void
+test_compat_libevent_tor_decode_libevent_version(void *ignored)
+{
+  (void)ignored;
+  le_version_t res;
+
+  res = tor_decode_libevent_version("SOMETHING WRONG");
+  tt_int_op(res, OP_EQ, LE_OTHER);
+
+  res = tor_decode_libevent_version("1.4.11");
+  tt_int_op(res, OP_EQ, V(1,4,11));
+
+  res = tor_decode_libevent_version("1.4.12b-stable");
+  tt_int_op(res, OP_EQ, V(1,4,12));
+
+  res = tor_decode_libevent_version("1.4.17b_stable");
+  tt_int_op(res, OP_EQ, V(1,4,17));
+
+  res = tor_decode_libevent_version("1.4.12!stable");
+  tt_int_op(res, OP_EQ, LE_OTHER);
+
+  res = tor_decode_libevent_version("1.4.12b!stable");
+  tt_int_op(res, OP_EQ, LE_OTHER);
+
+  res = tor_decode_libevent_version("1.4.13-");
+  tt_int_op(res, OP_EQ, V(1,4,13));
+
+  res = tor_decode_libevent_version("1.4.14_");
+  tt_int_op(res, OP_EQ, V(1,4,14));
+
+  res = tor_decode_libevent_version("1.4.15c-");
+  tt_int_op(res, OP_EQ, V(1,4,15));
+
+  res = tor_decode_libevent_version("1.4.16c_");
+  tt_int_op(res, OP_EQ, V(1,4,16));
+
+  res = tor_decode_libevent_version("1.4.17-s");
+  tt_int_op(res, OP_EQ, V(1,4,17));
+
+  res = tor_decode_libevent_version("1.5");
+  tt_int_op(res, OP_EQ, V(1,5,0));
+
+  res = tor_decode_libevent_version("1.2");
+  tt_int_op(res, OP_EQ, V(1,2,0));
+
+  res = tor_decode_libevent_version("1.2-");
+  tt_int_op(res, OP_EQ, LE_OTHER);
+
+  res = tor_decode_libevent_version("1.6e");
+  tt_int_op(res, OP_EQ, V_OLD(1,6,'e'));
+
+ done:
+  (void)0;
+}
+
+#if defined(LIBEVENT_VERSION)
+#define HEADER_VERSION LIBEVENT_VERSION
+#elif defined(_EVENT_VERSION)
+#define HEADER_VERSION _EVENT_VERSION
+#endif
+
+static void
+test_compat_libevent_header_version(void *ignored)
+{
+  (void)ignored;
+  const char *res;
+
+  res = tor_libevent_get_header_version_str();
+  tt_str_op(res, OP_EQ, HEADER_VERSION);
+
+ done:
+  (void)0;
+}
+
+struct testcase_t compat_libevent_tests[] = {
+  { "logging_callback", test_compat_libevent_logging_callback,
+    TT_FORK, NULL, NULL },
+  { "le_versions_compatibility",
+    test_compat_libevent_le_versions_compatibility, 0, NULL, NULL },
+  { "tor_decode_libevent_version",
+    test_compat_libevent_tor_decode_libevent_version, 0, NULL, NULL },
+  { "header_version", test_compat_libevent_header_version, 0, NULL, NULL },
+  END_OF_TESTCASES
+};
+
diff --git a/src/test/test_config.c b/src/test/test_config.c
index 28e9fa0..85bedd6 100644
--- a/src/test/test_config.c
+++ b/src/test/test_config.c
@@ -7,17 +7,43 @@
 
 #define CONFIG_PRIVATE
 #define PT_PRIVATE
+#define ROUTERSET_PRIVATE
 #include "or.h"
+#include "address.h"
 #include "addressmap.h"
+#include "circuitmux_ewma.h"
+#include "circuitbuild.h"
 #include "config.h"
 #include "confparse.h"
+#include "connection.h"
 #include "connection_edge.h"
 #include "test.h"
 #include "util.h"
 #include "address.h"
+#include "connection_or.h"
+#include "control.h"
+#include "cpuworker.h"
+#include "dirserv.h"
+#include "dirvote.h"
+#include "dns.h"
 #include "entrynodes.h"
 #include "transports.h"
+#include "ext_orport.h"
+#include "geoip.h"
+#include "hibernate.h"
+#include "main.h"
+#include "networkstatus.h"
+#include "nodelist.h"
+#include "policies.h"
+#include "rendclient.h"
+#include "rendservice.h"
+#include "router.h"
 #include "routerlist.h"
+#include "routerset.h"
+#include "statefile.h"
+#include "test.h"
+#include "transports.h"
+#include "util.h"
 
 static void
 test_config_addressmap(void *arg)
@@ -1444,6 +1470,176 @@ test_config_resolve_my_address(void *arg)
   UNMOCK(tor_gethostname);
 }
 
+static void
+test_config_adding_trusted_dir_server(void *arg)
+{
+  (void)arg;
+
+  const char digest[DIGEST_LEN] = "";
+  dir_server_t *ds = NULL;
+  tor_addr_port_t ipv6;
+  int rv = -1;
+
+  clear_dir_servers();
+  routerlist_free_all();
+
+  /* create a trusted ds without an IPv6 address and port */
+  ds = trusted_dir_server_new("ds", "127.0.0.1", 9059, 9060, NULL, digest,
+                              NULL, V3_DIRINFO, 1.0);
+  tt_assert(ds);
+  dir_server_add(ds);
+  tt_assert(get_n_authorities(V3_DIRINFO) == 1);
+  tt_assert(smartlist_len(router_get_fallback_dir_servers()) == 1);
+
+  /* create a trusted ds with an IPv6 address and port */
+  rv = tor_addr_port_parse(LOG_WARN, "[::1]:9061", &ipv6.addr, &ipv6.port, -1);
+  tt_assert(rv == 0);
+  ds = trusted_dir_server_new("ds", "127.0.0.1", 9059, 9060, &ipv6, digest,
+                              NULL, V3_DIRINFO, 1.0);
+  tt_assert(ds);
+  dir_server_add(ds);
+  tt_assert(get_n_authorities(V3_DIRINFO) == 2);
+  tt_assert(smartlist_len(router_get_fallback_dir_servers()) == 2);
+
+ done:
+  clear_dir_servers();
+  routerlist_free_all();
+}
+
+static void
+test_config_adding_fallback_dir_server(void *arg)
+{
+  (void)arg;
+
+  const char digest[DIGEST_LEN] = "";
+  dir_server_t *ds = NULL;
+  tor_addr_t ipv4;
+  tor_addr_port_t ipv6;
+  int rv = -1;
+
+  clear_dir_servers();
+  routerlist_free_all();
+
+  rv = tor_addr_parse(&ipv4, "127.0.0.1");
+  tt_assert(rv == AF_INET);
+
+  /* create a trusted ds without an IPv6 address and port */
+  ds = fallback_dir_server_new(&ipv4, 9059, 9060, NULL, digest, 1.0);
+  tt_assert(ds);
+  dir_server_add(ds);
+  tt_assert(smartlist_len(router_get_fallback_dir_servers()) == 1);
+
+  /* create a trusted ds with an IPv6 address and port */
+  rv = tor_addr_port_parse(LOG_WARN, "[::1]:9061", &ipv6.addr, &ipv6.port, -1);
+  tt_assert(rv == 0);
+  ds = fallback_dir_server_new(&ipv4, 9059, 9060, &ipv6, digest, 1.0);
+  tt_assert(ds);
+  dir_server_add(ds);
+  tt_assert(smartlist_len(router_get_fallback_dir_servers()) == 2);
+
+ done:
+  clear_dir_servers();
+  routerlist_free_all();
+}
+
+/* No secrets here:
+ * v3ident is `echo "onion" | shasum | cut -d" " -f1 | tr "a-f" "A-F"`
+ * fingerprint is `echo "unionem" | shasum | cut -d" " -f1 | tr "a-f" "A-F"`
+ * with added spaces
+ */
+#define TEST_DIR_AUTH_LINE_START                                        \
+                    "foobar orport=12345 "                              \
+                    "v3ident=14C131DFC5C6F93646BE72FA1401C02A8DF2E8B4 "
+#define TEST_DIR_AUTH_LINE_END                                          \
+                    "1.2.3.4:54321 "                                    \
+                    "FDB2 FBD2 AAA5 25FA 2999 E617 5091 5A32 C777 3B17"
+#define TEST_DIR_AUTH_IPV6_FLAG                                         \
+                    "ipv6=[feed::beef]:9 "
+
+static void
+test_config_parsing_trusted_dir_server(void *arg)
+{
+  (void)arg;
+  int rv = -1;
+
+  /* parse a trusted dir server without an IPv6 address and port */
+  rv = parse_dir_authority_line(TEST_DIR_AUTH_LINE_START
+                                TEST_DIR_AUTH_LINE_END,
+                                V3_DIRINFO, 1);
+  tt_assert(rv == 0);
+
+  /* parse a trusted dir server with an IPv6 address and port */
+  rv = parse_dir_authority_line(TEST_DIR_AUTH_LINE_START
+                                TEST_DIR_AUTH_IPV6_FLAG
+                                TEST_DIR_AUTH_LINE_END,
+                                V3_DIRINFO, 1);
+  tt_assert(rv == 0);
+
+  /* Since we are only validating, there is no cleanup. */
+ done:
+  ;
+}
+
+#undef TEST_DIR_AUTH_LINE_START
+#undef TEST_DIR_AUTH_LINE_END
+#undef TEST_DIR_AUTH_IPV6_FLAG
+
+/* No secrets here:
+ * id is `echo "syn-propanethial-S-oxide" | shasum | cut -d" " -f1`
+ */
+#define TEST_DIR_FALLBACK_LINE                                     \
+                    "1.2.3.4:54321 orport=12345 "                  \
+                    "id=50e643986f31ea1235bcc1af17a1c5c5cfc0ee54 "
+#define TEST_DIR_FALLBACK_IPV6_FLAG                                \
+                    "ipv6=[2015:c0de::deed]:9"
+
+static void
+test_config_parsing_fallback_dir_server(void *arg)
+{
+  (void)arg;
+  int rv = -1;
+
+  /* parse a trusted dir server without an IPv6 address and port */
+  rv = parse_dir_fallback_line(TEST_DIR_FALLBACK_LINE, 1);
+  tt_assert(rv == 0);
+
+  /* parse a trusted dir server with an IPv6 address and port */
+  rv = parse_dir_fallback_line(TEST_DIR_FALLBACK_LINE
+                               TEST_DIR_FALLBACK_IPV6_FLAG,
+                               1);
+  tt_assert(rv == 0);
+
+  /* Since we are only validating, there is no cleanup. */
+ done:
+  ;
+}
+
+#undef TEST_DIR_FALLBACK_LINE
+#undef TEST_DIR_FALLBACK_IPV6_FLAG
+
+static void
+test_config_adding_default_trusted_dir_servers(void *arg)
+{
+  (void)arg;
+
+  clear_dir_servers();
+  routerlist_free_all();
+
+  /* Assume we only have one bridge authority */
+  add_default_trusted_dir_authorities(BRIDGE_DIRINFO);
+  tt_assert(get_n_authorities(BRIDGE_DIRINFO) == 1);
+  tt_assert(smartlist_len(router_get_fallback_dir_servers()) == 1);
+
+  /* Assume we have nine V3 authorities */
+  add_default_trusted_dir_authorities(V3_DIRINFO);
+  tt_assert(get_n_authorities(V3_DIRINFO) == 9);
+  tt_assert(smartlist_len(router_get_fallback_dir_servers()) == 10);
+
+ done:
+  clear_dir_servers();
+  routerlist_free_all();
+}
+
 static int n_add_default_fallback_dir_servers_known_default = 0;
 
 /**
@@ -1471,13 +1667,14 @@ add_default_fallback_dir_servers_known_default(void)
   n_add_default_fallback_dir_servers_known_default++;
 }
 
+/* Test all the different combinations of adding dir servers */
 static void
 test_config_adding_dir_servers(void *arg)
 {
   (void)arg;
 
   /* allocate options */
-  or_options_t *options = tor_malloc(sizeof(or_options_t));
+  or_options_t *options = tor_malloc_zero(sizeof(or_options_t));
 
   /* Allocate and populate configuration lines:
    *
@@ -1486,8 +1683,7 @@ test_config_adding_dir_servers(void *arg)
    * Zeroing the structure has the same effect as initialising to:
    * { NULL, NULL, NULL, CONFIG_LINE_NORMAL, 0};
    */
-  config_line_t *test_dir_authority = tor_malloc(sizeof(config_line_t));
-  memset(test_dir_authority, 0, sizeof(config_line_t));
+  config_line_t *test_dir_authority = tor_malloc_zero(sizeof(config_line_t));
   test_dir_authority->key = tor_strdup("DirAuthority");
   test_dir_authority->value = tor_strdup(
     "D0 orport=9000 "
@@ -1495,16 +1691,16 @@ test_config_adding_dir_servers(void *arg)
     "127.0.0.1:60090 0123 4567 8901 2345 6789 0123 4567 8901 2345 6789"
     );
 
-  config_line_t *test_alt_bridge_authority = tor_malloc(sizeof(config_line_t));
-  memset(test_alt_bridge_authority, 0, sizeof(config_line_t));
+  config_line_t *test_alt_bridge_authority = tor_malloc_zero(
+                                                      sizeof(config_line_t));
   test_alt_bridge_authority->key = tor_strdup("AlternateBridgeAuthority");
   test_alt_bridge_authority->value = tor_strdup(
     "B1 orport=9001 bridge "
     "127.0.0.1:60091 1123 4567 8901 2345 6789 0123 4567 8901 2345 6789"
     );
 
-  config_line_t *test_alt_dir_authority = tor_malloc(sizeof(config_line_t));
-  memset(test_alt_dir_authority, 0, sizeof(config_line_t));
+  config_line_t *test_alt_dir_authority = tor_malloc_zero(
+                                                      sizeof(config_line_t));
   test_alt_dir_authority->key = tor_strdup("AlternateDirAuthority");
   test_alt_dir_authority->value = tor_strdup(
     "A2 orport=9002 "
@@ -1513,23 +1709,23 @@ test_config_adding_dir_servers(void *arg)
     );
 
   /* Use the format specified in the manual page */
-  config_line_t *test_fallback_directory = tor_malloc(sizeof(config_line_t));
-  memset(test_fallback_directory, 0, sizeof(config_line_t));
+  config_line_t *test_fallback_directory = tor_malloc_zero(
+                                                      sizeof(config_line_t));
   test_fallback_directory->key = tor_strdup("FallbackDir");
   test_fallback_directory->value = tor_strdup(
     "127.0.0.1:60093 orport=9003 id=0323456789012345678901234567890123456789"
     );
 
   /* We need to know if add_default_fallback_dir_servers is called,
+   * whatever the size of the list in fallback_dirs.inc,
    * so we use a version of add_default_fallback_dir_servers that adds
-   * one known default fallback directory.
-   * There doesn't appear to be any need to test it unmocked. */
+   * one known default fallback directory. */
   MOCK(add_default_fallback_dir_servers,
        add_default_fallback_dir_servers_known_default);
 
   /* There are 16 different cases, covering each combination of set/NULL for:
    * DirAuthorities, AlternateBridgeAuthority, AlternateDirAuthority &
-   * FallbackDir.
+   * FallbackDir. (We always set UseDefaultFallbackDirs to 1.)
    * But validate_dir_servers() ensures that:
    *   "You cannot set both DirAuthority and Alternate*Authority."
    * This reduces the number of cases to 10.
@@ -1543,8 +1739,6 @@ test_config_adding_dir_servers(void *arg)
    * The valid cases are cases 0-9 counting using this method, as every case
    * greater than or equal to 10 = 1010 is invalid.
    *
-   * After #15642 - Disable default fallback dirs when any custom dirs set
-   *
    * 1. Outcome: Use Set Directory Authorities
    *   - No Default Authorities
    *   - Use AlternateBridgeAuthority, AlternateDirAuthority, and FallbackDir
@@ -1581,20 +1775,6 @@ test_config_adding_dir_servers(void *arg)
    *  Cases expected to yield this outcome:
    *    0 (DirAuthorities, AlternateBridgeAuthority, AlternateDirAuthority
    *       and FallbackDir are all NULL)
-   *
-   * Before #15642 but after #13163 - Stop using default authorities when both
-   * Alternate Dir and Bridge Authority are set
-   * (#13163 was committed in 0.2.6 as c1dd43d823c7)
-   *
-   * The behaviour is different in the following cases
-   * where FallbackDir is NULL:
-   *  2, 6, 8
-   *
-   * In these cases, the Default Fallback Directories are applied, even when
-   * DirAuthorities or AlternateDirAuthority are set.
-   *
-   * However, as the list of default fallback directories is currently empty,
-   * this change doesn't modify any user-visible behaviour.
    */
 
   /*
@@ -1628,6 +1808,7 @@ test_config_adding_dir_servers(void *arg)
     options->AlternateBridgeAuthority = NULL;
     options->AlternateDirAuthority = NULL;
     options->FallbackDir = NULL;
+    options->UseDefaultFallbackDirs = 1;
 
     /* parse options - ensure we always update by passing NULL old_options */
     consider_adding_dir_servers(options, NULL);
@@ -1637,6 +1818,9 @@ test_config_adding_dir_servers(void *arg)
     /* we must have added the default fallback dirs */
     tt_assert(n_add_default_fallback_dir_servers_known_default == 1);
 
+    /* we have more fallbacks than just the authorities */
+    tt_assert(networkstatus_consensus_can_use_extra_fallbacks(options) == 1);
+
     {
       /* fallback_dir_servers */
       const smartlist_t *fallback_servers = router_get_fallback_dir_servers();
@@ -1669,7 +1853,10 @@ test_config_adding_dir_servers(void *arg)
       n_default_fallback_dir = (smartlist_len(fallback_servers) -
                                 n_default_alt_bridge_authority -
                                 n_default_alt_dir_authority);
-      /* If we have a negative count, something has gone really wrong */
+      /* If we have a negative count, something has gone really wrong,
+       * or some authorities aren't being added as fallback directories.
+       * (networkstatus_consensus_can_use_extra_fallbacks depends on all
+       * authorities being fallback directories.) */
       tt_assert(n_default_fallback_dir >= 0);
     }
   }
@@ -1703,6 +1890,7 @@ test_config_adding_dir_servers(void *arg)
     options->AlternateBridgeAuthority = NULL;
     options->AlternateDirAuthority = NULL;
     options->FallbackDir = test_fallback_directory;
+    options->UseDefaultFallbackDirs = 1;
 
     /* parse options - ensure we always update by passing NULL old_options */
     consider_adding_dir_servers(options, NULL);
@@ -1712,6 +1900,9 @@ test_config_adding_dir_servers(void *arg)
     /* we must not have added the default fallback dirs */
     tt_assert(n_add_default_fallback_dir_servers_known_default == 0);
 
+    /* we have more fallbacks than just the authorities */
+    tt_assert(networkstatus_consensus_can_use_extra_fallbacks(options) == 1);
+
     {
       /* trusted_dir_servers */
       const smartlist_t *dir_servers = router_get_trusted_dir_servers();
@@ -1840,6 +2031,7 @@ test_config_adding_dir_servers(void *arg)
     options->AlternateBridgeAuthority = NULL;
     options->AlternateDirAuthority = NULL;
     options->FallbackDir = NULL;
+    options->UseDefaultFallbackDirs = 1;
 
     /* parse options - ensure we always update by passing NULL old_options */
     consider_adding_dir_servers(options, NULL);
@@ -1849,6 +2041,9 @@ test_config_adding_dir_servers(void *arg)
     /* we must not have added the default fallback dirs */
     tt_assert(n_add_default_fallback_dir_servers_known_default == 0);
 
+    /* we just have the authorities */
+    tt_assert(networkstatus_consensus_can_use_extra_fallbacks(options) == 0);
+
     {
       /* trusted_dir_servers */
       const smartlist_t *dir_servers = router_get_trusted_dir_servers();
@@ -1977,6 +2172,7 @@ test_config_adding_dir_servers(void *arg)
     options->AlternateBridgeAuthority = test_alt_bridge_authority;
     options->AlternateDirAuthority = test_alt_dir_authority;
     options->FallbackDir = test_fallback_directory;
+    options->UseDefaultFallbackDirs = 1;
 
     /* parse options - ensure we always update by passing NULL old_options */
     consider_adding_dir_servers(options, NULL);
@@ -1986,6 +2182,9 @@ test_config_adding_dir_servers(void *arg)
     /* we must not have added the default fallback dirs */
     tt_assert(n_add_default_fallback_dir_servers_known_default == 0);
 
+    /* we have more fallbacks than just the authorities */
+    tt_assert(networkstatus_consensus_can_use_extra_fallbacks(options) == 1);
+
     {
       /* trusted_dir_servers */
       const smartlist_t *dir_servers = router_get_trusted_dir_servers();
@@ -2115,6 +2314,7 @@ test_config_adding_dir_servers(void *arg)
     options->AlternateBridgeAuthority = test_alt_bridge_authority;
     options->AlternateDirAuthority = test_alt_dir_authority;
     options->FallbackDir = NULL;
+    options->UseDefaultFallbackDirs = 1;
 
     /* parse options - ensure we always update by passing NULL old_options */
     consider_adding_dir_servers(options, NULL);
@@ -2124,6 +2324,9 @@ test_config_adding_dir_servers(void *arg)
     /* we must not have added the default fallback dirs */
     tt_assert(n_add_default_fallback_dir_servers_known_default == 0);
 
+    /* we have more fallbacks than just the authorities */
+    tt_assert(networkstatus_consensus_can_use_extra_fallbacks(options) == 0);
+
     {
       /* trusted_dir_servers */
       const smartlist_t *dir_servers = router_get_trusted_dir_servers();
@@ -2263,6 +2466,7 @@ test_config_adding_dir_servers(void *arg)
     options->AlternateBridgeAuthority = test_alt_bridge_authority;
     options->AlternateDirAuthority = NULL;
     options->FallbackDir = test_fallback_directory;
+    options->UseDefaultFallbackDirs = 1;
 
     /* parse options - ensure we always update by passing NULL old_options */
     consider_adding_dir_servers(options, NULL);
@@ -2272,6 +2476,9 @@ test_config_adding_dir_servers(void *arg)
     /* we must not have added the default fallback dirs */
     tt_assert(n_add_default_fallback_dir_servers_known_default == 0);
 
+    /* we have more fallbacks than just the authorities */
+    tt_assert(networkstatus_consensus_can_use_extra_fallbacks(options) == 1);
+
     {
       /* trusted_dir_servers */
       const smartlist_t *dir_servers = router_get_trusted_dir_servers();
@@ -2413,6 +2620,7 @@ test_config_adding_dir_servers(void *arg)
     options->AlternateBridgeAuthority = test_alt_bridge_authority;
     options->AlternateDirAuthority = NULL;
     options->FallbackDir = NULL;
+    options->UseDefaultFallbackDirs = 1;
 
     /* parse options - ensure we always update by passing NULL old_options */
     consider_adding_dir_servers(options, NULL);
@@ -2422,6 +2630,9 @@ test_config_adding_dir_servers(void *arg)
     /* we must have added the default fallback dirs */
     tt_assert(n_add_default_fallback_dir_servers_known_default == 1);
 
+    /* we have more fallbacks than just the authorities */
+    tt_assert(networkstatus_consensus_can_use_extra_fallbacks(options) == 1);
+
     {
       /* trusted_dir_servers */
       const smartlist_t *dir_servers = router_get_trusted_dir_servers();
@@ -2572,6 +2783,7 @@ test_config_adding_dir_servers(void *arg)
     options->AlternateBridgeAuthority = NULL;
     options->AlternateDirAuthority = test_alt_dir_authority;
     options->FallbackDir = test_fallback_directory;
+    options->UseDefaultFallbackDirs = 1;
 
     /* parse options - ensure we always update by passing NULL old_options */
     consider_adding_dir_servers(options, NULL);
@@ -2581,6 +2793,9 @@ test_config_adding_dir_servers(void *arg)
     /* we must not have added the default fallback dirs */
     tt_assert(n_add_default_fallback_dir_servers_known_default == 0);
 
+    /* we have more fallbacks than just the authorities */
+    tt_assert(networkstatus_consensus_can_use_extra_fallbacks(options) == 1);
+
     {
       /* trusted_dir_servers */
       const smartlist_t *dir_servers = router_get_trusted_dir_servers();
@@ -2725,6 +2940,7 @@ test_config_adding_dir_servers(void *arg)
     options->AlternateBridgeAuthority = NULL;
     options->AlternateDirAuthority = test_alt_dir_authority;
     options->FallbackDir = NULL;
+    options->UseDefaultFallbackDirs = 1;
 
     /* parse options - ensure we always update by passing NULL old_options */
     consider_adding_dir_servers(options, NULL);
@@ -2734,6 +2950,9 @@ test_config_adding_dir_servers(void *arg)
     /* we must not have added the default fallback dirs */
     tt_assert(n_add_default_fallback_dir_servers_known_default == 0);
 
+    /* we just have the authorities */
+    tt_assert(networkstatus_consensus_can_use_extra_fallbacks(options) == 0);
+
     {
       /* trusted_dir_servers */
       const smartlist_t *dir_servers = router_get_trusted_dir_servers();
@@ -2887,6 +3106,7 @@ test_config_adding_dir_servers(void *arg)
     options->AlternateBridgeAuthority = NULL;
     options->AlternateDirAuthority = NULL;
     options->FallbackDir = test_fallback_directory;
+    options->UseDefaultFallbackDirs = 1;
 
     /* parse options - ensure we always update by passing NULL old_options */
     consider_adding_dir_servers(options, NULL);
@@ -2896,6 +3116,9 @@ test_config_adding_dir_servers(void *arg)
     /* we must not have added the default fallback dirs */
     tt_assert(n_add_default_fallback_dir_servers_known_default == 0);
 
+    /* we have more fallbacks than just the authorities */
+    tt_assert(networkstatus_consensus_can_use_extra_fallbacks(options) == 1);
+
     {
       /* trusted_dir_servers */
       const smartlist_t *dir_servers = router_get_trusted_dir_servers();
@@ -3046,6 +3269,7 @@ test_config_adding_dir_servers(void *arg)
     options->AlternateBridgeAuthority = NULL;
     options->AlternateDirAuthority = NULL;
     options->FallbackDir = NULL;
+    options->UseDefaultFallbackDirs = 1;
 
     /* parse options - ensure we always update by passing NULL old_options */
     consider_adding_dir_servers(options, NULL);
@@ -3055,6 +3279,9 @@ test_config_adding_dir_servers(void *arg)
     /* we must have added the default fallback dirs */
     tt_assert(n_add_default_fallback_dir_servers_known_default == 1);
 
+    /* we have more fallbacks than just the authorities */
+    tt_assert(networkstatus_consensus_can_use_extra_fallbacks(options) == 1);
+
     {
       /* trusted_dir_servers */
       const smartlist_t *dir_servers = router_get_trusted_dir_servers();
@@ -3209,11 +3436,1133 @@ test_config_adding_dir_servers(void *arg)
   UNMOCK(add_default_fallback_dir_servers);
 }
 
+static void
+test_config_default_dir_servers(void *arg)
+{
+  or_options_t *opts = NULL;
+  (void)arg;
+  int trusted_count = 0;
+  int fallback_count = 0;
+
+  /* new set of options should stop fallback parsing */
+  opts = tor_malloc_zero(sizeof(or_options_t));
+  opts->UseDefaultFallbackDirs = 0;
+  /* set old_options to NULL to force dir update */
+  consider_adding_dir_servers(opts, NULL);
+  trusted_count = smartlist_len(router_get_trusted_dir_servers());
+  fallback_count = smartlist_len(router_get_fallback_dir_servers());
+  or_options_free(opts);
+  opts = NULL;
+
+  /* assume a release will never go out with less than 7 authorities */
+  tt_assert(trusted_count >= 7);
+  /* if we disable the default fallbacks, there must not be any extra */
+  tt_assert(fallback_count == trusted_count);
+
+  opts = tor_malloc_zero(sizeof(or_options_t));
+  opts->UseDefaultFallbackDirs = 1;
+  consider_adding_dir_servers(opts, opts);
+  trusted_count = smartlist_len(router_get_trusted_dir_servers());
+  fallback_count = smartlist_len(router_get_fallback_dir_servers());
+  or_options_free(opts);
+  opts = NULL;
+
+  /* assume a release will never go out with less than 7 authorities */
+  tt_assert(trusted_count >= 7);
+  /* XX/teor - allow for default fallbacks to be added without breaking
+   * the unit tests. Set a minimum fallback count once the list is stable. */
+  tt_assert(fallback_count >= trusted_count);
+
+ done:
+  or_options_free(opts);
+}
+
+static int mock_router_pick_published_address_result = 0;
+
+static int
+mock_router_pick_published_address(const or_options_t *options, uint32_t *addr)
+{
+  (void)options;
+  (void)addr;
+  return mock_router_pick_published_address_result;
+}
+
+static int mock_router_my_exit_policy_is_reject_star_result = 0;
+
+static int
+mock_router_my_exit_policy_is_reject_star(void)
+{
+  return mock_router_my_exit_policy_is_reject_star_result;
+}
+
+static int mock_advertised_server_mode_result = 0;
+
+static int
+mock_advertised_server_mode(void)
+{
+  return mock_advertised_server_mode_result;
+}
+
+static routerinfo_t *mock_router_get_my_routerinfo_result = NULL;
+
+static const routerinfo_t *
+mock_router_get_my_routerinfo(void)
+{
+  return mock_router_get_my_routerinfo_result;
+}
+
+static void
+test_config_directory_fetch(void *arg)
+{
+  (void)arg;
+
+  /* Test Setup */
+  or_options_t *options = tor_malloc_zero(sizeof(or_options_t));
+  routerinfo_t routerinfo;
+  memset(&routerinfo, 0, sizeof(routerinfo));
+  mock_router_pick_published_address_result = -1;
+  mock_router_my_exit_policy_is_reject_star_result = 1;
+  mock_advertised_server_mode_result = 0;
+  mock_router_get_my_routerinfo_result = NULL;
+  MOCK(router_pick_published_address, mock_router_pick_published_address);
+  MOCK(router_my_exit_policy_is_reject_star,
+       mock_router_my_exit_policy_is_reject_star);
+  MOCK(advertised_server_mode, mock_advertised_server_mode);
+  MOCK(router_get_my_routerinfo, mock_router_get_my_routerinfo);
+
+  /* Clients can use multiple directory mirrors for bootstrap */
+  memset(options, 0, sizeof(or_options_t));
+  options->ClientOnly = 1;
+  tt_assert(server_mode(options) == 0);
+  tt_assert(public_server_mode(options) == 0);
+  tt_assert(directory_fetches_from_authorities(options) == 0);
+  tt_assert(networkstatus_consensus_can_use_multiple_directories(options)
+            == 1);
+
+  /* Bridge Clients can use multiple directory mirrors for bootstrap */
+  memset(options, 0, sizeof(or_options_t));
+  options->UseBridges = 1;
+  tt_assert(server_mode(options) == 0);
+  tt_assert(public_server_mode(options) == 0);
+  tt_assert(directory_fetches_from_authorities(options) == 0);
+  tt_assert(networkstatus_consensus_can_use_multiple_directories(options)
+            == 1);
+
+  /* Bridge Relays (Bridges) must act like clients, and use multiple
+   * directory mirrors for bootstrap */
+  memset(options, 0, sizeof(or_options_t));
+  options->BridgeRelay = 1;
+  options->ORPort_set = 1;
+  tt_assert(server_mode(options) == 1);
+  tt_assert(public_server_mode(options) == 0);
+  tt_assert(directory_fetches_from_authorities(options) == 0);
+  tt_assert(networkstatus_consensus_can_use_multiple_directories(options)
+            == 1);
+
+  /* Clients set to FetchDirInfoEarly must fetch it from the authorities,
+   * but can use multiple authorities for bootstrap */
+  memset(options, 0, sizeof(or_options_t));
+  options->FetchDirInfoEarly = 1;
+  tt_assert(server_mode(options) == 0);
+  tt_assert(public_server_mode(options) == 0);
+  tt_assert(directory_fetches_from_authorities(options) == 1);
+  tt_assert(networkstatus_consensus_can_use_multiple_directories(options)
+            == 1);
+
+  /* OR servers only fetch the consensus from the authorities when they don't
+   * know their own address, but never use multiple directories for bootstrap
+   */
+  memset(options, 0, sizeof(or_options_t));
+  options->ORPort_set = 1;
+
+  mock_router_pick_published_address_result = -1;
+  tt_assert(server_mode(options) == 1);
+  tt_assert(public_server_mode(options) == 1);
+  tt_assert(directory_fetches_from_authorities(options) == 1);
+  tt_assert(networkstatus_consensus_can_use_multiple_directories(options)
+            == 0);
+
+  mock_router_pick_published_address_result = 0;
+  tt_assert(server_mode(options) == 1);
+  tt_assert(public_server_mode(options) == 1);
+  tt_assert(directory_fetches_from_authorities(options) == 0);
+  tt_assert(networkstatus_consensus_can_use_multiple_directories(options)
+            == 0);
+
+  /* Exit OR servers only fetch the consensus from the authorities when they
+   * refuse unknown exits, but never use multiple directories for bootstrap
+   */
+  memset(options, 0, sizeof(or_options_t));
+  options->ORPort_set = 1;
+  options->ExitRelay = 1;
+  mock_router_pick_published_address_result = 0;
+  mock_router_my_exit_policy_is_reject_star_result = 0;
+  mock_advertised_server_mode_result = 1;
+  mock_router_get_my_routerinfo_result = &routerinfo;
+
+  routerinfo.supports_tunnelled_dir_requests = 1;
+
+  options->RefuseUnknownExits = 1;
+  tt_assert(server_mode(options) == 1);
+  tt_assert(public_server_mode(options) == 1);
+  tt_assert(directory_fetches_from_authorities(options) == 1);
+  tt_assert(networkstatus_consensus_can_use_multiple_directories(options)
+            == 0);
+
+  options->RefuseUnknownExits = 0;
+  mock_router_pick_published_address_result = 0;
+  tt_assert(server_mode(options) == 1);
+  tt_assert(public_server_mode(options) == 1);
+  tt_assert(directory_fetches_from_authorities(options) == 0);
+  tt_assert(networkstatus_consensus_can_use_multiple_directories(options)
+            == 0);
+
+  /* Dir servers fetch the consensus from the authorities, unless they are not
+   * advertising themselves (hibernating) or have no routerinfo or are not
+   * advertising their dirport, and never use multiple directories for
+   * bootstrap. This only applies if they are also OR servers.
+   * (We don't care much about the behaviour of non-OR directory servers.) */
+  memset(options, 0, sizeof(or_options_t));
+  options->DirPort_set = 1;
+  options->ORPort_set = 1;
+  options->DirCache = 1;
+  mock_router_pick_published_address_result = 0;
+  mock_router_my_exit_policy_is_reject_star_result = 1;
+
+  mock_advertised_server_mode_result = 1;
+  routerinfo.dir_port = 1;
+  mock_router_get_my_routerinfo_result = &routerinfo;
+  tt_assert(server_mode(options) == 1);
+  tt_assert(public_server_mode(options) == 1);
+  tt_assert(directory_fetches_from_authorities(options) == 1);
+  tt_assert(networkstatus_consensus_can_use_multiple_directories(options)
+            == 0);
+
+  mock_advertised_server_mode_result = 0;
+  routerinfo.dir_port = 1;
+  mock_router_get_my_routerinfo_result = &routerinfo;
+  tt_assert(server_mode(options) == 1);
+  tt_assert(public_server_mode(options) == 1);
+  tt_assert(directory_fetches_from_authorities(options) == 0);
+  tt_assert(networkstatus_consensus_can_use_multiple_directories(options)
+            == 0);
+
+  mock_advertised_server_mode_result = 1;
+  mock_router_get_my_routerinfo_result = NULL;
+  tt_assert(server_mode(options) == 1);
+  tt_assert(public_server_mode(options) == 1);
+  tt_assert(directory_fetches_from_authorities(options) == 0);
+  tt_assert(networkstatus_consensus_can_use_multiple_directories(options)
+            == 0);
+
+  mock_advertised_server_mode_result = 1;
+  routerinfo.dir_port = 0;
+  routerinfo.supports_tunnelled_dir_requests = 0;
+  mock_router_get_my_routerinfo_result = &routerinfo;
+  tt_assert(server_mode(options) == 1);
+  tt_assert(public_server_mode(options) == 1);
+  tt_assert(directory_fetches_from_authorities(options) == 0);
+  tt_assert(networkstatus_consensus_can_use_multiple_directories(options)
+            == 0);
+
+  mock_advertised_server_mode_result = 1;
+  routerinfo.dir_port = 1;
+  routerinfo.supports_tunnelled_dir_requests = 1;
+  mock_router_get_my_routerinfo_result = &routerinfo;
+  tt_assert(server_mode(options) == 1);
+  tt_assert(public_server_mode(options) == 1);
+  tt_assert(directory_fetches_from_authorities(options) == 1);
+  tt_assert(networkstatus_consensus_can_use_multiple_directories(options)
+            == 0);
+
+ done:
+  tor_free(options);
+  UNMOCK(router_pick_published_address);
+  UNMOCK(router_get_my_routerinfo);
+  UNMOCK(advertised_server_mode);
+  UNMOCK(router_my_exit_policy_is_reject_star);
+}
+
+static void
+test_config_default_fallback_dirs(void *arg)
+{
+  const char *fallback[] = {
+#include "../or/fallback_dirs.inc"
+    NULL
+  };
+
+  int n_included_fallback_dirs = 0;
+  int n_added_fallback_dirs = 0;
+
+  (void)arg;
+  clear_dir_servers();
+
+  while (fallback[n_included_fallback_dirs])
+    n_included_fallback_dirs++;
+
+  add_default_fallback_dir_servers();
+
+  n_added_fallback_dirs = smartlist_len(router_get_fallback_dir_servers());
+
+  tt_assert(n_included_fallback_dirs == n_added_fallback_dirs);
+
+  done:
+  clear_dir_servers();
+}
+
+static config_line_t *
+mock_config_line(const char *key, const char *val)
+{
+  config_line_t *config_line = tor_malloc(sizeof(config_line_t));
+  memset(config_line, 0, sizeof(config_line_t));
+  config_line->key = tor_strdup(key);
+  config_line->value = tor_strdup(val);
+  return config_line;
+}
+
+static void
+test_config_parse_port_config__listenaddress(void *data)
+{
+  (void)data;
+  int ret;
+  config_line_t *config_listen_address = NULL, *config_listen_address2 = NULL,
+    *config_listen_address3 = NULL;
+  config_line_t *config_port1 = NULL, *config_port2 = NULL,
+    *config_port3 = NULL, *config_port4 = NULL, *config_port5 = NULL;
+  smartlist_t *slout = NULL;
+  port_cfg_t *port_cfg = NULL;
+
+  // Test basic invocation with no arguments
+  ret = parse_port_config(NULL, NULL, NULL, NULL, 0, NULL, 0, 0);
+  tt_int_op(ret, OP_EQ, 0);
+
+  // Setup some test data
+  config_listen_address = mock_config_line("DNSListenAddress", "127.0.0.1");
+  config_listen_address2 = mock_config_line("DNSListenAddress", "x$$$:::345");
+  config_listen_address3 = mock_config_line("DNSListenAddress",
+                                            "127.0.0.1:1442");
+  config_port1 = mock_config_line("DNSPort", "42");
+  config_port2 = mock_config_line("DNSPort", "43");
+  config_port1->next = config_port2;
+  config_port3 = mock_config_line("DNSPort", "auto");
+  config_port4 = mock_config_line("DNSPort", "55542");
+  config_port5 = mock_config_line("DNSPort", "666777");
+
+  // Test failure when we have a ListenAddress line and several
+  // Port lines for the same portname
+  ret = parse_port_config(NULL, config_port1, config_listen_address, "DNS", 0,
+                          NULL, 0, 0);
+  tt_int_op(ret, OP_EQ, -1);
+
+  // Test case when we have a listen address, no default port and allow
+  // spurious listen address lines
+  ret = parse_port_config(NULL, NULL, config_listen_address, "DNS", 0, NULL,
+                          0, CL_PORT_ALLOW_EXTRA_LISTENADDR);
+  tt_int_op(ret, OP_EQ, 1);
+
+  // Test case when we have a listen address, no default port but doesn't
+  // allow spurious listen address lines
+  ret = parse_port_config(NULL, NULL, config_listen_address, "DNS", 0, NULL,
+                          0, 0);
+  tt_int_op(ret, OP_EQ, -1);
+
+  // Test case when we have a listen address, and a port that points to auto,
+  // should use the AUTO port
+  slout = smartlist_new();
+  ret = parse_port_config(slout, config_port3, config_listen_address, "DNS",
+                          0, NULL, 0, 0);
+  tt_int_op(ret, OP_EQ, 0);
+  tt_int_op(smartlist_len(slout), OP_EQ, 1);
+  port_cfg = (port_cfg_t *)smartlist_get(slout, 0);
+  tt_int_op(port_cfg->port, OP_EQ, CFG_AUTO_PORT);
+
+  // Test when we have a listen address and a custom port
+  ret = parse_port_config(slout, config_port4, config_listen_address, "DNS",
+                          0, NULL, 0, 0);
+  tt_int_op(ret, OP_EQ, 0);
+  tt_int_op(smartlist_len(slout), OP_EQ, 2);
+  port_cfg = (port_cfg_t *)smartlist_get(slout, 1);
+  tt_int_op(port_cfg->port, OP_EQ, 55542);
+
+  // Test when we have a listen address and an invalid custom port
+  ret = parse_port_config(slout, config_port5, config_listen_address, "DNS",
+                          0, NULL, 0, 0);
+  tt_int_op(ret, OP_EQ, -1);
+
+  // Test we get a server port configuration when asked for it
+  ret = parse_port_config(slout, NULL, config_listen_address, "DNS", 0, NULL,
+                          123, CL_PORT_SERVER_OPTIONS);
+  tt_int_op(ret, OP_EQ, 0);
+  tt_int_op(smartlist_len(slout), OP_EQ, 4);
+  port_cfg = (port_cfg_t *)smartlist_get(slout, 2);
+  tt_int_op(port_cfg->port, OP_EQ, 123);
+  tt_int_op(port_cfg->server_cfg.no_listen, OP_EQ, 1);
+  tt_int_op(port_cfg->server_cfg.bind_ipv4_only, OP_EQ, 1);
+
+  // Test an invalid ListenAddress configuration
+  ret = parse_port_config(NULL, NULL, config_listen_address2, "DNS", 0, NULL,
+                          222, 0);
+  tt_int_op(ret, OP_EQ, -1);
+
+  // Test default to the port in the listen address if available
+  ret = parse_port_config(slout, config_port2, config_listen_address3, "DNS",
+                          0, NULL, 0, 0);
+  tt_int_op(ret, OP_EQ, 0);
+  tt_int_op(smartlist_len(slout), OP_EQ, 5);
+  port_cfg = (port_cfg_t *)smartlist_get(slout, 4);
+  tt_int_op(port_cfg->port, OP_EQ, 1442);
+
+  // Test we work correctly without an out, but with a listen address
+  // and a port
+  ret = parse_port_config(NULL, config_port2, config_listen_address, "DNS",
+                          0, NULL, 0, 0);
+  tt_int_op(ret, OP_EQ, 0);
+
+  // Test warning nonlocal control
+  ret = parse_port_config(slout, config_port2, config_listen_address, "DNS",
+                          CONN_TYPE_CONTROL_LISTENER, NULL, 0,
+                          CL_PORT_WARN_NONLOCAL);
+  tt_int_op(ret, OP_EQ, 0);
+
+  // Test warning nonlocal ext or listener
+  ret = parse_port_config(slout, config_port2, config_listen_address, "DNS",
+                          CONN_TYPE_EXT_OR_LISTENER, NULL, 0,
+                          CL_PORT_WARN_NONLOCAL);
+  tt_int_op(ret, OP_EQ, 0);
+
+  // Test warning nonlocal other
+  ret = parse_port_config(slout, config_port2, config_listen_address, "DNS",
+                          0, NULL, 0, CL_PORT_WARN_NONLOCAL);
+  tt_int_op(ret, OP_EQ, 0);
+
+  // Test warning nonlocal control without an out
+  ret = parse_port_config(NULL, config_port2, config_listen_address, "DNS",
+                          CONN_TYPE_CONTROL_LISTENER, NULL, 0,
+                          CL_PORT_WARN_NONLOCAL);
+  tt_int_op(ret, OP_EQ, 0);
+
+ done:
+  tor_free(config_listen_address);
+  tor_free(config_listen_address2);
+  tor_free(config_listen_address3);
+  tor_free(config_port1);
+  tor_free(config_port2);
+  tor_free(config_port3);
+  tor_free(config_port4);
+  tor_free(config_port5);
+  smartlist_free(slout);
+}
+
+static void
+test_config_parse_port_config__ports__no_ports_given(void *data)
+{
+  (void)data;
+  int ret;
+  smartlist_t *slout = NULL;
+  port_cfg_t *port_cfg = NULL;
+  config_line_t *config_port_invalid = NULL, *config_port_valid = NULL;
+
+  slout = smartlist_new();
+
+  // Test no defaultport, no defaultaddress and no out
+  ret = parse_port_config(NULL, NULL, NULL, "DNS", 0, NULL, 0, 0);
+  tt_int_op(ret, OP_EQ, 0);
+
+  // Test with defaultport, no defaultaddress and no out
+  ret = parse_port_config(NULL, NULL, NULL, "DNS", 0, NULL, 42, 0);
+  tt_int_op(ret, OP_EQ, 0);
+
+  // Test no defaultport, with defaultaddress and no out
+  ret = parse_port_config(NULL, NULL, NULL, "DNS", 0, "127.0.0.2", 0, 0);
+  tt_int_op(ret, OP_EQ, 0);
+
+  // Test with defaultport, with defaultaddress and no out
+  ret = parse_port_config(NULL, NULL, NULL, "DNS", 0, "127.0.0.2", 42, 0);
+  tt_int_op(ret, OP_EQ, 0);
+
+  // Test no defaultport, no defaultaddress and with out
+  ret = parse_port_config(slout, NULL, NULL, "DNS", 0, NULL, 0, 0);
+  tt_int_op(ret, OP_EQ, 0);
+  tt_int_op(smartlist_len(slout), OP_EQ, 0);
+
+  // Test with defaultport, no defaultaddress and with out
+  ret = parse_port_config(slout, NULL, NULL, "DNS", 0, NULL, 42, 0);
+  tt_int_op(ret, OP_EQ, 0);
+  tt_int_op(smartlist_len(slout), OP_EQ, 0);
+
+  // Test no defaultport, with defaultaddress and with out
+  ret = parse_port_config(slout, NULL, NULL, "DNS", 0, "127.0.0.2", 0, 0);
+  tt_int_op(ret, OP_EQ, 0);
+  tt_int_op(smartlist_len(slout), OP_EQ, 0);
+
+  // Test with defaultport, with defaultaddress and out, adds a new port cfg
+  smartlist_clear(slout);
+  ret = parse_port_config(slout, NULL, NULL, "DNS", 0, "127.0.0.2", 42, 0);
+  tt_int_op(ret, OP_EQ, 0);
+  tt_int_op(smartlist_len(slout), OP_EQ, 1);
+  port_cfg = (port_cfg_t *)smartlist_get(slout, 0);
+  tt_int_op(port_cfg->port, OP_EQ, 42);
+  tt_int_op(port_cfg->is_unix_addr, OP_EQ, 0);
+
+  // Test with defaultport, with defaultaddress and out, adds a new port cfg
+  // for a unix address
+  smartlist_clear(slout);
+  ret = parse_port_config(slout, NULL, NULL, "DNS", 0, "/foo/bar/unixdomain",
+                          42, CL_PORT_IS_UNIXSOCKET);
+  tt_int_op(ret, OP_EQ, 0);
+  tt_int_op(smartlist_len(slout), OP_EQ, 1);
+  port_cfg = (port_cfg_t *)smartlist_get(slout, 0);
+  tt_int_op(port_cfg->port, OP_EQ, 0);
+  tt_int_op(port_cfg->is_unix_addr, OP_EQ, 1);
+  tt_str_op(port_cfg->unix_addr, OP_EQ, "/foo/bar/unixdomain");
+
+ done:
+  smartlist_free(slout);
+  tor_free(config_port_invalid);
+  tor_free(config_port_valid);
+}
+
+static void
+test_config_parse_port_config__ports__ports_given(void *data)
+{
+  (void)data;
+  int ret;
+  smartlist_t *slout = NULL;
+  port_cfg_t *port_cfg = NULL;
+  config_line_t *config_port_invalid = NULL, *config_port_valid = NULL;
+  tor_addr_t addr;
+
+  slout = smartlist_new();
+
+  // Test error when encounters an invalid Port specification
+  config_port_invalid = mock_config_line("DNSPort", "");
+  ret = parse_port_config(NULL, config_port_invalid, NULL, "DNS", 0, NULL,
+                          0, 0);
+  tt_int_op(ret, OP_EQ, -1);
+
+  // Test error when encounters an empty unix domain specification
+  tor_free(config_port_invalid);
+  config_port_invalid = mock_config_line("DNSPort", "unix:");
+  ret = parse_port_config(NULL, config_port_invalid, NULL, "DNS", 0, NULL,
+                          0, 0);
+  tt_int_op(ret, OP_EQ, -1);
+
+  // Test error when encounters a unix domain specification but the listener
+  // doesnt support domain sockets
+  config_port_valid = mock_config_line("DNSPort", "unix:/tmp/foo/bar");
+  ret = parse_port_config(NULL, config_port_valid, NULL, "DNS",
+                          CONN_TYPE_AP_DNS_LISTENER, NULL, 0, 0);
+  tt_int_op(ret, OP_EQ, -1);
+
+  // Test valid unix domain
+  smartlist_clear(slout);
+  ret = parse_port_config(slout, config_port_valid, NULL, "DNS",
+                          CONN_TYPE_AP_LISTENER, NULL, 0, 0);
+#ifdef _WIN32
+  tt_int_op(ret, OP_EQ, -1);
+#else
+  tt_int_op(ret, OP_EQ, 0);
+  tt_int_op(smartlist_len(slout), OP_EQ, 1);
+  port_cfg = (port_cfg_t *)smartlist_get(slout, 0);
+  tt_int_op(port_cfg->port, OP_EQ, 0);
+  tt_int_op(port_cfg->is_unix_addr, OP_EQ, 1);
+  tt_str_op(port_cfg->unix_addr, OP_EQ, "/tmp/foo/bar");
+#endif
+
+  // Test failure if we have no ipv4 and no ipv6 (for unix domain sockets,
+  // this makes no sense - it should be fixed)
+  tor_free(config_port_invalid);
+  config_port_invalid = mock_config_line("DNSPort",
+                                         "unix:/tmp/foo/bar NoIPv4Traffic");
+  ret = parse_port_config(NULL, config_port_invalid, NULL, "DNS",
+                          CONN_TYPE_AP_LISTENER, NULL, 0,
+                          CL_PORT_TAKES_HOSTNAMES);
+  tt_int_op(ret, OP_EQ, -1);
+
+  // Test success with no ipv4 but take ipv6 (for unix domain sockets, this
+  // makes no sense - it should be fixed)
+  tor_free(config_port_valid);
+  smartlist_clear(slout);
+  config_port_valid = mock_config_line("DNSPort", "unix:/tmp/foo/bar "
+                                       "NoIPv4Traffic IPv6Traffic");
+  ret = parse_port_config(slout, config_port_valid, NULL, "DNS",
+                          CONN_TYPE_AP_LISTENER, NULL, 0,
+                          CL_PORT_TAKES_HOSTNAMES);
+#ifdef _WIN32
+  tt_int_op(ret, OP_EQ, -1);
+#else
+  tt_int_op(ret, OP_EQ, 0);
+  tt_int_op(smartlist_len(slout), OP_EQ, 1);
+  port_cfg = (port_cfg_t *)smartlist_get(slout, 0);
+  tt_int_op(port_cfg->entry_cfg.ipv4_traffic, OP_EQ, 0);
+  tt_int_op(port_cfg->entry_cfg.ipv6_traffic, OP_EQ, 1);
+#endif
+
+  // Test success with both ipv4 and ipv6 (for unix domain sockets,
+  // this makes no sense - it should be fixed)
+  tor_free(config_port_valid);
+  smartlist_clear(slout);
+  config_port_valid = mock_config_line("DNSPort", "unix:/tmp/foo/bar "
+                                       "IPv4Traffic IPv6Traffic");
+  ret = parse_port_config(slout, config_port_valid, NULL, "DNS",
+                          CONN_TYPE_AP_LISTENER, NULL, 0,
+                          CL_PORT_TAKES_HOSTNAMES);
+#ifdef _WIN32
+  tt_int_op(ret, OP_EQ, -1);
+#else
+  tt_int_op(ret, OP_EQ, 0);
+  tt_int_op(smartlist_len(slout), OP_EQ, 1);
+  port_cfg = (port_cfg_t *)smartlist_get(slout, 0);
+  tt_int_op(port_cfg->entry_cfg.ipv4_traffic, OP_EQ, 1);
+  tt_int_op(port_cfg->entry_cfg.ipv6_traffic, OP_EQ, 1);
+#endif
+
+  // Test failure if we specify world writable for an IP Port
+  tor_free(config_port_invalid);
+  config_port_invalid = mock_config_line("DNSPort", "42 WorldWritable");
+  ret = parse_port_config(NULL, config_port_invalid, NULL, "DNS", 0,
+                          "127.0.0.3", 0, 0);
+  tt_int_op(ret, OP_EQ, -1);
+
+  // Test failure if we specify group writable for an IP Port
+  tor_free(config_port_invalid);
+  config_port_invalid = mock_config_line("DNSPort", "42 GroupWritable");
+  ret = parse_port_config(NULL, config_port_invalid, NULL, "DNS", 0,
+                          "127.0.0.3", 0, 0);
+  tt_int_op(ret, OP_EQ, -1);
+
+  // Test success with only a port (this will fail without a default address)
+  tor_free(config_port_valid);
+  config_port_valid = mock_config_line("DNSPort", "42");
+  ret = parse_port_config(NULL, config_port_valid, NULL, "DNS", 0,
+                          "127.0.0.3", 0, 0);
+  tt_int_op(ret, OP_EQ, 0);
+
+  // Test success with only a port and isolate destination port
+  tor_free(config_port_valid);
+  smartlist_clear(slout);
+  config_port_valid = mock_config_line("DNSPort", "42 IsolateDestPort");
+  ret = parse_port_config(slout, config_port_valid, NULL, "DNS", 0,
+                          "127.0.0.3", 0, 0);
+  tt_int_op(ret, OP_EQ, 0);
+  tt_int_op(smartlist_len(slout), OP_EQ, 1);
+  port_cfg = (port_cfg_t *)smartlist_get(slout, 0);
+  tt_int_op(port_cfg->entry_cfg.isolation_flags, OP_EQ,
+            ISO_DEFAULT | ISO_DESTPORT);
+
+  // Test success with a negative isolate destination port, and plural
+  tor_free(config_port_valid);
+  smartlist_clear(slout);
+  config_port_valid = mock_config_line("DNSPort", "42 NoIsolateDestPorts");
+  ret = parse_port_config(slout, config_port_valid, NULL, "DNS", 0,
+                          "127.0.0.3", 0, 0);
+  tt_int_op(ret, OP_EQ, 0);
+  tt_int_op(smartlist_len(slout), OP_EQ, 1);
+  port_cfg = (port_cfg_t *)smartlist_get(slout, 0);
+  tt_int_op(port_cfg->entry_cfg.isolation_flags, OP_EQ,
+            ISO_DEFAULT & ~ISO_DESTPORT);
+
+  // Test success with isolate destination address
+  tor_free(config_port_valid);
+  smartlist_clear(slout);
+  config_port_valid = mock_config_line("DNSPort", "42 IsolateDestAddr");
+  ret = parse_port_config(slout, config_port_valid, NULL, "DNS", 0,
+                          "127.0.0.3", 0, 0);
+  tt_int_op(ret, OP_EQ, 0);
+  tt_int_op(smartlist_len(slout), OP_EQ, 1);
+  port_cfg = (port_cfg_t *)smartlist_get(slout, 0);
+  tt_int_op(port_cfg->entry_cfg.isolation_flags, OP_EQ,
+            ISO_DEFAULT | ISO_DESTADDR);
+
+  // Test success with isolate socks AUTH
+  tor_free(config_port_valid);
+  smartlist_clear(slout);
+  config_port_valid = mock_config_line("DNSPort", "42 IsolateSOCKSAuth");
+  ret = parse_port_config(slout, config_port_valid, NULL, "DNS", 0,
+                          "127.0.0.3", 0, 0);
+  tt_int_op(ret, OP_EQ, 0);
+  tt_int_op(smartlist_len(slout), OP_EQ, 1);
+  port_cfg = (port_cfg_t *)smartlist_get(slout, 0);
+  tt_int_op(port_cfg->entry_cfg.isolation_flags, OP_EQ,
+            ISO_DEFAULT | ISO_SOCKSAUTH);
+
+  // Test success with isolate client protocol
+  tor_free(config_port_valid);
+  smartlist_clear(slout);
+  config_port_valid = mock_config_line("DNSPort", "42 IsolateClientProtocol");
+  ret = parse_port_config(slout, config_port_valid, NULL, "DNS", 0,
+                          "127.0.0.3", 0, 0);
+  tt_int_op(ret, OP_EQ, 0);
+  tt_int_op(smartlist_len(slout), OP_EQ, 1);
+  port_cfg = (port_cfg_t *)smartlist_get(slout, 0);
+  tt_int_op(port_cfg->entry_cfg.isolation_flags, OP_EQ,
+            ISO_DEFAULT | ISO_CLIENTPROTO);
+
+  // Test success with isolate client address
+  tor_free(config_port_valid);
+  smartlist_clear(slout);
+  config_port_valid = mock_config_line("DNSPort", "42 IsolateClientAddr");
+  ret = parse_port_config(slout, config_port_valid, NULL, "DNS", 0,
+                          "127.0.0.3", 0, 0);
+  tt_int_op(ret, OP_EQ, 0);
+  tt_int_op(smartlist_len(slout), OP_EQ, 1);
+  port_cfg = (port_cfg_t *)smartlist_get(slout, 0);
+  tt_int_op(port_cfg->entry_cfg.isolation_flags, OP_EQ,
+            ISO_DEFAULT | ISO_CLIENTADDR);
+
+  // Test success with ignored unknown options
+  tor_free(config_port_valid);
+  config_port_valid = mock_config_line("DNSPort", "42 ThisOptionDoesntExist");
+  ret = parse_port_config(NULL, config_port_valid, NULL, "DNS", 0,
+                          "127.0.0.3", 0, 0);
+  tt_int_op(ret, OP_EQ, 0);
+
+  // Test success with no isolate socks AUTH
+  tor_free(config_port_valid);
+  smartlist_clear(slout);
+  config_port_valid = mock_config_line("DNSPort", "42 NoIsolateSOCKSAuth");
+  ret = parse_port_config(slout, config_port_valid, NULL, "DNS", 0,
+                          "127.0.0.3", 0, 0);
+  tt_int_op(ret, OP_EQ, 0);
+  tt_int_op(smartlist_len(slout), OP_EQ, 1);
+  port_cfg = (port_cfg_t *)smartlist_get(slout, 0);
+  tt_int_op(port_cfg->entry_cfg.socks_prefer_no_auth, OP_EQ, 1);
+
+  // Test success with prefer ipv6
+  tor_free(config_port_valid);
+  smartlist_clear(slout);
+  config_port_valid = mock_config_line("DNSPort", "42 IPv6Traffic PreferIPv6");
+  ret = parse_port_config(slout, config_port_valid, NULL, "DNS",
+                          CONN_TYPE_AP_LISTENER, "127.0.0.42", 0,
+                          CL_PORT_TAKES_HOSTNAMES);
+  tt_int_op(ret, OP_EQ, 0);
+  tt_int_op(smartlist_len(slout), OP_EQ, 1);
+  port_cfg = (port_cfg_t *)smartlist_get(slout, 0);
+  tt_int_op(port_cfg->entry_cfg.prefer_ipv6, OP_EQ, 1);
+
+  // Test success with cache ipv4 DNS
+  tor_free(config_port_valid);
+  smartlist_clear(slout);
+  config_port_valid = mock_config_line("DNSPort", "42 CacheIPv4DNS");
+  ret = parse_port_config(slout, config_port_valid, NULL, "DNS", 0,
+                          "127.0.0.42", 0, 0);
+  tt_int_op(ret, OP_EQ, 0);
+  tt_int_op(smartlist_len(slout), OP_EQ, 1);
+  port_cfg = (port_cfg_t *)smartlist_get(slout, 0);
+  tt_int_op(port_cfg->entry_cfg.cache_ipv4_answers, OP_EQ, 1);
+  tt_int_op(port_cfg->entry_cfg.cache_ipv6_answers, OP_EQ, 0);
+
+  // Test success with cache ipv6 DNS
+  tor_free(config_port_valid);
+  smartlist_clear(slout);
+  config_port_valid = mock_config_line("DNSPort", "42 CacheIPv6DNS");
+  ret = parse_port_config(slout, config_port_valid, NULL, "DNS", 0,
+                          "127.0.0.42", 0, 0);
+  tt_int_op(ret, OP_EQ, 0);
+  tt_int_op(smartlist_len(slout), OP_EQ, 1);
+  port_cfg = (port_cfg_t *)smartlist_get(slout, 0);
+  tt_int_op(port_cfg->entry_cfg.cache_ipv4_answers, OP_EQ, 1);
+  tt_int_op(port_cfg->entry_cfg.cache_ipv6_answers, OP_EQ, 1);
+
+  // Test success with no cache ipv4 DNS
+  tor_free(config_port_valid);
+  smartlist_clear(slout);
+  config_port_valid = mock_config_line("DNSPort", "42 NoCacheIPv4DNS");
+  ret = parse_port_config(slout, config_port_valid, NULL, "DNS", 0,
+                          "127.0.0.42", 0, 0);
+  tt_int_op(ret, OP_EQ, 0);
+  tt_int_op(smartlist_len(slout), OP_EQ, 1);
+  port_cfg = (port_cfg_t *)smartlist_get(slout, 0);
+  tt_int_op(port_cfg->entry_cfg.cache_ipv4_answers, OP_EQ, 0);
+  tt_int_op(port_cfg->entry_cfg.cache_ipv6_answers, OP_EQ, 0);
+
+  // Test success with cache DNS
+  tor_free(config_port_valid);
+  smartlist_clear(slout);
+  config_port_valid = mock_config_line("DNSPort", "42 CacheDNS");
+  ret = parse_port_config(slout, config_port_valid, NULL, "DNS", 0,
+                          "127.0.0.42", 0, CL_PORT_TAKES_HOSTNAMES);
+  tt_int_op(ret, OP_EQ, 0);
+  tt_int_op(smartlist_len(slout), OP_EQ, 1);
+  port_cfg = (port_cfg_t *)smartlist_get(slout, 0);
+  tt_int_op(port_cfg->entry_cfg.cache_ipv4_answers, OP_EQ, 1);
+  tt_int_op(port_cfg->entry_cfg.cache_ipv6_answers, OP_EQ, 1);
+
+  // Test success with use cached ipv4 DNS
+  tor_free(config_port_valid);
+  smartlist_clear(slout);
+  config_port_valid = mock_config_line("DNSPort", "42 UseIPv4Cache");
+  ret = parse_port_config(slout, config_port_valid, NULL, "DNS", 0,
+                          "127.0.0.42", 0, 0);
+  tt_int_op(ret, OP_EQ, 0);
+  tt_int_op(smartlist_len(slout), OP_EQ, 1);
+  port_cfg = (port_cfg_t *)smartlist_get(slout, 0);
+  tt_int_op(port_cfg->entry_cfg.use_cached_ipv4_answers, OP_EQ, 1);
+  tt_int_op(port_cfg->entry_cfg.use_cached_ipv6_answers, OP_EQ, 0);
+
+  // Test success with use cached ipv6 DNS
+  tor_free(config_port_valid);
+  smartlist_clear(slout);
+  config_port_valid = mock_config_line("DNSPort", "42 UseIPv6Cache");
+  ret = parse_port_config(slout, config_port_valid, NULL, "DNS", 0,
+                          "127.0.0.42", 0, 0);
+  tt_int_op(ret, OP_EQ, 0);
+  tt_int_op(smartlist_len(slout), OP_EQ, 1);
+  port_cfg = (port_cfg_t *)smartlist_get(slout, 0);
+  tt_int_op(port_cfg->entry_cfg.use_cached_ipv4_answers, OP_EQ, 0);
+  tt_int_op(port_cfg->entry_cfg.use_cached_ipv6_answers, OP_EQ, 1);
+
+  // Test success with use cached DNS
+  tor_free(config_port_valid);
+  smartlist_clear(slout);
+  config_port_valid = mock_config_line("DNSPort", "42 UseDNSCache");
+  ret = parse_port_config(slout, config_port_valid, NULL, "DNS", 0,
+                          "127.0.0.42", 0, 0);
+  tt_int_op(ret, OP_EQ, 0);
+  tt_int_op(smartlist_len(slout), OP_EQ, 1);
+  port_cfg = (port_cfg_t *)smartlist_get(slout, 0);
+  tt_int_op(port_cfg->entry_cfg.use_cached_ipv4_answers, OP_EQ, 1);
+  tt_int_op(port_cfg->entry_cfg.use_cached_ipv6_answers, OP_EQ, 1);
+
+  // Test success with not preferring ipv6 automap
+  tor_free(config_port_valid);
+  smartlist_clear(slout);
+  config_port_valid = mock_config_line("DNSPort", "42 NoPreferIPv6Automap");
+  ret = parse_port_config(slout, config_port_valid, NULL, "DNS", 0,
+                          "127.0.0.42", 0, 0);
+  tt_int_op(ret, OP_EQ, 0);
+  tt_int_op(smartlist_len(slout), OP_EQ, 1);
+  port_cfg = (port_cfg_t *)smartlist_get(slout, 0);
+  tt_int_op(port_cfg->entry_cfg.prefer_ipv6_virtaddr, OP_EQ, 0);
+
+  // Test success with prefer SOCKS no auth
+  tor_free(config_port_valid);
+  smartlist_clear(slout);
+  config_port_valid = mock_config_line("DNSPort", "42 PreferSOCKSNoAuth");
+  ret = parse_port_config(slout, config_port_valid, NULL, "DNS", 0,
+                          "127.0.0.42", 0, 0);
+  tt_int_op(ret, OP_EQ, 0);
+  tt_int_op(smartlist_len(slout), OP_EQ, 1);
+  port_cfg = (port_cfg_t *)smartlist_get(slout, 0);
+  tt_int_op(port_cfg->entry_cfg.socks_prefer_no_auth, OP_EQ, 1);
+
+  // Test failure with both a zero port and a non-zero port
+  tor_free(config_port_invalid);
+  tor_free(config_port_valid);
+  smartlist_clear(slout);
+  config_port_invalid = mock_config_line("DNSPort", "0");
+  config_port_valid = mock_config_line("DNSPort", "42");
+  config_port_invalid->next = config_port_valid;
+  ret = parse_port_config(slout, config_port_invalid, NULL, "DNS", 0,
+                          "127.0.0.42", 0, 0);
+  tt_int_op(ret, OP_EQ, -1);
+
+  // Test success with warn non-local control
+  smartlist_clear(slout);
+  ret = parse_port_config(slout, config_port_valid, NULL, "DNS",
+                          CONN_TYPE_CONTROL_LISTENER, "127.0.0.42", 0,
+                          CL_PORT_WARN_NONLOCAL);
+  tt_int_op(ret, OP_EQ, 0);
+
+  // Test success with warn non-local listener
+  smartlist_clear(slout);
+  ret = parse_port_config(slout, config_port_valid, NULL, "DNS",
+                          CONN_TYPE_EXT_OR_LISTENER, "127.0.0.42", 0,
+                          CL_PORT_WARN_NONLOCAL);
+  tt_int_op(ret, OP_EQ, 0);
+
+  // Test success with warn non-local other
+  smartlist_clear(slout);
+  ret = parse_port_config(slout, config_port_valid, NULL, "DNS", 0,
+                          "127.0.0.42", 0, CL_PORT_WARN_NONLOCAL);
+  tt_int_op(ret, OP_EQ, 0);
+
+  // Test success with warn non-local other without out
+  ret = parse_port_config(NULL, config_port_valid, NULL, "DNS", 0,
+                          "127.0.0.42", 0, CL_PORT_WARN_NONLOCAL);
+  tt_int_op(ret, OP_EQ, 0);
+
+  // Test success with both ipv4 and ipv6 but without stream options
+  tor_free(config_port_valid);
+  smartlist_clear(slout);
+  config_port_valid = mock_config_line("DNSPort", "42 IPv4Traffic "
+                                       "IPv6Traffic");
+  ret = parse_port_config(slout, config_port_valid, NULL, "DNS", 0,
+                          "127.0.0.44", 0,
+                          CL_PORT_TAKES_HOSTNAMES |
+                          CL_PORT_NO_STREAM_OPTIONS);
+  tt_int_op(ret, OP_EQ, 0);
+  tt_int_op(smartlist_len(slout), OP_EQ, 1);
+  port_cfg = (port_cfg_t *)smartlist_get(slout, 0);
+  tt_int_op(port_cfg->entry_cfg.ipv4_traffic, OP_EQ, 1);
+  tt_int_op(port_cfg->entry_cfg.ipv6_traffic, OP_EQ, 0);
+
+  // Test failure for a SessionGroup argument with invalid value
+  tor_free(config_port_invalid);
+  smartlist_clear(slout);
+  config_port_invalid = mock_config_line("DNSPort", "42 SessionGroup=invalid");
+  ret = parse_port_config(slout, config_port_invalid, NULL, "DNS", 0,
+                          "127.0.0.44", 0, CL_PORT_NO_STREAM_OPTIONS);
+  tt_int_op(ret, OP_EQ, -1);
+
+  // TODO: this seems wrong. Shouldn't it be the other way around?
+  // Potential bug.
+  // Test failure for a SessionGroup argument with valid value but with stream
+  // options allowed
+  tor_free(config_port_invalid);
+  smartlist_clear(slout);
+  config_port_invalid = mock_config_line("DNSPort", "42 SessionGroup=123");
+  ret = parse_port_config(slout, config_port_invalid, NULL, "DNS", 0,
+                          "127.0.0.44", 0, 0);
+  tt_int_op(ret, OP_EQ, -1);
+
+  // Test failure for more than one SessionGroup argument
+  tor_free(config_port_invalid);
+  smartlist_clear(slout);
+  config_port_invalid = mock_config_line("DNSPort", "42 SessionGroup=123 "
+                                         "SessionGroup=321");
+  ret = parse_port_config(slout, config_port_invalid, NULL, "DNS", 0,
+                          "127.0.0.44", 0, CL_PORT_NO_STREAM_OPTIONS);
+  tt_int_op(ret, OP_EQ, -1);
+
+  // Test success with a sessiongroup options
+  tor_free(config_port_valid);
+  smartlist_clear(slout);
+  config_port_valid = mock_config_line("DNSPort", "42 SessionGroup=1111122");
+  ret = parse_port_config(slout, config_port_valid, NULL, "DNS", 0,
+                          "127.0.0.44", 0, CL_PORT_NO_STREAM_OPTIONS);
+  tt_int_op(ret, OP_EQ, 0);
+  tt_int_op(smartlist_len(slout), OP_EQ, 1);
+  port_cfg = (port_cfg_t *)smartlist_get(slout, 0);
+  tt_int_op(port_cfg->entry_cfg.session_group, OP_EQ, 1111122);
+
+  // Test success with a zero unix domain socket, and doesnt add it to out
+  tor_free(config_port_valid);
+  smartlist_clear(slout);
+  config_port_valid = mock_config_line("DNSPort", "0");
+  ret = parse_port_config(slout, config_port_valid, NULL, "DNS", 0,
+                          "127.0.0.45", 0, CL_PORT_IS_UNIXSOCKET);
+  tt_int_op(ret, OP_EQ, 0);
+  tt_int_op(smartlist_len(slout), OP_EQ, 0);
+
+  // Test success with a one unix domain socket, and doesnt add it to out
+  tor_free(config_port_valid);
+  smartlist_clear(slout);
+  config_port_valid = mock_config_line("DNSPort", "something");
+  ret = parse_port_config(slout, config_port_valid, NULL, "DNS", 0,
+                          "127.0.0.45", 0, CL_PORT_IS_UNIXSOCKET);
+  tt_int_op(ret, OP_EQ, 0);
+  tt_int_op(smartlist_len(slout), OP_EQ, 1);
+  port_cfg = (port_cfg_t *)smartlist_get(slout, 0);
+  tt_int_op(port_cfg->is_unix_addr, OP_EQ, 1);
+  tt_str_op(port_cfg->unix_addr, OP_EQ, "something");
+
+  // Test success with a port of auto - it uses the default address
+  tor_free(config_port_valid);
+  smartlist_clear(slout);
+  config_port_valid = mock_config_line("DNSPort", "auto");
+  ret = parse_port_config(slout, config_port_valid, NULL, "DNS", 0,
+                          "127.0.0.46", 0, 0);
+  tt_int_op(ret, OP_EQ, 0);
+  tt_int_op(smartlist_len(slout), OP_EQ, 1);
+  port_cfg = (port_cfg_t *)smartlist_get(slout, 0);
+  tt_int_op(port_cfg->port, OP_EQ, CFG_AUTO_PORT);
+  tor_addr_parse(&addr, "127.0.0.46");
+  tt_assert(tor_addr_eq(&port_cfg->addr, &addr))
+
+  // Test success with parsing both an address and an auto port
+  tor_free(config_port_valid);
+  smartlist_clear(slout);
+  config_port_valid = mock_config_line("DNSPort", "127.0.0.122:auto");
+  ret = parse_port_config(slout, config_port_valid, NULL, "DNS", 0,
+                          "127.0.0.46", 0, 0);
+  tt_int_op(ret, OP_EQ, 0);
+  tt_int_op(smartlist_len(slout), OP_EQ, 1);
+  port_cfg = (port_cfg_t *)smartlist_get(slout, 0);
+  tt_int_op(port_cfg->port, OP_EQ, CFG_AUTO_PORT);
+  tor_addr_parse(&addr, "127.0.0.122");
+  tt_assert(tor_addr_eq(&port_cfg->addr, &addr))
+
+  // Test failure when asked to parse an invalid address followed by auto
+  tor_free(config_port_invalid);
+  config_port_invalid = mock_config_line("DNSPort", "invalidstuff!!:auto");
+  ret = parse_port_config(NULL, config_port_invalid, NULL, "DNS", 0,
+                          "127.0.0.46", 0, 0);
+  tt_int_op(ret, OP_EQ, -1);
+
+  // Test success with parsing both an address and a real port
+  tor_free(config_port_valid);
+  smartlist_clear(slout);
+  config_port_valid = mock_config_line("DNSPort", "127.0.0.123:656");
+  ret = parse_port_config(slout, config_port_valid, NULL, "DNS", 0,
+                          "127.0.0.46", 0, 0);
+  tt_int_op(ret, OP_EQ, 0);
+  tt_int_op(smartlist_len(slout), OP_EQ, 1);
+  port_cfg = (port_cfg_t *)smartlist_get(slout, 0);
+  tt_int_op(port_cfg->port, OP_EQ, 656);
+  tor_addr_parse(&addr, "127.0.0.123");
+  tt_assert(tor_addr_eq(&port_cfg->addr, &addr))
+
+  // Test failure if we can't parse anything at all
+  tor_free(config_port_invalid);
+  smartlist_clear(slout);
+  config_port_invalid = mock_config_line("DNSPort", "something wrong");
+  ret = parse_port_config(slout, config_port_invalid, NULL, "DNS", 0,
+                          "127.0.0.46", 0, 0);
+  tt_int_op(ret, OP_EQ, -1);
+
+  // Test failure if we find both an address, a port and an auto
+  tor_free(config_port_invalid);
+  smartlist_clear(slout);
+  config_port_invalid = mock_config_line("DNSPort", "127.0.1.0:123:auto");
+  ret = parse_port_config(slout, config_port_invalid, NULL, "DNS", 0,
+                          "127.0.0.46", 0, 0);
+  tt_int_op(ret, OP_EQ, -1);
+
+  // Test that default to group writeable default sets group writeable for
+  // domain socket
+  tor_free(config_port_valid);
+  smartlist_clear(slout);
+  config_port_valid = mock_config_line("DNSPort", "unix:/tmp/somewhere");
+  ret = parse_port_config(slout, config_port_valid, NULL, "DNS",
+                          CONN_TYPE_AP_LISTENER, "127.0.0.46", 0,
+                          CL_PORT_DFLT_GROUP_WRITABLE);
+#ifdef _WIN32
+  tt_int_op(ret, OP_EQ, -1);
+#else
+  tt_int_op(ret, OP_EQ, 0);
+  tt_int_op(smartlist_len(slout), OP_EQ, 1);
+  port_cfg = (port_cfg_t *)smartlist_get(slout, 0);
+  tt_int_op(port_cfg->is_group_writable, OP_EQ, 1);
+#endif
+
+ done:
+  smartlist_free(slout);
+  tor_free(config_port_invalid);
+  tor_free(config_port_valid);
+}
+
+static void
+test_config_parse_port_config__ports__server_options(void *data)
+{
+  (void)data;
+  int ret;
+  smartlist_t *slout = NULL;
+  port_cfg_t *port_cfg = NULL;
+  config_line_t *config_port_invalid = NULL, *config_port_valid = NULL;
+
+  slout = smartlist_new();
+
+  // Test success with NoAdvertise option
+  tor_free(config_port_valid);
+  config_port_valid = mock_config_line("DNSPort",
+                                       "127.0.0.124:656 NoAdvertise");
+  ret = parse_port_config(slout, config_port_valid, NULL, "DNS", 0, NULL, 0,
+                          CL_PORT_SERVER_OPTIONS);
+  tt_int_op(ret, OP_EQ, 0);
+  tt_int_op(smartlist_len(slout), OP_EQ, 1);
+  port_cfg = (port_cfg_t *)smartlist_get(slout, 0);
+  tt_int_op(port_cfg->server_cfg.no_advertise, OP_EQ, 1);
+  tt_int_op(port_cfg->server_cfg.no_listen, OP_EQ, 0);
+
+  // Test success with NoListen option
+  tor_free(config_port_valid);
+  smartlist_clear(slout);
+  config_port_valid = mock_config_line("DNSPort", "127.0.0.124:656 NoListen");
+  ret = parse_port_config(slout, config_port_valid, NULL, "DNS", 0, NULL, 0,
+                          CL_PORT_SERVER_OPTIONS);
+  tt_int_op(ret, OP_EQ, 0);
+  tt_int_op(smartlist_len(slout), OP_EQ, 1);
+  port_cfg = (port_cfg_t *)smartlist_get(slout, 0);
+  tt_int_op(port_cfg->server_cfg.no_advertise, OP_EQ, 0);
+  tt_int_op(port_cfg->server_cfg.no_listen, OP_EQ, 1);
+
+  // Test failure with both NoAdvertise and NoListen option
+  tor_free(config_port_invalid);
+  smartlist_clear(slout);
+  config_port_invalid = mock_config_line("DNSPort", "127.0.0.124:656 NoListen "
+                                         "NoAdvertise");
+  ret = parse_port_config(slout, config_port_invalid, NULL, "DNS", 0, NULL,
+                          0, CL_PORT_SERVER_OPTIONS);
+  tt_int_op(ret, OP_EQ, -1);
+
+  // Test success with IPv4Only
+  tor_free(config_port_valid);
+  smartlist_clear(slout);
+  config_port_valid = mock_config_line("DNSPort", "127.0.0.124:656 IPv4Only");
+  ret = parse_port_config(slout, config_port_valid, NULL, "DNS", 0, NULL, 0,
+                          CL_PORT_SERVER_OPTIONS);
+  tt_int_op(ret, OP_EQ, 0);
+  tt_int_op(smartlist_len(slout), OP_EQ, 1);
+  port_cfg = (port_cfg_t *)smartlist_get(slout, 0);
+  tt_int_op(port_cfg->server_cfg.bind_ipv4_only, OP_EQ, 1);
+  tt_int_op(port_cfg->server_cfg.bind_ipv6_only, OP_EQ, 0);
+
+  // Test success with IPv6Only
+  tor_free(config_port_valid);
+  smartlist_clear(slout);
+  config_port_valid = mock_config_line("DNSPort", "[::1]:656 IPv6Only");
+  ret = parse_port_config(slout, config_port_valid, NULL, "DNS", 0, NULL, 0,
+                          CL_PORT_SERVER_OPTIONS);
+  tt_int_op(ret, OP_EQ, 0);
+  tt_int_op(smartlist_len(slout), OP_EQ, 1);
+  port_cfg = (port_cfg_t *)smartlist_get(slout, 0);
+  tt_int_op(port_cfg->server_cfg.bind_ipv4_only, OP_EQ, 0);
+  tt_int_op(port_cfg->server_cfg.bind_ipv6_only, OP_EQ, 1);
+
+  // Test failure with both IPv4Only and IPv6Only
+  tor_free(config_port_invalid);
+  smartlist_clear(slout);
+  config_port_invalid = mock_config_line("DNSPort", "127.0.0.124:656 IPv6Only "
+                                         "IPv4Only");
+  ret = parse_port_config(slout, config_port_invalid, NULL, "DNS", 0, NULL,
+                          0, CL_PORT_SERVER_OPTIONS);
+  tt_int_op(ret, OP_EQ, -1);
+
+  // Test success with invalid parameter
+  tor_free(config_port_valid);
+  smartlist_clear(slout);
+  config_port_valid = mock_config_line("DNSPort", "127.0.0.124:656 unknown");
+  ret = parse_port_config(slout, config_port_valid, NULL, "DNS", 0, NULL, 0,
+                          CL_PORT_SERVER_OPTIONS);
+  tt_int_op(ret, OP_EQ, 0);
+  tt_int_op(smartlist_len(slout), OP_EQ, 1);
+
+  // Test failure when asked to bind only to ipv6 but gets an ipv4 address
+  tor_free(config_port_invalid);
+  smartlist_clear(slout);
+  config_port_invalid = mock_config_line("DNSPort",
+                                         "127.0.0.124:656 IPv6Only");
+  ret = parse_port_config(slout, config_port_invalid, NULL, "DNS", 0, NULL,
+                          0, CL_PORT_SERVER_OPTIONS);
+  tt_int_op(ret, OP_EQ, -1);
+
+  // Test failure when asked to bind only to ipv4 but gets an ipv6 address
+  tor_free(config_port_invalid);
+  smartlist_clear(slout);
+  config_port_invalid = mock_config_line("DNSPort", "[::1]:656 IPv4Only");
+  ret = parse_port_config(slout, config_port_invalid, NULL, "DNS", 0, NULL,
+                          0, CL_PORT_SERVER_OPTIONS);
+  tt_int_op(ret, OP_EQ, -1);
+
+ done:
+  smartlist_free(slout);
+  tor_free(config_port_invalid);
+  tor_free(config_port_valid);
+}
+
 #define CONFIG_TEST(name, flags)                          \
   { #name, test_config_ ## name, flags, NULL, NULL }
 
 struct testcase_t config_tests[] = {
+  CONFIG_TEST(adding_trusted_dir_server, TT_FORK),
+  CONFIG_TEST(adding_fallback_dir_server, TT_FORK),
+  CONFIG_TEST(parsing_trusted_dir_server, 0),
+  CONFIG_TEST(parsing_fallback_dir_server, 0),
+  CONFIG_TEST(adding_default_trusted_dir_servers, TT_FORK),
   CONFIG_TEST(adding_dir_servers, TT_FORK),
+  CONFIG_TEST(default_dir_servers, TT_FORK),
+  CONFIG_TEST(default_fallback_dirs, 0),
   CONFIG_TEST(resolve_my_address, TT_FORK),
   CONFIG_TEST(addressmap, 0),
   CONFIG_TEST(parse_bridge_line, 0),
@@ -3222,6 +4571,11 @@ struct testcase_t config_tests[] = {
   CONFIG_TEST(check_or_create_data_subdir, TT_FORK),
   CONFIG_TEST(write_to_data_subdir, TT_FORK),
   CONFIG_TEST(fix_my_family, 0),
+  CONFIG_TEST(directory_fetch, 0),
+  CONFIG_TEST(parse_port_config__listenaddress, 0),
+  CONFIG_TEST(parse_port_config__ports__no_ports_given, 0),
+  CONFIG_TEST(parse_port_config__ports__server_options, 0),
+  CONFIG_TEST(parse_port_config__ports__ports_given, 0),
   END_OF_TESTCASES
 };
 
diff --git a/src/test/test_connection.c b/src/test/test_connection.c
new file mode 100644
index 0000000..c5ef929
--- /dev/null
+++ b/src/test/test_connection.c
@@ -0,0 +1,761 @@
+/* Copyright (c) 2015, The Tor Project, Inc. */
+/* See LICENSE for licensing information */
+
+#include "orconfig.h"
+
+#define CONNECTION_PRIVATE
+#define MAIN_PRIVATE
+
+#include "or.h"
+#include "test.h"
+
+#include "connection.h"
+#include "main.h"
+#include "networkstatus.h"
+#include "rendcache.h"
+#include "directory.h"
+
+static void test_conn_lookup_addr_helper(const char *address,
+                                         int family,
+                                         tor_addr_t *addr);
+
+static void * test_conn_get_basic_setup(const struct testcase_t *tc);
+static int test_conn_get_basic_teardown(const struct testcase_t *tc,
+                                        void *arg);
+
+static void * test_conn_get_rend_setup(const struct testcase_t *tc);
+static int test_conn_get_rend_teardown(const struct testcase_t *tc,
+                                        void *arg);
+
+static void * test_conn_get_rsrc_setup(const struct testcase_t *tc);
+static int test_conn_get_rsrc_teardown(const struct testcase_t *tc,
+                                        void *arg);
+
+/* Arbitrary choice - IPv4 Directory Connection to localhost */
+#define TEST_CONN_TYPE          (CONN_TYPE_DIR)
+/* We assume every machine has IPv4 localhost, is that ok? */
+#define TEST_CONN_ADDRESS       "127.0.0.1"
+#define TEST_CONN_PORT          (12345)
+#define TEST_CONN_ADDRESS_PORT  "127.0.0.1:12345"
+#define TEST_CONN_FAMILY        (AF_INET)
+#define TEST_CONN_STATE         (DIR_CONN_STATE_MIN_)
+#define TEST_CONN_ADDRESS_2     "127.0.0.2"
+
+#define TEST_CONN_BASIC_PURPOSE (DIR_PURPOSE_MIN_)
+
+#define TEST_CONN_REND_ADDR     "cfs3rltphxxvabci"
+#define TEST_CONN_REND_PURPOSE  (DIR_PURPOSE_FETCH_RENDDESC_V2)
+#define TEST_CONN_REND_PURPOSE_SUCCESSFUL (DIR_PURPOSE_HAS_FETCHED_RENDDESC_V2)
+#define TEST_CONN_REND_TYPE_2   (CONN_TYPE_AP)
+#define TEST_CONN_REND_ADDR_2   "icbavxxhptlr3sfc"
+
+#define TEST_CONN_RSRC          (networkstatus_get_flavor_name(FLAV_MICRODESC))
+#define TEST_CONN_RSRC_PURPOSE  (DIR_PURPOSE_FETCH_CONSENSUS)
+#define TEST_CONN_RSRC_STATE_SUCCESSFUL (DIR_CONN_STATE_CLIENT_FINISHED)
+#define TEST_CONN_RSRC_2        (networkstatus_get_flavor_name(FLAV_NS))
+
+#define TEST_CONN_DL_STATE      (DIR_CONN_STATE_CLIENT_SENDING)
+
+#define TEST_CONN_FD_INIT 50
+static int mock_connection_connect_sockaddr_called = 0;
+static int fake_socket_number = TEST_CONN_FD_INIT;
+
+static int
+mock_connection_connect_sockaddr(connection_t *conn,
+                                 const struct sockaddr *sa,
+                                 socklen_t sa_len,
+                                 const struct sockaddr *bindaddr,
+                                 socklen_t bindaddr_len,
+                                 int *socket_error)
+{
+  (void)sa_len;
+  (void)bindaddr;
+  (void)bindaddr_len;
+
+  tor_assert(conn);
+  tor_assert(sa);
+  tor_assert(socket_error);
+
+  mock_connection_connect_sockaddr_called++;
+
+  conn->s = fake_socket_number++;
+  tt_assert(SOCKET_OK(conn->s));
+  /* We really should call tor_libevent_initialize() here. Because we don't,
+   * we are relying on other parts of the code not checking if the_event_base
+   * (and therefore event->ev_base) is NULL.  */
+  tt_assert(connection_add_connecting(conn) == 0);
+
+ done:
+  /* Fake "connected" status */
+  return 1;
+}
+
+static void
+test_conn_lookup_addr_helper(const char *address, int family, tor_addr_t *addr)
+{
+  int rv = 0;
+
+  tt_assert(addr);
+
+  rv = tor_addr_lookup(address, family, addr);
+  /* XXXX - should we retry on transient failure? */
+  tt_assert(rv == 0);
+  tt_assert(tor_addr_is_loopback(addr));
+  tt_assert(tor_addr_is_v4(addr));
+
+  return;
+
+ done:
+  tor_addr_make_null(addr, TEST_CONN_FAMILY);
+}
+
+static void *
+test_conn_get_basic_setup(const struct testcase_t *tc)
+{
+  connection_t *conn = NULL;
+  tor_addr_t addr;
+  int socket_err = 0;
+  int in_progress = 0;
+  (void)tc;
+
+  MOCK(connection_connect_sockaddr,
+       mock_connection_connect_sockaddr);
+
+  init_connection_lists();
+
+  conn = connection_new(TEST_CONN_TYPE, TEST_CONN_FAMILY);
+  tt_assert(conn);
+
+  test_conn_lookup_addr_helper(TEST_CONN_ADDRESS, TEST_CONN_FAMILY, &addr);
+  tt_assert(!tor_addr_is_null(&addr));
+
+  /* XXXX - connection_connect doesn't set these, should it? */
+  tor_addr_copy_tight(&conn->addr, &addr);
+  conn->port = TEST_CONN_PORT;
+  mock_connection_connect_sockaddr_called = 0;
+  in_progress = connection_connect(conn, TEST_CONN_ADDRESS_PORT, &addr,
+                                   TEST_CONN_PORT, &socket_err);
+  tt_assert(mock_connection_connect_sockaddr_called == 1);
+  tt_assert(!socket_err);
+  tt_assert(in_progress == 0 || in_progress == 1);
+
+  /* fake some of the attributes so the connection looks OK */
+  conn->state = TEST_CONN_STATE;
+  conn->purpose = TEST_CONN_BASIC_PURPOSE;
+  assert_connection_ok(conn, time(NULL));
+
+  UNMOCK(connection_connect_sockaddr);
+
+  return conn;
+
+  /* On failure */
+ done:
+  UNMOCK(connection_connect_sockaddr);
+  test_conn_get_basic_teardown(tc, conn);
+
+  /* Returning NULL causes the unit test to fail */
+  return NULL;
+}
+
+static int
+test_conn_get_basic_teardown(const struct testcase_t *tc, void *arg)
+{
+  (void)tc;
+  connection_t *conn = arg;
+
+  tt_assert(conn);
+  assert_connection_ok(conn, time(NULL));
+
+  /* teardown the connection as fast as possible */
+  if (conn->linked_conn) {
+    assert_connection_ok(conn->linked_conn, time(NULL));
+
+    /* We didn't call tor_libevent_initialize(), so event_base was NULL,
+     * so we can't rely on connection_unregister_events() use of event_del().
+     */
+    if (conn->linked_conn->read_event) {
+      tor_free(conn->linked_conn->read_event);
+      conn->linked_conn->read_event = NULL;
+    }
+    if (conn->linked_conn->write_event) {
+      tor_free(conn->linked_conn->write_event);
+      conn->linked_conn->write_event = NULL;
+    }
+
+    if (!conn->linked_conn->marked_for_close) {
+      connection_close_immediate(conn->linked_conn);
+      connection_mark_for_close(conn->linked_conn);
+    }
+    conn->linked_conn->linked_conn = NULL;
+    connection_free(conn->linked_conn);
+    conn->linked_conn = NULL;
+  }
+
+  /* We didn't set the events up properly, so we can't use event_del() in
+   * close_closeable_connections() > connection_free()
+   * > connection_unregister_events() */
+  if (conn->read_event) {
+    tor_free(conn->read_event);
+    conn->read_event = NULL;
+  }
+  if (conn->write_event) {
+    tor_free(conn->write_event);
+    conn->write_event = NULL;
+  }
+
+  if (!conn->marked_for_close) {
+    connection_close_immediate(conn);
+    connection_mark_for_close(conn);
+  }
+
+  close_closeable_connections();
+
+  /* The unit test will fail if we return 0 */
+  return 1;
+
+  /* When conn == NULL, we can't cleanup anything */
+ done:
+  return 0;
+}
+
+static void *
+test_conn_get_rend_setup(const struct testcase_t *tc)
+{
+  dir_connection_t *conn = DOWNCAST(dir_connection_t,
+                                    test_conn_get_basic_setup(tc));
+  tt_assert(conn);
+  assert_connection_ok(&conn->base_, time(NULL));
+
+  rend_cache_init();
+
+  /* TODO: use directory_initiate_command_rend() to do this - maybe? */
+  conn->rend_data = tor_malloc_zero(sizeof(rend_data_t));
+  tor_assert(strlen(TEST_CONN_REND_ADDR) == REND_SERVICE_ID_LEN_BASE32);
+  memcpy(conn->rend_data->onion_address,
+         TEST_CONN_REND_ADDR,
+         REND_SERVICE_ID_LEN_BASE32+1);
+  conn->rend_data->hsdirs_fp = smartlist_new();
+  conn->base_.purpose = TEST_CONN_REND_PURPOSE;
+
+  assert_connection_ok(&conn->base_, time(NULL));
+  return conn;
+
+  /* On failure */
+ done:
+  test_conn_get_rend_teardown(tc, conn);
+  /* Returning NULL causes the unit test to fail */
+  return NULL;
+}
+
+static int
+test_conn_get_rend_teardown(const struct testcase_t *tc, void *arg)
+{
+  dir_connection_t *conn = DOWNCAST(dir_connection_t, arg);
+  int rv = 0;
+
+  tt_assert(conn);
+  assert_connection_ok(&conn->base_, time(NULL));
+
+  /* avoid a last-ditch attempt to refetch the descriptor */
+  conn->base_.purpose = TEST_CONN_REND_PURPOSE_SUCCESSFUL;
+
+  /* connection_free_() cleans up rend_data */
+  rv = test_conn_get_basic_teardown(tc, arg);
+ done:
+  rend_cache_free_all();
+  return rv;
+}
+
+static void *
+test_conn_get_rsrc_setup(const struct testcase_t *tc)
+{
+  dir_connection_t *conn = DOWNCAST(dir_connection_t,
+                                    test_conn_get_basic_setup(tc));
+  tt_assert(conn);
+  assert_connection_ok(&conn->base_, time(NULL));
+
+  /* TODO: use the canonical function to do this - maybe? */
+  conn->requested_resource = tor_strdup(TEST_CONN_RSRC);
+  conn->base_.purpose = TEST_CONN_RSRC_PURPOSE;
+
+  assert_connection_ok(&conn->base_, time(NULL));
+  return conn;
+
+  /* On failure */
+ done:
+  test_conn_get_rend_teardown(tc, conn);
+  /* Returning NULL causes the unit test to fail */
+  return NULL;
+}
+
+static int
+test_conn_get_rsrc_teardown(const struct testcase_t *tc, void *arg)
+{
+  dir_connection_t *conn = DOWNCAST(dir_connection_t, arg);
+  int rv = 0;
+
+  tt_assert(conn);
+  assert_connection_ok(&conn->base_, time(NULL));
+
+  /* avoid a last-ditch attempt to refetch the consensus */
+  conn->base_.state = TEST_CONN_RSRC_STATE_SUCCESSFUL;
+
+  /* connection_free_() cleans up requested_resource */
+  rv = test_conn_get_basic_teardown(tc, arg);
+ done:
+  return rv;
+}
+
+static void *
+test_conn_download_status_setup(const struct testcase_t *tc)
+{
+  (void)tc;
+
+  /* Don't return NULL, that causes the test to fail */
+  return (void*)"ok";
+}
+
+static int
+test_conn_download_status_teardown(const struct testcase_t *tc, void *arg)
+{
+  (void)arg;
+  int rv = 0;
+
+  /* Ignore arg, and just loop through the connection array */
+  SMARTLIST_FOREACH_BEGIN(get_connection_array(), connection_t *, conn) {
+    if (conn) {
+      assert_connection_ok(conn, time(NULL));
+
+      /* connection_free_() cleans up requested_resource */
+      rv = test_conn_get_rsrc_teardown(tc, conn);
+      tt_assert(rv == 1);
+    }
+  } SMARTLIST_FOREACH_END(conn);
+
+ done:
+  return rv;
+}
+
+static dir_connection_t *
+test_conn_download_status_add_a_connection(void)
+{
+  dir_connection_t *conn = DOWNCAST(dir_connection_t,
+                                    test_conn_get_rsrc_setup(NULL));
+
+  tt_assert(conn);
+  assert_connection_ok(&conn->base_, time(NULL));
+
+  return conn;
+
+ done:
+  test_conn_download_status_teardown(NULL, NULL);
+  return NULL;
+}
+
+static struct testcase_setup_t test_conn_get_basic_st = {
+  test_conn_get_basic_setup, test_conn_get_basic_teardown
+};
+
+static struct testcase_setup_t test_conn_get_rend_st = {
+  test_conn_get_rend_setup, test_conn_get_rend_teardown
+};
+
+static struct testcase_setup_t test_conn_get_rsrc_st = {
+  test_conn_get_rsrc_setup, test_conn_get_rsrc_teardown
+};
+
+static struct testcase_setup_t test_conn_download_status_st = {
+  test_conn_download_status_setup, test_conn_download_status_teardown
+};
+
+static void
+test_conn_get_basic(void *arg)
+{
+  connection_t *conn = (connection_t*)arg;
+  tor_addr_t addr, addr2;
+
+  tt_assert(conn);
+  assert_connection_ok(conn, time(NULL));
+
+  test_conn_lookup_addr_helper(TEST_CONN_ADDRESS, TEST_CONN_FAMILY, &addr);
+  tt_assert(!tor_addr_is_null(&addr));
+  test_conn_lookup_addr_helper(TEST_CONN_ADDRESS_2, TEST_CONN_FAMILY, &addr2);
+  tt_assert(!tor_addr_is_null(&addr2));
+
+  /* Check that we get this connection back when we search for it by
+   * its attributes, but get NULL when we supply a different value. */
+
+  tt_assert(connection_get_by_global_id(conn->global_identifier) == conn);
+  tt_assert(connection_get_by_global_id(!conn->global_identifier) == NULL);
+
+  tt_assert(connection_get_by_type(conn->type) == conn);
+  tt_assert(connection_get_by_type(TEST_CONN_TYPE) == conn);
+  tt_assert(connection_get_by_type(!conn->type) == NULL);
+  tt_assert(connection_get_by_type(!TEST_CONN_TYPE) == NULL);
+
+  tt_assert(connection_get_by_type_state(conn->type, conn->state)
+            == conn);
+  tt_assert(connection_get_by_type_state(TEST_CONN_TYPE, TEST_CONN_STATE)
+            == conn);
+  tt_assert(connection_get_by_type_state(!conn->type, !conn->state)
+            == NULL);
+  tt_assert(connection_get_by_type_state(!TEST_CONN_TYPE, !TEST_CONN_STATE)
+            == NULL);
+
+  /* Match on the connection fields themselves */
+  tt_assert(connection_get_by_type_addr_port_purpose(conn->type,
+                                                     &conn->addr,
+                                                     conn->port,
+                                                     conn->purpose)
+            == conn);
+  /* Match on the original inputs to the connection */
+  tt_assert(connection_get_by_type_addr_port_purpose(TEST_CONN_TYPE,
+                                                     &conn->addr,
+                                                     conn->port,
+                                                     conn->purpose)
+            == conn);
+  tt_assert(connection_get_by_type_addr_port_purpose(conn->type,
+                                                     &addr,
+                                                     conn->port,
+                                                     conn->purpose)
+            == conn);
+  tt_assert(connection_get_by_type_addr_port_purpose(conn->type,
+                                                     &conn->addr,
+                                                     TEST_CONN_PORT,
+                                                     conn->purpose)
+            == conn);
+  tt_assert(connection_get_by_type_addr_port_purpose(conn->type,
+                                                     &conn->addr,
+                                                     conn->port,
+                                                     TEST_CONN_BASIC_PURPOSE)
+            == conn);
+  tt_assert(connection_get_by_type_addr_port_purpose(TEST_CONN_TYPE,
+                                                     &addr,
+                                                     TEST_CONN_PORT,
+                                                     TEST_CONN_BASIC_PURPOSE)
+            == conn);
+  /* Then try each of the not-matching combinations */
+  tt_assert(connection_get_by_type_addr_port_purpose(!conn->type,
+                                                     &conn->addr,
+                                                     conn->port,
+                                                     conn->purpose)
+            == NULL);
+  tt_assert(connection_get_by_type_addr_port_purpose(conn->type,
+                                                     &addr2,
+                                                     conn->port,
+                                                     conn->purpose)
+            == NULL);
+  tt_assert(connection_get_by_type_addr_port_purpose(conn->type,
+                                                     &conn->addr,
+                                                     !conn->port,
+                                                     conn->purpose)
+            == NULL);
+  tt_assert(connection_get_by_type_addr_port_purpose(conn->type,
+                                                     &conn->addr,
+                                                     conn->port,
+                                                     !conn->purpose)
+            == NULL);
+  /* Then try everything not-matching */
+  tt_assert(connection_get_by_type_addr_port_purpose(!conn->type,
+                                                     &addr2,
+                                                     !conn->port,
+                                                     !conn->purpose)
+            == NULL);
+  tt_assert(connection_get_by_type_addr_port_purpose(!TEST_CONN_TYPE,
+                                                     &addr2,
+                                                     !TEST_CONN_PORT,
+                                                     !TEST_CONN_BASIC_PURPOSE)
+            == NULL);
+
+ done:
+  ;
+}
+
+static void
+test_conn_get_rend(void *arg)
+{
+  dir_connection_t *conn = DOWNCAST(dir_connection_t, arg);
+  tt_assert(conn);
+  assert_connection_ok(&conn->base_, time(NULL));
+
+  tt_assert(connection_get_by_type_state_rendquery(
+                                            conn->base_.type,
+                                            conn->base_.state,
+                                            conn->rend_data->onion_address)
+            == TO_CONN(conn));
+  tt_assert(connection_get_by_type_state_rendquery(
+                                            TEST_CONN_TYPE,
+                                            TEST_CONN_STATE,
+                                            TEST_CONN_REND_ADDR)
+            == TO_CONN(conn));
+  tt_assert(connection_get_by_type_state_rendquery(TEST_CONN_REND_TYPE_2,
+                                                   !conn->base_.state,
+                                                   "")
+            == NULL);
+  tt_assert(connection_get_by_type_state_rendquery(TEST_CONN_REND_TYPE_2,
+                                                   !TEST_CONN_STATE,
+                                                   TEST_CONN_REND_ADDR_2)
+            == NULL);
+
+ done:
+  ;
+}
+
+#define sl_is_conn_assert(sl_input, conn) \
+  do {                                               \
+    the_sl = (sl_input);                             \
+    tt_assert(smartlist_len((the_sl)) == 1);         \
+    tt_assert(smartlist_get((the_sl), 0) == (conn)); \
+    smartlist_free(the_sl); the_sl = NULL;           \
+  } while (0)
+
+#define sl_no_conn_assert(sl_input)          \
+  do {                                       \
+    the_sl = (sl_input);                     \
+    tt_assert(smartlist_len((the_sl)) == 0); \
+    smartlist_free(the_sl); the_sl = NULL;   \
+  } while (0)
+
+static void
+test_conn_get_rsrc(void *arg)
+{
+  dir_connection_t *conn = DOWNCAST(dir_connection_t, arg);
+  smartlist_t *the_sl = NULL;
+  tt_assert(conn);
+  assert_connection_ok(&conn->base_, time(NULL));
+
+  tt_assert(connection_dir_get_by_purpose_and_resource(
+                                                    conn->base_.purpose,
+                                                    conn->requested_resource)
+            == conn);
+  tt_assert(connection_dir_get_by_purpose_and_resource(
+                                                    TEST_CONN_RSRC_PURPOSE,
+                                                    TEST_CONN_RSRC)
+            == conn);
+  tt_assert(connection_dir_get_by_purpose_and_resource(
+                                                    !conn->base_.purpose,
+                                                    "")
+            == NULL);
+  tt_assert(connection_dir_get_by_purpose_and_resource(
+                                                    !TEST_CONN_RSRC_PURPOSE,
+                                                    TEST_CONN_RSRC_2)
+            == NULL);
+
+  tt_assert(connection_dir_get_by_purpose_resource_and_state(
+                                                    conn->base_.purpose,
+                                                    conn->requested_resource,
+                                                    conn->base_.state)
+            == conn);
+  tt_assert(connection_dir_get_by_purpose_resource_and_state(
+                                                    TEST_CONN_RSRC_PURPOSE,
+                                                    TEST_CONN_RSRC,
+                                                    TEST_CONN_STATE)
+            == conn);
+  tt_assert(connection_dir_get_by_purpose_resource_and_state(
+                                                    !conn->base_.purpose,
+                                                    "",
+                                                    !conn->base_.state)
+            == NULL);
+  tt_assert(connection_dir_get_by_purpose_resource_and_state(
+                                                    !TEST_CONN_RSRC_PURPOSE,
+                                                    TEST_CONN_RSRC_2,
+                                                    !TEST_CONN_STATE)
+            == NULL);
+
+  sl_is_conn_assert(connection_dir_list_by_purpose_and_resource(
+                                                    conn->base_.purpose,
+                                                    conn->requested_resource),
+                    conn);
+  sl_is_conn_assert(connection_dir_list_by_purpose_and_resource(
+                                                    TEST_CONN_RSRC_PURPOSE,
+                                                    TEST_CONN_RSRC),
+                    conn);
+  sl_no_conn_assert(connection_dir_list_by_purpose_and_resource(
+                                                    !conn->base_.purpose,
+                                                    ""));
+  sl_no_conn_assert(connection_dir_list_by_purpose_and_resource(
+                                                    !TEST_CONN_RSRC_PURPOSE,
+                                                    TEST_CONN_RSRC_2));
+
+  sl_is_conn_assert(connection_dir_list_by_purpose_resource_and_state(
+                                                    conn->base_.purpose,
+                                                    conn->requested_resource,
+                                                    conn->base_.state),
+                    conn);
+  sl_is_conn_assert(connection_dir_list_by_purpose_resource_and_state(
+                                                    TEST_CONN_RSRC_PURPOSE,
+                                                    TEST_CONN_RSRC,
+                                                    TEST_CONN_STATE),
+                    conn);
+  sl_no_conn_assert(connection_dir_list_by_purpose_resource_and_state(
+                                                    !conn->base_.purpose,
+                                                    "",
+                                                    !conn->base_.state));
+  sl_no_conn_assert(connection_dir_list_by_purpose_resource_and_state(
+                                                    !TEST_CONN_RSRC_PURPOSE,
+                                                    TEST_CONN_RSRC_2,
+                                                    !TEST_CONN_STATE));
+
+  tt_assert(connection_dir_count_by_purpose_and_resource(
+                                                    conn->base_.purpose,
+                                                    conn->requested_resource)
+            == 1);
+  tt_assert(connection_dir_count_by_purpose_and_resource(
+                                                    TEST_CONN_RSRC_PURPOSE,
+                                                    TEST_CONN_RSRC)
+            == 1);
+  tt_assert(connection_dir_count_by_purpose_and_resource(
+                                                    !conn->base_.purpose,
+                                                    "")
+            == 0);
+  tt_assert(connection_dir_count_by_purpose_and_resource(
+                                                    !TEST_CONN_RSRC_PURPOSE,
+                                                    TEST_CONN_RSRC_2)
+            == 0);
+
+  tt_assert(connection_dir_count_by_purpose_resource_and_state(
+                                                    conn->base_.purpose,
+                                                    conn->requested_resource,
+                                                    conn->base_.state)
+            == 1);
+  tt_assert(connection_dir_count_by_purpose_resource_and_state(
+                                                    TEST_CONN_RSRC_PURPOSE,
+                                                    TEST_CONN_RSRC,
+                                                    TEST_CONN_STATE)
+            == 1);
+  tt_assert(connection_dir_count_by_purpose_resource_and_state(
+                                                    !conn->base_.purpose,
+                                                    "",
+                                                    !conn->base_.state)
+            == 0);
+  tt_assert(connection_dir_count_by_purpose_resource_and_state(
+                                                    !TEST_CONN_RSRC_PURPOSE,
+                                                    TEST_CONN_RSRC_2,
+                                                    !TEST_CONN_STATE)
+            == 0);
+
+ done:
+  smartlist_free(the_sl);
+}
+
+static void
+test_conn_download_status(void *arg)
+{
+  (void)arg;
+  dir_connection_t *conn = NULL;
+  dir_connection_t *conn2 = NULL;
+  dir_connection_t *conn3 = NULL;
+
+  /* no connections, no excess, not downloading */
+  tt_assert(networkstatus_consensus_has_excess_connections() == 0);
+  tt_assert(networkstatus_consensus_is_downloading_usable_flavor() == 0);
+  tt_assert(connection_dir_avoid_extra_connection_for_purpose(
+                                                 TEST_CONN_RSRC_PURPOSE) == 0);
+
+  /* one connection, no excess, not downloading */
+  conn = test_conn_download_status_add_a_connection();
+  tt_assert(networkstatus_consensus_has_excess_connections() == 0);
+  tt_assert(networkstatus_consensus_is_downloading_usable_flavor() == 0);
+  tt_assert(connection_dir_avoid_extra_connection_for_purpose(
+                                                 TEST_CONN_RSRC_PURPOSE) == 0);
+
+  /* one connection, no excess, but downloading */
+  conn->base_.state = TEST_CONN_DL_STATE;
+  tt_assert(networkstatus_consensus_has_excess_connections() == 0);
+  tt_assert(networkstatus_consensus_is_downloading_usable_flavor() == 1);
+  tt_assert(connection_dir_avoid_extra_connection_for_purpose(
+                                                 TEST_CONN_RSRC_PURPOSE) == 1);
+  conn->base_.state = TEST_CONN_STATE;
+
+  /* two connections, excess, but not downloading */
+  conn2 = test_conn_download_status_add_a_connection();
+  tt_assert(networkstatus_consensus_has_excess_connections() == 1);
+  tt_assert(networkstatus_consensus_is_downloading_usable_flavor() == 0);
+  tt_assert(connection_dir_avoid_extra_connection_for_purpose(
+                                                 TEST_CONN_RSRC_PURPOSE) == 0);
+
+  /* two connections, excess, downloading */
+  conn2->base_.state = TEST_CONN_DL_STATE;
+  tt_assert(networkstatus_consensus_has_excess_connections() == 1);
+  tt_assert(networkstatus_consensus_is_downloading_usable_flavor() == 1);
+  tt_assert(connection_dir_avoid_extra_connection_for_purpose(
+                                                 TEST_CONN_RSRC_PURPOSE) == 1);
+  conn2->base_.state = TEST_CONN_STATE;
+
+  /* more connections, excess, but not downloading */
+  conn3 = test_conn_download_status_add_a_connection();
+  tt_assert(networkstatus_consensus_has_excess_connections() == 1);
+  tt_assert(networkstatus_consensus_is_downloading_usable_flavor() == 0);
+  tt_assert(connection_dir_avoid_extra_connection_for_purpose(
+                                                 TEST_CONN_RSRC_PURPOSE) == 0);
+
+  /* more connections, excess, downloading */
+  conn3->base_.state = TEST_CONN_DL_STATE;
+  tt_assert(networkstatus_consensus_has_excess_connections() == 1);
+  tt_assert(networkstatus_consensus_is_downloading_usable_flavor() == 1);
+  tt_assert(connection_dir_avoid_extra_connection_for_purpose(
+                                                 TEST_CONN_RSRC_PURPOSE) == 1);
+
+  /* more connections, more downloading */
+  conn2->base_.state = TEST_CONN_DL_STATE;
+  tt_assert(networkstatus_consensus_has_excess_connections() == 1);
+  tt_assert(networkstatus_consensus_is_downloading_usable_flavor() == 1);
+  tt_assert(connection_dir_avoid_extra_connection_for_purpose(
+                                                 TEST_CONN_RSRC_PURPOSE) == 1);
+
+  /* now try closing the one that isn't downloading:
+   * these tests won't work unless tor thinks it is bootstrapping */
+  tt_assert(networkstatus_consensus_is_boostrapping(time(NULL)));
+
+  tt_assert(connection_dir_count_by_purpose_and_resource(
+                                                        TEST_CONN_RSRC_PURPOSE,
+                                                        TEST_CONN_RSRC) == 3);
+  tt_assert(connection_dir_avoid_extra_connection_for_purpose(
+                                                 TEST_CONN_RSRC_PURPOSE) == 1);
+  tt_assert(connection_dir_close_consensus_conn_if_extra(conn) == -1);
+  tt_assert(connection_dir_count_by_purpose_and_resource(
+                                                        TEST_CONN_RSRC_PURPOSE,
+                                                        TEST_CONN_RSRC) == 2);
+  tt_assert(connection_dir_avoid_extra_connection_for_purpose(
+                                                 TEST_CONN_RSRC_PURPOSE) == 1);
+
+  /* now try closing one that is already closed - nothing happens */
+  tt_assert(connection_dir_close_consensus_conn_if_extra(conn) == 0);
+  tt_assert(connection_dir_count_by_purpose_and_resource(
+                                                        TEST_CONN_RSRC_PURPOSE,
+                                                        TEST_CONN_RSRC) == 2);
+  tt_assert(connection_dir_avoid_extra_connection_for_purpose(
+                                                 TEST_CONN_RSRC_PURPOSE) == 1);
+
+  /* now try closing one that is downloading - it stays open */
+  tt_assert(connection_dir_close_consensus_conn_if_extra(conn2) == 0);
+  tt_assert(connection_dir_count_by_purpose_and_resource(
+                                                        TEST_CONN_RSRC_PURPOSE,
+                                                        TEST_CONN_RSRC) == 2);
+  tt_assert(connection_dir_avoid_extra_connection_for_purpose(
+                                                 TEST_CONN_RSRC_PURPOSE) == 1);
+
+  /* now try closing all excess connections */
+  connection_dir_close_extra_consensus_conns();
+  tt_assert(connection_dir_count_by_purpose_and_resource(
+                                                        TEST_CONN_RSRC_PURPOSE,
+                                                        TEST_CONN_RSRC) == 1);
+  tt_assert(connection_dir_avoid_extra_connection_for_purpose(
+                                                 TEST_CONN_RSRC_PURPOSE) == 1);
+
+ done:
+  /* the teardown function removes all the connections */;
+}
+
+#define CONNECTION_TESTCASE(name, fork, setup)                           \
+  { #name, test_conn_##name, fork, &setup, NULL }
+
+struct testcase_t connection_tests[] = {
+  CONNECTION_TESTCASE(get_basic, TT_FORK, test_conn_get_basic_st),
+  CONNECTION_TESTCASE(get_rend,  TT_FORK, test_conn_get_rend_st),
+  CONNECTION_TESTCASE(get_rsrc,  TT_FORK, test_conn_get_rsrc_st),
+  CONNECTION_TESTCASE(download_status,  TT_FORK, test_conn_download_status_st),
+//CONNECTION_TESTCASE(func_suffix, TT_FORK, setup_func_pair),
+  END_OF_TESTCASES
+};
+
diff --git a/src/test/test_crypto.c b/src/test/test_crypto.c
index dbaec61..671ae7d 100644
--- a/src/test/test_crypto.c
+++ b/src/test/test_crypto.c
@@ -5,6 +5,7 @@
 
 #include "orconfig.h"
 #define CRYPTO_CURVE25519_PRIVATE
+#define CRYPTO_PRIVATE
 #include "or.h"
 #include "test.h"
 #include "aes.h"
@@ -15,6 +16,7 @@
 #include "ed25519_vectors.inc"
 
 #include <openssl/evp.h>
+#include <openssl/rand.h>
 
 extern const char AUTHORITY_SIGNKEY_3[];
 extern const char AUTHORITY_SIGNKEY_A_DIGEST[];
@@ -131,6 +133,38 @@ test_crypto_rng_range(void *arg)
   ;
 }
 
+/* Test for rectifying openssl RAND engine. */
+static void
+test_crypto_rng_engine(void *arg)
+{
+  (void)arg;
+  RAND_METHOD dummy_method;
+  memset(&dummy_method, 0, sizeof(dummy_method));
+
+  /* We should be a no-op if we're already on RAND_OpenSSL */
+  tt_int_op(0, ==, crypto_force_rand_ssleay());
+  tt_assert(RAND_get_rand_method() == RAND_OpenSSL());
+
+  /* We should correct the method if it's a dummy. */
+  RAND_set_rand_method(&dummy_method);
+#ifdef LIBRESSL_VERSION_NUMBER
+  /* On libressl, you can't override the RNG. */
+  tt_assert(RAND_get_rand_method() == RAND_OpenSSL());
+  tt_int_op(0, ==, crypto_force_rand_ssleay());
+#else
+  tt_assert(RAND_get_rand_method() == &dummy_method);
+  tt_int_op(1, ==, crypto_force_rand_ssleay());
+#endif
+  tt_assert(RAND_get_rand_method() == RAND_OpenSSL());
+
+  /* Make sure we aren't calling dummy_method */
+  crypto_rand((void *) &dummy_method, sizeof(dummy_method));
+  crypto_rand((void *) &dummy_method, sizeof(dummy_method));
+
+ done:
+  ;
+}
+
 /** Run unit tests for our AES functionality */
 static void
 test_crypto_aes(void *arg)
@@ -284,10 +318,11 @@ test_crypto_sha(void *arg)
 {
   crypto_digest_t *d1 = NULL, *d2 = NULL;
   int i;
-  char key[160];
-  char digest[32];
-  char data[50];
-  char d_out1[DIGEST_LEN], d_out2[DIGEST256_LEN];
+#define RFC_4231_MAX_KEY_SIZE 131
+  char key[RFC_4231_MAX_KEY_SIZE];
+  char digest[DIGEST256_LEN];
+  char data[DIGEST512_LEN];
+  char d_out1[DIGEST512_LEN], d_out2[DIGEST512_LEN];
   char *mem_op_hex_tmp=NULL;
 
   /* Test SHA-1 with a test vector from the specification. */
@@ -302,6 +337,13 @@ test_crypto_sha(void *arg)
                        "96177A9CB410FF61F20015AD");
   tt_int_op(i, OP_EQ, 0);
 
+  /* Test SHA-512 with a test vector from the specification. */
+  i = crypto_digest512(data, "abc", 3, DIGEST_SHA512);
+  test_memeq_hex(data, "ddaf35a193617abacc417349ae20413112e6fa4e89a97"
+                       "ea20a9eeee64b55d39a2192992a274fc1a836ba3c23a3"
+                       "feebbd454d4423643ce80e2a9ac94fa54ca49f");
+  tt_int_op(i, OP_EQ, 0);
+
   /* Test HMAC-SHA256 with test cases from wikipedia and RFC 4231 */
 
   /* Case empty (wikipedia) */
@@ -378,15 +420,15 @@ test_crypto_sha(void *arg)
   d2 = crypto_digest_dup(d1);
   tt_assert(d2);
   crypto_digest_add_bytes(d2, "ghijkl", 6);
-  crypto_digest_get_digest(d2, d_out1, sizeof(d_out1));
+  crypto_digest_get_digest(d2, d_out1, DIGEST_LEN);
   crypto_digest(d_out2, "abcdefghijkl", 12);
   tt_mem_op(d_out1,OP_EQ, d_out2, DIGEST_LEN);
   crypto_digest_assign(d2, d1);
   crypto_digest_add_bytes(d2, "mno", 3);
-  crypto_digest_get_digest(d2, d_out1, sizeof(d_out1));
+  crypto_digest_get_digest(d2, d_out1, DIGEST_LEN);
   crypto_digest(d_out2, "abcdefmno", 9);
   tt_mem_op(d_out1,OP_EQ, d_out2, DIGEST_LEN);
-  crypto_digest_get_digest(d1, d_out1, sizeof(d_out1));
+  crypto_digest_get_digest(d1, d_out1, DIGEST_LEN);
   crypto_digest(d_out2, "abcdef", 6);
   tt_mem_op(d_out1,OP_EQ, d_out2, DIGEST_LEN);
   crypto_digest_free(d1);
@@ -399,17 +441,38 @@ test_crypto_sha(void *arg)
   d2 = crypto_digest_dup(d1);
   tt_assert(d2);
   crypto_digest_add_bytes(d2, "ghijkl", 6);
-  crypto_digest_get_digest(d2, d_out1, sizeof(d_out1));
+  crypto_digest_get_digest(d2, d_out1, DIGEST256_LEN);
   crypto_digest256(d_out2, "abcdefghijkl", 12, DIGEST_SHA256);
-  tt_mem_op(d_out1,OP_EQ, d_out2, DIGEST_LEN);
+  tt_mem_op(d_out1,OP_EQ, d_out2, DIGEST256_LEN);
   crypto_digest_assign(d2, d1);
   crypto_digest_add_bytes(d2, "mno", 3);
-  crypto_digest_get_digest(d2, d_out1, sizeof(d_out1));
+  crypto_digest_get_digest(d2, d_out1, DIGEST256_LEN);
   crypto_digest256(d_out2, "abcdefmno", 9, DIGEST_SHA256);
-  tt_mem_op(d_out1,OP_EQ, d_out2, DIGEST_LEN);
-  crypto_digest_get_digest(d1, d_out1, sizeof(d_out1));
+  tt_mem_op(d_out1,OP_EQ, d_out2, DIGEST256_LEN);
+  crypto_digest_get_digest(d1, d_out1, DIGEST256_LEN);
   crypto_digest256(d_out2, "abcdef", 6, DIGEST_SHA256);
-  tt_mem_op(d_out1,OP_EQ, d_out2, DIGEST_LEN);
+  tt_mem_op(d_out1,OP_EQ, d_out2, DIGEST256_LEN);
+  crypto_digest_free(d1);
+  crypto_digest_free(d2);
+
+  /* Incremental digest code with sha512 */
+  d1 = crypto_digest512_new(DIGEST_SHA512);
+  tt_assert(d1);
+  crypto_digest_add_bytes(d1, "abcdef", 6);
+  d2 = crypto_digest_dup(d1);
+  tt_assert(d2);
+  crypto_digest_add_bytes(d2, "ghijkl", 6);
+  crypto_digest_get_digest(d2, d_out1, DIGEST512_LEN);
+  crypto_digest512(d_out2, "abcdefghijkl", 12, DIGEST_SHA512);
+  tt_mem_op(d_out1,OP_EQ, d_out2, DIGEST512_LEN);
+  crypto_digest_assign(d2, d1);
+  crypto_digest_add_bytes(d2, "mno", 3);
+  crypto_digest_get_digest(d2, d_out1, DIGEST512_LEN);
+  crypto_digest512(d_out2, "abcdefmno", 9, DIGEST_SHA512);
+  tt_mem_op(d_out1,OP_EQ, d_out2, DIGEST512_LEN);
+  crypto_digest_get_digest(d1, d_out1, DIGEST512_LEN);
+  crypto_digest512(d_out2, "abcdef", 6, DIGEST_SHA512);
+  tt_mem_op(d_out1,OP_EQ, d_out2, DIGEST512_LEN);
 
  done:
   if (d1)
@@ -419,6 +482,394 @@ test_crypto_sha(void *arg)
   tor_free(mem_op_hex_tmp);
 }
 
+static void
+test_crypto_sha3(void *arg)
+{
+  crypto_digest_t *d1 = NULL, *d2 = NULL;
+  int i;
+  char data[DIGEST512_LEN];
+  char d_out1[DIGEST512_LEN], d_out2[DIGEST512_LEN];
+  char *mem_op_hex_tmp=NULL;
+  char *large = NULL;
+
+  (void)arg;
+
+  /* Test SHA3-[256,512] with a test vectors from the Keccak Code Package.
+   *
+   * NB: The code package's test vectors have length expressed in bits.
+   */
+
+  /* Len = 8, Msg = CC */
+  const uint8_t keccak_kat_msg8[] = { 0xcc };
+  i = crypto_digest256(data, (const char*)keccak_kat_msg8, 1, DIGEST_SHA3_256);
+  test_memeq_hex(data, "677035391CD3701293D385F037BA3279"
+                       "6252BB7CE180B00B582DD9B20AAAD7F0");
+  tt_int_op(i, OP_EQ, 0);
+  i = crypto_digest512(data, (const char*)keccak_kat_msg8, 1, DIGEST_SHA3_512);
+  test_memeq_hex(data, "3939FCC8B57B63612542DA31A834E5DC"
+                       "C36E2EE0F652AC72E02624FA2E5ADEEC"
+                       "C7DD6BB3580224B4D6138706FC6E8059"
+                       "7B528051230B00621CC2B22999EAA205");
+  tt_int_op(i, OP_EQ, 0);
+
+  /* Len = 24, Msg = 1F877C */
+  const uint8_t keccak_kat_msg24[] = { 0x1f, 0x87, 0x7c };
+  i = crypto_digest256(data, (const char*)keccak_kat_msg24, 3,
+                       DIGEST_SHA3_256);
+  test_memeq_hex(data, "BC22345E4BD3F792A341CF18AC0789F1"
+                       "C9C966712A501B19D1B6632CCD408EC5");
+  tt_int_op(i, OP_EQ, 0);
+  i = crypto_digest512(data, (const char*)keccak_kat_msg24, 3,
+                       DIGEST_SHA3_512);
+  test_memeq_hex(data, "CB20DCF54955F8091111688BECCEF48C"
+                       "1A2F0D0608C3A575163751F002DB30F4"
+                       "0F2F671834B22D208591CFAF1F5ECFE4"
+                       "3C49863A53B3225BDFD7C6591BA7658B");
+  tt_int_op(i, OP_EQ, 0);
+
+  /* Len = 1080, Msg = B771D5CEF... ...C35AC81B5 (SHA3-256 rate - 1) */
+  const uint8_t keccak_kat_msg1080[] = {
+    0xB7, 0x71, 0xD5, 0xCE, 0xF5, 0xD1, 0xA4, 0x1A, 0x93, 0xD1,
+    0x56, 0x43, 0xD7, 0x18, 0x1D, 0x2A, 0x2E, 0xF0, 0xA8, 0xE8,
+    0x4D, 0x91, 0x81, 0x2F, 0x20, 0xED, 0x21, 0xF1, 0x47, 0xBE,
+    0xF7, 0x32, 0xBF, 0x3A, 0x60, 0xEF, 0x40, 0x67, 0xC3, 0x73,
+    0x4B, 0x85, 0xBC, 0x8C, 0xD4, 0x71, 0x78, 0x0F, 0x10, 0xDC,
+    0x9E, 0x82, 0x91, 0xB5, 0x83, 0x39, 0xA6, 0x77, 0xB9, 0x60,
+    0x21, 0x8F, 0x71, 0xE7, 0x93, 0xF2, 0x79, 0x7A, 0xEA, 0x34,
+    0x94, 0x06, 0x51, 0x28, 0x29, 0x06, 0x5D, 0x37, 0xBB, 0x55,
+    0xEA, 0x79, 0x6F, 0xA4, 0xF5, 0x6F, 0xD8, 0x89, 0x6B, 0x49,
+    0xB2, 0xCD, 0x19, 0xB4, 0x32, 0x15, 0xAD, 0x96, 0x7C, 0x71,
+    0x2B, 0x24, 0xE5, 0x03, 0x2D, 0x06, 0x52, 0x32, 0xE0, 0x2C,
+    0x12, 0x74, 0x09, 0xD2, 0xED, 0x41, 0x46, 0xB9, 0xD7, 0x5D,
+    0x76, 0x3D, 0x52, 0xDB, 0x98, 0xD9, 0x49, 0xD3, 0xB0, 0xFE,
+    0xD6, 0xA8, 0x05, 0x2F, 0xBB,
+  };
+  i = crypto_digest256(data, (const char*)keccak_kat_msg1080, 135,
+                       DIGEST_SHA3_256);
+  test_memeq_hex(data, "A19EEE92BB2097B64E823D597798AA18"
+                       "BE9B7C736B8059ABFD6779AC35AC81B5");
+  tt_int_op(i, OP_EQ, 0);
+  i = crypto_digest512(data, (const char*)keccak_kat_msg1080, 135,
+                       DIGEST_SHA3_512);
+  test_memeq_hex(data, "7575A1FB4FC9A8F9C0466BD5FCA496D1"
+                       "CB78696773A212A5F62D02D14E3259D1"
+                       "92A87EBA4407DD83893527331407B6DA"
+                       "DAAD920DBC46489B677493CE5F20B595");
+  tt_int_op(i, OP_EQ, 0);
+
+  /* Len = 1088, Msg = B32D95B0... ...8E380C04 (SHA3-256 rate) */
+  const uint8_t keccak_kat_msg1088[] = {
+    0xB3, 0x2D, 0x95, 0xB0, 0xB9, 0xAA, 0xD2, 0xA8, 0x81, 0x6D,
+    0xE6, 0xD0, 0x6D, 0x1F, 0x86, 0x00, 0x85, 0x05, 0xBD, 0x8C,
+    0x14, 0x12, 0x4F, 0x6E, 0x9A, 0x16, 0x3B, 0x5A, 0x2A, 0xDE,
+    0x55, 0xF8, 0x35, 0xD0, 0xEC, 0x38, 0x80, 0xEF, 0x50, 0x70,
+    0x0D, 0x3B, 0x25, 0xE4, 0x2C, 0xC0, 0xAF, 0x05, 0x0C, 0xCD,
+    0x1B, 0xE5, 0xE5, 0x55, 0xB2, 0x30, 0x87, 0xE0, 0x4D, 0x7B,
+    0xF9, 0x81, 0x36, 0x22, 0x78, 0x0C, 0x73, 0x13, 0xA1, 0x95,
+    0x4F, 0x87, 0x40, 0xB6, 0xEE, 0x2D, 0x3F, 0x71, 0xF7, 0x68,
+    0xDD, 0x41, 0x7F, 0x52, 0x04, 0x82, 0xBD, 0x3A, 0x08, 0xD4,
+    0xF2, 0x22, 0xB4, 0xEE, 0x9D, 0xBD, 0x01, 0x54, 0x47, 0xB3,
+    0x35, 0x07, 0xDD, 0x50, 0xF3, 0xAB, 0x42, 0x47, 0xC5, 0xDE,
+    0x9A, 0x8A, 0xBD, 0x62, 0xA8, 0xDE, 0xCE, 0xA0, 0x1E, 0x3B,
+    0x87, 0xC8, 0xB9, 0x27, 0xF5, 0xB0, 0x8B, 0xEB, 0x37, 0x67,
+    0x4C, 0x6F, 0x8E, 0x38, 0x0C, 0x04,
+  };
+  i = crypto_digest256(data, (const char*)keccak_kat_msg1088, 136,
+                       DIGEST_SHA3_256);
+  test_memeq_hex(data, "DF673F4105379FF6B755EEAB20CEB0DC"
+                       "77B5286364FE16C59CC8A907AFF07732");
+  tt_int_op(i, OP_EQ, 0);
+  i = crypto_digest512(data, (const char*)keccak_kat_msg1088, 136,
+                       DIGEST_SHA3_512);
+  test_memeq_hex(data, "2E293765022D48996CE8EFF0BE54E87E"
+                       "FB94A14C72DE5ACD10D0EB5ECE029CAD"
+                       "FA3BA17A40B2FFA2163991B17786E51C"
+                       "ABA79E5E0FFD34CF085E2A098BE8BACB");
+  tt_int_op(i, OP_EQ, 0);
+
+  /* Len = 1096, Msg = 04410E310... ...601016A0D (SHA3-256 rate + 1) */
+  const uint8_t keccak_kat_msg1096[] = {
+    0x04, 0x41, 0x0E, 0x31, 0x08, 0x2A, 0x47, 0x58, 0x4B, 0x40,
+    0x6F, 0x05, 0x13, 0x98, 0xA6, 0xAB, 0xE7, 0x4E, 0x4D, 0xA5,
+    0x9B, 0xB6, 0xF8, 0x5E, 0x6B, 0x49, 0xE8, 0xA1, 0xF7, 0xF2,
+    0xCA, 0x00, 0xDF, 0xBA, 0x54, 0x62, 0xC2, 0xCD, 0x2B, 0xFD,
+    0xE8, 0xB6, 0x4F, 0xB2, 0x1D, 0x70, 0xC0, 0x83, 0xF1, 0x13,
+    0x18, 0xB5, 0x6A, 0x52, 0xD0, 0x3B, 0x81, 0xCA, 0xC5, 0xEE,
+    0xC2, 0x9E, 0xB3, 0x1B, 0xD0, 0x07, 0x8B, 0x61, 0x56, 0x78,
+    0x6D, 0xA3, 0xD6, 0xD8, 0xC3, 0x30, 0x98, 0xC5, 0xC4, 0x7B,
+    0xB6, 0x7A, 0xC6, 0x4D, 0xB1, 0x41, 0x65, 0xAF, 0x65, 0xB4,
+    0x45, 0x44, 0xD8, 0x06, 0xDD, 0xE5, 0xF4, 0x87, 0xD5, 0x37,
+    0x3C, 0x7F, 0x97, 0x92, 0xC2, 0x99, 0xE9, 0x68, 0x6B, 0x7E,
+    0x58, 0x21, 0xE7, 0xC8, 0xE2, 0x45, 0x83, 0x15, 0xB9, 0x96,
+    0xB5, 0x67, 0x7D, 0x92, 0x6D, 0xAC, 0x57, 0xB3, 0xF2, 0x2D,
+    0xA8, 0x73, 0xC6, 0x01, 0x01, 0x6A, 0x0D,
+  };
+  i = crypto_digest256(data, (const char*)keccak_kat_msg1096, 137,
+                       DIGEST_SHA3_256);
+  test_memeq_hex(data, "D52432CF3B6B4B949AA848E058DCD62D"
+                       "735E0177279222E7AC0AF8504762FAA0");
+  tt_int_op(i, OP_EQ, 0);
+  i = crypto_digest512(data, (const char*)keccak_kat_msg1096, 137,
+                       DIGEST_SHA3_512);
+  test_memeq_hex(data, "BE8E14B6757FFE53C9B75F6DDE9A7B6C"
+                       "40474041DE83D4A60645A826D7AF1ABE"
+                       "1EEFCB7B74B62CA6A514E5F2697D585B"
+                       "FECECE12931BBE1D4ED7EBF7B0BE660E");
+  tt_int_op(i, OP_EQ, 0);
+
+  /* Len = 1144, Msg = EA40E83C...  ...66DFAFEC (SHA3-512 rate *2 - 1) */
+  const uint8_t keccak_kat_msg1144[] = {
+    0xEA, 0x40, 0xE8, 0x3C, 0xB1, 0x8B, 0x3A, 0x24, 0x2C, 0x1E,
+    0xCC, 0x6C, 0xCD, 0x0B, 0x78, 0x53, 0xA4, 0x39, 0xDA, 0xB2,
+    0xC5, 0x69, 0xCF, 0xC6, 0xDC, 0x38, 0xA1, 0x9F, 0x5C, 0x90,
+    0xAC, 0xBF, 0x76, 0xAE, 0xF9, 0xEA, 0x37, 0x42, 0xFF, 0x3B,
+    0x54, 0xEF, 0x7D, 0x36, 0xEB, 0x7C, 0xE4, 0xFF, 0x1C, 0x9A,
+    0xB3, 0xBC, 0x11, 0x9C, 0xFF, 0x6B, 0xE9, 0x3C, 0x03, 0xE2,
+    0x08, 0x78, 0x33, 0x35, 0xC0, 0xAB, 0x81, 0x37, 0xBE, 0x5B,
+    0x10, 0xCD, 0xC6, 0x6F, 0xF3, 0xF8, 0x9A, 0x1B, 0xDD, 0xC6,
+    0xA1, 0xEE, 0xD7, 0x4F, 0x50, 0x4C, 0xBE, 0x72, 0x90, 0x69,
+    0x0B, 0xB2, 0x95, 0xA8, 0x72, 0xB9, 0xE3, 0xFE, 0x2C, 0xEE,
+    0x9E, 0x6C, 0x67, 0xC4, 0x1D, 0xB8, 0xEF, 0xD7, 0xD8, 0x63,
+    0xCF, 0x10, 0xF8, 0x40, 0xFE, 0x61, 0x8E, 0x79, 0x36, 0xDA,
+    0x3D, 0xCA, 0x5C, 0xA6, 0xDF, 0x93, 0x3F, 0x24, 0xF6, 0x95,
+    0x4B, 0xA0, 0x80, 0x1A, 0x12, 0x94, 0xCD, 0x8D, 0x7E, 0x66,
+    0xDF, 0xAF, 0xEC,
+  };
+  i = crypto_digest512(data, (const char*)keccak_kat_msg1144, 143,
+                       DIGEST_SHA3_512);
+  test_memeq_hex(data, "3A8E938C45F3F177991296B24565D9A6"
+                       "605516615D96A062C8BE53A0D6C5A648"
+                       "7BE35D2A8F3CF6620D0C2DBA2C560D68"
+                       "295F284BE7F82F3B92919033C9CE5D80");
+  tt_int_op(i, OP_EQ, 0);
+  i = crypto_digest256(data, (const char*)keccak_kat_msg1144, 143,
+                       DIGEST_SHA3_256);
+  test_memeq_hex(data, "E58A947E98D6DD7E932D2FE02D9992E6"
+                       "118C0C2C606BDCDA06E7943D2C95E0E5");
+  tt_int_op(i, OP_EQ, 0);
+
+  /* Len = 1152, Msg = 157D5B7E... ...79EE00C63 (SHA3-512 rate * 2) */
+  const uint8_t keccak_kat_msg1152[] = {
+    0x15, 0x7D, 0x5B, 0x7E, 0x45, 0x07, 0xF6, 0x6D, 0x9A, 0x26,
+    0x74, 0x76, 0xD3, 0x38, 0x31, 0xE7, 0xBB, 0x76, 0x8D, 0x4D,
+    0x04, 0xCC, 0x34, 0x38, 0xDA, 0x12, 0xF9, 0x01, 0x02, 0x63,
+    0xEA, 0x5F, 0xCA, 0xFB, 0xDE, 0x25, 0x79, 0xDB, 0x2F, 0x6B,
+    0x58, 0xF9, 0x11, 0xD5, 0x93, 0xD5, 0xF7, 0x9F, 0xB0, 0x5F,
+    0xE3, 0x59, 0x6E, 0x3F, 0xA8, 0x0F, 0xF2, 0xF7, 0x61, 0xD1,
+    0xB0, 0xE5, 0x70, 0x80, 0x05, 0x5C, 0x11, 0x8C, 0x53, 0xE5,
+    0x3C, 0xDB, 0x63, 0x05, 0x52, 0x61, 0xD7, 0xC9, 0xB2, 0xB3,
+    0x9B, 0xD9, 0x0A, 0xCC, 0x32, 0x52, 0x0C, 0xBB, 0xDB, 0xDA,
+    0x2C, 0x4F, 0xD8, 0x85, 0x6D, 0xBC, 0xEE, 0x17, 0x31, 0x32,
+    0xA2, 0x67, 0x91, 0x98, 0xDA, 0xF8, 0x30, 0x07, 0xA9, 0xB5,
+    0xC5, 0x15, 0x11, 0xAE, 0x49, 0x76, 0x6C, 0x79, 0x2A, 0x29,
+    0x52, 0x03, 0x88, 0x44, 0x4E, 0xBE, 0xFE, 0x28, 0x25, 0x6F,
+    0xB3, 0x3D, 0x42, 0x60, 0x43, 0x9C, 0xBA, 0x73, 0xA9, 0x47,
+    0x9E, 0xE0, 0x0C, 0x63,
+  };
+  i = crypto_digest512(data, (const char*)keccak_kat_msg1152, 144,
+                       DIGEST_SHA3_512);
+  test_memeq_hex(data, "FE45289874879720CE2A844AE34BB735"
+                       "22775DCB6019DCD22B8885994672A088"
+                       "9C69E8115C641DC8B83E39F7311815A1"
+                       "64DC46E0BA2FCA344D86D4BC2EF2532C");
+  tt_int_op(i, OP_EQ, 0);
+  i = crypto_digest256(data, (const char*)keccak_kat_msg1152, 144,
+                       DIGEST_SHA3_256);
+  test_memeq_hex(data, "A936FB9AF87FB67857B3EAD5C76226AD"
+                       "84DA47678F3C2FFE5A39FDB5F7E63FFB");
+  tt_int_op(i, OP_EQ, 0);
+
+  /* Len = 1160, Msg = 836B34B5... ...11044C53 (SHA3-512 rate * 2 + 1) */
+  const uint8_t keccak_kat_msg1160[] = {
+    0x83, 0x6B, 0x34, 0xB5, 0x15, 0x47, 0x6F, 0x61, 0x3F, 0xE4,
+    0x47, 0xA4, 0xE0, 0xC3, 0xF3, 0xB8, 0xF2, 0x09, 0x10, 0xAC,
+    0x89, 0xA3, 0x97, 0x70, 0x55, 0xC9, 0x60, 0xD2, 0xD5, 0xD2,
+    0xB7, 0x2B, 0xD8, 0xAC, 0xC7, 0x15, 0xA9, 0x03, 0x53, 0x21,
+    0xB8, 0x67, 0x03, 0xA4, 0x11, 0xDD, 0xE0, 0x46, 0x6D, 0x58,
+    0xA5, 0x97, 0x69, 0x67, 0x2A, 0xA6, 0x0A, 0xD5, 0x87, 0xB8,
+    0x48, 0x1D, 0xE4, 0xBB, 0xA5, 0x52, 0xA1, 0x64, 0x57, 0x79,
+    0x78, 0x95, 0x01, 0xEC, 0x53, 0xD5, 0x40, 0xB9, 0x04, 0x82,
+    0x1F, 0x32, 0xB0, 0xBD, 0x18, 0x55, 0xB0, 0x4E, 0x48, 0x48,
+    0xF9, 0xF8, 0xCF, 0xE9, 0xEB, 0xD8, 0x91, 0x1B, 0xE9, 0x57,
+    0x81, 0xA7, 0x59, 0xD7, 0xAD, 0x97, 0x24, 0xA7, 0x10, 0x2D,
+    0xBE, 0x57, 0x67, 0x76, 0xB7, 0xC6, 0x32, 0xBC, 0x39, 0xB9,
+    0xB5, 0xE1, 0x90, 0x57, 0xE2, 0x26, 0x55, 0x2A, 0x59, 0x94,
+    0xC1, 0xDB, 0xB3, 0xB5, 0xC7, 0x87, 0x1A, 0x11, 0xF5, 0x53,
+    0x70, 0x11, 0x04, 0x4C, 0x53,
+  };
+  i = crypto_digest512(data, (const char*)keccak_kat_msg1160, 145,
+                       DIGEST_SHA3_512);
+  test_memeq_hex(data, "AFF61C6E11B98E55AC213B1A0BC7DE04"
+                       "05221AC5EFB1229842E4614F4A029C9B"
+                       "D14A0ED7FD99AF3681429F3F309FDB53"
+                       "166AA9A3CD9F1F1223D04B4A9015E94A");
+  tt_int_op(i, OP_EQ, 0);
+  i = crypto_digest256(data, (const char*)keccak_kat_msg1160, 145,
+                       DIGEST_SHA3_256);
+  test_memeq_hex(data, "3A654B88F88086C2751EDAE6D3924814"
+                       "3CF6235C6B0B7969342C45A35194B67E");
+  tt_int_op(i, OP_EQ, 0);
+
+  /* SHA3-[256,512] Empty case (wikipedia) */
+  i = crypto_digest256(data, "", 0, DIGEST_SHA3_256);
+  test_memeq_hex(data, "a7ffc6f8bf1ed76651c14756a061d662"
+                       "f580ff4de43b49fa82d80a4b80f8434a");
+  tt_int_op(i, OP_EQ, 0);
+  i = crypto_digest512(data, "", 0, DIGEST_SHA3_512);
+  test_memeq_hex(data, "a69f73cca23a9ac5c8b567dc185a756e"
+                       "97c982164fe25859e0d1dcc1475c80a6"
+                       "15b2123af1f5f94c11e3e9402c3ac558"
+                       "f500199d95b6d3e301758586281dcd26");
+  tt_int_op(i, OP_EQ, 0);
+
+  /* Incremental digest code with SHA3-256 */
+  d1 = crypto_digest256_new(DIGEST_SHA3_256);
+  tt_assert(d1);
+  crypto_digest_add_bytes(d1, "abcdef", 6);
+  d2 = crypto_digest_dup(d1);
+  tt_assert(d2);
+  crypto_digest_add_bytes(d2, "ghijkl", 6);
+  crypto_digest_get_digest(d2, d_out1, DIGEST256_LEN);
+  crypto_digest256(d_out2, "abcdefghijkl", 12, DIGEST_SHA3_256);
+  tt_mem_op(d_out1,OP_EQ, d_out2, DIGEST256_LEN);
+  crypto_digest_assign(d2, d1);
+  crypto_digest_add_bytes(d2, "mno", 3);
+  crypto_digest_get_digest(d2, d_out1, DIGEST256_LEN);
+  crypto_digest256(d_out2, "abcdefmno", 9, DIGEST_SHA3_256);
+  tt_mem_op(d_out1,OP_EQ, d_out2, DIGEST256_LEN);
+  crypto_digest_get_digest(d1, d_out1, DIGEST256_LEN);
+  crypto_digest256(d_out2, "abcdef", 6, DIGEST_SHA3_256);
+  tt_mem_op(d_out1,OP_EQ, d_out2, DIGEST256_LEN);
+  crypto_digest_free(d1);
+  crypto_digest_free(d2);
+
+  /* Incremental digest code with SHA3-512 */
+  d1 = crypto_digest512_new(DIGEST_SHA3_512);
+  tt_assert(d1);
+  crypto_digest_add_bytes(d1, "abcdef", 6);
+  d2 = crypto_digest_dup(d1);
+  tt_assert(d2);
+  crypto_digest_add_bytes(d2, "ghijkl", 6);
+  crypto_digest_get_digest(d2, d_out1, DIGEST512_LEN);
+  crypto_digest512(d_out2, "abcdefghijkl", 12, DIGEST_SHA3_512);
+  tt_mem_op(d_out1,OP_EQ, d_out2, DIGEST512_LEN);
+  crypto_digest_assign(d2, d1);
+  crypto_digest_add_bytes(d2, "mno", 3);
+  crypto_digest_get_digest(d2, d_out1, DIGEST512_LEN);
+  crypto_digest512(d_out2, "abcdefmno", 9, DIGEST_SHA3_512);
+  tt_mem_op(d_out1,OP_EQ, d_out2, DIGEST512_LEN);
+  crypto_digest_get_digest(d1, d_out1, DIGEST512_LEN);
+  crypto_digest512(d_out2, "abcdef", 6, DIGEST_SHA3_512);
+  tt_mem_op(d_out1,OP_EQ, d_out2, DIGEST512_LEN);
+  crypto_digest_free(d1);
+
+  /* Attempt to exercise the incremental hashing code by creating a randomized
+   * 100 KiB buffer, and hashing rand[1, 5 * Rate] bytes at a time.  SHA3-512
+   * is used because it has a lowest rate of the family (the code is common,
+   * but the slower rate exercises more of it).
+   */
+  const size_t bufsz = 100 * 1024;
+  size_t j = 0;
+  large = tor_malloc(bufsz);
+  crypto_rand(large, bufsz);
+  d1 = crypto_digest512_new(DIGEST_SHA3_512); /* Running digest. */
+  while (j < bufsz) {
+    /* Pick how much data to add to the running digest. */
+    size_t incr = (size_t)crypto_rand_int_range(1, 72 * 5);
+    incr = MIN(bufsz - j, incr);
+
+    /* Add the data, and calculate the hash. */
+    crypto_digest_add_bytes(d1, large + j, incr);
+    crypto_digest_get_digest(d1, d_out1, DIGEST512_LEN);
+
+    /* One-shot hash the buffer up to the data that was just added,
+     * and ensure that the values match up.
+     *
+     * XXX/yawning: If this actually fails, it'll be rather difficult to
+     * reproduce.  Improvements welcome.
+     */
+    i = crypto_digest512(d_out2, large, j + incr, DIGEST_SHA3_512);
+    tt_int_op(i, OP_EQ, 0);
+    tt_mem_op(d_out1, OP_EQ, d_out2, DIGEST512_LEN);
+
+    j += incr;
+  }
+
+ done:
+  if (d1)
+    crypto_digest_free(d1);
+  if (d2)
+    crypto_digest_free(d2);
+  tor_free(large);
+  tor_free(mem_op_hex_tmp);
+}
+
+/** Run unit tests for our XOF. */
+static void
+test_crypto_sha3_xof(void *arg)
+{
+  uint8_t msg[255];
+  uint8_t out[512];
+  crypto_xof_t *xof;
+  char *mem_op_hex_tmp=NULL;
+
+  (void)arg;
+
+  /* SHAKE256 test vector (Len = 2040) from the Keccak Code Package. */
+  base16_decode((char *)msg, 255,
+                "3A3A819C48EFDE2AD914FBF00E18AB6BC4F14513AB27D0C178A188B61431"
+                "E7F5623CB66B23346775D386B50E982C493ADBBFC54B9A3CD383382336A1"
+                "A0B2150A15358F336D03AE18F666C7573D55C4FD181C29E6CCFDE63EA35F"
+                "0ADF5885CFC0A3D84A2B2E4DD24496DB789E663170CEF74798AA1BBCD457"
+                "4EA0BBA40489D764B2F83AADC66B148B4A0CD95246C127D5871C4F114186"
+                "90A5DDF01246A0C80A43C70088B6183639DCFDA4125BD113A8F49EE23ED3"
+                "06FAAC576C3FB0C1E256671D817FC2534A52F5B439F72E424DE376F4C565"
+                "CCA82307DD9EF76DA5B7C4EB7E085172E328807C02D011FFBF33785378D7"
+                "9DC266F6A5BE6BB0E4A92ECEEBAEB1", 510);
+  const char *squeezed_hex =
+                "8A5199B4A7E133E264A86202720655894D48CFF344A928CF8347F48379CE"
+                "F347DFC5BCFFAB99B27B1F89AA2735E23D30088FFA03B9EDB02B9635470A"
+                "B9F1038985D55F9CA774572DD006470EA65145469609F9FA0831BF1FFD84"
+                "2DC24ACADE27BD9816E3B5BF2876CB112232A0EB4475F1DFF9F5C713D9FF"
+                "D4CCB89AE5607FE35731DF06317949EEF646E9591CF3BE53ADD6B7DD2B60"
+                "96E2B3FB06E662EC8B2D77422DAAD9463CD155204ACDBD38E319613F39F9"
+                "9B6DFB35CA9365160066DB19835888C2241FF9A731A4ACBB5663727AAC34"
+                "A401247FBAA7499E7D5EE5B69D31025E63D04C35C798BCA1262D5673A9CF"
+                "0930B5AD89BD485599DC184528DA4790F088EBD170B635D9581632D2FF90"
+                "DB79665CED430089AF13C9F21F6D443A818064F17AEC9E9C5457001FA8DC"
+                "6AFBADBE3138F388D89D0E6F22F66671255B210754ED63D81DCE75CE8F18"
+                "9B534E6D6B3539AA51E837C42DF9DF59C71E6171CD4902FE1BDC73FB1775"
+                "B5C754A1ED4EA7F3105FC543EE0418DAD256F3F6118EA77114A16C15355B"
+                "42877A1DB2A7DF0E155AE1D8670ABCEC3450F4E2EEC9838F895423EF63D2"
+                "61138BAAF5D9F104CB5A957AEA06C0B9B8C78B0D441796DC0350DDEABB78"
+                "A33B6F1F9E68EDE3D1805C7B7E2CFD54E0FAD62F0D8CA67A775DC4546AF9"
+                "096F2EDB221DB42843D65327861282DC946A0BA01A11863AB2D1DFD16E39"
+                "73D4";
+
+  /* Test oneshot absorb/squeeze. */
+  xof = crypto_xof_new();
+  tt_assert(xof);
+  crypto_xof_add_bytes(xof, msg, sizeof(msg));
+  crypto_xof_squeeze_bytes(xof, out, sizeof(out));
+  test_memeq_hex(out, squeezed_hex);
+  crypto_xof_free(xof);
+  memset(out, 0, sizeof(out));
+
+  /* Test incremental absorb/squeeze. */
+  xof = crypto_xof_new();
+  tt_assert(xof);
+  for (size_t i = 0; i < sizeof(msg); i++)
+    crypto_xof_add_bytes(xof, msg + i, 1);
+  for (size_t i = 0; i < sizeof(out); i++)
+    crypto_xof_squeeze_bytes(xof, out + i, 1);
+  test_memeq_hex(out, squeezed_hex);
+
+ done:
+  if (xof)
+    crypto_xof_free(xof);
+  tor_free(mem_op_hex_tmp);
+}
+
 /** Run unit tests for our public key crypto functions */
 static void
 test_crypto_pk(void *arg)
@@ -663,6 +1114,11 @@ test_crypto_digests(void *arg)
   crypto_pk_free(k);
 }
 
+#ifndef OPENSSL_1_1_API
+#define EVP_ENCODE_CTX_new() tor_malloc_zero(sizeof(EVP_ENCODE_CTX))
+#define EVP_ENCODE_CTX_free(ctx) tor_free(ctx)
+#endif
+
 /** Encode src into dest with OpenSSL's EVP Encode interface, returning the
  * length of the encoded data in bytes.
  */
@@ -670,12 +1126,13 @@ static int
 base64_encode_evp(char *dest, char *src, size_t srclen)
 {
   const unsigned char *s = (unsigned char*)src;
-  EVP_ENCODE_CTX ctx;
+  EVP_ENCODE_CTX *ctx = EVP_ENCODE_CTX_new();
   int len, ret;
 
-  EVP_EncodeInit(&ctx);
-  EVP_EncodeUpdate(&ctx, (unsigned char *)dest, &len, s, (int)srclen);
-  EVP_EncodeFinal(&ctx, (unsigned char *)(dest + len), &ret);
+  EVP_EncodeInit(ctx);
+  EVP_EncodeUpdate(ctx, (unsigned char *)dest, &len, s, (int)srclen);
+  EVP_EncodeFinal(ctx, (unsigned char *)(dest + len), &ret);
+  EVP_ENCODE_CTX_free(ctx);
   return ret+ len;
 }
 
@@ -1271,6 +1728,24 @@ test_crypto_curve25519_persist(void *arg)
   tor_free(tag);
 }
 
+static void *
+ed25519_testcase_setup(const struct testcase_t *testcase)
+{
+  crypto_ed25519_testing_force_impl(testcase->setup_data);
+  return testcase->setup_data;
+}
+static int
+ed25519_testcase_cleanup(const struct testcase_t *testcase, void *ptr)
+{
+  (void)testcase;
+  (void)ptr;
+  crypto_ed25519_testing_restore_impl();
+  return 1;
+}
+static const struct testcase_setup_t ed25519_test_setup = {
+  ed25519_testcase_setup, ed25519_testcase_cleanup
+};
+
 static void
 test_crypto_ed25519_simple(void *arg)
 {
@@ -1803,13 +2278,126 @@ test_crypto_siphash(void *arg)
   ;
 }
 
+/* We want the likelihood that the random buffer exhibits any regular pattern
+ * to be far less than the memory bit error rate in the int return value.
+ * Using 2048 bits provides a failure rate of 1/(3 * 10^616), and we call
+ * 3 functions, leading to an overall error rate of 1/10^616.
+ * This is comparable with the 1/10^603 failure rate of test_crypto_rng_range.
+ */
+#define FAILURE_MODE_BUFFER_SIZE (2048/8)
+
+/** Check crypto_rand for a failure mode where it does nothing to the buffer,
+ * or it sets the buffer to all zeroes. Return 0 when the check passes,
+ * or -1 when it fails. */
+static int
+crypto_rand_check_failure_mode_zero(void)
+{
+  char buf[FAILURE_MODE_BUFFER_SIZE];
+
+  memset(buf, 0, FAILURE_MODE_BUFFER_SIZE);
+  crypto_rand(buf, FAILURE_MODE_BUFFER_SIZE);
+
+  for (size_t i = 0; i < FAILURE_MODE_BUFFER_SIZE; i++) {
+    if (buf[i] != 0) {
+      return 0;
+    }
+  }
+
+  return -1;
+}
+
+/** Check crypto_rand for a failure mode where every int64_t in the buffer is
+ * the same. Return 0 when the check passes, or -1 when it fails. */
+static int
+crypto_rand_check_failure_mode_identical(void)
+{
+  /* just in case the buffer size isn't a multiple of sizeof(int64_t) */
+#define FAILURE_MODE_BUFFER_SIZE_I64 \
+  (FAILURE_MODE_BUFFER_SIZE/SIZEOF_INT64_T)
+#define FAILURE_MODE_BUFFER_SIZE_I64_BYTES \
+  (FAILURE_MODE_BUFFER_SIZE_I64*SIZEOF_INT64_T)
+
+#if FAILURE_MODE_BUFFER_SIZE_I64 < 2
+#error FAILURE_MODE_BUFFER_SIZE needs to be at least 2*SIZEOF_INT64_T
+#endif
+
+  int64_t buf[FAILURE_MODE_BUFFER_SIZE_I64];
+
+  memset(buf, 0, FAILURE_MODE_BUFFER_SIZE_I64_BYTES);
+  crypto_rand((char *)buf, FAILURE_MODE_BUFFER_SIZE_I64_BYTES);
+
+  for (size_t i = 1; i < FAILURE_MODE_BUFFER_SIZE_I64; i++) {
+    if (buf[i] != buf[i-1]) {
+      return 0;
+    }
+  }
+
+  return -1;
+}
+
+/** Check crypto_rand for a failure mode where it increments the "random"
+ * value by 1 for every byte in the buffer. (This is OpenSSL's PREDICT mode.)
+ * Return 0 when the check passes, or -1 when it fails. */
+static int
+crypto_rand_check_failure_mode_predict(void)
+{
+  unsigned char buf[FAILURE_MODE_BUFFER_SIZE];
+
+  memset(buf, 0, FAILURE_MODE_BUFFER_SIZE);
+  crypto_rand((char *)buf, FAILURE_MODE_BUFFER_SIZE);
+
+  for (size_t i = 1; i < FAILURE_MODE_BUFFER_SIZE; i++) {
+    /* check if the last byte was incremented by 1, including integer
+     * wrapping */
+    if (buf[i] - buf[i-1] != 1 && buf[i-1] - buf[i] != 255) {
+      return 0;
+    }
+  }
+
+  return -1;
+}
+
+#undef FAILURE_MODE_BUFFER_SIZE
+
+static void
+test_crypto_failure_modes(void *arg)
+{
+  int rv = 0;
+  (void)arg;
+
+  rv = crypto_early_init();
+  tt_assert(rv == 0);
+
+  /* Check random works */
+  rv = crypto_rand_check_failure_mode_zero();
+  tt_assert(rv == 0);
+
+  rv = crypto_rand_check_failure_mode_identical();
+  tt_assert(rv == 0);
+
+  rv = crypto_rand_check_failure_mode_predict();
+  tt_assert(rv == 0);
+
+ done:
+  ;
+}
+
 #define CRYPTO_LEGACY(name)                                            \
   { #name, test_crypto_ ## name , 0, NULL, NULL }
 
+#define ED25519_TEST_ONE(name, fl, which)                               \
+  { #name "/ed25519_" which, test_crypto_ed25519_ ## name, (fl),        \
+    &ed25519_test_setup, (void*)which }
+
+#define ED25519_TEST(name, fl)                  \
+  ED25519_TEST_ONE(name, (fl), "donna"),        \
+  ED25519_TEST_ONE(name, (fl), "ref10")
+
 struct testcase_t crypto_tests[] = {
   CRYPTO_LEGACY(formats),
   CRYPTO_LEGACY(rng),
   { "rng_range", test_crypto_rng_range, 0, NULL, NULL },
+  { "rng_engine", test_crypto_rng_engine, TT_FORK, NULL, NULL },
   { "aes_AES", test_crypto_aes, TT_FORK, &passthrough_setup, (void*)"aes" },
   { "aes_EVP", test_crypto_aes, TT_FORK, &passthrough_setup, (void*)"evp" },
   CRYPTO_LEGACY(sha),
@@ -1817,6 +2405,8 @@ struct testcase_t crypto_tests[] = {
   { "pk_fingerprints", test_crypto_pk_fingerprints, TT_FORK, NULL, NULL },
   { "pk_base64", test_crypto_pk_base64, TT_FORK, NULL, NULL },
   CRYPTO_LEGACY(digests),
+  { "sha3", test_crypto_sha3, TT_FORK, NULL, NULL},
+  { "sha3_xof", test_crypto_sha3_xof, TT_FORK, NULL, NULL},
   CRYPTO_LEGACY(dh),
   { "aes_iv_AES", test_crypto_aes_iv, TT_FORK, &passthrough_setup,
     (void*)"aes" },
@@ -1832,15 +2422,15 @@ struct testcase_t crypto_tests[] = {
   { "curve25519_wrappers", test_crypto_curve25519_wrappers, 0, NULL, NULL },
   { "curve25519_encode", test_crypto_curve25519_encode, 0, NULL, NULL },
   { "curve25519_persist", test_crypto_curve25519_persist, 0, NULL, NULL },
-  { "ed25519_simple", test_crypto_ed25519_simple, 0, NULL, NULL },
-  { "ed25519_test_vectors", test_crypto_ed25519_test_vectors, 0, NULL, NULL },
-  { "ed25519_encode", test_crypto_ed25519_encode, 0, NULL, NULL },
-  { "ed25519_convert", test_crypto_ed25519_convert, 0, NULL, NULL },
-  { "ed25519_blinding", test_crypto_ed25519_blinding, 0, NULL, NULL },
-  { "ed25519_testvectors", test_crypto_ed25519_testvectors, 0, NULL, NULL },
-  { "ed25519_fuzz_donna", test_crypto_ed25519_fuzz_donna, TT_FORK, NULL,
-    NULL },
+  ED25519_TEST(simple, 0),
+  ED25519_TEST(test_vectors, 0),
+  ED25519_TEST(encode, 0),
+  ED25519_TEST(convert, 0),
+  ED25519_TEST(blinding, 0),
+  ED25519_TEST(testvectors, 0),
+  ED25519_TEST(fuzz_donna, TT_FORK),
   { "siphash", test_crypto_siphash, 0, NULL, NULL },
+  { "failure_modes", test_crypto_failure_modes, TT_FORK, NULL, NULL },
   END_OF_TESTCASES
 };
 
diff --git a/src/test/test_dir.c b/src/test/test_dir.c
index 855746e..4824a94 100644
--- a/src/test/test_dir.c
+++ b/src/test/test_dir.c
@@ -6,19 +6,24 @@
 #include "orconfig.h"
 #include <math.h>
 
+#define CONFIG_PRIVATE
 #define DIRSERV_PRIVATE
 #define DIRVOTE_PRIVATE
 #define ROUTER_PRIVATE
 #define ROUTERLIST_PRIVATE
 #define HIBERNATE_PRIVATE
 #define NETWORKSTATUS_PRIVATE
+#define RELAY_PRIVATE
+
 #include "or.h"
+#include "confparse.h"
 #include "config.h"
 #include "crypto_ed25519.h"
 #include "directory.h"
 #include "dirserv.h"
 #include "dirvote.h"
 #include "hibernate.h"
+#include "memarea.h"
 #include "networkstatus.h"
 #include "router.h"
 #include "routerkeys.h"
@@ -26,7 +31,11 @@
 #include "routerparse.h"
 #include "routerset.h"
 #include "test.h"
+#include "test_dir_common.h"
 #include "torcert.h"
+#include "relay.h"
+
+#define NS_MODULE dir
 
 static void
 test_dir_nicknames(void *arg)
@@ -110,6 +119,7 @@ test_dir_formats(void *arg)
   r1->cache_info.published_on = 0;
   r1->or_port = 9000;
   r1->dir_port = 9003;
+  r1->supports_tunnelled_dir_requests = 1;
   tor_addr_parse(&r1->ipv6_addr, "1:2:3:4::");
   r1->ipv6_orport = 9999;
   r1->onion_pkey = crypto_pk_dup_key(pk1);
@@ -154,6 +164,7 @@ test_dir_formats(void *arg)
   r2->cache_info.published_on = 5;
   r2->or_port = 9005;
   r2->dir_port = 0;
+  r2->supports_tunnelled_dir_requests = 1;
   r2->onion_pkey = crypto_pk_dup_key(pk2);
   curve25519_keypair_t r2_onion_keypair;
   curve25519_keypair_generate(&r2_onion_keypair, 0);
@@ -174,7 +185,9 @@ test_dir_formats(void *arg)
   /* XXXX025 router_dump_to_string should really take this from ri.*/
   options->ContactInfo = tor_strdup("Magri White "
                                     "<magri@elsewhere.example.com>");
+
   buf = router_dump_router_to_string(r1, pk2, NULL, NULL, NULL);
+
   tor_free(options->ContactInfo);
   tt_assert(buf);
 
@@ -200,7 +213,8 @@ test_dir_formats(void *arg)
   strlcat(buf2, "hidden-service-dir\n", sizeof(buf2));
   strlcat(buf2, "contact Magri White <magri@elsewhere.example.com>\n",
           sizeof(buf2));
-  strlcat(buf2, "reject *:*\nrouter-signature\n", sizeof(buf2));
+  strlcat(buf2, "reject *:*\n", sizeof(buf2));
+  strlcat(buf2, "tunnelled-dir-server\nrouter-signature\n", sizeof(buf2));
   buf[strlen(buf2)] = '\0'; /* Don't compare the sig; it's never the same
                              * twice */
 
@@ -214,12 +228,13 @@ test_dir_formats(void *arg)
   tt_assert(rp1);
   tt_int_op(rp1->addr,OP_EQ, r1->addr);
   tt_int_op(rp1->or_port,OP_EQ, r1->or_port);
-  //test_eq(rp1->dir_port, r1->dir_port);
+  tt_int_op(rp1->dir_port,OP_EQ, r1->dir_port);
   tt_int_op(rp1->bandwidthrate,OP_EQ, r1->bandwidthrate);
   tt_int_op(rp1->bandwidthburst,OP_EQ, r1->bandwidthburst);
   tt_int_op(rp1->bandwidthcapacity,OP_EQ, r1->bandwidthcapacity);
   tt_assert(crypto_pk_cmp_keys(rp1->onion_pkey, pk1) == 0);
   tt_assert(crypto_pk_cmp_keys(rp1->identity_pkey, pk2) == 0);
+  tt_assert(rp1->supports_tunnelled_dir_requests);
   //tt_assert(rp1->exit_policy == NULL);
   tor_free(buf);
 
@@ -290,6 +305,7 @@ test_dir_formats(void *arg)
                 BASE64_ENCODE_MULTILINE);
   strlcat(buf2, cert_buf, sizeof(buf2));
   strlcat(buf2, "accept *:80\nreject 18.0.0.0/8:24\n", sizeof(buf2));
+  strlcat(buf2, "tunnelled-dir-server\n", sizeof(buf2));
   strlcat(buf2, "router-sig-ed25519 ", sizeof(buf2));
 
   buf = router_dump_router_to_string(r2, pk1, pk2, &r2_onion_keypair, &kp2);
@@ -301,6 +317,8 @@ test_dir_formats(void *arg)
   tor_free(buf);
 
   buf = router_dump_router_to_string(r2, pk1, NULL, NULL, NULL);
+
+  /* Reset for later */
   cp = buf;
   rp2 = router_parse_entry_from_string((const char*)cp,NULL,1,0,NULL,NULL);
   tt_assert(rp2);
@@ -315,6 +333,7 @@ test_dir_formats(void *arg)
              CURVE25519_PUBKEY_LEN);
   tt_assert(crypto_pk_cmp_keys(rp2->onion_pkey, pk2) == 0);
   tt_assert(crypto_pk_cmp_keys(rp2->identity_pkey, pk1) == 0);
+  tt_assert(rp2->supports_tunnelled_dir_requests);
 
   tt_int_op(smartlist_len(rp2->exit_policy),OP_EQ, 2);
 
@@ -478,6 +497,7 @@ test_dir_routerinfo_parsing(void *arg)
 #undef CHECK_FAIL
 #undef CHECK_OK
  done:
+  memarea_clear_freelist();
   routerinfo_free(ri);
 }
 
@@ -580,6 +600,8 @@ test_dir_extrainfo_parsing(void *arg)
 #undef CHECK_FAIL
 
  done:
+  escaped(NULL);
+  memarea_clear_freelist();
   extrainfo_free(ei);
   routerinfo_free(ri);
   digestmap_free((digestmap_t*)map, routerinfo_free_wrapper_);
@@ -1477,13 +1499,6 @@ test_dir_param_voting(void *arg)
   return;
 }
 
-extern const char AUTHORITY_CERT_1[];
-extern const char AUTHORITY_SIGNKEY_1[];
-extern const char AUTHORITY_CERT_2[];
-extern const char AUTHORITY_SIGNKEY_2[];
-extern const char AUTHORITY_CERT_3[];
-extern const char AUTHORITY_SIGNKEY_3[];
-
 /** Helper: Test that two networkstatus_voter_info_t do in fact represent the
  * same voting authority, and that they do in fact have all the same
  * information. */
@@ -1503,42 +1518,6 @@ test_same_voter(networkstatus_voter_info_t *v1,
   ;
 }
 
-/** Helper: Make a new routerinfo containing the right information for a
- * given vote_routerstatus_t. */
-static routerinfo_t *
-generate_ri_from_rs(const vote_routerstatus_t *vrs)
-{
-  routerinfo_t *r;
-  const routerstatus_t *rs = &vrs->status;
-  static time_t published = 0;
-
-  r = tor_malloc_zero(sizeof(routerinfo_t));
-  r->cert_expiration_time = TIME_MAX;
-  memcpy(r->cache_info.identity_digest, rs->identity_digest, DIGEST_LEN);
-  memcpy(r->cache_info.signed_descriptor_digest, rs->descriptor_digest,
-         DIGEST_LEN);
-  r->cache_info.do_not_cache = 1;
-  r->cache_info.routerlist_index = -1;
-  r->cache_info.signed_descriptor_body =
-    tor_strdup("123456789012345678901234567890123");
-  r->cache_info.signed_descriptor_len =
-    strlen(r->cache_info.signed_descriptor_body);
-  r->exit_policy = smartlist_new();
-  r->cache_info.published_on = ++published + time(NULL);
-  if (rs->has_bandwidth) {
-    /*
-     * Multiply by 1000 because the routerinfo_t and the routerstatus_t
-     * seem to use different units (*sigh*) and because we seem stuck on
-     * icky and perverse decimal kilobytes (*double sigh*) - see
-     * router_get_advertised_bandwidth_capped() of routerlist.c and
-     * routerstatus_format_entry() of dirserv.c.
-     */
-    r->bandwidthrate = rs->bandwidth_kb * 1000;
-    r->bandwidthcapacity = rs->bandwidth_kb * 1000;
-  }
-  return r;
-}
-
 /** Helper: get a detached signatures document for one or two
  * consensuses. */
 static char *
@@ -1556,100 +1535,6 @@ get_detached_sigs(networkstatus_t *ns, networkstatus_t *ns2)
   return r;
 }
 
-/**
- * Generate a routerstatus for v3_networkstatus test
- */
-static vote_routerstatus_t *
-gen_routerstatus_for_v3ns(int idx, time_t now)
-{
-  vote_routerstatus_t *vrs=NULL;
-  routerstatus_t *rs;
-  tor_addr_t addr_ipv6;
-
-  switch (idx) {
-    case 0:
-      /* Generate the first routerstatus. */
-      vrs = tor_malloc_zero(sizeof(vote_routerstatus_t));
-      rs = &vrs->status;
-      vrs->version = tor_strdup("0.1.2.14");
-      rs->published_on = now-1500;
-      strlcpy(rs->nickname, "router2", sizeof(rs->nickname));
-      memset(rs->identity_digest, 3, DIGEST_LEN);
-      memset(rs->descriptor_digest, 78, DIGEST_LEN);
-      rs->addr = 0x99008801;
-      rs->or_port = 443;
-      rs->dir_port = 8000;
-      /* all flags but running cleared */
-      rs->is_flagged_running = 1;
-      break;
-    case 1:
-      /* Generate the second routerstatus. */
-      vrs = tor_malloc_zero(sizeof(vote_routerstatus_t));
-      rs = &vrs->status;
-      vrs->version = tor_strdup("0.2.0.5");
-      rs->published_on = now-1000;
-      strlcpy(rs->nickname, "router1", sizeof(rs->nickname));
-      memset(rs->identity_digest, 5, DIGEST_LEN);
-      memset(rs->descriptor_digest, 77, DIGEST_LEN);
-      rs->addr = 0x99009901;
-      rs->or_port = 443;
-      rs->dir_port = 0;
-      tor_addr_parse(&addr_ipv6, "[1:2:3::4]");
-      tor_addr_copy(&rs->ipv6_addr, &addr_ipv6);
-      rs->ipv6_orport = 4711;
-      rs->is_exit = rs->is_stable = rs->is_fast = rs->is_flagged_running =
-        rs->is_valid = rs->is_possible_guard = 1;
-      break;
-    case 2:
-      /* Generate the third routerstatus. */
-      vrs = tor_malloc_zero(sizeof(vote_routerstatus_t));
-      rs = &vrs->status;
-      vrs->version = tor_strdup("0.1.0.3");
-      rs->published_on = now-1000;
-      strlcpy(rs->nickname, "router3", sizeof(rs->nickname));
-      memset(rs->identity_digest, 33, DIGEST_LEN);
-      memset(rs->descriptor_digest, 79, DIGEST_LEN);
-      rs->addr = 0xAA009901;
-      rs->or_port = 400;
-      rs->dir_port = 9999;
-      rs->is_authority = rs->is_exit = rs->is_stable = rs->is_fast =
-        rs->is_flagged_running = rs->is_valid =
-        rs->is_possible_guard = 1;
-      break;
-    case 3:
-      /* Generate a fourth routerstatus that is not running. */
-      vrs = tor_malloc_zero(sizeof(vote_routerstatus_t));
-      rs = &vrs->status;
-      vrs->version = tor_strdup("0.1.6.3");
-      rs->published_on = now-1000;
-      strlcpy(rs->nickname, "router4", sizeof(rs->nickname));
-      memset(rs->identity_digest, 34, DIGEST_LEN);
-      memset(rs->descriptor_digest, 47, DIGEST_LEN);
-      rs->addr = 0xC0000203;
-      rs->or_port = 500;
-      rs->dir_port = 1999;
-      /* Running flag (and others) cleared */
-      break;
-    case 4:
-      /* No more for this test; return NULL */
-      vrs = NULL;
-      break;
-    default:
-      /* Shouldn't happen */
-      tt_assert(0);
-  }
-  if (vrs) {
-    vrs->microdesc = tor_malloc_zero(sizeof(vote_microdesc_hash_t));
-    tor_asprintf(&vrs->microdesc->microdesc_hash_line,
-                 "m 9,10,11,12,13,14,15,16,17 "
-                 "sha256=xyzajkldsdsajdadlsdjaslsdksdjlsdjsdaskdaaa%d\n",
-                 idx);
-  }
-
- done:
-  return vrs;
-}
-
 /** Apply tweaks to the vote list for each voter */
 static int
 vote_tweaks_for_v3ns(networkstatus_t *v, int voter, time_t now)
@@ -1681,7 +1566,7 @@ vote_tweaks_for_v3ns(networkstatus_t *v, int voter, time_t now)
       vrs = smartlist_get(v->routerstatus_list, 0);
       memset(vrs->status.descriptor_digest, (int)'Z', DIGEST_LEN);
       tt_assert(router_add_to_routerlist(
-                  generate_ri_from_rs(vrs), &msg,0,0) >= 0);
+                  dir_common_generate_ri_from_rs(vrs), &msg,0,0) >= 0);
     }
   }
 
@@ -1746,11 +1631,11 @@ test_vrs_for_v3ns(vote_routerstatus_t *vrs, int voter, time_t now)
     tt_assert(tor_addr_eq(&rs->ipv6_addr, &addr_ipv6));
     tt_int_op(rs->ipv6_orport,OP_EQ, 4711);
     if (voter == 1) {
-      /* all except "authority" (1) and "v2dir" (64) */
-      tt_u64_op(vrs->flags, OP_EQ, U64_LITERAL(190));
+      /* all except "authority" (1) */
+      tt_u64_op(vrs->flags, OP_EQ, U64_LITERAL(254));
     } else {
-      /* 1023 - authority(1) - madeofcheese(16) - madeoftin(32) - v2dir(256) */
-      tt_u64_op(vrs->flags, OP_EQ, U64_LITERAL(718));
+      /* 1023 - authority(1) - madeofcheese(16) - madeoftin(32) */
+      tt_u64_op(vrs->flags, OP_EQ, U64_LITERAL(974));
     }
   } else if (tor_memeq(rs->identity_digest,
                        "\x33\x33\x33\x33\x33\x33\x33\x33\x33\x33"
@@ -1820,6 +1705,7 @@ test_routerstatus_for_v3ns(routerstatus_t *rs, time_t now)
     tt_assert(rs->is_flagged_running);
     tt_assert(!rs->is_valid);
     tt_assert(!rs->is_named);
+    tt_assert(rs->is_v2_dir);
     /* XXXX check version */
   } else if (tor_memeq(rs->identity_digest,
                        "\x5\x5\x5\x5\x5\x5\x5\x5\x5\x5\x5\x5\x5\x5\x5\x5"
@@ -1845,6 +1731,7 @@ test_routerstatus_for_v3ns(routerstatus_t *rs, time_t now)
     tt_assert(rs->is_stable);
     tt_assert(rs->is_flagged_running);
     tt_assert(rs->is_valid);
+    tt_assert(rs->is_v2_dir);
     tt_assert(!rs->is_named);
     /* XXXX check version */
   } else {
@@ -1869,7 +1756,6 @@ test_a_networkstatus(
   authority_cert_t *cert1=NULL, *cert2=NULL, *cert3=NULL;
   crypto_pk_t *sign_skey_1=NULL, *sign_skey_2=NULL, *sign_skey_3=NULL;
   crypto_pk_t *sign_skey_leg1=NULL;
-  const char *msg=NULL;
   /*
    * Sum the non-zero returns from vote_tweaks() we've seen; if vote_tweaks()
    * returns non-zero, it changed net_params and we should skip the tests for
@@ -1885,8 +1771,7 @@ test_a_networkstatus(
   vote_routerstatus_t *vrs;
   routerstatus_t *rs;
   int idx, n_rs, n_vrs;
-  char *v1_text=NULL, *v2_text=NULL, *v3_text=NULL, *consensus_text=NULL,
-    *cp=NULL;
+  char *consensus_text=NULL, *cp=NULL;
   smartlist_t *votes = smartlist_new();
 
   /* For generating the two other consensuses. */
@@ -1901,79 +1786,13 @@ test_a_networkstatus(
   tt_assert(rs_test);
   tt_assert(vrs_test);
 
-  /* Parse certificates and keys. */
-  cert1 = authority_cert_parse_from_string(AUTHORITY_CERT_1, NULL);
-  tt_assert(cert1);
-  cert2 = authority_cert_parse_from_string(AUTHORITY_CERT_2, NULL);
-  tt_assert(cert2);
-  cert3 = authority_cert_parse_from_string(AUTHORITY_CERT_3, NULL);
-  tt_assert(cert3);
-  sign_skey_1 = crypto_pk_new();
-  sign_skey_2 = crypto_pk_new();
-  sign_skey_3 = crypto_pk_new();
+  tt_assert(!dir_common_authority_pk_init(&cert1, &cert2, &cert3,
+                                          &sign_skey_1, &sign_skey_2,
+                                          &sign_skey_3));
   sign_skey_leg1 = pk_generate(4);
 
-  tt_assert(!crypto_pk_read_private_key_from_string(sign_skey_1,
-                                                   AUTHORITY_SIGNKEY_1, -1));
-  tt_assert(!crypto_pk_read_private_key_from_string(sign_skey_2,
-                                                   AUTHORITY_SIGNKEY_2, -1));
-  tt_assert(!crypto_pk_read_private_key_from_string(sign_skey_3,
-                                                   AUTHORITY_SIGNKEY_3, -1));
-
-  tt_assert(!crypto_pk_cmp_keys(sign_skey_1, cert1->signing_key));
-  tt_assert(!crypto_pk_cmp_keys(sign_skey_2, cert2->signing_key));
-
-  /*
-   * Set up a vote; generate it; try to parse it.
-   */
-  vote = tor_malloc_zero(sizeof(networkstatus_t));
-  vote->type = NS_TYPE_VOTE;
-  vote->published = now;
-  vote->valid_after = now+1000;
-  vote->fresh_until = now+2000;
-  vote->valid_until = now+3000;
-  vote->vote_seconds = 100;
-  vote->dist_seconds = 200;
-  vote->supported_methods = smartlist_new();
-  smartlist_split_string(vote->supported_methods, "1 2 3", NULL, 0, -1);
-  vote->client_versions = tor_strdup("0.1.2.14,0.1.2.15");
-  vote->server_versions = tor_strdup("0.1.2.14,0.1.2.15,0.1.2.16");
-  vote->known_flags = smartlist_new();
-  smartlist_split_string(vote->known_flags,
-                     "Authority Exit Fast Guard Running Stable V2Dir Valid",
-                     0, SPLIT_SKIP_SPACE|SPLIT_IGNORE_BLANK, 0);
-  vote->voters = smartlist_new();
-  voter = tor_malloc_zero(sizeof(networkstatus_voter_info_t));
-  voter->nickname = tor_strdup("Voter1");
-  voter->address = tor_strdup("1.2.3.4");
-  voter->addr = 0x01020304;
-  voter->dir_port = 80;
-  voter->or_port = 9000;
-  voter->contact = tor_strdup("voter@example.com");
-  crypto_pk_get_digest(cert1->identity_key, voter->identity_digest);
-  smartlist_add(vote->voters, voter);
-  vote->cert = authority_cert_dup(cert1);
-  vote->net_params = smartlist_new();
-  smartlist_split_string(vote->net_params, "circuitwindow=101 foo=990",
-                         NULL, 0, 0);
-  vote->routerstatus_list = smartlist_new();
-  /* add routerstatuses */
-  idx = 0;
-  do {
-    vrs = vrs_gen(idx, now);
-    if (vrs) {
-      smartlist_add(vote->routerstatus_list, vrs);
-      tt_assert(router_add_to_routerlist(generate_ri_from_rs(vrs),
-                                           &msg,0,0)>=0);
-      ++idx;
-    }
-  } while (vrs);
-  n_vrs = idx;
-
-  /* dump the vote and try to parse it. */
-  v1_text = format_networkstatus_vote(sign_skey_1, vote);
-  tt_assert(v1_text);
-  v1 = networkstatus_parse_vote_from_string(v1_text, NULL, NS_TYPE_VOTE);
+  tt_assert(!dir_common_construct_vote_1(&vote, cert1, sign_skey_1, vrs_gen,
+                                         &v1, &n_vrs, now, 1));
   tt_assert(v1);
 
   /* Make sure the parsed thing was right. */
@@ -2000,6 +1819,8 @@ test_a_networkstatus(
   tt_str_op(cp,OP_EQ, "Authority:Exit:Fast:Guard:Running:Stable:V2Dir:Valid");
   tor_free(cp);
   tt_int_op(smartlist_len(v1->routerstatus_list),OP_EQ, n_vrs);
+  networkstatus_vote_free(vote);
+  vote = NULL;
 
   if (vote_tweaks) params_tweaked += vote_tweaks(v1, 1, now);
 
@@ -2011,33 +1832,10 @@ test_a_networkstatus(
   }
 
   /* Generate second vote. It disagrees on some of the times,
-   * and doesn't list versions, and knows some crazy flags */
-  vote->published = now+1;
-  vote->fresh_until = now+3005;
-  vote->dist_seconds = 300;
-  authority_cert_free(vote->cert);
-  vote->cert = authority_cert_dup(cert2);
-  SMARTLIST_FOREACH(vote->net_params, char *, c, tor_free(c));
-  smartlist_clear(vote->net_params);
-  smartlist_split_string(vote->net_params, "bar=2000000000 circuitwindow=20",
-                         NULL, 0, 0);
-  tor_free(vote->client_versions);
-  tor_free(vote->server_versions);
-  voter = smartlist_get(vote->voters, 0);
-  tor_free(voter->nickname);
-  tor_free(voter->address);
-  voter->nickname = tor_strdup("Voter2");
-  voter->address = tor_strdup("2.3.4.5");
-  voter->addr = 0x02030405;
-  crypto_pk_get_digest(cert2->identity_key, voter->identity_digest);
-  smartlist_add(vote->known_flags, tor_strdup("MadeOfCheese"));
-  smartlist_add(vote->known_flags, tor_strdup("MadeOfTin"));
-  smartlist_sort_strings(vote->known_flags);
-
-  /* generate and parse v2. */
-  v2_text = format_networkstatus_vote(sign_skey_2, vote);
-  tt_assert(v2_text);
-  v2 = networkstatus_parse_vote_from_string(v2_text, NULL, NS_TYPE_VOTE);
+   * and doesn't list versions, and knows some crazy flags.
+   * Generate and parse v2. */
+  tt_assert(!dir_common_construct_vote_2(&vote, cert2, sign_skey_2, vrs_gen,
+                                         &v2, &n_vrs, now, 1));
   tt_assert(v2);
 
   if (vote_tweaks) params_tweaked += vote_tweaks(v2, 2, now);
@@ -2055,34 +1853,12 @@ test_a_networkstatus(
     tt_assert(vrs);
     vrs_test(vrs, 2, now);
   }
+  networkstatus_vote_free(vote);
+  vote = NULL;
 
-  /* Generate the third vote. */
-  vote->published = now;
-  vote->fresh_until = now+2003;
-  vote->dist_seconds = 250;
-  authority_cert_free(vote->cert);
-  vote->cert = authority_cert_dup(cert3);
-  SMARTLIST_FOREACH(vote->net_params, char *, c, tor_free(c));
-  smartlist_clear(vote->net_params);
-  smartlist_split_string(vote->net_params, "circuitwindow=80 foo=660",
-                         NULL, 0, 0);
-  smartlist_add(vote->supported_methods, tor_strdup("4"));
-  vote->client_versions = tor_strdup("0.1.2.14,0.1.2.17");
-  vote->server_versions = tor_strdup("0.1.2.10,0.1.2.15,0.1.2.16");
-  voter = smartlist_get(vote->voters, 0);
-  tor_free(voter->nickname);
-  tor_free(voter->address);
-  voter->nickname = tor_strdup("Voter3");
-  voter->address = tor_strdup("3.4.5.6");
-  voter->addr = 0x03040506;
-  crypto_pk_get_digest(cert3->identity_key, voter->identity_digest);
-  /* This one has a legacy id. */
-  memset(voter->legacy_id_digest, (int)'A', DIGEST_LEN);
-
-  v3_text = format_networkstatus_vote(sign_skey_3, vote);
-  tt_assert(v3_text);
-
-  v3 = networkstatus_parse_vote_from_string(v3_text, NULL, NS_TYPE_VOTE);
+  /* Generate the third vote with a legacy id. */
+  tt_assert(!dir_common_construct_vote_3(&vote, cert3, sign_skey_3, vrs_gen,
+                                         &v3, &n_vrs, now, 1));
   tt_assert(v3);
 
   if (vote_tweaks) params_tweaked += vote_tweaks(v3, 3, now);
@@ -2153,12 +1929,20 @@ test_a_networkstatus(
 
   /* Check the routerstatuses. */
   n_rs = smartlist_len(con->routerstatus_list);
+  tt_assert(n_rs);
   for (idx = 0; idx < n_rs; ++idx) {
     rs = smartlist_get(con->routerstatus_list, idx);
     tt_assert(rs);
     rs_test(rs, now);
   }
 
+  n_rs = smartlist_len(con_md->routerstatus_list);
+  tt_assert(n_rs);
+  for (idx = 0; idx < n_rs; ++idx) {
+    rs = smartlist_get(con_md->routerstatus_list, idx);
+    tt_assert(rs);
+  }
+
   /* Check signatures.  the first voter is a pseudo-entry with a legacy key.
    * The second one hasn't signed.  The fourth one has signed: validate it. */
   voter = smartlist_get(con->voters, 1);
@@ -2309,38 +2093,22 @@ test_a_networkstatus(
  done:
   tor_free(cp);
   smartlist_free(votes);
-  tor_free(v1_text);
-  tor_free(v2_text);
-  tor_free(v3_text);
   tor_free(consensus_text);
   tor_free(consensus_text_md);
 
-  if (vote)
-    networkstatus_vote_free(vote);
-  if (v1)
-    networkstatus_vote_free(v1);
-  if (v2)
-    networkstatus_vote_free(v2);
-  if (v3)
-    networkstatus_vote_free(v3);
-  if (con)
-    networkstatus_vote_free(con);
-  if (con_md)
-    networkstatus_vote_free(con_md);
-  if (sign_skey_1)
-    crypto_pk_free(sign_skey_1);
-  if (sign_skey_2)
-    crypto_pk_free(sign_skey_2);
-  if (sign_skey_3)
-    crypto_pk_free(sign_skey_3);
-  if (sign_skey_leg1)
-    crypto_pk_free(sign_skey_leg1);
-  if (cert1)
-    authority_cert_free(cert1);
-  if (cert2)
-    authority_cert_free(cert2);
-  if (cert3)
-    authority_cert_free(cert3);
+  networkstatus_vote_free(vote);
+  networkstatus_vote_free(v1);
+  networkstatus_vote_free(v2);
+  networkstatus_vote_free(v3);
+  networkstatus_vote_free(con);
+  networkstatus_vote_free(con_md);
+  crypto_pk_free(sign_skey_1);
+  crypto_pk_free(sign_skey_2);
+  crypto_pk_free(sign_skey_3);
+  crypto_pk_free(sign_skey_leg1);
+  authority_cert_free(cert1);
+  authority_cert_free(cert2);
+  authority_cert_free(cert3);
 
   tor_free(consensus_text2);
   tor_free(consensus_text3);
@@ -2348,18 +2116,13 @@ test_a_networkstatus(
   tor_free(consensus_text_md3);
   tor_free(detached_text1);
   tor_free(detached_text2);
-  if (con2)
-    networkstatus_vote_free(con2);
-  if (con3)
-    networkstatus_vote_free(con3);
-  if (con_md2)
-    networkstatus_vote_free(con_md2);
-  if (con_md3)
-    networkstatus_vote_free(con_md3);
-  if (dsig1)
-    ns_detached_signatures_free(dsig1);
-  if (dsig2)
-    ns_detached_signatures_free(dsig2);
+
+  networkstatus_vote_free(con2);
+  networkstatus_vote_free(con3);
+  networkstatus_vote_free(con_md2);
+  networkstatus_vote_free(con_md3);
+  ns_detached_signatures_free(dsig1);
+  ns_detached_signatures_free(dsig2);
 }
 
 /** Run unit tests for generating and parsing V3 consensus networkstatus
@@ -2368,7 +2131,7 @@ static void
 test_dir_v3_networkstatus(void *arg)
 {
   (void)arg;
-  test_a_networkstatus(gen_routerstatus_for_v3ns,
+  test_a_networkstatus(dir_common_gen_routerstatus_for_v3ns,
                        vote_tweaks_for_v3ns,
                        test_vrs_for_v3ns,
                        test_consensus_for_v3ns,
@@ -2965,6 +2728,7 @@ test_dir_fmt_control_ns(void *arg)
   rs.is_fast = 1;
   rs.is_flagged_running = 1;
   rs.has_bandwidth = 1;
+  rs.is_v2_dir = 1;
   rs.bandwidth_kb = 1000;
 
   s = networkstatus_getinfo_helper_single(&rs);
@@ -3340,12 +3104,33 @@ static void
 test_dir_fetch_type(void *arg)
 {
   (void)arg;
-  tt_assert(dir_fetch_type(DIR_PURPOSE_FETCH_MICRODESC, ROUTER_PURPOSE_GENERAL,
-                           NULL) == MICRODESC_DIRINFO);
-  tt_assert(dir_fetch_type(DIR_PURPOSE_FETCH_SERVERDESC, ROUTER_PURPOSE_BRIDGE,
-                           NULL) == BRIDGE_DIRINFO);
-  tt_assert(dir_fetch_type(DIR_PURPOSE_FETCH_CONSENSUS, ROUTER_PURPOSE_GENERAL,
-                           "microdesc") == (V3_DIRINFO | MICRODESC_DIRINFO));
+  tt_int_op(dir_fetch_type(DIR_PURPOSE_FETCH_EXTRAINFO, ROUTER_PURPOSE_BRIDGE,
+                           NULL), OP_EQ, EXTRAINFO_DIRINFO | BRIDGE_DIRINFO);
+  tt_int_op(dir_fetch_type(DIR_PURPOSE_FETCH_EXTRAINFO, ROUTER_PURPOSE_GENERAL,
+                           NULL), OP_EQ, EXTRAINFO_DIRINFO | V3_DIRINFO);
+
+  tt_int_op(dir_fetch_type(DIR_PURPOSE_FETCH_SERVERDESC, ROUTER_PURPOSE_BRIDGE,
+                           NULL), OP_EQ, BRIDGE_DIRINFO);
+  tt_int_op(dir_fetch_type(DIR_PURPOSE_FETCH_SERVERDESC,
+                           ROUTER_PURPOSE_GENERAL, NULL), OP_EQ, V3_DIRINFO);
+
+  tt_int_op(dir_fetch_type(DIR_PURPOSE_FETCH_STATUS_VOTE,
+                           ROUTER_PURPOSE_GENERAL, NULL), OP_EQ, V3_DIRINFO);
+  tt_int_op(dir_fetch_type(DIR_PURPOSE_FETCH_DETACHED_SIGNATURES,
+                           ROUTER_PURPOSE_GENERAL, NULL), OP_EQ, V3_DIRINFO);
+  tt_int_op(dir_fetch_type(DIR_PURPOSE_FETCH_CERTIFICATE,
+                           ROUTER_PURPOSE_GENERAL, NULL), OP_EQ, V3_DIRINFO);
+
+  tt_int_op(dir_fetch_type(DIR_PURPOSE_FETCH_CONSENSUS, ROUTER_PURPOSE_GENERAL,
+                           "microdesc"), OP_EQ, V3_DIRINFO|MICRODESC_DIRINFO);
+  tt_int_op(dir_fetch_type(DIR_PURPOSE_FETCH_CONSENSUS, ROUTER_PURPOSE_GENERAL,
+                           NULL), OP_EQ, V3_DIRINFO);
+
+  tt_int_op(dir_fetch_type(DIR_PURPOSE_FETCH_MICRODESC, ROUTER_PURPOSE_GENERAL,
+                           NULL), OP_EQ, MICRODESC_DIRINFO);
+
+  tt_int_op(dir_fetch_type(DIR_PURPOSE_FETCH_RENDDESC_V2,
+                           ROUTER_PURPOSE_GENERAL, NULL), OP_EQ, NO_DIRINFO);
  done: ;
 }
 
@@ -3453,7 +3238,7 @@ test_dir_packages(void *arg)
   ADD(4, "clownshoes 22alpha4 http://quumble.example.cam/ blake2=fooa");
   ADD(5, "clownshoes 22alpha4 http://quumble.example.cam/ blake2=fooa");
 
-  /* Five votes for A ... all from the same guy.  Three for B. */
+  /* Five votes for A ... all from the same authority.  Three for B. */
   ADD(0, "cbc 99.1.11.1.1 http://example.com/cbc/ cubehash=ahooy sha512=m");
   ADD(1, "cbc 99.1.11.1.1 http://example.com/cbc/ cubehash=ahooy sha512=m");
   ADD(3, "cbc 99.1.11.1.1 http://example.com/cbc/ cubehash=ahooy sha512=m");
@@ -3494,6 +3279,770 @@ test_dir_packages(void *arg)
   tor_free(res);
 }
 
+static void
+test_dir_download_status_schedule(void *arg)
+{
+  (void)arg;
+  download_status_t dls_failure = { 0, 0, 0, DL_SCHED_GENERIC,
+                                             DL_WANT_AUTHORITY,
+                                             DL_SCHED_INCREMENT_FAILURE };
+  download_status_t dls_attempt = { 0, 0, 0, DL_SCHED_CONSENSUS,
+                                             DL_WANT_ANY_DIRSERVER,
+                                             DL_SCHED_INCREMENT_ATTEMPT};
+  download_status_t dls_bridge  = { 0, 0, 0, DL_SCHED_BRIDGE,
+                                             DL_WANT_AUTHORITY,
+                                             DL_SCHED_INCREMENT_FAILURE};
+  int increment = -1;
+  int expected_increment = -1;
+  time_t current_time = time(NULL);
+  int delay1 = -1;
+  int delay2 = -1;
+  smartlist_t *schedule = smartlist_new();
+
+  /* Make a dummy schedule */
+  smartlist_add(schedule, (void *)&delay1);
+  smartlist_add(schedule, (void *)&delay2);
+
+  /* check a range of values */
+  delay1 = 1000;
+  increment = download_status_schedule_get_delay(&dls_failure,
+                                                 schedule,
+                                                 TIME_MIN);
+  expected_increment = delay1;
+  tt_assert(increment == expected_increment);
+  tt_assert(dls_failure.next_attempt_at == TIME_MIN + expected_increment);
+
+#if TIME_T_IS_SIGNED
+  delay1 = INT_MAX;
+  increment =  download_status_schedule_get_delay(&dls_failure,
+                                                  schedule,
+                                                  -1);
+  expected_increment = delay1;
+  tt_assert(increment == expected_increment);
+  tt_assert(dls_failure.next_attempt_at == TIME_MAX);
+#endif
+
+  delay1 = 0;
+  increment = download_status_schedule_get_delay(&dls_attempt,
+                                                 schedule,
+                                                 0);
+  expected_increment = delay1;
+  tt_assert(increment == expected_increment);
+  tt_assert(dls_attempt.next_attempt_at == 0 + expected_increment);
+
+  delay1 = 1000;
+  increment = download_status_schedule_get_delay(&dls_attempt,
+                                                 schedule,
+                                                 1);
+  expected_increment = delay1;
+  tt_assert(increment == expected_increment);
+  tt_assert(dls_attempt.next_attempt_at == 1 + expected_increment);
+
+  delay1 = INT_MAX;
+  increment = download_status_schedule_get_delay(&dls_bridge,
+                                                 schedule,
+                                                 current_time);
+  expected_increment = delay1;
+  tt_assert(increment == expected_increment);
+  tt_assert(dls_bridge.next_attempt_at == TIME_MAX);
+
+  delay1 = 1;
+  increment = download_status_schedule_get_delay(&dls_bridge,
+                                                 schedule,
+                                                 TIME_MAX);
+  expected_increment = delay1;
+  tt_assert(increment == expected_increment);
+  tt_assert(dls_bridge.next_attempt_at == TIME_MAX);
+
+  /* see what happens when we reach the end */
+  dls_attempt.n_download_attempts++;
+  dls_bridge.n_download_failures++;
+
+  delay2 = 100;
+  increment = download_status_schedule_get_delay(&dls_attempt,
+                                                 schedule,
+                                                 current_time);
+  expected_increment = delay2;
+  tt_assert(increment == expected_increment);
+  tt_assert(dls_attempt.next_attempt_at == current_time + delay2);
+
+  delay2 = 1;
+  increment = download_status_schedule_get_delay(&dls_bridge,
+                                                 schedule,
+                                                 current_time);
+  expected_increment = delay2;
+  tt_assert(increment == expected_increment);
+  tt_assert(dls_bridge.next_attempt_at == current_time + delay2);
+
+  /* see what happens when we try to go off the end */
+  dls_attempt.n_download_attempts++;
+  dls_bridge.n_download_failures++;
+
+  delay2 = 5;
+  increment = download_status_schedule_get_delay(&dls_attempt,
+                                                 schedule,
+                                                 current_time);
+  expected_increment = delay2;
+  tt_assert(increment == expected_increment);
+  tt_assert(dls_attempt.next_attempt_at == current_time + delay2);
+
+  delay2 = 17;
+  increment = download_status_schedule_get_delay(&dls_bridge,
+                                                 schedule,
+                                                 current_time);
+  expected_increment = delay2;
+  tt_assert(increment == expected_increment);
+  tt_assert(dls_bridge.next_attempt_at == current_time + delay2);
+
+  /* see what happens when we reach IMPOSSIBLE_TO_DOWNLOAD */
+  dls_attempt.n_download_attempts = IMPOSSIBLE_TO_DOWNLOAD;
+  dls_bridge.n_download_failures = IMPOSSIBLE_TO_DOWNLOAD;
+
+  delay2 = 35;
+  increment = download_status_schedule_get_delay(&dls_attempt,
+                                                 schedule,
+                                                 current_time);
+  expected_increment = INT_MAX;
+  tt_assert(increment == expected_increment);
+  tt_assert(dls_attempt.next_attempt_at == TIME_MAX);
+
+  delay2 = 99;
+  increment = download_status_schedule_get_delay(&dls_bridge,
+                                                 schedule,
+                                                 current_time);
+  expected_increment = INT_MAX;
+  tt_assert(increment == expected_increment);
+  tt_assert(dls_bridge.next_attempt_at == TIME_MAX);
+
+ done:
+  /* the pointers in schedule are allocated on the stack */
+  smartlist_free(schedule);
+}
+
+static void
+test_dir_download_status_increment(void *arg)
+{
+  (void)arg;
+  download_status_t dls_failure = { 0, 0, 0, DL_SCHED_GENERIC,
+    DL_WANT_AUTHORITY,
+    DL_SCHED_INCREMENT_FAILURE };
+  download_status_t dls_attempt = { 0, 0, 0, DL_SCHED_BRIDGE,
+    DL_WANT_ANY_DIRSERVER,
+    DL_SCHED_INCREMENT_ATTEMPT};
+  int delay0 = -1;
+  int delay1 = -1;
+  int delay2 = -1;
+  smartlist_t *schedule = smartlist_new();
+  or_options_t test_options;
+  time_t next_at = TIME_MAX;
+  time_t current_time = time(NULL);
+
+  /* Provide some values for the schedule */
+  delay0 = 10;
+  delay1 = 99;
+  delay2 = 20;
+
+  /* Make the schedule */
+  smartlist_add(schedule, (void *)&delay0);
+  smartlist_add(schedule, (void *)&delay1);
+  smartlist_add(schedule, (void *)&delay2);
+
+  /* Put it in the options */
+  mock_options = &test_options;
+  reset_options(mock_options, &mock_get_options_calls);
+  mock_options->TestingClientDownloadSchedule = schedule;
+  mock_options->TestingBridgeDownloadSchedule = schedule;
+
+  MOCK(get_options, mock_get_options);
+
+  /* Check that a failure reset works */
+  mock_get_options_calls = 0;
+  download_status_reset(&dls_failure);
+  /* we really want to test that it's equal to time(NULL) + delay0, but that's
+   * an unrealiable test, because time(NULL) might change. */
+  tt_assert(download_status_get_next_attempt_at(&dls_failure)
+            >= current_time + delay0);
+  tt_assert(download_status_get_next_attempt_at(&dls_failure)
+            != TIME_MAX);
+  tt_assert(download_status_get_n_failures(&dls_failure) == 0);
+  tt_assert(download_status_get_n_attempts(&dls_failure) == 0);
+  tt_assert(mock_get_options_calls >= 1);
+
+  /* avoid timing inconsistencies */
+  dls_failure.next_attempt_at = current_time + delay0;
+
+  /* check that a reset schedule becomes ready at the right time */
+  tt_assert(download_status_is_ready(&dls_failure,
+                                     current_time + delay0 - 1,
+                                     1) == 0);
+  tt_assert(download_status_is_ready(&dls_failure,
+                                     current_time + delay0,
+                                     1) == 1);
+  tt_assert(download_status_is_ready(&dls_failure,
+                                     current_time + delay0 + 1,
+                                     1) == 1);
+
+  /* Check that a failure increment works */
+  mock_get_options_calls = 0;
+  next_at = download_status_increment_failure(&dls_failure, 404, "test", 0,
+                                              current_time);
+  tt_assert(next_at == current_time + delay1);
+  tt_assert(download_status_get_n_failures(&dls_failure) == 1);
+  tt_assert(download_status_get_n_attempts(&dls_failure) == 1);
+  tt_assert(mock_get_options_calls >= 1);
+
+  /* check that an incremented schedule becomes ready at the right time */
+  tt_assert(download_status_is_ready(&dls_failure,
+                                     current_time + delay1 - 1,
+                                     1) == 0);
+  tt_assert(download_status_is_ready(&dls_failure,
+                                     current_time + delay1,
+                                     1) == 1);
+  tt_assert(download_status_is_ready(&dls_failure,
+                                     current_time + delay1 + 1,
+                                     1) == 1);
+
+  /* check that a schedule isn't ready if it's had too many failures */
+  tt_assert(download_status_is_ready(&dls_failure,
+                                     current_time + delay1 + 10,
+                                     0) == 0);
+
+  /* Check that failure increments don't happen on 503 for clients, but that
+   * attempt increments do. */
+  mock_get_options_calls = 0;
+  next_at = download_status_increment_failure(&dls_failure, 503, "test", 0,
+                                              current_time);
+  tt_assert(next_at == current_time + delay1);
+  tt_assert(download_status_get_n_failures(&dls_failure) == 1);
+  tt_assert(download_status_get_n_attempts(&dls_failure) == 2);
+  tt_assert(mock_get_options_calls >= 1);
+
+  /* Check that failure increments do happen on 503 for servers */
+  mock_get_options_calls = 0;
+  next_at = download_status_increment_failure(&dls_failure, 503, "test", 1,
+                                              current_time);
+  tt_assert(next_at == current_time + delay2);
+  tt_assert(download_status_get_n_failures(&dls_failure) == 2);
+  tt_assert(download_status_get_n_attempts(&dls_failure) == 3);
+  tt_assert(mock_get_options_calls >= 1);
+
+  /* Check what happens when we run off the end of the schedule */
+  mock_get_options_calls = 0;
+  next_at = download_status_increment_failure(&dls_failure, 404, "test", 0,
+                                              current_time);
+  tt_assert(next_at == current_time + delay2);
+  tt_assert(download_status_get_n_failures(&dls_failure) == 3);
+  tt_assert(download_status_get_n_attempts(&dls_failure) == 4);
+  tt_assert(mock_get_options_calls >= 1);
+
+  /* Check what happens when we hit the failure limit */
+  mock_get_options_calls = 0;
+  download_status_mark_impossible(&dls_failure);
+  next_at = download_status_increment_failure(&dls_failure, 404, "test", 0,
+                                              current_time);
+  tt_assert(next_at == TIME_MAX);
+  tt_assert(download_status_get_n_failures(&dls_failure)
+            == IMPOSSIBLE_TO_DOWNLOAD);
+  tt_assert(download_status_get_n_attempts(&dls_failure)
+            == IMPOSSIBLE_TO_DOWNLOAD);
+  tt_assert(mock_get_options_calls >= 1);
+
+  /* Check that a failure reset doesn't reset at the limit */
+  mock_get_options_calls = 0;
+  download_status_reset(&dls_failure);
+  tt_assert(download_status_get_next_attempt_at(&dls_failure)
+            == TIME_MAX);
+  tt_assert(download_status_get_n_failures(&dls_failure)
+            == IMPOSSIBLE_TO_DOWNLOAD);
+  tt_assert(download_status_get_n_attempts(&dls_failure)
+            == IMPOSSIBLE_TO_DOWNLOAD);
+  tt_assert(mock_get_options_calls == 0);
+
+  /* Check that a failure reset resets just before the limit */
+  mock_get_options_calls = 0;
+  dls_failure.n_download_failures = IMPOSSIBLE_TO_DOWNLOAD - 1;
+  dls_failure.n_download_attempts = IMPOSSIBLE_TO_DOWNLOAD - 1;
+  download_status_reset(&dls_failure);
+  /* we really want to test that it's equal to time(NULL) + delay0, but that's
+   * an unrealiable test, because time(NULL) might change. */
+  tt_assert(download_status_get_next_attempt_at(&dls_failure)
+            >= current_time + delay0);
+  tt_assert(download_status_get_next_attempt_at(&dls_failure)
+            != TIME_MAX);
+  tt_assert(download_status_get_n_failures(&dls_failure) == 0);
+  tt_assert(download_status_get_n_attempts(&dls_failure) == 0);
+  tt_assert(mock_get_options_calls >= 1);
+
+  /* Check that failure increments do happen on attempt-based schedules,
+   * but that the retry is set at the end of time */
+  mock_get_options_calls = 0;
+  next_at = download_status_increment_failure(&dls_attempt, 404, "test", 0,
+                                              current_time);
+  tt_assert(next_at == TIME_MAX);
+  tt_assert(download_status_get_n_failures(&dls_attempt) == 1);
+  tt_assert(download_status_get_n_attempts(&dls_attempt) == 0);
+  tt_assert(mock_get_options_calls == 0);
+
+  /* Check that an attempt reset works */
+  mock_get_options_calls = 0;
+  download_status_reset(&dls_attempt);
+  /* we really want to test that it's equal to time(NULL) + delay0, but that's
+   * an unrealiable test, because time(NULL) might change. */
+  tt_assert(download_status_get_next_attempt_at(&dls_attempt)
+            >= current_time + delay0);
+  tt_assert(download_status_get_next_attempt_at(&dls_attempt)
+            != TIME_MAX);
+  tt_assert(download_status_get_n_failures(&dls_attempt) == 0);
+  tt_assert(download_status_get_n_attempts(&dls_attempt) == 0);
+  tt_assert(mock_get_options_calls >= 1);
+
+  /* avoid timing inconsistencies */
+  dls_attempt.next_attempt_at = current_time + delay0;
+
+  /* check that a reset schedule becomes ready at the right time */
+  tt_assert(download_status_is_ready(&dls_attempt,
+                                     current_time + delay0 - 1,
+                                     1) == 0);
+  tt_assert(download_status_is_ready(&dls_attempt,
+                                     current_time + delay0,
+                                     1) == 1);
+  tt_assert(download_status_is_ready(&dls_attempt,
+                                     current_time + delay0 + 1,
+                                     1) == 1);
+
+  /* Check that an attempt increment works */
+  mock_get_options_calls = 0;
+  next_at = download_status_increment_attempt(&dls_attempt, "test",
+                                              current_time);
+  tt_assert(next_at == current_time + delay1);
+  tt_assert(download_status_get_n_failures(&dls_attempt) == 0);
+  tt_assert(download_status_get_n_attempts(&dls_attempt) == 1);
+  tt_assert(mock_get_options_calls >= 1);
+
+  /* check that an incremented schedule becomes ready at the right time */
+  tt_assert(download_status_is_ready(&dls_attempt,
+                                     current_time + delay1 - 1,
+                                     1) == 0);
+  tt_assert(download_status_is_ready(&dls_attempt,
+                                     current_time + delay1,
+                                     1) == 1);
+  tt_assert(download_status_is_ready(&dls_attempt,
+                                     current_time + delay1 + 1,
+                                     1) == 1);
+
+  /* check that a schedule isn't ready if it's had too many attempts */
+  tt_assert(download_status_is_ready(&dls_attempt,
+                                     current_time + delay1 + 10,
+                                     0) == 0);
+
+  /* Check what happens when we reach then run off the end of the schedule */
+  mock_get_options_calls = 0;
+  next_at = download_status_increment_attempt(&dls_attempt, "test",
+                                              current_time);
+  tt_assert(next_at == current_time + delay2);
+  tt_assert(download_status_get_n_failures(&dls_attempt) == 0);
+  tt_assert(download_status_get_n_attempts(&dls_attempt) == 2);
+  tt_assert(mock_get_options_calls >= 1);
+
+  mock_get_options_calls = 0;
+  next_at = download_status_increment_attempt(&dls_attempt, "test",
+                                              current_time);
+  tt_assert(next_at == current_time + delay2);
+  tt_assert(download_status_get_n_failures(&dls_attempt) == 0);
+  tt_assert(download_status_get_n_attempts(&dls_attempt) == 3);
+  tt_assert(mock_get_options_calls >= 1);
+
+  /* Check what happens when we hit the attempt limit */
+  mock_get_options_calls = 0;
+  download_status_mark_impossible(&dls_attempt);
+  next_at = download_status_increment_attempt(&dls_attempt, "test",
+                                              current_time);
+  tt_assert(next_at == TIME_MAX);
+  tt_assert(download_status_get_n_failures(&dls_attempt)
+            == IMPOSSIBLE_TO_DOWNLOAD);
+  tt_assert(download_status_get_n_attempts(&dls_attempt)
+            == IMPOSSIBLE_TO_DOWNLOAD);
+  tt_assert(mock_get_options_calls >= 1);
+
+  /* Check that an attempt reset doesn't reset at the limit */
+  mock_get_options_calls = 0;
+  download_status_reset(&dls_attempt);
+  tt_assert(download_status_get_next_attempt_at(&dls_attempt)
+            == TIME_MAX);
+  tt_assert(download_status_get_n_failures(&dls_attempt)
+            == IMPOSSIBLE_TO_DOWNLOAD);
+  tt_assert(download_status_get_n_attempts(&dls_attempt)
+            == IMPOSSIBLE_TO_DOWNLOAD);
+  tt_assert(mock_get_options_calls == 0);
+
+  /* Check that an attempt reset resets just before the limit */
+  mock_get_options_calls = 0;
+  dls_attempt.n_download_failures = IMPOSSIBLE_TO_DOWNLOAD - 1;
+  dls_attempt.n_download_attempts = IMPOSSIBLE_TO_DOWNLOAD - 1;
+  download_status_reset(&dls_attempt);
+  /* we really want to test that it's equal to time(NULL) + delay0, but that's
+   * an unrealiable test, because time(NULL) might change. */
+  tt_assert(download_status_get_next_attempt_at(&dls_attempt)
+            >= current_time + delay0);
+  tt_assert(download_status_get_next_attempt_at(&dls_attempt)
+            != TIME_MAX);
+  tt_assert(download_status_get_n_failures(&dls_attempt) == 0);
+  tt_assert(download_status_get_n_attempts(&dls_attempt) == 0);
+  tt_assert(mock_get_options_calls >= 1);
+
+  /* Check that attempt increments don't happen on failure-based schedules,
+   * and that the attempt is set at the end of time */
+  mock_get_options_calls = 0;
+  next_at = download_status_increment_attempt(&dls_failure, "test",
+                                              current_time);
+  tt_assert(next_at == TIME_MAX);
+  tt_assert(download_status_get_n_failures(&dls_failure) == 0);
+  tt_assert(download_status_get_n_attempts(&dls_failure) == 0);
+  tt_assert(mock_get_options_calls == 0);
+
+ done:
+  /* the pointers in schedule are allocated on the stack */
+  smartlist_free(schedule);
+  UNMOCK(get_options);
+  mock_options = NULL;
+  mock_get_options_calls = 0;
+}
+
+static void
+test_dir_authdir_type_to_string(void *data)
+{
+  (void)data;
+  char *res;
+
+  tt_str_op(res = authdir_type_to_string(NO_DIRINFO), OP_EQ,
+            "[Not an authority]");
+  tor_free(res);
+
+  tt_str_op(res = authdir_type_to_string(EXTRAINFO_DIRINFO), OP_EQ,
+            "[Not an authority]");
+  tor_free(res);
+
+  tt_str_op(res = authdir_type_to_string(MICRODESC_DIRINFO), OP_EQ,
+            "[Not an authority]");
+  tor_free(res);
+
+  tt_str_op(res = authdir_type_to_string(V3_DIRINFO), OP_EQ, "V3");
+  tor_free(res);
+
+  tt_str_op(res = authdir_type_to_string(BRIDGE_DIRINFO), OP_EQ, "Bridge");
+  tor_free(res);
+
+  tt_str_op(res = authdir_type_to_string(
+            V3_DIRINFO | BRIDGE_DIRINFO | EXTRAINFO_DIRINFO), OP_EQ,
+            "V3, Bridge");
+  done:
+  tor_free(res);
+}
+
+static void
+test_dir_conn_purpose_to_string(void *data)
+{
+  (void)data;
+
+#define EXPECT_CONN_PURPOSE(purpose, expected) \
+  tt_str_op(dir_conn_purpose_to_string(purpose), OP_EQ, expected);
+
+  EXPECT_CONN_PURPOSE(DIR_PURPOSE_UPLOAD_DIR, "server descriptor upload");
+  EXPECT_CONN_PURPOSE(DIR_PURPOSE_UPLOAD_VOTE, "server vote upload");
+  EXPECT_CONN_PURPOSE(DIR_PURPOSE_UPLOAD_SIGNATURES,
+                      "consensus signature upload");
+  EXPECT_CONN_PURPOSE(DIR_PURPOSE_FETCH_SERVERDESC, "server descriptor fetch");
+  EXPECT_CONN_PURPOSE(DIR_PURPOSE_FETCH_EXTRAINFO, "extra-info fetch");
+  EXPECT_CONN_PURPOSE(DIR_PURPOSE_FETCH_CONSENSUS,
+                      "consensus network-status fetch");
+  EXPECT_CONN_PURPOSE(DIR_PURPOSE_FETCH_CERTIFICATE, "authority cert fetch");
+  EXPECT_CONN_PURPOSE(DIR_PURPOSE_FETCH_STATUS_VOTE, "status vote fetch");
+  EXPECT_CONN_PURPOSE(DIR_PURPOSE_FETCH_DETACHED_SIGNATURES,
+                      "consensus signature fetch");
+  EXPECT_CONN_PURPOSE(DIR_PURPOSE_FETCH_RENDDESC_V2,
+                      "hidden-service v2 descriptor fetch");
+  EXPECT_CONN_PURPOSE(DIR_PURPOSE_UPLOAD_RENDDESC_V2,
+                      "hidden-service v2 descriptor upload");
+  EXPECT_CONN_PURPOSE(DIR_PURPOSE_FETCH_MICRODESC, "microdescriptor fetch");
+  EXPECT_CONN_PURPOSE(1024, "(unknown)");
+
+  done: ;
+}
+
+NS_DECL(int,
+public_server_mode, (const or_options_t *options));
+
+static int
+NS(public_server_mode)(const or_options_t *options)
+{
+  (void)options;
+
+  if (CALLED(public_server_mode)++ == 0) {
+    return 1;
+  }
+
+  return 0;
+}
+
+static void
+test_dir_should_use_directory_guards(void *data)
+{
+  or_options_t *options;
+  char *errmsg = NULL;
+  (void)data;
+
+  NS_MOCK(public_server_mode);
+
+  options = options_new();
+  options_init(options);
+
+  tt_int_op(should_use_directory_guards(options), OP_EQ, 0);
+  tt_int_op(CALLED(public_server_mode), OP_EQ, 1);
+
+  options->UseEntryGuardsAsDirGuards = 1;
+  options->UseEntryGuards = 1;
+  options->DownloadExtraInfo = 0;
+  options->FetchDirInfoEarly = 0;
+  options->FetchDirInfoExtraEarly = 0;
+  options->FetchUselessDescriptors = 0;
+  tt_int_op(should_use_directory_guards(options), OP_EQ, 1);
+  tt_int_op(CALLED(public_server_mode), OP_EQ, 2);
+
+  options->UseEntryGuards = 0;
+  tt_int_op(should_use_directory_guards(options), OP_EQ, 0);
+  tt_int_op(CALLED(public_server_mode), OP_EQ, 3);
+  options->UseEntryGuards = 1;
+
+  options->UseEntryGuardsAsDirGuards = 0;
+  tt_int_op(should_use_directory_guards(options), OP_EQ, 0);
+  tt_int_op(CALLED(public_server_mode), OP_EQ, 4);
+  options->UseEntryGuardsAsDirGuards = 1;
+
+  options->DownloadExtraInfo = 1;
+  tt_int_op(should_use_directory_guards(options), OP_EQ, 0);
+  tt_int_op(CALLED(public_server_mode), OP_EQ, 5);
+  options->DownloadExtraInfo = 0;
+
+  options->FetchDirInfoEarly = 1;
+  tt_int_op(should_use_directory_guards(options), OP_EQ, 0);
+  tt_int_op(CALLED(public_server_mode), OP_EQ, 6);
+  options->FetchDirInfoEarly = 0;
+
+  options->FetchDirInfoExtraEarly = 1;
+  tt_int_op(should_use_directory_guards(options), OP_EQ, 0);
+  tt_int_op(CALLED(public_server_mode), OP_EQ, 7);
+  options->FetchDirInfoExtraEarly = 0;
+
+  options->FetchUselessDescriptors = 1;
+  tt_int_op(should_use_directory_guards(options), OP_EQ, 0);
+  tt_int_op(CALLED(public_server_mode), OP_EQ, 8);
+  options->FetchUselessDescriptors = 0;
+
+  done:
+    NS_UNMOCK(public_server_mode);
+    or_options_free(options);
+    tor_free(errmsg);
+}
+
+NS_DECL(void,
+directory_initiate_command_routerstatus, (const routerstatus_t *status,
+                                          uint8_t dir_purpose,
+                                          uint8_t router_purpose,
+                                          dir_indirection_t indirection,
+                                          const char *resource,
+                                          const char *payload,
+                                          size_t payload_len,
+                                          time_t if_modified_since));
+
+static void
+test_dir_should_not_init_request_to_ourselves(void *data)
+{
+  char digest[DIGEST_LEN];
+  dir_server_t *ourself = NULL;
+  crypto_pk_t *key = pk_generate(2);
+  (void) data;
+
+  NS_MOCK(directory_initiate_command_routerstatus);
+
+  clear_dir_servers();
+  routerlist_free_all();
+
+  set_server_identity_key(key);
+  crypto_pk_get_digest(key, (char*) &digest);
+  ourself = trusted_dir_server_new("ourself", "127.0.0.1", 9059, 9060,
+                                   NULL, digest,
+                                   NULL, V3_DIRINFO, 1.0);
+
+  tt_assert(ourself);
+  dir_server_add(ourself);
+
+  directory_get_from_all_authorities(DIR_PURPOSE_FETCH_STATUS_VOTE, 0, NULL);
+  tt_int_op(CALLED(directory_initiate_command_routerstatus), OP_EQ, 0);
+
+  directory_get_from_all_authorities(DIR_PURPOSE_FETCH_DETACHED_SIGNATURES, 0,
+                                     NULL);
+
+  tt_int_op(CALLED(directory_initiate_command_routerstatus), OP_EQ, 0);
+
+  done:
+    NS_UNMOCK(directory_initiate_command_routerstatus);
+    clear_dir_servers();
+    routerlist_free_all();
+    crypto_pk_free(key);
+}
+
+static void
+test_dir_should_not_init_request_to_dir_auths_without_v3_info(void *data)
+{
+  dir_server_t *ds = NULL;
+  dirinfo_type_t dirinfo_type = BRIDGE_DIRINFO | EXTRAINFO_DIRINFO \
+                                | MICRODESC_DIRINFO;
+  (void) data;
+
+  NS_MOCK(directory_initiate_command_routerstatus);
+
+  clear_dir_servers();
+  routerlist_free_all();
+
+  ds = trusted_dir_server_new("ds", "10.0.0.1", 9059, 9060, NULL,
+                              "12345678901234567890", NULL, dirinfo_type, 1.0);
+  tt_assert(ds);
+  dir_server_add(ds);
+
+  directory_get_from_all_authorities(DIR_PURPOSE_FETCH_STATUS_VOTE, 0, NULL);
+  tt_int_op(CALLED(directory_initiate_command_routerstatus), OP_EQ, 0);
+
+  directory_get_from_all_authorities(DIR_PURPOSE_FETCH_DETACHED_SIGNATURES, 0,
+                                     NULL);
+  tt_int_op(CALLED(directory_initiate_command_routerstatus), OP_EQ, 0);
+
+  done:
+    NS_UNMOCK(directory_initiate_command_routerstatus);
+    clear_dir_servers();
+    routerlist_free_all();
+}
+
+static void
+test_dir_should_init_request_to_dir_auths(void *data)
+{
+  dir_server_t *ds = NULL;
+  (void) data;
+
+  NS_MOCK(directory_initiate_command_routerstatus);
+
+  clear_dir_servers();
+  routerlist_free_all();
+
+  ds = trusted_dir_server_new("ds", "10.0.0.1", 9059, 9060, NULL,
+                              "12345678901234567890", NULL, V3_DIRINFO, 1.0);
+  tt_assert(ds);
+  dir_server_add(ds);
+
+  directory_get_from_all_authorities(DIR_PURPOSE_FETCH_STATUS_VOTE, 0, NULL);
+  tt_int_op(CALLED(directory_initiate_command_routerstatus), OP_EQ, 1);
+
+  directory_get_from_all_authorities(DIR_PURPOSE_FETCH_DETACHED_SIGNATURES, 0,
+                                     NULL);
+  tt_int_op(CALLED(directory_initiate_command_routerstatus), OP_EQ, 2);
+
+  done:
+    NS_UNMOCK(directory_initiate_command_routerstatus);
+    clear_dir_servers();
+    routerlist_free_all();
+}
+
+void
+NS(directory_initiate_command_routerstatus)(const routerstatus_t *status,
+                                            uint8_t dir_purpose,
+                                            uint8_t router_purpose,
+                                            dir_indirection_t indirection,
+                                            const char *resource,
+                                            const char *payload,
+                                            size_t payload_len,
+                                            time_t if_modified_since)
+{
+  (void)status;
+  (void)dir_purpose;
+  (void)router_purpose;
+  (void)indirection;
+  (void)resource;
+  (void)payload;
+  (void)payload_len;
+  (void)if_modified_since;
+  CALLED(directory_initiate_command_routerstatus)++;
+}
+
+static void
+test_dir_choose_compression_level(void* data)
+{
+  (void)data;
+
+  /* It starts under_memory_pressure */
+  tt_int_op(have_been_under_memory_pressure(), OP_EQ, 1);
+
+  tt_assert(HIGH_COMPRESSION == choose_compression_level(-1));
+  tt_assert(LOW_COMPRESSION == choose_compression_level(1024-1));
+  tt_assert(MEDIUM_COMPRESSION == choose_compression_level(2048-1));
+  tt_assert(HIGH_COMPRESSION == choose_compression_level(2048));
+
+  /* Reset under_memory_pressure timer */
+  cell_queues_check_size();
+  tt_int_op(have_been_under_memory_pressure(), OP_EQ, 0);
+
+  tt_assert(HIGH_COMPRESSION == choose_compression_level(-1));
+  tt_assert(HIGH_COMPRESSION == choose_compression_level(1024-1));
+  tt_assert(HIGH_COMPRESSION == choose_compression_level(2048-1));
+  tt_assert(HIGH_COMPRESSION == choose_compression_level(2048));
+
+  done: ;
+}
+
+static void
+test_dir_find_dl_schedule(void* data)
+{
+  download_status_t dls;
+  smartlist_t server, client, server_cons, client_cons, bridge;
+  (void)data;
+
+  mock_options = malloc(sizeof(or_options_t));
+  reset_options(mock_options, &mock_get_options_calls);
+  MOCK(get_options, mock_get_options);
+
+  mock_options->TestingServerDownloadSchedule = &server;
+  mock_options->TestingClientDownloadSchedule = &client;
+  mock_options->TestingServerConsensusDownloadSchedule = &server_cons;
+  mock_options->TestingClientConsensusDownloadSchedule = &client_cons;
+  mock_options->TestingBridgeDownloadSchedule = &bridge;
+
+  dls.schedule = DL_SCHED_GENERIC;
+  mock_options->ClientOnly = 1;
+  tt_ptr_op(find_dl_schedule(&dls, mock_options), OP_EQ, &client);
+  mock_options->ClientOnly = 0;
+  mock_options->DirPort_set = 1;
+  mock_options->ORPort_set = 1;
+  mock_options->DirCache = 1;
+  tt_ptr_op(find_dl_schedule(&dls, mock_options), OP_EQ, &server);
+
+#if 0
+  dls.schedule = DL_SCHED_CONSENSUS;
+  mock_options->ClientOnly = 1;
+  mock_options->DirCache = 0;
+  tt_ptr_op(find_dl_schedule(&dls, mock_options), OP_EQ, &client_cons);
+  mock_options->ClientOnly = 0;
+  mock_options->DirCache = 1;
+  tt_ptr_op(find_dl_schedule(&dls, mock_options), OP_EQ, &server_cons);
+#endif
+
+  dls.schedule = DL_SCHED_BRIDGE;
+  mock_options->ClientOnly = 1;
+  tt_ptr_op(find_dl_schedule(&dls, mock_options), OP_EQ, &bridge);
+  mock_options->ClientOnly = 0;
+  tt_ptr_op(find_dl_schedule(&dls, mock_options), OP_EQ, &bridge);
+
+ done:
+  UNMOCK(get_options);
+}
+
 #define DIR_LEGACY(name)                                                   \
   { #name, test_dir_ ## name , TT_FORK, NULL, NULL }
 
@@ -3525,6 +4074,16 @@ struct testcase_t dir_tests[] = {
   DIR(purpose_needs_anonymity, 0),
   DIR(fetch_type, 0),
   DIR(packages, 0),
+  DIR(download_status_schedule, 0),
+  DIR(download_status_increment, 0),
+  DIR(authdir_type_to_string, 0),
+  DIR(conn_purpose_to_string, 0),
+  DIR(should_use_directory_guards, 0),
+  DIR(should_not_init_request_to_ourselves, TT_FORK),
+  DIR(should_not_init_request_to_dir_auths_without_v3_info, 0),
+  DIR(should_init_request_to_dir_auths, 0),
+  DIR(choose_compression_level, 0),
+  DIR(find_dl_schedule, 0),
   END_OF_TESTCASES
 };
 
diff --git a/src/test/test_dir_common.c b/src/test/test_dir_common.c
new file mode 100644
index 0000000..f9e97c9
--- /dev/null
+++ b/src/test/test_dir_common.c
@@ -0,0 +1,425 @@
+/* Copyright (c) 2001-2004, Roger Dingledine.
+ * Copyright (c) 2004-2006, Roger Dingledine, Nick Mathewson.
+ * Copyright (c) 2007-2014, The Tor Project, Inc. */
+/* See LICENSE for licensing information */
+
+#include "orconfig.h"
+#define DIRVOTE_PRIVATE
+#include "crypto.h"
+#include "test.h"
+#include "container.h"
+#include "or.h"
+#include "dirvote.h"
+#include "nodelist.h"
+#include "routerlist.h"
+#include "test_dir_common.h"
+
+void dir_common_setup_vote(networkstatus_t **vote, time_t now);
+networkstatus_t * dir_common_add_rs_and_parse(networkstatus_t *vote,
+                            networkstatus_t **vote_out,
+               vote_routerstatus_t * (*vrs_gen)(int idx, time_t now),
+                            crypto_pk_t *sign_skey, int *n_vrs,
+                            time_t now, int clear_rl);
+
+extern const char AUTHORITY_CERT_1[];
+extern const char AUTHORITY_SIGNKEY_1[];
+extern const char AUTHORITY_CERT_2[];
+extern const char AUTHORITY_SIGNKEY_2[];
+extern const char AUTHORITY_CERT_3[];
+extern const char AUTHORITY_SIGNKEY_3[];
+
+/** Initialize and set auth certs and keys
+ * Returns 0 on success, -1 on failure. Clean up handled by caller.
+ */
+int
+dir_common_authority_pk_init(authority_cert_t **cert1,
+                             authority_cert_t **cert2,
+                             authority_cert_t **cert3,
+                             crypto_pk_t **sign_skey_1,
+                             crypto_pk_t **sign_skey_2,
+                             crypto_pk_t **sign_skey_3)
+{
+  /* Parse certificates and keys. */
+  authority_cert_t *cert;
+  cert = authority_cert_parse_from_string(AUTHORITY_CERT_1, NULL);
+  tt_assert(cert);
+  tt_assert(cert->identity_key);
+  *cert1 = cert;
+  tt_assert(*cert1);
+  *cert2 = authority_cert_parse_from_string(AUTHORITY_CERT_2, NULL);
+  tt_assert(*cert2);
+  *cert3 = authority_cert_parse_from_string(AUTHORITY_CERT_3, NULL);
+  tt_assert(*cert3);
+  *sign_skey_1 = crypto_pk_new();
+  *sign_skey_2 = crypto_pk_new();
+  *sign_skey_3 = crypto_pk_new();
+
+  tt_assert(!crypto_pk_read_private_key_from_string(*sign_skey_1,
+                                                   AUTHORITY_SIGNKEY_1, -1));
+  tt_assert(!crypto_pk_read_private_key_from_string(*sign_skey_2,
+                                                   AUTHORITY_SIGNKEY_2, -1));
+  tt_assert(!crypto_pk_read_private_key_from_string(*sign_skey_3,
+                                                   AUTHORITY_SIGNKEY_3, -1));
+
+  tt_assert(!crypto_pk_cmp_keys(*sign_skey_1, (*cert1)->signing_key));
+  tt_assert(!crypto_pk_cmp_keys(*sign_skey_2, (*cert2)->signing_key));
+
+  return 0;
+ done:
+  return -1;
+}
+
+/**
+ * Generate a routerstatus for v3_networkstatus test.
+ */
+vote_routerstatus_t *
+dir_common_gen_routerstatus_for_v3ns(int idx, time_t now)
+{
+  vote_routerstatus_t *vrs=NULL;
+  routerstatus_t *rs = NULL;
+  tor_addr_t addr_ipv6;
+  char *method_list = NULL;
+
+  switch (idx) {
+    case 0:
+      /* Generate the first routerstatus. */
+      vrs = tor_malloc_zero(sizeof(vote_routerstatus_t));
+      rs = &vrs->status;
+      vrs->version = tor_strdup("0.1.2.14");
+      rs->published_on = now-1500;
+      strlcpy(rs->nickname, "router2", sizeof(rs->nickname));
+      memset(rs->identity_digest, TEST_DIR_ROUTER_ID_1, DIGEST_LEN);
+      memset(rs->descriptor_digest, TEST_DIR_ROUTER_DD_1, DIGEST_LEN);
+      rs->addr = 0x99008801;
+      rs->or_port = 443;
+      rs->dir_port = 8000;
+      /* all flags but running and v2dir cleared */
+      rs->is_flagged_running = 1;
+      rs->is_v2_dir = 1;
+      break;
+    case 1:
+      /* Generate the second routerstatus. */
+      vrs = tor_malloc_zero(sizeof(vote_routerstatus_t));
+      rs = &vrs->status;
+      vrs->version = tor_strdup("0.2.0.5");
+      rs->published_on = now-1000;
+      strlcpy(rs->nickname, "router1", sizeof(rs->nickname));
+      memset(rs->identity_digest, TEST_DIR_ROUTER_ID_2, DIGEST_LEN);
+      memset(rs->descriptor_digest, TEST_DIR_ROUTER_DD_2, DIGEST_LEN);
+      rs->addr = 0x99009901;
+      rs->or_port = 443;
+      rs->dir_port = 0;
+      tor_addr_parse(&addr_ipv6, "[1:2:3::4]");
+      tor_addr_copy(&rs->ipv6_addr, &addr_ipv6);
+      rs->ipv6_orport = 4711;
+      rs->is_exit = rs->is_stable = rs->is_fast = rs->is_flagged_running =
+        rs->is_valid = rs->is_possible_guard = rs->is_v2_dir = 1;
+      break;
+    case 2:
+      /* Generate the third routerstatus. */
+      vrs = tor_malloc_zero(sizeof(vote_routerstatus_t));
+      rs = &vrs->status;
+      vrs->version = tor_strdup("0.1.0.3");
+      rs->published_on = now-1000;
+      strlcpy(rs->nickname, "router3", sizeof(rs->nickname));
+      memset(rs->identity_digest, TEST_DIR_ROUTER_ID_3, DIGEST_LEN);
+      memset(rs->descriptor_digest, TEST_DIR_ROUTER_DD_3, DIGEST_LEN);
+      rs->addr = 0xAA009901;
+      rs->or_port = 400;
+      rs->dir_port = 9999;
+      rs->is_authority = rs->is_exit = rs->is_stable = rs->is_fast =
+        rs->is_flagged_running = rs->is_valid = rs->is_v2_dir =
+        rs->is_possible_guard = 1;
+      break;
+    case 3:
+      /* Generate a fourth routerstatus that is not running. */
+      vrs = tor_malloc_zero(sizeof(vote_routerstatus_t));
+      rs = &vrs->status;
+      vrs->version = tor_strdup("0.1.6.3");
+      rs->published_on = now-1000;
+      strlcpy(rs->nickname, "router4", sizeof(rs->nickname));
+      memset(rs->identity_digest, TEST_DIR_ROUTER_ID_4, DIGEST_LEN);
+      memset(rs->descriptor_digest, TEST_DIR_ROUTER_DD_4, DIGEST_LEN);
+      rs->addr = 0xC0000203;
+      rs->or_port = 500;
+      rs->dir_port = 1999;
+      rs->is_v2_dir = 1;
+      /* Running flag (and others) cleared */
+      break;
+    case 4:
+      /* No more for this test; return NULL */
+      vrs = NULL;
+      break;
+    default:
+      /* Shouldn't happen */
+      tt_assert(0);
+  }
+  if (vrs) {
+    vrs->microdesc = tor_malloc_zero(sizeof(vote_microdesc_hash_t));
+    method_list = make_consensus_method_list(MIN_SUPPORTED_CONSENSUS_METHOD,
+                                             MAX_SUPPORTED_CONSENSUS_METHOD,
+                                             ",");
+    tor_asprintf(&vrs->microdesc->microdesc_hash_line,
+                 "m %s "
+                 "sha256=xyzajkldsdsajdadlsdjaslsdksdjlsdjsdaskdaaa%d\n",
+                 method_list, idx);
+  }
+
+ done:
+  tor_free(method_list);
+  return vrs;
+}
+
+/** Initialize networkstatus vote object attributes. */
+void
+dir_common_setup_vote(networkstatus_t **vote, time_t now)
+{
+  *vote = tor_malloc_zero(sizeof(networkstatus_t));
+  (*vote)->type = NS_TYPE_VOTE;
+  (*vote)->published = now;
+  (*vote)->supported_methods = smartlist_new();
+  (*vote)->known_flags = smartlist_new();
+  (*vote)->net_params = smartlist_new();
+  (*vote)->routerstatus_list = smartlist_new();
+  (*vote)->voters = smartlist_new();
+}
+
+/** Helper: Make a new routerinfo containing the right information for a
+ * given vote_routerstatus_t. */
+routerinfo_t *
+dir_common_generate_ri_from_rs(const vote_routerstatus_t *vrs)
+{
+  routerinfo_t *r;
+  const routerstatus_t *rs = &vrs->status;
+  static time_t published = 0;
+
+  r = tor_malloc_zero(sizeof(routerinfo_t));
+  r->cert_expiration_time = TIME_MAX;
+  memcpy(r->cache_info.identity_digest, rs->identity_digest, DIGEST_LEN);
+  memcpy(r->cache_info.signed_descriptor_digest, rs->descriptor_digest,
+         DIGEST_LEN);
+  r->cache_info.do_not_cache = 1;
+  r->cache_info.routerlist_index = -1;
+  r->cache_info.signed_descriptor_body =
+    tor_strdup("123456789012345678901234567890123");
+  r->cache_info.signed_descriptor_len =
+    strlen(r->cache_info.signed_descriptor_body);
+  r->exit_policy = smartlist_new();
+  r->cache_info.published_on = ++published + time(NULL);
+  if (rs->has_bandwidth) {
+    /*
+     * Multiply by 1000 because the routerinfo_t and the routerstatus_t
+     * seem to use different units (*sigh*) and because we seem stuck on
+     * icky and perverse decimal kilobytes (*double sigh*) - see
+     * router_get_advertised_bandwidth_capped() of routerlist.c and
+     * routerstatus_format_entry() of dirserv.c.
+     */
+    r->bandwidthrate = rs->bandwidth_kb * 1000;
+    r->bandwidthcapacity = rs->bandwidth_kb * 1000;
+  }
+  return r;
+}
+
+/** Create routerstatuses and signed vote.
+ * Create routerstatuses using *vrs_gen* and add them to global routerlist.
+ * Next, create signed vote using *sign_skey* and *vote*, which should have
+ * predefined header fields.
+ * Setting *clear_rl* clears the global routerlist before adding the new
+ * routers.
+ * Return the signed vote, same as *vote_out*. Save the number of routers added
+ * in *n_vrs*.
+ */
+networkstatus_t *
+dir_common_add_rs_and_parse(networkstatus_t *vote, networkstatus_t **vote_out,
+                       vote_routerstatus_t * (*vrs_gen)(int idx, time_t now),
+                       crypto_pk_t *sign_skey, int *n_vrs, time_t now,
+                       int clear_rl)
+{
+  vote_routerstatus_t *vrs;
+  char *v_text=NULL;
+  const char *msg=NULL;
+  int idx;
+  was_router_added_t router_added = -1;
+  *vote_out = NULL;
+
+  if (clear_rl) {
+    nodelist_free_all();
+    routerlist_free_all();
+  }
+
+  idx = 0;
+  do {
+    vrs = vrs_gen(idx, now);
+    if (vrs) {
+      smartlist_add(vote->routerstatus_list, vrs);
+      router_added =
+        router_add_to_routerlist(dir_common_generate_ri_from_rs(vrs),
+                                 &msg,0,0);
+      tt_assert(router_added >= 0);
+      ++idx;
+    }
+  } while (vrs);
+  *n_vrs = idx;
+
+  /* dump the vote and try to parse it. */
+  v_text = format_networkstatus_vote(sign_skey, vote);
+  tt_assert(v_text);
+  *vote_out = networkstatus_parse_vote_from_string(v_text, NULL, NS_TYPE_VOTE);
+
+ done:
+  if (v_text)
+    tor_free(v_text);
+
+  return *vote_out;
+}
+
+/** Create a fake *vote* where *cert* describes the signer, *sign_skey*
+ * is the signing key, and *vrs_gen* is the function we'll use to create the
+ * routers on which we're voting.
+ * We pass *vote_out*, *n_vrs*, and *clear_rl* directly to vrs_gen().
+ * Return 0 on success, return -1 on failure.
+ */
+int
+dir_common_construct_vote_1(networkstatus_t **vote, authority_cert_t *cert,
+                        crypto_pk_t *sign_skey,
+                        vote_routerstatus_t * (*vrs_gen)(int idx, time_t now),
+                        networkstatus_t **vote_out, int *n_vrs,
+                        time_t now, int clear_rl)
+{
+  networkstatus_voter_info_t *voter;
+
+  dir_common_setup_vote(vote, now);
+  (*vote)->valid_after = now+1000;
+  (*vote)->fresh_until = now+2000;
+  (*vote)->valid_until = now+3000;
+  (*vote)->vote_seconds = 100;
+  (*vote)->dist_seconds = 200;
+  smartlist_split_string((*vote)->supported_methods, "1 2 3", NULL, 0, -1);
+  (*vote)->client_versions = tor_strdup("0.1.2.14,0.1.2.15");
+  (*vote)->server_versions = tor_strdup("0.1.2.14,0.1.2.15,0.1.2.16");
+  smartlist_split_string((*vote)->known_flags,
+                     "Authority Exit Fast Guard Running Stable V2Dir Valid",
+                     0, SPLIT_SKIP_SPACE|SPLIT_IGNORE_BLANK, 0);
+  voter = tor_malloc_zero(sizeof(networkstatus_voter_info_t));
+  voter->nickname = tor_strdup("Voter1");
+  voter->address = tor_strdup("1.2.3.4");
+  voter->addr = 0x01020304;
+  voter->dir_port = 80;
+  voter->or_port = 9000;
+  voter->contact = tor_strdup("voter@example.com");
+  crypto_pk_get_digest(cert->identity_key, voter->identity_digest);
+  /*
+   * Set up a vote; generate it; try to parse it.
+   */
+  smartlist_add((*vote)->voters, voter);
+  (*vote)->cert = authority_cert_dup(cert);
+  smartlist_split_string((*vote)->net_params, "circuitwindow=101 foo=990",
+                         NULL, 0, 0);
+  *n_vrs = 0;
+  /* add routerstatuses */
+  if (!dir_common_add_rs_and_parse(*vote, vote_out, vrs_gen, sign_skey,
+                                  n_vrs, now, clear_rl))
+    return -1;
+
+  return 0;
+}
+
+/** See dir_common_construct_vote_1.
+ * Produces a vote with slightly different values.
+ */
+int
+dir_common_construct_vote_2(networkstatus_t **vote, authority_cert_t *cert,
+                        crypto_pk_t *sign_skey,
+                        vote_routerstatus_t * (*vrs_gen)(int idx, time_t now),
+                        networkstatus_t **vote_out, int *n_vrs,
+                        time_t now, int clear_rl)
+{
+  networkstatus_voter_info_t *voter;
+
+  dir_common_setup_vote(vote, now);
+  (*vote)->type = NS_TYPE_VOTE;
+  (*vote)->published += 1;
+  (*vote)->valid_after = now+1000;
+  (*vote)->fresh_until = now+3005;
+  (*vote)->valid_until = now+3000;
+  (*vote)->vote_seconds = 100;
+  (*vote)->dist_seconds = 300;
+  smartlist_split_string((*vote)->supported_methods, "1 2 3", NULL, 0, -1);
+  smartlist_split_string((*vote)->known_flags,
+                         "Authority Exit Fast Guard MadeOfCheese MadeOfTin "
+                         "Running Stable V2Dir Valid", 0,
+                         SPLIT_SKIP_SPACE|SPLIT_IGNORE_BLANK, 0);
+  voter = tor_malloc_zero(sizeof(networkstatus_voter_info_t));
+  voter->nickname = tor_strdup("Voter2");
+  voter->address = tor_strdup("2.3.4.5");
+  voter->addr = 0x02030405;
+  voter->dir_port = 80;
+  voter->or_port = 9000;
+  voter->contact = tor_strdup("voter@example.com");
+  crypto_pk_get_digest(cert->identity_key, voter->identity_digest);
+  /*
+   * Set up a vote; generate it; try to parse it.
+   */
+  smartlist_add((*vote)->voters, voter);
+  (*vote)->cert = authority_cert_dup(cert);
+  if (! (*vote)->net_params)
+    (*vote)->net_params = smartlist_new();
+  smartlist_split_string((*vote)->net_params,
+                         "bar=2000000000 circuitwindow=20",
+                         NULL, 0, 0);
+  /* add routerstatuses */
+  /* dump the vote and try to parse it. */
+  dir_common_add_rs_and_parse(*vote, vote_out, vrs_gen, sign_skey,
+                              n_vrs, now, clear_rl);
+
+  return 0;
+}
+
+/** See dir_common_construct_vote_1.
+ * Produces a vote with slightly different values. Adds a legacy key.
+ */
+int
+dir_common_construct_vote_3(networkstatus_t **vote, authority_cert_t *cert,
+                        crypto_pk_t *sign_skey,
+                        vote_routerstatus_t * (*vrs_gen)(int idx, time_t now),
+                        networkstatus_t **vote_out, int *n_vrs,
+                        time_t now, int clear_rl)
+{
+  networkstatus_voter_info_t *voter;
+
+  dir_common_setup_vote(vote, now);
+  (*vote)->valid_after = now+1000;
+  (*vote)->fresh_until = now+2003;
+  (*vote)->valid_until = now+3000;
+  (*vote)->vote_seconds = 100;
+  (*vote)->dist_seconds = 250;
+  smartlist_split_string((*vote)->supported_methods, "1 2 3 4", NULL, 0, -1);
+  (*vote)->client_versions = tor_strdup("0.1.2.14,0.1.2.17");
+  (*vote)->server_versions = tor_strdup("0.1.2.10,0.1.2.15,0.1.2.16");
+  smartlist_split_string((*vote)->known_flags,
+                     "Authority Exit Fast Guard Running Stable V2Dir Valid",
+                     0, SPLIT_SKIP_SPACE|SPLIT_IGNORE_BLANK, 0);
+  voter = tor_malloc_zero(sizeof(networkstatus_voter_info_t));
+  voter->nickname = tor_strdup("Voter2");
+  voter->address = tor_strdup("3.4.5.6");
+  voter->addr = 0x03040506;
+  voter->dir_port = 80;
+  voter->or_port = 9000;
+  voter->contact = tor_strdup("voter@example.com");
+  crypto_pk_get_digest(cert->identity_key, voter->identity_digest);
+  memset(voter->legacy_id_digest, (int)'A', DIGEST_LEN);
+  /*
+   * Set up a vote; generate it; try to parse it.
+   */
+  smartlist_add((*vote)->voters, voter);
+  (*vote)->cert = authority_cert_dup(cert);
+  smartlist_split_string((*vote)->net_params, "circuitwindow=80 foo=660",
+                         NULL, 0, 0);
+  /* add routerstatuses */
+  /* dump the vote and try to parse it. */
+  dir_common_add_rs_and_parse(*vote, vote_out, vrs_gen, sign_skey,
+                              n_vrs, now, clear_rl);
+
+  return 0;
+}
+
diff --git a/src/test/test_dir_common.h b/src/test/test_dir_common.h
new file mode 100644
index 0000000..9557cb7
--- /dev/null
+++ b/src/test/test_dir_common.h
@@ -0,0 +1,52 @@
+/* Copyright (c) 2001-2004, Roger Dingledine.
+ * Copyright (c) 2004-2006, Roger Dingledine, Nick Mathewson.
+ * Copyright (c) 2007-2014, The Tor Project, Inc. */
+/* See LICENSE for licensing information */
+
+#include "or.h"
+#include "networkstatus.h"
+#include "routerparse.h"
+
+#define TEST_DIR_ROUTER_ID_1 3
+#define TEST_DIR_ROUTER_ID_2 5
+#define TEST_DIR_ROUTER_ID_3 33
+#define TEST_DIR_ROUTER_ID_4 34
+
+#define TEST_DIR_ROUTER_DD_1 78
+#define TEST_DIR_ROUTER_DD_2 77
+#define TEST_DIR_ROUTER_DD_3 79
+#define TEST_DIR_ROUTER_DD_4 44
+
+int dir_common_authority_pk_init(authority_cert_t **cert1,
+                       authority_cert_t **cert2,
+                       authority_cert_t **cert3,
+                       crypto_pk_t **sign_skey_1,
+                       crypto_pk_t **sign_skey_2,
+                       crypto_pk_t **sign_skey_3);
+
+routerinfo_t * dir_common_generate_ri_from_rs(const vote_routerstatus_t *vrs);
+
+vote_routerstatus_t * dir_common_gen_routerstatus_for_v3ns(int idx,
+                                                           time_t now);
+
+int dir_common_construct_vote_1(networkstatus_t **vote,
+                        authority_cert_t *cert1,
+                        crypto_pk_t *sign_skey,
+                        vote_routerstatus_t * (*vrs_gen)(int idx, time_t now),
+                        networkstatus_t **vote_out, int *n_vrs, time_t now,
+                        int clear_rl);
+
+int dir_common_construct_vote_2(networkstatus_t **vote,
+                        authority_cert_t *cert2,
+                        crypto_pk_t *sign_skey,
+                        vote_routerstatus_t * (*vrs_gen)(int idx, time_t now),
+                        networkstatus_t **vote_out, int *n_vrs, time_t now,
+                        int clear_rl);
+
+int dir_common_construct_vote_3(networkstatus_t **vote,
+                        authority_cert_t *cert3,
+                        crypto_pk_t *sign_skey,
+                        vote_routerstatus_t * (*vrs_gen)(int idx, time_t now),
+                        networkstatus_t **vote_out, int *n_vrs, time_t now,
+                        int clear_rl);
+
diff --git a/src/test/test_dir_handle_get.c b/src/test/test_dir_handle_get.c
new file mode 100644
index 0000000..e1ac50e
--- /dev/null
+++ b/src/test/test_dir_handle_get.c
@@ -0,0 +1,2556 @@
+/* Copyright (c) 2001-2004, Roger Dingledine.
+ * Copyright (c) 2004-2006, Roger Dingledine, Nick Mathewson.
+ * Copyright (c) 2007-2015, The Tor Project, Inc. */
+/* See LICENSE for licensing information */
+
+#define RENDCOMMON_PRIVATE
+#define GEOIP_PRIVATE
+#define CONNECTION_PRIVATE
+#define CONFIG_PRIVATE
+#define RENDCACHE_PRIVATE
+
+#include "or.h"
+#include "config.h"
+#include "connection.h"
+#include "directory.h"
+#include "test.h"
+#include "connection.h"
+#include "rendcommon.h"
+#include "rendcache.h"
+#include "router.h"
+#include "routerlist.h"
+#include "rend_test_helpers.h"
+#include "microdesc.h"
+#include "test_helpers.h"
+#include "nodelist.h"
+#include "entrynodes.h"
+#include "routerparse.h"
+#include "networkstatus.h"
+#include "geoip.h"
+#include "dirserv.h"
+#include "torgzip.h"
+#include "dirvote.h"
+
+#ifdef _WIN32
+/* For mkdir() */
+#include <direct.h>
+#else
+#include <dirent.h>
+#endif
+
+#include "vote_descriptors.inc"
+
+#define NS_MODULE dir_handle_get
+
+static void
+connection_write_to_buf_mock(const char *string, size_t len,
+                             connection_t *conn, int zlib)
+{
+  (void) zlib;
+
+  tor_assert(string);
+  tor_assert(conn);
+
+  write_to_buf(string, len, conn->outbuf);
+}
+
+#define GET(path) "GET " path " HTTP/1.0\r\n\r\n"
+#define NOT_FOUND "HTTP/1.0 404 Not found\r\n\r\n"
+#define BAD_REQUEST "HTTP/1.0 400 Bad request\r\n\r\n"
+#define SERVER_BUSY "HTTP/1.0 503 Directory busy, try again later\r\n\r\n"
+#define NOT_ENOUGH_CONSENSUS_SIGNATURES "HTTP/1.0 404 " \
+  "Consensus not signed by sufficient number of requested authorities\r\n\r\n"
+
+static tor_addr_t MOCK_TOR_ADDR;
+
+static void
+test_dir_handle_get_bad_request(void *data)
+{
+  dir_connection_t *conn = NULL;
+  char *header = NULL;
+  (void) data;
+
+  MOCK(connection_write_to_buf_impl_, connection_write_to_buf_mock);
+
+  conn = dir_connection_new(tor_addr_family(&MOCK_TOR_ADDR));
+  tt_int_op(directory_handle_command_get(conn, "", NULL, 0), OP_EQ, 0);
+
+  fetch_from_buf_http(TO_CONN(conn)->outbuf, &header, MAX_HEADERS_SIZE,
+                      NULL, NULL, 1, 0);
+
+  tt_str_op(header, OP_EQ, BAD_REQUEST);
+
+  done:
+    UNMOCK(connection_write_to_buf_impl_);
+    connection_free_(TO_CONN(conn));
+    tor_free(header);
+}
+
+static void
+test_dir_handle_get_v1_command_not_found(void *data)
+{
+  dir_connection_t *conn = NULL;
+  char *header = NULL;
+  (void) data;
+
+  MOCK(connection_write_to_buf_impl_, connection_write_to_buf_mock);
+
+  conn = dir_connection_new(tor_addr_family(&MOCK_TOR_ADDR));
+
+  // no frontpage configured
+  tt_ptr_op(get_dirportfrontpage(), OP_EQ, NULL);
+
+  /* V1 path */
+  tt_int_op(directory_handle_command_get(conn, GET("/tor/"), NULL, 0),
+            OP_EQ, 0);
+
+  fetch_from_buf_http(TO_CONN(conn)->outbuf, &header, MAX_HEADERS_SIZE,
+                      NULL, NULL, 1, 0);
+
+  tt_str_op(NOT_FOUND, OP_EQ, header);
+
+  done:
+    UNMOCK(connection_write_to_buf_impl_);
+    connection_free_(TO_CONN(conn));
+    tor_free(header);
+}
+
+static const char*
+mock_get_dirportfrontpage(void)
+{
+  return "HELLO FROM FRONTPAGE";
+}
+
+static void
+test_dir_handle_get_v1_command(void *data)
+{
+  dir_connection_t *conn = NULL;
+  char *header = NULL;
+  char *body = NULL;
+  size_t body_used = 0, body_len = 0;
+  const char *exp_body = NULL;
+  (void) data;
+
+  MOCK(connection_write_to_buf_impl_, connection_write_to_buf_mock);
+  MOCK(get_dirportfrontpage, mock_get_dirportfrontpage);
+
+  exp_body = get_dirportfrontpage();
+  body_len = strlen(exp_body);
+
+  conn = dir_connection_new(tor_addr_family(&MOCK_TOR_ADDR));
+  tt_int_op(directory_handle_command_get(conn, GET("/tor/"), NULL, 0),
+            OP_EQ, 0);
+
+  fetch_from_buf_http(TO_CONN(conn)->outbuf, &header, MAX_HEADERS_SIZE,
+                      &body, &body_used, body_len+1, 0);
+
+  tt_assert(header);
+  tt_assert(body);
+
+  tt_ptr_op(strstr(header, "HTTP/1.0 200 OK\r\n"), OP_EQ, header);
+  tt_assert(strstr(header, "Content-Type: text/html\r\n"));
+  tt_assert(strstr(header, "Content-Encoding: identity\r\n"));
+  tt_assert(strstr(header, "Content-Length: 20\r\n"));
+
+  tt_int_op(body_used, OP_EQ, strlen(body));
+  tt_str_op(body, OP_EQ, exp_body);
+
+  done:
+    UNMOCK(connection_write_to_buf_impl_);
+    UNMOCK(get_dirportfrontpage);
+    connection_free_(TO_CONN(conn));
+    tor_free(header);
+    tor_free(body);
+}
+
+static void
+test_dir_handle_get_not_found(void *data)
+{
+  dir_connection_t *conn = NULL;
+  char *header = NULL;
+  (void) data;
+
+  MOCK(connection_write_to_buf_impl_, connection_write_to_buf_mock);
+
+  conn = dir_connection_new(tor_addr_family(&MOCK_TOR_ADDR));
+
+  /* Unrecognized path */
+  tt_int_op(directory_handle_command_get(conn, GET("/anything"), NULL, 0),
+            OP_EQ, 0);
+  fetch_from_buf_http(TO_CONN(conn)->outbuf, &header, MAX_HEADERS_SIZE,
+                      NULL, NULL, 1, 0);
+
+  tt_str_op(NOT_FOUND, OP_EQ, header);
+
+  done:
+    UNMOCK(connection_write_to_buf_impl_);
+    connection_free_(TO_CONN(conn));
+    tor_free(header);
+}
+
+static void
+test_dir_handle_get_robots_txt(void *data)
+{
+  dir_connection_t *conn = NULL;
+  char *header = NULL;
+  char *body = NULL;
+  size_t body_used = 0;
+  (void) data;
+
+  MOCK(connection_write_to_buf_impl_, connection_write_to_buf_mock);
+
+  conn = dir_connection_new(tor_addr_family(&MOCK_TOR_ADDR));
+
+  tt_int_op(directory_handle_command_get(conn, GET("/tor/robots.txt"),
+                                         NULL, 0), OP_EQ, 0);
+  fetch_from_buf_http(TO_CONN(conn)->outbuf, &header, MAX_HEADERS_SIZE,
+                      &body, &body_used, 29, 0);
+
+  tt_assert(header);
+  tt_assert(body);
+
+  tt_ptr_op(strstr(header, "HTTP/1.0 200 OK\r\n"), OP_EQ, header);
+  tt_assert(strstr(header, "Content-Type: text/plain\r\n"));
+  tt_assert(strstr(header, "Content-Encoding: identity\r\n"));
+  tt_assert(strstr(header, "Content-Length: 28\r\n"));
+
+  tt_int_op(body_used, OP_EQ, strlen(body));
+  tt_str_op(body, OP_EQ, "User-agent: *\r\nDisallow: /\r\n");
+
+  done:
+    UNMOCK(connection_write_to_buf_impl_);
+    connection_free_(TO_CONN(conn));
+    tor_free(header);
+    tor_free(body);
+}
+
+static void
+test_dir_handle_get_bytes_txt(void *data)
+{
+  dir_connection_t *conn = NULL;
+  char *header = NULL;
+  char *body = NULL;
+  size_t body_used = 0, body_len = 0;
+  char buff[30];
+  char *exp_body = NULL;
+  (void) data;
+
+  exp_body = directory_dump_request_log();
+  body_len = strlen(exp_body);
+
+  MOCK(connection_write_to_buf_impl_, connection_write_to_buf_mock);
+
+  conn = dir_connection_new(tor_addr_family(&MOCK_TOR_ADDR));
+
+  tt_int_op(directory_handle_command_get(conn, GET("/tor/bytes.txt"), NULL, 0),
+            OP_EQ, 0);
+  fetch_from_buf_http(TO_CONN(conn)->outbuf, &header, MAX_HEADERS_SIZE,
+                      &body, &body_used, body_len+1, 0);
+
+  tt_assert(header);
+  tt_assert(body);
+
+  tt_ptr_op(strstr(header, "HTTP/1.0 200 OK\r\n"), OP_EQ, header);
+  tt_assert(strstr(header, "Content-Type: text/plain\r\n"));
+  tt_assert(strstr(header, "Content-Encoding: identity\r\n"));
+  tt_assert(strstr(header, "Pragma: no-cache\r\n"));
+
+  sprintf(buff, "Content-Length: %ld\r\n", (long) body_len);
+  tt_assert(strstr(header, buff));
+
+  tt_int_op(body_used, OP_EQ, strlen(body));
+  tt_str_op(body, OP_EQ, exp_body);
+
+  done:
+    UNMOCK(connection_write_to_buf_impl_);
+    connection_free_(TO_CONN(conn));
+    tor_free(header);
+    tor_free(body);
+    tor_free(exp_body);
+}
+
+#define RENDEZVOUS2_GET(descid) GET("/tor/rendezvous2/" descid)
+static void
+test_dir_handle_get_rendezvous2_not_found_if_not_encrypted(void *data)
+{
+  dir_connection_t *conn = NULL;
+  char *header = NULL;
+  (void) data;
+
+  MOCK(connection_write_to_buf_impl_, connection_write_to_buf_mock);
+
+  conn = dir_connection_new(tor_addr_family(&MOCK_TOR_ADDR));
+
+  // connection is not encrypted
+  tt_assert(!connection_dir_is_encrypted(conn))
+
+  tt_int_op(directory_handle_command_get(conn, RENDEZVOUS2_GET(), NULL, 0),
+            OP_EQ, 0);
+  fetch_from_buf_http(TO_CONN(conn)->outbuf, &header, MAX_HEADERS_SIZE,
+                      NULL, NULL, 1, 0);
+
+  tt_str_op(NOT_FOUND, OP_EQ, header);
+
+  done:
+    UNMOCK(connection_write_to_buf_impl_);
+    connection_free_(TO_CONN(conn));
+    tor_free(header);
+}
+
+static void
+test_dir_handle_get_rendezvous2_on_encrypted_conn_with_invalid_desc_id(
+  void *data)
+{
+  dir_connection_t *conn = NULL;
+  char *header = NULL;
+  (void) data;
+
+  MOCK(connection_write_to_buf_impl_, connection_write_to_buf_mock);
+  conn = dir_connection_new(tor_addr_family(&MOCK_TOR_ADDR));
+
+  // connection is encrypted
+  TO_CONN(conn)->linked = 1;
+  tt_assert(connection_dir_is_encrypted(conn));
+
+  tt_int_op(directory_handle_command_get(conn,
+            RENDEZVOUS2_GET("invalid-desc-id"), NULL, 0), OP_EQ, 0);
+  fetch_from_buf_http(TO_CONN(conn)->outbuf, &header, MAX_HEADERS_SIZE,
+                      NULL, NULL, 1, 0);
+
+  tt_str_op(header, OP_EQ, BAD_REQUEST);
+
+  done:
+    UNMOCK(connection_write_to_buf_impl_);
+    connection_free_(TO_CONN(conn));
+    tor_free(header);
+}
+
+static void
+test_dir_handle_get_rendezvous2_on_encrypted_conn_not_well_formed(void *data)
+{
+  dir_connection_t *conn = NULL;
+  char *header = NULL;
+  (void) data;
+
+  MOCK(connection_write_to_buf_impl_, connection_write_to_buf_mock);
+  conn = dir_connection_new(tor_addr_family(&MOCK_TOR_ADDR));
+
+  // connection is encrypted
+  TO_CONN(conn)->linked = 1;
+  tt_assert(connection_dir_is_encrypted(conn));
+
+  //TODO: this cant be reached because rend_valid_descriptor_id() prevents this
+  //case to happen. This test is the same as
+  //test_dir_handle_get_rendezvous2_on_encrypted_conn_with_invalid_desc_id
+  //We should refactor to remove the case from the switch.
+
+  const char *req = RENDEZVOUS2_GET("1bababababababababababababababab");
+  tt_int_op(directory_handle_command_get(conn, req, NULL, 0), OP_EQ, 0);
+
+  fetch_from_buf_http(TO_CONN(conn)->outbuf, &header, MAX_HEADERS_SIZE,
+                      NULL, NULL, 1, 0);
+
+  tt_str_op(header, OP_EQ, BAD_REQUEST);
+
+  done:
+    UNMOCK(connection_write_to_buf_impl_);
+    connection_free_(TO_CONN(conn));
+    tor_free(header);
+}
+
+static void
+test_dir_handle_get_rendezvous2_not_found(void *data)
+{
+  dir_connection_t *conn = NULL;
+  char *header = NULL;
+  (void) data;
+
+  MOCK(connection_write_to_buf_impl_, connection_write_to_buf_mock);
+  conn = dir_connection_new(tor_addr_family(&MOCK_TOR_ADDR));
+
+  rend_cache_init();
+
+  // connection is encrypted
+  TO_CONN(conn)->linked = 1;
+  tt_assert(connection_dir_is_encrypted(conn));
+
+  const char *req = RENDEZVOUS2_GET("3xqunszqnaolrrfmtzgaki7mxelgvkje");
+  tt_int_op(directory_handle_command_get(conn, req, NULL, 0), OP_EQ, 0);
+  fetch_from_buf_http(TO_CONN(conn)->outbuf, &header, MAX_HEADERS_SIZE,
+                      NULL, NULL, 1, 0);
+
+  tt_str_op(NOT_FOUND, OP_EQ, header);
+
+  done:
+    UNMOCK(connection_write_to_buf_impl_);
+    connection_free_(TO_CONN(conn));
+    tor_free(header);
+    rend_cache_free_all();
+}
+
+NS_DECL(const routerinfo_t *, router_get_my_routerinfo, (void));
+NS_DECL(int, hid_serv_responsible_for_desc_id, (const char *id));
+
+static routerinfo_t *mock_routerinfo;
+static int hid_serv_responsible_for_desc_id_response;
+
+static const routerinfo_t *
+NS(router_get_my_routerinfo)(void)
+{
+  if (!mock_routerinfo) {
+    mock_routerinfo = tor_malloc_zero(sizeof(routerinfo_t));
+  }
+
+  return mock_routerinfo;
+}
+
+static int
+NS(hid_serv_responsible_for_desc_id)(const char *id)
+{
+  (void)id;
+  return hid_serv_responsible_for_desc_id_response;
+}
+
+static void
+test_dir_handle_get_rendezvous2_on_encrypted_conn_success(void *data)
+{
+  dir_connection_t *conn = NULL;
+  char *header = NULL;
+  char *body = NULL;
+  size_t body_used = 0;
+  char buff[30];
+  char req[70];
+  rend_encoded_v2_service_descriptor_t *desc_holder = NULL;
+  char *service_id = NULL;
+  char desc_id_base32[REND_DESC_ID_V2_LEN_BASE32 + 1];
+  size_t body_len = 0;
+  (void) data;
+
+  MOCK(connection_write_to_buf_impl_, connection_write_to_buf_mock);
+  NS_MOCK(router_get_my_routerinfo);
+  NS_MOCK(hid_serv_responsible_for_desc_id);
+
+  rend_cache_init();
+  hid_serv_responsible_for_desc_id_response = 1;
+
+  /* create a valid rend service descriptor */
+  #define RECENT_TIME -10
+  generate_desc(RECENT_TIME, &desc_holder, &service_id, 3);
+
+  tt_int_op(rend_cache_store_v2_desc_as_dir(desc_holder->desc_str),
+            OP_EQ, RCS_OKAY);
+
+  base32_encode(desc_id_base32, sizeof(desc_id_base32), desc_holder->desc_id,
+                DIGEST_LEN);
+
+  conn = dir_connection_new(tor_addr_family(&MOCK_TOR_ADDR));
+
+  // connection is encrypted
+  TO_CONN(conn)->linked = 1;
+  tt_assert(connection_dir_is_encrypted(conn));
+
+  sprintf(req, RENDEZVOUS2_GET("%s"), desc_id_base32);
+
+  tt_int_op(directory_handle_command_get(conn, req, NULL, 0), OP_EQ, 0);
+
+  body_len = strlen(desc_holder->desc_str);
+  fetch_from_buf_http(TO_CONN(conn)->outbuf, &header, MAX_HEADERS_SIZE,
+                      &body, &body_used, body_len+1, 0);
+
+  tt_assert(header);
+  tt_assert(body);
+
+  tt_ptr_op(strstr(header, "HTTP/1.0 200 OK\r\n"), OP_EQ, header);
+  tt_assert(strstr(header, "Content-Type: text/plain\r\n"));
+  tt_assert(strstr(header, "Content-Encoding: identity\r\n"));
+  tt_assert(strstr(header, "Pragma: no-cache\r\n"));
+  sprintf(buff, "Content-Length: %ld\r\n", (long) body_len);
+  tt_assert(strstr(header, buff));
+
+  tt_int_op(body_used, OP_EQ, strlen(body));
+  tt_str_op(body, OP_EQ, desc_holder->desc_str);
+
+  done:
+    UNMOCK(connection_write_to_buf_impl_);
+    NS_UNMOCK(router_get_my_routerinfo);
+    NS_UNMOCK(hid_serv_responsible_for_desc_id);
+    tor_free(mock_routerinfo->cache_info.signed_descriptor_body);
+    tor_free(mock_routerinfo);
+
+    connection_free_(TO_CONN(conn));
+    tor_free(header);
+    tor_free(body);
+    rend_encoded_v2_service_descriptor_free(desc_holder);
+    tor_free(service_id);
+    rend_cache_free_all();
+}
+
+#define MICRODESC_GET(digest) GET("/tor/micro/d/" digest)
+static void
+test_dir_handle_get_micro_d_not_found(void *data)
+{
+  dir_connection_t *conn = NULL;
+  char *header = NULL;
+  (void) data;
+
+  MOCK(connection_write_to_buf_impl_, connection_write_to_buf_mock);
+
+  #define B64_256_1 "8/Pz8/u7vz8/Pz+7vz8/Pz+7u/Pz8/P7u/Pz8/P7u78"
+  #define B64_256_2 "zMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMw"
+  conn = dir_connection_new(tor_addr_family(&MOCK_TOR_ADDR));
+
+  const char *req = MICRODESC_GET(B64_256_1 "-" B64_256_2);
+  tt_int_op(directory_handle_command_get(conn, req, NULL, 0), OP_EQ, 0);
+
+  fetch_from_buf_http(TO_CONN(conn)->outbuf, &header, MAX_HEADERS_SIZE,
+                      NULL, NULL, 1, 0);
+
+  tt_str_op(NOT_FOUND, OP_EQ, header);
+
+  done:
+    UNMOCK(connection_write_to_buf_impl_);
+
+    connection_free_(TO_CONN(conn));
+    tor_free(header);
+}
+
+static or_options_t *mock_options = NULL;
+static void
+init_mock_options(void)
+{
+  mock_options = malloc(sizeof(or_options_t));
+  memset(mock_options, 0, sizeof(or_options_t));
+  mock_options->TestingTorNetwork = 1;
+}
+
+static const or_options_t *
+mock_get_options(void)
+{
+  tor_assert(mock_options);
+  return mock_options;
+}
+
+static const char microdesc[] =
+  "onion-key\n"
+  "-----BEGIN RSA PUBLIC KEY-----\n"
+  "MIGJAoGBAMjlHH/daN43cSVRaHBwgUfnszzAhg98EvivJ9Qxfv51mvQUxPjQ07es\n"
+  "gV/3n8fyh3Kqr/ehi9jxkdgSRfSnmF7giaHL1SLZ29kA7KtST+pBvmTpDtHa3ykX\n"
+  "Xorc7hJvIyTZoc1HU+5XSynj3gsBE5IGK1ZRzrNS688LnuZMVp1tAgMBAAE=\n"
+  "-----END RSA PUBLIC KEY-----\n";
+
+static void
+test_dir_handle_get_micro_d(void *data)
+{
+  dir_connection_t *conn = NULL;
+  microdesc_cache_t *mc = NULL ;
+  smartlist_t *list = NULL;
+  char digest[DIGEST256_LEN];
+  char digest_base64[128];
+  char path[80];
+  char *header = NULL;
+  char *body = NULL;
+  size_t body_used = 0;
+  (void) data;
+
+  MOCK(get_options, mock_get_options);
+  MOCK(connection_write_to_buf_impl_, connection_write_to_buf_mock);
+
+  /* SETUP */
+  init_mock_options();
+  const char *fn = get_fname("dir_handle_datadir_test1");
+  mock_options->DataDirectory = tor_strdup(fn);
+
+#ifdef _WIN32
+  tt_int_op(0, OP_EQ, mkdir(mock_options->DataDirectory));
+#else
+  tt_int_op(0, OP_EQ, mkdir(mock_options->DataDirectory, 0700));
+#endif
+
+  /* Add microdesc to cache */
+  crypto_digest256(digest, microdesc, strlen(microdesc), DIGEST_SHA256);
+  base64_encode_nopad(digest_base64, sizeof(digest_base64),
+                      (uint8_t *) digest, DIGEST256_LEN);
+
+  mc = get_microdesc_cache();
+  list = microdescs_add_to_cache(mc, microdesc, NULL, SAVED_NOWHERE, 0,
+                                  time(NULL), NULL);
+  tt_int_op(1, OP_EQ, smartlist_len(list));
+
+  /* Make the request */
+  conn = dir_connection_new(tor_addr_family(&MOCK_TOR_ADDR));
+
+  sprintf(path, MICRODESC_GET("%s"), digest_base64);
+  tt_int_op(directory_handle_command_get(conn, path, NULL, 0), OP_EQ, 0);
+
+  fetch_from_buf_http(TO_CONN(conn)->outbuf, &header, MAX_HEADERS_SIZE,
+                      &body, &body_used, strlen(microdesc)+1, 0);
+
+  tt_assert(header);
+  tt_assert(body);
+
+  tt_ptr_op(strstr(header, "HTTP/1.0 200 OK\r\n"), OP_EQ, header);
+  tt_assert(strstr(header, "Content-Type: text/plain\r\n"));
+  tt_assert(strstr(header, "Content-Encoding: identity\r\n"));
+
+  tt_int_op(body_used, OP_EQ, strlen(body));
+  tt_str_op(body, OP_EQ, microdesc);
+
+  done:
+    UNMOCK(get_options);
+    UNMOCK(connection_write_to_buf_impl_);
+
+    or_options_free(mock_options); mock_options = NULL;
+    connection_free_(TO_CONN(conn));
+    tor_free(header);
+    tor_free(body);
+    smartlist_free(list);
+    microdesc_free_all();
+}
+
+static void
+test_dir_handle_get_micro_d_server_busy(void *data)
+{
+  dir_connection_t *conn = NULL;
+  microdesc_cache_t *mc = NULL ;
+  smartlist_t *list = NULL;
+  char digest[DIGEST256_LEN];
+  char digest_base64[128];
+  char path[80];
+  char *header = NULL;
+  (void) data;
+
+  MOCK(get_options, mock_get_options);
+  MOCK(connection_write_to_buf_impl_, connection_write_to_buf_mock);
+
+  /* SETUP */
+  init_mock_options();
+  const char *fn = get_fname("dir_handle_datadir_test2");
+  mock_options->DataDirectory = tor_strdup(fn);
+
+#ifdef _WIN32
+  tt_int_op(0, OP_EQ, mkdir(mock_options->DataDirectory));
+#else
+  tt_int_op(0, OP_EQ, mkdir(mock_options->DataDirectory, 0700));
+#endif
+
+  /* Add microdesc to cache */
+  crypto_digest256(digest, microdesc, strlen(microdesc), DIGEST_SHA256);
+  base64_encode_nopad(digest_base64, sizeof(digest_base64),
+                      (uint8_t *) digest, DIGEST256_LEN);
+
+  mc = get_microdesc_cache();
+  list = microdescs_add_to_cache(mc, microdesc, NULL, SAVED_NOWHERE, 0,
+                                  time(NULL), NULL);
+  tt_int_op(1, OP_EQ, smartlist_len(list));
+
+  //Make it busy
+  mock_options->CountPrivateBandwidth = 1;
+
+  /* Make the request */
+  conn = dir_connection_new(tor_addr_family(&MOCK_TOR_ADDR));
+
+  sprintf(path, MICRODESC_GET("%s"), digest_base64);
+  tt_int_op(directory_handle_command_get(conn, path, NULL, 0), OP_EQ, 0);
+
+  fetch_from_buf_http(TO_CONN(conn)->outbuf, &header, MAX_HEADERS_SIZE,
+                      NULL, NULL, 1, 0);
+
+  tt_str_op(SERVER_BUSY, OP_EQ, header);
+
+  done:
+    UNMOCK(get_options);
+    UNMOCK(connection_write_to_buf_impl_);
+
+    or_options_free(mock_options); mock_options = NULL;
+    connection_free_(TO_CONN(conn));
+    tor_free(header);
+    smartlist_free(list);
+    microdesc_free_all();
+}
+
+#define BRIDGES_PATH "/tor/networkstatus-bridges"
+static void
+test_dir_handle_get_networkstatus_bridges_not_found_without_auth(void *data)
+{
+  dir_connection_t *conn = NULL;
+  char *header = NULL;
+  (void) data;
+
+  MOCK(get_options, mock_get_options);
+  MOCK(connection_write_to_buf_impl_, connection_write_to_buf_mock);
+
+  /* SETUP */
+  init_mock_options();
+  mock_options->BridgeAuthoritativeDir = 1;
+  mock_options->BridgePassword_AuthDigest_ = tor_strdup("digest");
+
+  conn = dir_connection_new(tor_addr_family(&MOCK_TOR_ADDR));
+  TO_CONN(conn)->linked = 1;
+
+  const char *req = GET(BRIDGES_PATH);
+  tt_int_op(directory_handle_command_get(conn, req, NULL, 0), OP_EQ, 0);
+
+  fetch_from_buf_http(TO_CONN(conn)->outbuf, &header, MAX_HEADERS_SIZE,
+                      NULL, NULL, 1, 0);
+
+  tt_str_op(NOT_FOUND, OP_EQ, header);
+
+  done:
+    UNMOCK(get_options);
+    UNMOCK(connection_write_to_buf_impl_);
+    or_options_free(mock_options); mock_options = NULL;
+    connection_free_(TO_CONN(conn));
+    tor_free(header);
+}
+
+static void
+test_dir_handle_get_networkstatus_bridges(void *data)
+{
+  dir_connection_t *conn = NULL;
+  char *header = NULL;
+  (void) data;
+
+  MOCK(get_options, mock_get_options);
+  MOCK(connection_write_to_buf_impl_, connection_write_to_buf_mock);
+
+  /* SETUP */
+  init_mock_options();
+  mock_options->BridgeAuthoritativeDir = 1;
+  mock_options->BridgePassword_AuthDigest_ = tor_malloc(DIGEST256_LEN);
+  crypto_digest256(mock_options->BridgePassword_AuthDigest_,
+                     "abcdefghijklm12345", 18, DIGEST_SHA256);
+
+  conn = dir_connection_new(tor_addr_family(&MOCK_TOR_ADDR));
+  TO_CONN(conn)->linked = 1;
+
+  const char *req = "GET " BRIDGES_PATH " HTTP/1.0\r\n"
+                    "Authorization: Basic abcdefghijklm12345\r\n\r\n";
+  tt_int_op(directory_handle_command_get(conn, req, NULL, 0), OP_EQ, 0);
+
+  fetch_from_buf_http(TO_CONN(conn)->outbuf, &header, MAX_HEADERS_SIZE,
+                      NULL, NULL, 1, 0);
+
+  tt_ptr_op(strstr(header, "HTTP/1.0 200 OK\r\n"), OP_EQ, header);
+  tt_assert(strstr(header, "Content-Type: text/plain\r\n"));
+  tt_assert(strstr(header, "Content-Encoding: identity\r\n"));
+  tt_assert(strstr(header, "Content-Length: 0\r\n"));
+
+  done:
+    UNMOCK(get_options);
+    UNMOCK(connection_write_to_buf_impl_);
+    or_options_free(mock_options); mock_options = NULL;
+    connection_free_(TO_CONN(conn));
+    tor_free(header);
+}
+
+static void
+test_dir_handle_get_networkstatus_bridges_not_found_wrong_auth(void *data)
+{
+  dir_connection_t *conn = NULL;
+  char *header = NULL;
+  (void) data;
+
+  MOCK(get_options, mock_get_options);
+  MOCK(connection_write_to_buf_impl_, connection_write_to_buf_mock);
+
+  /* SETUP */
+  init_mock_options();
+  mock_options->BridgeAuthoritativeDir = 1;
+  mock_options->BridgePassword_AuthDigest_ = tor_malloc(DIGEST256_LEN);
+  crypto_digest256(mock_options->BridgePassword_AuthDigest_,
+                     "abcdefghijklm12345", 18, DIGEST_SHA256);
+
+  conn = dir_connection_new(tor_addr_family(&MOCK_TOR_ADDR));
+  TO_CONN(conn)->linked = 1;
+
+  const char *req = "GET " BRIDGES_PATH " HTTP/1.0\r\n"
+                           "Authorization: Basic NOTSAMEDIGEST\r\n\r\n";
+  tt_int_op(directory_handle_command_get(conn, req, NULL, 0), OP_EQ, 0);
+
+  fetch_from_buf_http(TO_CONN(conn)->outbuf, &header, MAX_HEADERS_SIZE,
+                      NULL, NULL, 1, 0);
+
+  tt_str_op(NOT_FOUND, OP_EQ, header);
+
+  done:
+    UNMOCK(get_options);
+    UNMOCK(connection_write_to_buf_impl_);
+    or_options_free(mock_options); mock_options = NULL;
+    connection_free_(TO_CONN(conn));
+    tor_free(header);
+}
+
+#define SERVER_DESC_GET(id) GET("/tor/server/" id)
+static void
+test_dir_handle_get_server_descriptors_not_found(void* data)
+{
+  dir_connection_t *conn = NULL;
+  char *header = NULL;
+  (void) data;
+
+  MOCK(connection_write_to_buf_impl_, connection_write_to_buf_mock);
+
+  conn = dir_connection_new(tor_addr_family(&MOCK_TOR_ADDR));
+
+  const char *req = SERVER_DESC_GET("invalid");
+  tt_int_op(directory_handle_command_get(conn, req, NULL, 0), OP_EQ, 0);
+
+  fetch_from_buf_http(TO_CONN(conn)->outbuf, &header, MAX_HEADERS_SIZE,
+                      NULL, NULL, 1, 0);
+
+  tt_str_op(NOT_FOUND, OP_EQ, header);
+  tt_int_op(conn->dir_spool_src, OP_EQ, DIR_SPOOL_SERVER_BY_FP);
+
+  done:
+    UNMOCK(connection_write_to_buf_impl_);
+    or_options_free(mock_options); mock_options = NULL;
+    connection_free_(TO_CONN(conn));
+    tor_free(header);
+}
+
+static void
+test_dir_handle_get_server_descriptors_all(void* data)
+{
+  dir_connection_t *conn = NULL;
+  char *header = NULL;
+  char *body = NULL;
+  size_t body_used = 0;
+  (void) data;
+
+  /* Setup fake routerlist. */
+  helper_setup_fake_routerlist();
+
+  //TODO: change to router_get_my_extrainfo when testing "extra" path
+  NS_MOCK(router_get_my_routerinfo);
+  MOCK(connection_write_to_buf_impl_, connection_write_to_buf_mock);
+
+  // We are one of the routers
+  routerlist_t *our_routerlist = router_get_routerlist();
+  tt_int_op(smartlist_len(our_routerlist->routers), OP_GE, 1);
+  mock_routerinfo = smartlist_get(our_routerlist->routers, 0);
+  set_server_identity_key(mock_routerinfo->identity_pkey);
+
+  /* Treat "all" requests as if they were unencrypted */
+  mock_routerinfo->cache_info.send_unencrypted = 1;
+
+  conn = dir_connection_new(tor_addr_family(&MOCK_TOR_ADDR));
+
+  const char *req = SERVER_DESC_GET("all");
+  tt_int_op(directory_handle_command_get(conn, req, NULL, 0), OP_EQ, 0);
+
+  //TODO: Is this a BUG?
+  //It requires strlen(signed_descriptor_len)+1 as body_len but returns a body
+  //which is smaller than that by annotation_len bytes
+  fetch_from_buf_http(TO_CONN(conn)->outbuf, &header, MAX_HEADERS_SIZE,
+                      &body, &body_used,
+                      mock_routerinfo->cache_info.signed_descriptor_len+1, 0);
+
+  tt_assert(header);
+  tt_assert(body);
+
+  tt_ptr_op(strstr(header, "HTTP/1.0 200 OK\r\n"), OP_EQ, header);
+  tt_assert(strstr(header, "Content-Type: text/plain\r\n"));
+  tt_assert(strstr(header, "Content-Encoding: identity\r\n"));
+
+  //TODO: Is this a BUG?
+  //This is what should be expected: tt_int_op(body_used, OP_EQ, strlen(body));
+  tt_int_op(body_used, OP_EQ,
+            mock_routerinfo->cache_info.signed_descriptor_len);
+
+  tt_str_op(body, OP_EQ, mock_routerinfo->cache_info.signed_descriptor_body +
+                         mock_routerinfo->cache_info.annotations_len);
+  tt_int_op(conn->dir_spool_src, OP_EQ, DIR_SPOOL_NONE);
+
+  done:
+    NS_UNMOCK(router_get_my_routerinfo);
+    UNMOCK(connection_write_to_buf_impl_);
+    connection_free_(TO_CONN(conn));
+    tor_free(header);
+    tor_free(body);
+
+    routerlist_free_all();
+    nodelist_free_all();
+    entry_guards_free_all();
+}
+
+static char
+TEST_DESCRIPTOR[] =
+"@uploaded-at 2014-06-08 19:20:11\n"
+"@source \"127.0.0.1\"\n"
+"router test000a 127.0.0.1 5000 0 7000\n"
+"platform Tor 0.2.5.3-alpha-dev on Linux\n"
+"protocols Link 1 2 Circuit 1\n"
+"published 2014-06-08 19:20:11\n"
+"fingerprint C7E7 CCB8 179F 8CC3 7F5C 8A04 2B3A 180B 934B 14BA\n"
+"uptime 0\n"
+"bandwidth 1073741824 1073741824 0\n"
+"extra-info-digest 67A152A4C7686FB07664F872620635F194D76D95\n"
+"caches-extra-info\n"
+"onion-key\n"
+"-----BEGIN RSA PUBLIC KEY-----\n"
+"MIGJAoGBAOuBUIEBARMkkka/TGyaQNgUEDLP0KG7sy6KNQTNOlZHUresPr/vlVjo\n"
+"HPpLMfu9M2z18c51YX/muWwY9x4MyQooD56wI4+AqXQcJRwQfQlPn3Ay82uZViA9\n"
+"DpBajRieLlKKkl145KjArpD7F5BVsqccvjErgFYXvhhjSrx7BVLnAgMBAAE=\n"
+"-----END RSA PUBLIC KEY-----\n"
+"signing-key\n"
+"-----BEGIN RSA PUBLIC KEY-----\n"
+"MIGJAoGBAN6NLnSxWQnFXxqZi5D3b0BMgV6y9NJLGjYQVP+eWtPZWgqyv4zeYsqv\n"
+"O9y6c5lvxyUxmNHfoAbe/s8f2Vf3/YaC17asAVSln4ktrr3e9iY74a9RMWHv1Gzk\n"
+"3042nMcqj3PEhRN0PoLkcOZNjjmNbaqki6qy9bWWZDNTdo+uI44dAgMBAAE=\n"
+"-----END RSA PUBLIC KEY-----\n"
+"hidden-service-dir\n"
+"contact auth0@test.test\n"
+"ntor-onion-key pK4bs08ERYN591jj7ca17Rn9Q02TIEfhnjR6hSq+fhU=\n"
+"reject *:*\n"
+"router-signature\n"
+"-----BEGIN SIGNATURE-----\n"
+"rx88DuM3Y7tODlHNDDEVzKpwh3csaG1or+T4l2Xs1oq3iHHyPEtB6QTLYrC60trG\n"
+"aAPsj3DEowGfjga1b248g2dtic8Ab+0exfjMm1RHXfDam5TXXZU3A0wMyoHjqHuf\n"
+"eChGPgFNUvEc+5YtD27qEDcUjcinYztTs7/dzxBT4PE=\n"
+"-----END SIGNATURE-----\n";
+
+static void
+test_dir_handle_get_server_descriptors_authority(void* data)
+{
+  dir_connection_t *conn = NULL;
+  char *header = NULL;
+  char *body = NULL;
+  size_t body_used = 0;
+  crypto_pk_t *identity_pkey = pk_generate(0);
+  (void) data;
+
+  NS_MOCK(router_get_my_routerinfo);
+  MOCK(connection_write_to_buf_impl_, connection_write_to_buf_mock);
+
+  /* init mock */
+  router_get_my_routerinfo();
+  crypto_pk_get_digest(identity_pkey,
+                       mock_routerinfo->cache_info.identity_digest);
+
+  // the digest is mine (the channel is unnecrypted, so we must allow sending)
+  set_server_identity_key(identity_pkey);
+  mock_routerinfo->cache_info.send_unencrypted = 1;
+
+  /* Setup descriptor */
+  long annotation_len = strstr(TEST_DESCRIPTOR, "router ") - TEST_DESCRIPTOR;
+  mock_routerinfo->cache_info.signed_descriptor_body =
+    tor_strdup(TEST_DESCRIPTOR);
+  mock_routerinfo->cache_info.signed_descriptor_len =
+    strlen(TEST_DESCRIPTOR) - annotation_len;;
+  mock_routerinfo->cache_info.annotations_len = annotation_len;
+
+  conn = dir_connection_new(tor_addr_family(&MOCK_TOR_ADDR));
+
+  const char *req = SERVER_DESC_GET("authority");
+  tt_int_op(directory_handle_command_get(conn, req, NULL, 0), OP_EQ, 0);
+
+  //TODO: Is this a BUG?
+  //It requires strlen(TEST_DESCRIPTOR)+1 as body_len but returns a body which
+  //is smaller than that by annotation_len bytes
+  fetch_from_buf_http(TO_CONN(conn)->outbuf, &header, MAX_HEADERS_SIZE,
+                      &body, &body_used, strlen(TEST_DESCRIPTOR)+1, 0);
+
+  tt_assert(header);
+  tt_assert(body);
+
+  tt_ptr_op(strstr(header, "HTTP/1.0 200 OK\r\n"), OP_EQ, header);
+  tt_assert(strstr(header, "Content-Type: text/plain\r\n"));
+  tt_assert(strstr(header, "Content-Encoding: identity\r\n"));
+
+  tt_int_op(body_used, OP_EQ, strlen(body));
+
+  tt_str_op(body, OP_EQ, TEST_DESCRIPTOR + annotation_len);
+  tt_int_op(conn->dir_spool_src, OP_EQ, DIR_SPOOL_NONE);
+
+  done:
+    NS_UNMOCK(router_get_my_routerinfo);
+    UNMOCK(connection_write_to_buf_impl_);
+    tor_free(mock_routerinfo->cache_info.signed_descriptor_body);
+    tor_free(mock_routerinfo);
+    connection_free_(TO_CONN(conn));
+    tor_free(header);
+    tor_free(body);
+    crypto_pk_free(identity_pkey);
+}
+
+static void
+test_dir_handle_get_server_descriptors_fp(void* data)
+{
+  dir_connection_t *conn = NULL;
+  char *header = NULL;
+  char *body = NULL;
+  size_t body_used = 0;
+  crypto_pk_t *identity_pkey = pk_generate(0);
+  (void) data;
+
+  NS_MOCK(router_get_my_routerinfo);
+  MOCK(connection_write_to_buf_impl_, connection_write_to_buf_mock);
+
+  /* init mock */
+  router_get_my_routerinfo();
+  crypto_pk_get_digest(identity_pkey,
+                       mock_routerinfo->cache_info.identity_digest);
+
+  // the digest is mine (the channel is unnecrypted, so we must allow sending)
+  set_server_identity_key(identity_pkey);
+  mock_routerinfo->cache_info.send_unencrypted = 1;
+
+  /* Setup descriptor */
+  long annotation_len = strstr(TEST_DESCRIPTOR, "router ") - TEST_DESCRIPTOR;
+  mock_routerinfo->cache_info.signed_descriptor_body =
+    tor_strdup(TEST_DESCRIPTOR);
+  mock_routerinfo->cache_info.signed_descriptor_len =
+    strlen(TEST_DESCRIPTOR) - annotation_len;
+  mock_routerinfo->cache_info.annotations_len = annotation_len;
+
+  conn = dir_connection_new(tor_addr_family(&MOCK_TOR_ADDR));
+
+  #define HEX1 "Fe0daff89127389bc67558691231234551193EEE"
+  #define HEX2 "Deadbeef99999991111119999911111111f00ba4"
+  const char *hex_digest = hex_str(mock_routerinfo->cache_info.identity_digest,
+                                   DIGEST_LEN);
+
+  char req[155];
+  sprintf(req, SERVER_DESC_GET("fp/%s+" HEX1 "+" HEX2), hex_digest);
+  tt_int_op(directory_handle_command_get(conn, req, NULL, 0), OP_EQ, 0);
+
+  //TODO: Is this a BUG?
+  //It requires strlen(TEST_DESCRIPTOR)+1 as body_len but returns a body which
+  //is smaller than that by annotation_len bytes
+  fetch_from_buf_http(TO_CONN(conn)->outbuf, &header, MAX_HEADERS_SIZE,
+                      &body, &body_used, strlen(TEST_DESCRIPTOR)+1, 0);
+
+  tt_assert(header);
+  tt_assert(body);
+
+  tt_ptr_op(strstr(header, "HTTP/1.0 200 OK\r\n"), OP_EQ, header);
+  tt_assert(strstr(header, "Content-Type: text/plain\r\n"));
+  tt_assert(strstr(header, "Content-Encoding: identity\r\n"));
+
+  tt_int_op(body_used, OP_EQ, strlen(body));
+
+  tt_str_op(body, OP_EQ, TEST_DESCRIPTOR + annotation_len);
+  tt_int_op(conn->dir_spool_src, OP_EQ, DIR_SPOOL_NONE);
+
+  done:
+    NS_UNMOCK(router_get_my_routerinfo);
+    UNMOCK(connection_write_to_buf_impl_);
+    tor_free(mock_routerinfo->cache_info.signed_descriptor_body);
+    tor_free(mock_routerinfo);
+    connection_free_(TO_CONN(conn));
+    tor_free(header);
+    tor_free(body);
+    crypto_pk_free(identity_pkey);
+}
+
+#define HEX1 "Fe0daff89127389bc67558691231234551193EEE"
+#define HEX2 "Deadbeef99999991111119999911111111f00ba4"
+
+static void
+test_dir_handle_get_server_descriptors_d(void* data)
+{
+  dir_connection_t *conn = NULL;
+  char *header = NULL;
+  char *body = NULL;
+  size_t body_used = 0;
+  crypto_pk_t *identity_pkey = pk_generate(0);
+  (void) data;
+
+  /* Setup fake routerlist. */
+  helper_setup_fake_routerlist();
+
+  MOCK(connection_write_to_buf_impl_, connection_write_to_buf_mock);
+
+  /* Get one router's signed_descriptor_digest */
+  routerlist_t *our_routerlist = router_get_routerlist();
+  tt_int_op(smartlist_len(our_routerlist->routers), OP_GE, 1);
+  routerinfo_t *router = smartlist_get(our_routerlist->routers, 0);
+  const char *hex_digest = hex_str(router->cache_info.signed_descriptor_digest,
+                                   DIGEST_LEN);
+
+  conn = dir_connection_new(tor_addr_family(&MOCK_TOR_ADDR));
+
+  char req_header[155];
+  sprintf(req_header, SERVER_DESC_GET("d/%s+" HEX1 "+" HEX2), hex_digest);
+  tt_int_op(directory_handle_command_get(conn, req_header, NULL, 0), OP_EQ, 0);
+
+  //TODO: Is this a BUG?
+  //It requires strlen(signed_descriptor_len)+1 as body_len but returns a body
+  //which is smaller than that by annotation_len bytes
+  fetch_from_buf_http(TO_CONN(conn)->outbuf, &header, MAX_HEADERS_SIZE,
+                      &body, &body_used,
+                      router->cache_info.signed_descriptor_len+1, 0);
+
+  tt_assert(header);
+  tt_assert(body);
+
+  tt_ptr_op(strstr(header, "HTTP/1.0 200 OK\r\n"), OP_EQ, header);
+  tt_assert(strstr(header, "Content-Type: text/plain\r\n"));
+  tt_assert(strstr(header, "Content-Encoding: identity\r\n"));
+
+  //TODO: Is this a BUG?
+  //This is what should be expected:
+  //tt_int_op(body_used, OP_EQ, strlen(body));
+  tt_int_op(body_used, OP_EQ, router->cache_info.signed_descriptor_len);
+
+  tt_str_op(body, OP_EQ, router->cache_info.signed_descriptor_body +
+                         router->cache_info.annotations_len);
+  tt_int_op(conn->dir_spool_src, OP_EQ, DIR_SPOOL_NONE);
+
+  done:
+    UNMOCK(connection_write_to_buf_impl_);
+    tor_free(mock_routerinfo);
+    connection_free_(TO_CONN(conn));
+    tor_free(header);
+    tor_free(body);
+    crypto_pk_free(identity_pkey);
+
+    routerlist_free_all();
+    nodelist_free_all();
+    entry_guards_free_all();
+}
+
+static void
+test_dir_handle_get_server_descriptors_busy(void* data)
+{
+  dir_connection_t *conn = NULL;
+  char *header = NULL;
+  crypto_pk_t *identity_pkey = pk_generate(0);
+  (void) data;
+
+  /* Setup fake routerlist. */
+  helper_setup_fake_routerlist();
+
+  MOCK(connection_write_to_buf_impl_, connection_write_to_buf_mock);
+
+  //Make it busy
+  MOCK(get_options, mock_get_options);
+  init_mock_options();
+  mock_options->CountPrivateBandwidth = 1;
+
+  /* Get one router's signed_descriptor_digest */
+  routerlist_t *our_routerlist = router_get_routerlist();
+  tt_int_op(smartlist_len(our_routerlist->routers), OP_GE, 1);
+  routerinfo_t *router = smartlist_get(our_routerlist->routers, 0);
+  const char *hex_digest = hex_str(router->cache_info.signed_descriptor_digest,
+                                   DIGEST_LEN);
+
+  conn = dir_connection_new(tor_addr_family(&MOCK_TOR_ADDR));
+
+  #define HEX1 "Fe0daff89127389bc67558691231234551193EEE"
+  #define HEX2 "Deadbeef99999991111119999911111111f00ba4"
+  char req_header[155];
+  sprintf(req_header, SERVER_DESC_GET("d/%s+" HEX1 "+" HEX2), hex_digest);
+  tt_int_op(directory_handle_command_get(conn, req_header, NULL, 0), OP_EQ, 0);
+
+  fetch_from_buf_http(TO_CONN(conn)->outbuf, &header, MAX_HEADERS_SIZE,
+                      NULL, NULL, 1, 0);
+
+  tt_assert(header);
+  tt_str_op(SERVER_BUSY, OP_EQ, header);
+
+  tt_int_op(conn->dir_spool_src, OP_EQ, DIR_SPOOL_NONE);
+
+  done:
+    UNMOCK(get_options);
+    UNMOCK(connection_write_to_buf_impl_);
+    tor_free(mock_routerinfo);
+    connection_free_(TO_CONN(conn));
+    tor_free(header);
+    crypto_pk_free(identity_pkey);
+
+    routerlist_free_all();
+    nodelist_free_all();
+    entry_guards_free_all();
+}
+
+static void
+test_dir_handle_get_server_keys_bad_req(void* data)
+{
+  dir_connection_t *conn = NULL;
+  char *header = NULL;
+  (void) data;
+
+  MOCK(connection_write_to_buf_impl_, connection_write_to_buf_mock);
+
+  conn = dir_connection_new(tor_addr_family(&MOCK_TOR_ADDR));
+
+  const char *req = GET("/tor/keys/");
+  tt_int_op(directory_handle_command_get(conn, req, NULL, 0), OP_EQ, 0);
+
+  fetch_from_buf_http(TO_CONN(conn)->outbuf, &header, MAX_HEADERS_SIZE,
+                      NULL, NULL, 1, 0);
+
+  tt_assert(header);
+  tt_str_op(BAD_REQUEST, OP_EQ, header);
+
+  done:
+    UNMOCK(connection_write_to_buf_impl_);
+    connection_free_(TO_CONN(conn));
+    tor_free(header);
+}
+
+static void
+test_dir_handle_get_server_keys_all_not_found(void* data)
+{
+  dir_connection_t *conn = NULL;
+  char *header = NULL;
+  (void) data;
+
+  MOCK(connection_write_to_buf_impl_, connection_write_to_buf_mock);
+
+  conn = dir_connection_new(tor_addr_family(&MOCK_TOR_ADDR));
+
+  const char *req = GET("/tor/keys/all");
+  tt_int_op(directory_handle_command_get(conn, req, NULL, 0), OP_EQ, 0);
+
+  fetch_from_buf_http(TO_CONN(conn)->outbuf, &header, MAX_HEADERS_SIZE,
+                      NULL, NULL, 1, 0);
+
+  tt_assert(header);
+  tt_str_op(NOT_FOUND, OP_EQ, header);
+
+  done:
+    UNMOCK(connection_write_to_buf_impl_);
+    connection_free_(TO_CONN(conn));
+    tor_free(header);
+}
+
+#define TEST_CERTIFICATE AUTHORITY_CERT_3
+#define TEST_SIGNING_KEY AUTHORITY_SIGNKEY_A_DIGEST
+extern const char AUTHORITY_CERT_3[];
+extern const char AUTHORITY_SIGNKEY_A_DIGEST[];
+
+static const char TEST_CERT_IDENT_KEY[] =
+  "D867ACF56A9D229B35C25F0090BC9867E906BE69";
+
+static void
+test_dir_handle_get_server_keys_all(void* data)
+{
+  dir_connection_t *conn = NULL;
+  char *header = NULL;
+  char *body = NULL;
+  size_t body_used = 0;
+  const char digest[DIGEST_LEN] = "";
+
+  dir_server_t *ds = NULL;
+  (void) data;
+
+  MOCK(connection_write_to_buf_impl_, connection_write_to_buf_mock);
+
+  clear_dir_servers();
+  routerlist_free_all();
+
+  /* create a trusted ds */
+  ds = trusted_dir_server_new("ds", "127.0.0.1", 9059, 9060, NULL, digest,
+                              NULL, V3_DIRINFO, 1.0);
+  tt_assert(ds);
+  dir_server_add(ds);
+
+  /* ds v3_identity_digest is the certificate's identity_key */
+  base16_decode(ds->v3_identity_digest, DIGEST_LEN,
+                TEST_CERT_IDENT_KEY, HEX_DIGEST_LEN);
+  tt_int_op(0, OP_EQ, trusted_dirs_load_certs_from_string(TEST_CERTIFICATE,
+    TRUSTED_DIRS_CERTS_SRC_DL_BY_ID_DIGEST, 1));
+
+  conn = dir_connection_new(tor_addr_family(&MOCK_TOR_ADDR));
+
+  const char *req = GET("/tor/keys/all");
+  tt_int_op(directory_handle_command_get(conn, req, NULL, 0), OP_EQ, 0);
+
+  fetch_from_buf_http(TO_CONN(conn)->outbuf, &header, MAX_HEADERS_SIZE,
+                      &body, &body_used, strlen(TEST_CERTIFICATE)+1, 0);
+
+  tt_assert(header);
+  tt_assert(body);
+
+  tt_ptr_op(strstr(header, "HTTP/1.0 200 OK\r\n"), OP_EQ, header);
+  tt_assert(strstr(header, "Content-Type: text/plain\r\n"));
+  tt_assert(strstr(header, "Content-Encoding: identity\r\n"));
+  tt_assert(strstr(header, "Content-Length: 1883\r\n"));
+
+  tt_str_op(TEST_CERTIFICATE, OP_EQ, body);
+
+  done:
+    UNMOCK(connection_write_to_buf_impl_);
+    connection_free_(TO_CONN(conn));
+    tor_free(header);
+    tor_free(body);
+
+    clear_dir_servers();
+    routerlist_free_all();
+}
+
+static void
+test_dir_handle_get_server_keys_authority_not_found(void* data)
+{
+  dir_connection_t *conn = NULL;
+  char *header = NULL;
+  (void) data;
+
+  MOCK(connection_write_to_buf_impl_, connection_write_to_buf_mock);
+
+  conn = dir_connection_new(tor_addr_family(&MOCK_TOR_ADDR));
+
+  const char *req = GET("/tor/keys/authority");
+  tt_int_op(directory_handle_command_get(conn, req, NULL, 0), OP_EQ, 0);
+
+  fetch_from_buf_http(TO_CONN(conn)->outbuf, &header, MAX_HEADERS_SIZE,
+                      NULL, NULL, 1, 0);
+
+  tt_assert(header);
+  tt_str_op(NOT_FOUND, OP_EQ, header);
+
+  done:
+    UNMOCK(connection_write_to_buf_impl_);
+    connection_free_(TO_CONN(conn));
+    tor_free(header);
+}
+
+static authority_cert_t * mock_cert = NULL;
+
+static authority_cert_t *
+get_my_v3_authority_cert_m(void)
+{
+  tor_assert(mock_cert);
+  return mock_cert;
+}
+
+static void
+test_dir_handle_get_server_keys_authority(void* data)
+{
+  dir_connection_t *conn = NULL;
+  char *header = NULL;
+  char *body = NULL;
+  size_t body_used = 0;
+  (void) data;
+
+  mock_cert = authority_cert_parse_from_string(TEST_CERTIFICATE, NULL);
+
+  MOCK(get_my_v3_authority_cert, get_my_v3_authority_cert_m);
+  MOCK(connection_write_to_buf_impl_, connection_write_to_buf_mock);
+
+  conn = dir_connection_new(tor_addr_family(&MOCK_TOR_ADDR));
+
+  const char *req = GET("/tor/keys/authority");
+  tt_int_op(directory_handle_command_get(conn, req, NULL, 0), OP_EQ, 0);
+
+  fetch_from_buf_http(TO_CONN(conn)->outbuf, &header, MAX_HEADERS_SIZE,
+                      &body, &body_used, strlen(TEST_CERTIFICATE)+1, 0);
+
+  tt_assert(header);
+  tt_assert(body);
+
+  tt_ptr_op(strstr(header, "HTTP/1.0 200 OK\r\n"), OP_EQ, header);
+  tt_assert(strstr(header, "Content-Type: text/plain\r\n"));
+  tt_assert(strstr(header, "Content-Encoding: identity\r\n"));
+  tt_assert(strstr(header, "Content-Length: 1883\r\n"));
+
+  tt_str_op(TEST_CERTIFICATE, OP_EQ, body);
+
+  done:
+    UNMOCK(get_my_v3_authority_cert);
+    UNMOCK(connection_write_to_buf_impl_);
+    connection_free_(TO_CONN(conn));
+    tor_free(header);
+    tor_free(body);
+    authority_cert_free(mock_cert); mock_cert = NULL;
+}
+
+static void
+test_dir_handle_get_server_keys_fp_not_found(void* data)
+{
+  dir_connection_t *conn = NULL;
+  char *header = NULL;
+  (void) data;
+
+  MOCK(connection_write_to_buf_impl_, connection_write_to_buf_mock);
+
+  conn = dir_connection_new(tor_addr_family(&MOCK_TOR_ADDR));
+
+  const char *req = GET("/tor/keys/fp/somehex");
+  tt_int_op(directory_handle_command_get(conn, req, NULL, 0), OP_EQ, 0);
+
+  fetch_from_buf_http(TO_CONN(conn)->outbuf, &header, MAX_HEADERS_SIZE,
+                      NULL, NULL, 1, 0);
+
+  tt_assert(header);
+  tt_str_op(NOT_FOUND, OP_EQ, header);
+
+  done:
+    UNMOCK(connection_write_to_buf_impl_);
+    connection_free_(TO_CONN(conn));
+    tor_free(header);
+}
+
+static void
+test_dir_handle_get_server_keys_fp(void* data)
+{
+  dir_connection_t *conn = NULL;
+  char *header = NULL;
+  char *body = NULL;
+  size_t body_used = 0;
+  dir_server_t *ds = NULL;
+  const char digest[DIGEST_LEN] = "";
+  (void) data;
+
+  MOCK(connection_write_to_buf_impl_, connection_write_to_buf_mock);
+
+  clear_dir_servers();
+  routerlist_free_all();
+
+  /* create a trusted ds */
+  ds = trusted_dir_server_new("ds", "127.0.0.1", 9059, 9060, NULL, digest,
+                              NULL, V3_DIRINFO, 1.0);
+  tt_assert(ds);
+  dir_server_add(ds);
+
+  /* ds v3_identity_digest is the certificate's identity_key */
+  base16_decode(ds->v3_identity_digest, DIGEST_LEN,
+                TEST_CERT_IDENT_KEY, HEX_DIGEST_LEN);
+
+  tt_int_op(0, OP_EQ, trusted_dirs_load_certs_from_string(TEST_CERTIFICATE,
+    TRUSTED_DIRS_CERTS_SRC_DL_BY_ID_DIGEST, 1));
+
+  conn = dir_connection_new(tor_addr_family(&MOCK_TOR_ADDR));
+  char req[71];
+  sprintf(req, GET("/tor/keys/fp/%s"), TEST_CERT_IDENT_KEY);
+  tt_int_op(directory_handle_command_get(conn, req, NULL, 0), OP_EQ, 0);
+
+  fetch_from_buf_http(TO_CONN(conn)->outbuf, &header, MAX_HEADERS_SIZE,
+                      &body, &body_used, strlen(TEST_CERTIFICATE)+1, 0);
+
+  tt_assert(header);
+  tt_assert(body);
+
+  tt_ptr_op(strstr(header, "HTTP/1.0 200 OK\r\n"), OP_EQ, header);
+  tt_assert(strstr(header, "Content-Type: text/plain\r\n"));
+  tt_assert(strstr(header, "Content-Encoding: identity\r\n"));
+  tt_assert(strstr(header, "Content-Length: 1883\r\n"));
+
+  tt_str_op(TEST_CERTIFICATE, OP_EQ, body);
+
+  done:
+    UNMOCK(connection_write_to_buf_impl_);
+    connection_free_(TO_CONN(conn));
+    tor_free(header);
+    tor_free(body);
+    clear_dir_servers();
+    routerlist_free_all();
+}
+
+static void
+test_dir_handle_get_server_keys_sk_not_found(void* data)
+{
+  dir_connection_t *conn = NULL;
+  char *header = NULL;
+  (void) data;
+
+  MOCK(connection_write_to_buf_impl_, connection_write_to_buf_mock);
+
+  conn = dir_connection_new(tor_addr_family(&MOCK_TOR_ADDR));
+
+  const char *req = GET("/tor/keys/sk/somehex");
+  tt_int_op(directory_handle_command_get(conn, req, NULL, 0), OP_EQ, 0);
+
+  fetch_from_buf_http(TO_CONN(conn)->outbuf, &header, MAX_HEADERS_SIZE,
+                      NULL, NULL, 1, 0);
+
+  tt_assert(header);
+  tt_str_op(NOT_FOUND, OP_EQ, header);
+
+  done:
+    UNMOCK(connection_write_to_buf_impl_);
+    connection_free_(TO_CONN(conn));
+    tor_free(header);
+}
+
+static void
+test_dir_handle_get_server_keys_sk(void* data)
+{
+  dir_connection_t *conn = NULL;
+  char *header = NULL;
+  char *body = NULL;
+  size_t body_used = 0;
+  (void) data;
+
+  mock_cert = authority_cert_parse_from_string(TEST_CERTIFICATE, NULL);
+  MOCK(get_my_v3_authority_cert, get_my_v3_authority_cert_m);
+  MOCK(connection_write_to_buf_impl_, connection_write_to_buf_mock);
+
+  clear_dir_servers();
+  routerlist_free_all();
+
+  tt_int_op(0, OP_EQ, trusted_dirs_load_certs_from_string(TEST_CERTIFICATE,
+    TRUSTED_DIRS_CERTS_SRC_DL_BY_ID_DIGEST, 1));
+
+  conn = dir_connection_new(tor_addr_family(&MOCK_TOR_ADDR));
+  char req[71];
+  sprintf(req, GET("/tor/keys/sk/%s"), TEST_SIGNING_KEY);
+  tt_int_op(directory_handle_command_get(conn, req, NULL, 0), OP_EQ, 0);
+
+  fetch_from_buf_http(TO_CONN(conn)->outbuf, &header, MAX_HEADERS_SIZE,
+                      &body, &body_used, strlen(TEST_CERTIFICATE)+1, 0);
+
+  tt_assert(header);
+  tt_assert(body);
+
+  tt_ptr_op(strstr(header, "HTTP/1.0 200 OK\r\n"), OP_EQ, header);
+  tt_assert(strstr(header, "Content-Type: text/plain\r\n"));
+  tt_assert(strstr(header, "Content-Encoding: identity\r\n"));
+  tt_assert(strstr(header, "Content-Length: 1883\r\n"));
+
+  tt_str_op(TEST_CERTIFICATE, OP_EQ, body);
+
+  done:
+    UNMOCK(get_my_v3_authority_cert);
+    UNMOCK(connection_write_to_buf_impl_);
+    connection_free_(TO_CONN(conn));
+    authority_cert_free(mock_cert); mock_cert = NULL;
+    tor_free(header);
+    tor_free(body);
+}
+
+static void
+test_dir_handle_get_server_keys_fpsk_not_found(void* data)
+{
+  dir_connection_t *conn = NULL;
+  char *header = NULL;
+  (void) data;
+
+  MOCK(connection_write_to_buf_impl_, connection_write_to_buf_mock);
+
+  conn = dir_connection_new(tor_addr_family(&MOCK_TOR_ADDR));
+
+  const char *req = GET("/tor/keys/fp-sk/somehex");
+  tt_int_op(directory_handle_command_get(conn, req, NULL, 0), OP_EQ, 0);
+
+  fetch_from_buf_http(TO_CONN(conn)->outbuf, &header, MAX_HEADERS_SIZE,
+                      NULL, NULL, 1, 0);
+
+  tt_assert(header);
+  tt_str_op(NOT_FOUND, OP_EQ, header);
+
+  done:
+    UNMOCK(connection_write_to_buf_impl_);
+    connection_free_(TO_CONN(conn));
+    tor_free(header);
+}
+
+static void
+test_dir_handle_get_server_keys_fpsk(void* data)
+{
+  dir_connection_t *conn = NULL;
+  char *header = NULL;
+  char *body = NULL;
+  size_t body_used = 0;
+  dir_server_t *ds = NULL;
+  const char digest[DIGEST_LEN] = "";
+  (void) data;
+
+  MOCK(connection_write_to_buf_impl_, connection_write_to_buf_mock);
+
+  clear_dir_servers();
+  routerlist_free_all();
+
+  /* create a trusted ds */
+  ds = trusted_dir_server_new("ds", "127.0.0.1", 9059, 9060, NULL, digest,
+                              NULL, V3_DIRINFO, 1.0);
+  tt_assert(ds);
+
+  /* ds v3_identity_digest is the certificate's identity_key */
+  base16_decode(ds->v3_identity_digest, DIGEST_LEN,
+                TEST_CERT_IDENT_KEY, HEX_DIGEST_LEN);
+  dir_server_add(ds);
+
+  tt_int_op(0, OP_EQ, trusted_dirs_load_certs_from_string(TEST_CERTIFICATE,
+    TRUSTED_DIRS_CERTS_SRC_DL_BY_ID_DIGEST, 1));
+
+  conn = dir_connection_new(tor_addr_family(&MOCK_TOR_ADDR));
+
+  char req[115];
+  sprintf(req, GET("/tor/keys/fp-sk/%s-%s"),
+          TEST_CERT_IDENT_KEY, TEST_SIGNING_KEY);
+
+  tt_int_op(directory_handle_command_get(conn, req, NULL, 0), OP_EQ, 0);
+
+  fetch_from_buf_http(TO_CONN(conn)->outbuf, &header, MAX_HEADERS_SIZE,
+                      &body, &body_used, strlen(TEST_CERTIFICATE)+1, 0);
+
+  tt_assert(header);
+  tt_assert(body);
+
+  tt_ptr_op(strstr(header, "HTTP/1.0 200 OK\r\n"), OP_EQ, header);
+  tt_assert(strstr(header, "Content-Type: text/plain\r\n"));
+  tt_assert(strstr(header, "Content-Encoding: identity\r\n"));
+  tt_assert(strstr(header, "Content-Length: 1883\r\n"));
+
+  tt_str_op(TEST_CERTIFICATE, OP_EQ, body);
+
+  done:
+    UNMOCK(connection_write_to_buf_impl_);
+    connection_free_(TO_CONN(conn));
+    tor_free(header);
+    tor_free(body);
+
+    clear_dir_servers();
+    routerlist_free_all();
+}
+
+static void
+test_dir_handle_get_server_keys_busy(void* data)
+{
+  dir_connection_t *conn = NULL;
+  char *header = NULL;
+  dir_server_t *ds = NULL;
+  const char digest[DIGEST_LEN] = "";
+  (void) data;
+
+  clear_dir_servers();
+  routerlist_free_all();
+
+  /* create a trusted ds */
+  ds = trusted_dir_server_new("ds", "127.0.0.1", 9059, 9060, NULL, digest,
+                              NULL, V3_DIRINFO, 1.0);
+  tt_assert(ds);
+
+  /* ds v3_identity_digest is the certificate's identity_key */
+  base16_decode(ds->v3_identity_digest, DIGEST_LEN,
+                TEST_CERT_IDENT_KEY, HEX_DIGEST_LEN);
+  dir_server_add(ds);
+
+  tt_int_op(0, OP_EQ, trusted_dirs_load_certs_from_string(TEST_CERTIFICATE,
+    TRUSTED_DIRS_CERTS_SRC_DL_BY_ID_DIGEST, 1));
+
+  MOCK(get_options, mock_get_options);
+  MOCK(connection_write_to_buf_impl_, connection_write_to_buf_mock);
+
+  /* setup busy server */
+  init_mock_options();
+  mock_options->CountPrivateBandwidth = 1;
+
+  conn = dir_connection_new(tor_addr_family(&MOCK_TOR_ADDR));
+  char req[71];
+  sprintf(req, GET("/tor/keys/fp/%s"), TEST_CERT_IDENT_KEY);
+  tt_int_op(directory_handle_command_get(conn, req, NULL, 0), OP_EQ, 0);
+
+  fetch_from_buf_http(TO_CONN(conn)->outbuf, &header, MAX_HEADERS_SIZE,
+                      NULL, NULL, 1, 0);
+
+  tt_assert(header);
+  tt_str_op(SERVER_BUSY, OP_EQ, header);
+
+  done:
+    UNMOCK(get_options);
+    UNMOCK(connection_write_to_buf_impl_);
+    connection_free_(TO_CONN(conn));
+    tor_free(header);
+    or_options_free(mock_options); mock_options = NULL;
+
+    clear_dir_servers();
+    routerlist_free_all();
+}
+
+static networkstatus_t *mock_ns_val = NULL;
+static networkstatus_t *
+mock_ns_get_by_flavor(consensus_flavor_t f)
+{
+  (void)f;
+  return mock_ns_val;
+}
+
+static void
+test_dir_handle_get_status_vote_current_consensus_ns_not_enough_sigs(void* d)
+{
+  dir_connection_t *conn = NULL;
+  char *header = NULL;
+  char *stats = NULL;
+  (void) d;
+
+  /* init mock */
+  mock_ns_val = tor_malloc_zero(sizeof(networkstatus_t));
+  mock_ns_val->flavor = FLAV_NS;
+  mock_ns_val->voters = smartlist_new();
+
+  /* init mock */
+  init_mock_options();
+
+  MOCK(get_options, mock_get_options);
+  MOCK(connection_write_to_buf_impl_, connection_write_to_buf_mock);
+  MOCK(networkstatus_get_latest_consensus_by_flavor, mock_ns_get_by_flavor);
+
+  /* start gathering stats */
+  mock_options->DirReqStatistics = 1;
+  geoip_dirreq_stats_init(time(NULL));
+
+  conn = dir_connection_new(tor_addr_family(&MOCK_TOR_ADDR));
+
+  tt_int_op(0, OP_EQ, directory_handle_command_get(conn,
+    GET("/tor/status-vote/current/consensus-ns/" HEX1 "+" HEX2), NULL, 0));
+
+  fetch_from_buf_http(TO_CONN(conn)->outbuf, &header, MAX_HEADERS_SIZE,
+                      NULL, NULL, 1, 0);
+
+  tt_assert(header);
+  tt_str_op(NOT_ENOUGH_CONSENSUS_SIGNATURES, OP_EQ, header);
+
+  stats = geoip_format_dirreq_stats(time(NULL));
+  tt_assert(stats);
+  tt_assert(strstr(stats, "not-enough-sigs=8"));
+
+  done:
+    UNMOCK(networkstatus_get_latest_consensus_by_flavor);
+    UNMOCK(connection_write_to_buf_impl_);
+    UNMOCK(get_options);
+
+    connection_free_(TO_CONN(conn));
+    tor_free(header);
+    tor_free(stats);
+    smartlist_free(mock_ns_val->voters);
+    tor_free(mock_ns_val);
+    or_options_free(mock_options); mock_options = NULL;
+}
+
+static void
+test_dir_handle_get_status_vote_current_consensus_ns_not_found(void* data)
+{
+  dir_connection_t *conn = NULL;
+  char *header = NULL;
+  char *stats = NULL;
+  (void) data;
+
+  init_mock_options();
+
+  MOCK(get_options, mock_get_options);
+  MOCK(connection_write_to_buf_impl_, connection_write_to_buf_mock);
+
+  /* start gathering stats */
+  mock_options->DirReqStatistics = 1;
+  geoip_dirreq_stats_init(time(NULL));
+
+  conn = dir_connection_new(tor_addr_family(&MOCK_TOR_ADDR));
+  tt_int_op(0, OP_EQ, directory_handle_command_get(conn,
+    GET("/tor/status-vote/current/consensus-ns"), NULL, 0));
+
+  fetch_from_buf_http(TO_CONN(conn)->outbuf, &header, MAX_HEADERS_SIZE,
+                      NULL, NULL, 1, 0);
+  tt_assert(header);
+  tt_str_op(NOT_FOUND, OP_EQ, header);
+
+  stats = geoip_format_dirreq_stats(time(NULL));
+  tt_assert(stats);
+  tt_assert(strstr(stats, "not-found=8"));
+
+  done:
+    UNMOCK(connection_write_to_buf_impl_);
+    UNMOCK(get_options);
+    connection_free_(TO_CONN(conn));
+    tor_free(header);
+    tor_free(stats);
+    or_options_free(mock_options); mock_options = NULL;
+}
+
+NS_DECL(int, geoip_get_country_by_addr, (const tor_addr_t *addr));
+
+int
+NS(geoip_get_country_by_addr)(const tor_addr_t *addr)
+{
+  (void)addr;
+  CALLED(geoip_get_country_by_addr)++;
+  return 1;
+}
+
+static void
+status_vote_current_consensus_ns_test(char **header, char **body,
+                                      size_t *body_len)
+{
+  digests_t digests;
+  dir_connection_t *conn = NULL;
+
+  #define NETWORK_STATUS "some network status string"
+  dirserv_set_cached_consensus_networkstatus(NETWORK_STATUS, "ns", &digests,
+                                             time(NULL));
+
+  MOCK(connection_write_to_buf_impl_, connection_write_to_buf_mock);
+
+  tt_assert(mock_options);
+  mock_options->DirReqStatistics = 1;
+  geoip_dirreq_stats_init(time(NULL));
+
+  /* init geoip database */
+  geoip_parse_entry("10,50,AB", AF_INET);
+  tt_str_op("ab", OP_EQ, geoip_get_country_name(1));
+
+  conn = dir_connection_new(tor_addr_family(&MOCK_TOR_ADDR));
+  TO_CONN(conn)->address = tor_strdup("127.0.0.1");
+
+  tt_int_op(0, OP_EQ, directory_handle_command_get(conn,
+    GET("/tor/status-vote/current/consensus-ns"), NULL, 0));
+
+  fetch_from_buf_http(TO_CONN(conn)->outbuf, header, MAX_HEADERS_SIZE,
+                      body, body_len, strlen(NETWORK_STATUS)+7, 0);
+
+  done:
+    UNMOCK(connection_write_to_buf_impl_);
+    connection_free_(TO_CONN(conn));
+}
+
+static void
+test_dir_handle_get_status_vote_current_consensus_ns(void* data)
+{
+  char *header = NULL;
+  char *body = NULL, *comp_body = NULL;
+  size_t body_used = 0, comp_body_used = 0;
+  char *stats = NULL, *hist = NULL;
+  (void) data;
+
+  dirserv_free_all();
+  clear_geoip_db();
+
+  NS_MOCK(geoip_get_country_by_addr);
+  MOCK(get_options, mock_get_options);
+
+  init_mock_options();
+
+  status_vote_current_consensus_ns_test(&header, &comp_body, &comp_body_used);
+  tt_assert(header);
+
+  tt_ptr_op(strstr(header, "HTTP/1.0 200 OK\r\n"), OP_EQ, header);
+  tt_assert(strstr(header, "Content-Type: text/plain\r\n"));
+  tt_assert(strstr(header, "Content-Encoding: identity\r\n"));
+  tt_assert(strstr(header, "Pragma: no-cache\r\n"));
+
+  compress_method_t compression = detect_compression_method(comp_body,
+                                                            comp_body_used);
+  tt_int_op(ZLIB_METHOD, OP_EQ, compression);
+
+  tor_gzip_uncompress(&body, &body_used, comp_body, comp_body_used,
+                      compression, 0, LOG_PROTOCOL_WARN);
+
+  tt_str_op(NETWORK_STATUS, OP_EQ, body);
+  tt_int_op(strlen(NETWORK_STATUS), OP_EQ, body_used);
+
+  stats = geoip_format_dirreq_stats(time(NULL));
+  tt_assert(stats);
+
+  tt_assert(strstr(stats, "ok=8"));
+  tt_assert(strstr(stats, "dirreq-v3-ips ab=8"));
+  tt_assert(strstr(stats, "dirreq-v3-reqs ab=8"));
+  tt_assert(strstr(stats, "dirreq-v3-direct-dl"
+                          " complete=0,timeout=0,running=4"));
+
+  hist = geoip_get_request_history();
+  tt_assert(hist);
+  tt_str_op("ab=8", OP_EQ, hist);
+
+  done:
+    NS_UNMOCK(geoip_get_country_by_addr);
+    UNMOCK(get_options);
+    tor_free(header);
+    tor_free(comp_body);
+    tor_free(body);
+    tor_free(stats);
+    tor_free(hist);
+    or_options_free(mock_options); mock_options = NULL;
+
+    dirserv_free_all();
+    clear_geoip_db();
+}
+
+static void
+test_dir_handle_get_status_vote_current_consensus_ns_busy(void* data)
+{
+  char *header = NULL;
+  char *body = NULL;
+  size_t body_used = 0;
+  char *stats = NULL;
+  (void) data;
+
+  dirserv_free_all();
+  clear_geoip_db();
+
+  MOCK(get_options, mock_get_options);
+
+  // Make it busy
+  init_mock_options();
+  mock_options->CountPrivateBandwidth = 1;
+
+  status_vote_current_consensus_ns_test(&header, &body, &body_used);
+  tt_assert(header);
+
+  tt_str_op(SERVER_BUSY, OP_EQ, header);
+
+  stats = geoip_format_dirreq_stats(time(NULL));
+  tt_assert(stats);
+  tt_assert(strstr(stats, "busy=8"));
+
+  done:
+    UNMOCK(get_options);
+    tor_free(header);
+    tor_free(body);
+    or_options_free(mock_options); mock_options = NULL;
+
+    tor_free(stats);
+    dirserv_free_all();
+    clear_geoip_db();
+}
+
+static void
+test_dir_handle_get_status_vote_current_not_found(void* data)
+{
+  dir_connection_t *conn = NULL;
+  char *header = NULL;
+  (void) data;
+
+  MOCK(connection_write_to_buf_impl_, connection_write_to_buf_mock);
+
+  conn = dir_connection_new(tor_addr_family(&MOCK_TOR_ADDR));
+  tt_int_op(0, OP_EQ, directory_handle_command_get(conn,
+    GET("/tor/status-vote/current/" HEX1), NULL, 0));
+
+  fetch_from_buf_http(TO_CONN(conn)->outbuf, &header, MAX_HEADERS_SIZE,
+                      NULL, NULL, 1, 0);
+  tt_assert(header);
+  tt_str_op(NOT_FOUND, OP_EQ, header);
+
+  done:
+    UNMOCK(connection_write_to_buf_impl_);
+    connection_free_(TO_CONN(conn));
+    tor_free(header);
+}
+
+#define VOTE_DIGEST "312A4890D4D832597ABBD3089C782DBBFB81E48D"
+
+static void
+status_vote_current_d_test(char **header, char **body, size_t *body_l)
+{
+  dir_connection_t *conn = NULL;
+
+  MOCK(connection_write_to_buf_impl_, connection_write_to_buf_mock);
+
+  conn = dir_connection_new(tor_addr_family(&MOCK_TOR_ADDR));
+  tt_int_op(0, OP_EQ, directory_handle_command_get(conn,
+    GET("/tor/status-vote/current/d/" VOTE_DIGEST), NULL, 0));
+
+  fetch_from_buf_http(TO_CONN(conn)->outbuf, header, MAX_HEADERS_SIZE,
+                      body, body_l, strlen(VOTE_BODY_V3)+1, 0);
+  tt_assert(header);
+
+  done:
+    UNMOCK(connection_write_to_buf_impl_);
+    connection_free_(TO_CONN(conn));
+}
+
+static void
+status_vote_next_d_test(char **header, char **body, size_t *body_l)
+{
+  dir_connection_t *conn = NULL;
+
+  MOCK(connection_write_to_buf_impl_, connection_write_to_buf_mock);
+
+  conn = dir_connection_new(tor_addr_family(&MOCK_TOR_ADDR));
+  tt_int_op(0, OP_EQ, directory_handle_command_get(conn,
+    GET("/tor/status-vote/next/d/" VOTE_DIGEST), NULL, 0));
+
+  fetch_from_buf_http(TO_CONN(conn)->outbuf, header, MAX_HEADERS_SIZE,
+                      body, body_l, strlen(VOTE_BODY_V3)+1, 0);
+  tt_assert(header);
+
+  done:
+    UNMOCK(connection_write_to_buf_impl_);
+    connection_free_(TO_CONN(conn));
+}
+
+static void
+test_dir_handle_get_status_vote_current_d_not_found(void* data)
+{
+  char *header = NULL;
+  (void) data;
+
+  status_vote_current_d_test(&header, NULL, NULL);
+
+  tt_assert(header);
+  tt_str_op(NOT_FOUND, OP_EQ, header);
+
+  done:
+    tor_free(header);
+}
+
+static void
+test_dir_handle_get_status_vote_next_d_not_found(void* data)
+{
+  char *header = NULL;
+  (void) data;
+
+  status_vote_next_d_test(&header, NULL, NULL);
+
+  tt_assert(header);
+  tt_str_op(NOT_FOUND, OP_EQ, header);
+
+  done:
+    UNMOCK(connection_write_to_buf_impl_);
+    tor_free(header);
+}
+
+static void
+test_dir_handle_get_status_vote_d(void* data)
+{
+  char *header = NULL, *body = NULL;
+  size_t body_used = 0;
+  dir_server_t *ds = NULL;
+  const char digest[DIGEST_LEN] = "";
+  (void) data;
+
+  clear_dir_servers();
+  dirvote_free_all();
+
+  /* create a trusted ds */
+  ds = trusted_dir_server_new("ds", "127.0.0.1", 9059, 9060, NULL, digest,
+                              NULL, V3_DIRINFO, 1.0);
+  tt_assert(ds);
+  dir_server_add(ds);
+
+  /* ds v3_identity_digest is the certificate's identity_key */
+  base16_decode(ds->v3_identity_digest, DIGEST_LEN,
+                TEST_CERT_IDENT_KEY, HEX_DIGEST_LEN);
+
+  init_mock_options();
+  mock_options->AuthoritativeDir = 1;
+  mock_options->V3AuthoritativeDir = 1;
+  mock_options->TestingV3AuthVotingStartOffset = 0;
+  mock_options->TestingV3AuthInitialVotingInterval = 1;
+  mock_options->TestingV3AuthInitialVoteDelay = 1;
+  mock_options->TestingV3AuthInitialDistDelay = 1;
+
+  time_t now = 1441223455 -1;
+  dirvote_recalculate_timing(mock_options, now);
+
+  const char *msg_out = NULL;
+  int status_out = 0;
+  struct pending_vote_t *pv = dirvote_add_vote(VOTE_BODY_V3, &msg_out,
+                                               &status_out);
+  tt_assert(pv);
+
+  status_vote_current_d_test(&header, &body, &body_used);
+
+  tt_assert(header);
+  tt_ptr_op(strstr(header, "HTTP/1.0 200 OK\r\n"), OP_EQ, header);
+  tt_assert(strstr(header, "Content-Type: text/plain\r\n"));
+  tt_assert(strstr(header, "Content-Encoding: identity\r\n"));
+  tt_assert(strstr(header, "Content-Length: 4135\r\n"));
+
+  tt_str_op(VOTE_BODY_V3, OP_EQ, body);
+
+  tor_free(header);
+  tor_free(body);
+
+  status_vote_next_d_test(&header, &body, &body_used);
+
+  tt_assert(header);
+  tt_ptr_op(strstr(header, "HTTP/1.0 200 OK\r\n"), OP_EQ, header);
+  tt_assert(strstr(header, "Content-Type: text/plain\r\n"));
+  tt_assert(strstr(header, "Content-Encoding: identity\r\n"));
+  tt_assert(strstr(header, "Content-Length: 4135\r\n"));
+
+  tt_str_op(VOTE_BODY_V3, OP_EQ, body);
+
+  done:
+    tor_free(header);
+    tor_free(body);
+    or_options_free(mock_options); mock_options = NULL;
+
+    clear_dir_servers();
+    dirvote_free_all();
+}
+
+static void
+test_dir_handle_get_status_vote_next_not_found(void* data)
+{
+  dir_connection_t *conn = NULL;
+  char *header = NULL;
+  (void) data;
+
+  MOCK(connection_write_to_buf_impl_, connection_write_to_buf_mock);
+
+  conn = dir_connection_new(tor_addr_family(&MOCK_TOR_ADDR));
+  tt_int_op(0, OP_EQ, directory_handle_command_get(conn,
+    GET("/tor/status-vote/next/" HEX1), NULL, 0));
+
+  fetch_from_buf_http(TO_CONN(conn)->outbuf, &header, MAX_HEADERS_SIZE,
+                      NULL, NULL, 1, 0);
+  tt_assert(header);
+  tt_str_op(NOT_FOUND, OP_EQ, header);
+
+  done:
+    UNMOCK(connection_write_to_buf_impl_);
+    connection_free_(TO_CONN(conn));
+    tor_free(header);
+}
+
+static void
+status_vote_next_consensus_test(char **header, char **body, size_t *body_used)
+{
+  dir_connection_t *conn = NULL;
+
+  MOCK(connection_write_to_buf_impl_, connection_write_to_buf_mock);
+
+  conn = dir_connection_new(tor_addr_family(&MOCK_TOR_ADDR));
+  tt_int_op(0, OP_EQ, directory_handle_command_get(conn,
+    GET("/tor/status-vote/next/consensus"), NULL, 0));
+
+  fetch_from_buf_http(TO_CONN(conn)->outbuf, header, MAX_HEADERS_SIZE,
+                      body, body_used, 18, 0);
+  done:
+    UNMOCK(connection_write_to_buf_impl_);
+    connection_free_(TO_CONN(conn));
+}
+
+static void
+test_dir_handle_get_status_vote_next_consensus_not_found(void* data)
+{
+  char *header = NULL, *body = NULL;
+  size_t body_used;
+  (void) data;
+
+  status_vote_next_consensus_test(&header, &body, &body_used);
+
+  tt_assert(header);
+  tt_str_op(NOT_FOUND, OP_EQ, header);
+
+  done:
+    tor_free(header);
+    tor_free(body);
+}
+
+static void
+test_dir_handle_get_status_vote_current_authority_not_found(void* data)
+{
+  dir_connection_t *conn = NULL;
+  char *header = NULL;
+  (void) data;
+
+  MOCK(connection_write_to_buf_impl_, connection_write_to_buf_mock);
+
+  conn = dir_connection_new(tor_addr_family(&MOCK_TOR_ADDR));
+  tt_int_op(0, OP_EQ, directory_handle_command_get(conn,
+    GET("/tor/status-vote/current/authority"), NULL, 0));
+
+  fetch_from_buf_http(TO_CONN(conn)->outbuf, &header, MAX_HEADERS_SIZE,
+                      NULL, NULL, 1, 0);
+  tt_assert(header);
+  tt_str_op(NOT_FOUND, OP_EQ, header);
+
+  done:
+    UNMOCK(connection_write_to_buf_impl_);
+    connection_free_(TO_CONN(conn));
+    tor_free(header);
+}
+
+static void
+test_dir_handle_get_status_vote_next_authority_not_found(void* data)
+{
+  dir_connection_t *conn = NULL;
+  char *header = NULL;
+  (void) data;
+
+  MOCK(connection_write_to_buf_impl_, connection_write_to_buf_mock);
+
+  conn = dir_connection_new(tor_addr_family(&MOCK_TOR_ADDR));
+  tt_int_op(0, OP_EQ, directory_handle_command_get(conn,
+    GET("/tor/status-vote/next/authority"), NULL, 0));
+
+  fetch_from_buf_http(TO_CONN(conn)->outbuf, &header, MAX_HEADERS_SIZE,
+                      NULL, NULL, 1, 0);
+  tt_assert(header);
+  tt_str_op(NOT_FOUND, OP_EQ, header);
+
+  done:
+    UNMOCK(connection_write_to_buf_impl_);
+    connection_free_(TO_CONN(conn));
+    tor_free(header);
+}
+
+NS_DECL(const char*,
+dirvote_get_pending_consensus, (consensus_flavor_t flav));
+
+const char*
+NS(dirvote_get_pending_consensus)(consensus_flavor_t flav)
+{
+  (void)flav;
+  return "pending consensus";
+}
+
+static void
+test_dir_handle_get_status_vote_next_consensus(void* data)
+{
+  char *header = NULL, *body = NULL;
+  size_t body_used = 0;
+  (void) data;
+
+  NS_MOCK(dirvote_get_pending_consensus);
+
+  status_vote_next_consensus_test(&header, &body, &body_used);
+  tt_assert(header);
+
+  tt_ptr_op(strstr(header, "HTTP/1.0 200 OK\r\n"), OP_EQ, header);
+  tt_assert(strstr(header, "Content-Type: text/plain\r\n"));
+  tt_assert(strstr(header, "Content-Encoding: identity\r\n"));
+  tt_assert(strstr(header, "Content-Length: 17\r\n"));
+
+  tt_str_op("pending consensus", OP_EQ, body);
+
+  done:
+    NS_UNMOCK(dirvote_get_pending_consensus);
+    tor_free(header);
+    tor_free(body);
+}
+
+static void
+test_dir_handle_get_status_vote_next_consensus_busy(void* data)
+{
+  char *header = NULL, *body = NULL;
+  size_t body_used = 0;
+  (void) data;
+
+  MOCK(get_options, mock_get_options);
+  NS_MOCK(dirvote_get_pending_consensus);
+
+  //Make it busy
+  init_mock_options();
+  mock_options->CountPrivateBandwidth = 1;
+
+  status_vote_next_consensus_test(&header, &body, &body_used);
+
+  tt_assert(header);
+  tt_str_op(SERVER_BUSY, OP_EQ, header);
+
+  done:
+    NS_UNMOCK(dirvote_get_pending_consensus);
+    UNMOCK(get_options);
+    tor_free(header);
+    tor_free(body);
+    or_options_free(mock_options); mock_options = NULL;
+}
+
+static void
+status_vote_next_consensus_signatures_test(char **header, char **body,
+                                           size_t *body_used)
+{
+  dir_connection_t *conn = NULL;
+
+  MOCK(connection_write_to_buf_impl_, connection_write_to_buf_mock);
+
+  conn = dir_connection_new(tor_addr_family(&MOCK_TOR_ADDR));
+  tt_int_op(0, OP_EQ, directory_handle_command_get(conn,
+    GET("/tor/status-vote/next/consensus-signatures"), NULL, 0));
+
+  fetch_from_buf_http(TO_CONN(conn)->outbuf, header, MAX_HEADERS_SIZE,
+                      body, body_used, 22, 0);
+
+  done:
+    connection_free_(TO_CONN(conn));
+    UNMOCK(connection_write_to_buf_impl_);
+}
+
+static void
+test_dir_handle_get_status_vote_next_consensus_signatures_not_found(void* data)
+{
+  dir_connection_t *conn = NULL;
+  char *header = NULL, *body = NULL;
+  size_t body_used;
+  (void) data;
+
+  status_vote_next_consensus_signatures_test(&header, &body, &body_used);
+
+  tt_assert(header);
+  tt_str_op(NOT_FOUND, OP_EQ, header);
+
+  done:
+    connection_free_(TO_CONN(conn));
+    tor_free(header);
+    tor_free(body);
+}
+
+NS_DECL(const char*,
+dirvote_get_pending_detached_signatures, (void));
+
+const char*
+NS(dirvote_get_pending_detached_signatures)(void)
+{
+  return "pending detached sigs";
+}
+
+static void
+test_dir_handle_get_status_vote_next_consensus_signatures(void* data)
+{
+  char *header = NULL, *body = NULL;
+  size_t body_used = 0;
+  (void) data;
+
+  NS_MOCK(dirvote_get_pending_detached_signatures);
+
+  status_vote_next_consensus_signatures_test(&header, &body, &body_used);
+  tt_assert(header);
+
+  tt_ptr_op(strstr(header, "HTTP/1.0 200 OK\r\n"), OP_EQ, header);
+  tt_assert(strstr(header, "Content-Type: text/plain\r\n"));
+  tt_assert(strstr(header, "Content-Encoding: identity\r\n"));
+  tt_assert(strstr(header, "Content-Length: 21\r\n"));
+
+  tt_str_op("pending detached sigs", OP_EQ, body);
+
+  done:
+    NS_UNMOCK(dirvote_get_pending_detached_signatures);
+    tor_free(header);
+    tor_free(body);
+}
+
+static void
+test_dir_handle_get_status_vote_next_consensus_signatures_busy(void* data)
+{
+  dir_connection_t *conn = NULL;
+  char *header = NULL, *body = NULL;
+  size_t body_used;
+  (void) data;
+
+  NS_MOCK(dirvote_get_pending_detached_signatures);
+  MOCK(get_options, mock_get_options);
+
+  //Make it busy
+  init_mock_options();
+  mock_options->CountPrivateBandwidth = 1;
+
+  status_vote_next_consensus_signatures_test(&header, &body, &body_used);
+
+  tt_assert(header);
+  tt_str_op(SERVER_BUSY, OP_EQ, header);
+
+  done:
+    UNMOCK(get_options);
+    NS_UNMOCK(dirvote_get_pending_detached_signatures);
+    connection_free_(TO_CONN(conn));
+    tor_free(header);
+    tor_free(body);
+    or_options_free(mock_options); mock_options = NULL;
+}
+
+static void
+test_dir_handle_get_status_vote_next_authority(void* data)
+{
+  dir_connection_t *conn = NULL;
+  char *header = NULL, *body = NULL;
+  const char *msg_out = NULL;
+  int status_out = 0;
+  size_t body_used = 0;
+  dir_server_t *ds = NULL;
+  const char digest[DIGEST_LEN] = "";
+  (void) data;
+
+  clear_dir_servers();
+  routerlist_free_all();
+  dirvote_free_all();
+
+  mock_cert = authority_cert_parse_from_string(TEST_CERTIFICATE, NULL);
+
+  /* create a trusted ds */
+  ds = trusted_dir_server_new("ds", "127.0.0.1", 9059, 9060, NULL, digest,
+                              NULL, V3_DIRINFO, 1.0);
+  tt_assert(ds);
+  dir_server_add(ds);
+
+  /* ds v3_identity_digest is the certificate's identity_key */
+  base16_decode(ds->v3_identity_digest, DIGEST_LEN,
+                TEST_CERT_IDENT_KEY, HEX_DIGEST_LEN);
+  tt_int_op(0, OP_EQ, trusted_dirs_load_certs_from_string(TEST_CERTIFICATE,
+    TRUSTED_DIRS_CERTS_SRC_DL_BY_ID_DIGEST, 1));
+
+  init_mock_options();
+  mock_options->AuthoritativeDir = 1;
+  mock_options->V3AuthoritativeDir = 1;
+  mock_options->TestingV3AuthVotingStartOffset = 0;
+  mock_options->TestingV3AuthInitialVotingInterval = 1;
+  mock_options->TestingV3AuthInitialVoteDelay = 1;
+  mock_options->TestingV3AuthInitialDistDelay = 1;
+
+  time_t now = 1441223455 -1;
+  dirvote_recalculate_timing(mock_options, now);
+
+  struct pending_vote_t *vote = dirvote_add_vote(VOTE_BODY_V3, &msg_out,
+                                                 &status_out);
+  tt_assert(vote);
+
+  MOCK(get_my_v3_authority_cert, get_my_v3_authority_cert_m);
+  MOCK(connection_write_to_buf_impl_, connection_write_to_buf_mock);
+
+  conn = dir_connection_new(tor_addr_family(&MOCK_TOR_ADDR));
+  tt_int_op(0, OP_EQ, directory_handle_command_get(conn,
+    GET("/tor/status-vote/next/authority"), NULL, 0));
+
+  fetch_from_buf_http(TO_CONN(conn)->outbuf, &header, MAX_HEADERS_SIZE,
+                      &body, &body_used, strlen(VOTE_BODY_V3)+1, 0);
+
+  tt_assert(header);
+  tt_ptr_op(strstr(header, "HTTP/1.0 200 OK\r\n"), OP_EQ, header);
+  tt_assert(strstr(header, "Content-Type: text/plain\r\n"));
+  tt_assert(strstr(header, "Content-Encoding: identity\r\n"));
+  tt_assert(strstr(header, "Content-Length: 4135\r\n"));
+
+  tt_str_op(VOTE_BODY_V3, OP_EQ, body);
+
+  done:
+    UNMOCK(connection_write_to_buf_impl_);
+    UNMOCK(get_my_v3_authority_cert);
+    connection_free_(TO_CONN(conn));
+    tor_free(header);
+    tor_free(body);
+    authority_cert_free(mock_cert); mock_cert = NULL;
+    or_options_free(mock_options); mock_options = NULL;
+
+    clear_dir_servers();
+    routerlist_free_all();
+    dirvote_free_all();
+}
+
+static void
+test_dir_handle_get_status_vote_current_authority(void* data)
+{
+  dir_connection_t *conn = NULL;
+  char *header = NULL, *body = NULL;
+  const char *msg_out = NULL;
+  int status_out = 0;
+  size_t body_used = 0;
+  const char digest[DIGEST_LEN] = "";
+
+  dir_server_t *ds = NULL;
+  (void) data;
+
+  clear_dir_servers();
+  routerlist_free_all();
+  dirvote_free_all();
+
+  mock_cert = authority_cert_parse_from_string(TEST_CERTIFICATE, NULL);
+
+  /* create a trusted ds */
+  ds = trusted_dir_server_new("ds", "127.0.0.1", 9059, 9060, NULL, digest,
+                              NULL, V3_DIRINFO, 1.0);
+  tt_assert(ds);
+  dir_server_add(ds);
+
+  /* ds v3_identity_digest is the certificate's identity_key */
+  base16_decode(ds->v3_identity_digest, DIGEST_LEN,
+                TEST_CERT_IDENT_KEY, HEX_DIGEST_LEN);
+
+  tt_int_op(0, OP_EQ, trusted_dirs_load_certs_from_string(TEST_CERTIFICATE,
+    TRUSTED_DIRS_CERTS_SRC_DL_BY_ID_DIGEST, 1));
+
+  init_mock_options();
+  mock_options->AuthoritativeDir = 1;
+  mock_options->V3AuthoritativeDir = 1;
+  mock_options->TestingV3AuthVotingStartOffset = 0;
+  mock_options->TestingV3AuthInitialVotingInterval = 1;
+  mock_options->TestingV3AuthInitialVoteDelay = 1;
+  mock_options->TestingV3AuthInitialDistDelay = 1;
+
+  time_t now = 1441223455;
+  dirvote_recalculate_timing(mock_options, now-1);
+
+  struct pending_vote_t *vote = dirvote_add_vote(VOTE_BODY_V3, &msg_out,
+                                                 &status_out);
+  tt_assert(vote);
+
+  // move the pending vote to previous vote
+  dirvote_act(mock_options, now+1);
+
+  MOCK(get_my_v3_authority_cert, get_my_v3_authority_cert_m);
+  MOCK(connection_write_to_buf_impl_, connection_write_to_buf_mock);
+
+  conn = dir_connection_new(tor_addr_family(&MOCK_TOR_ADDR));
+  tt_int_op(0, OP_EQ, directory_handle_command_get(conn,
+    GET("/tor/status-vote/current/authority"), NULL, 0));
+
+  fetch_from_buf_http(TO_CONN(conn)->outbuf, &header, MAX_HEADERS_SIZE,
+                      &body, &body_used, strlen(VOTE_BODY_V3)+1, 0);
+
+  tt_assert(header);
+  tt_ptr_op(strstr(header, "HTTP/1.0 200 OK\r\n"), OP_EQ, header);
+  tt_assert(strstr(header, "Content-Type: text/plain\r\n"));
+  tt_assert(strstr(header, "Content-Encoding: identity\r\n"));
+  tt_assert(strstr(header, "Content-Length: 4135\r\n"));
+
+  tt_str_op(VOTE_BODY_V3, OP_EQ, body);
+
+  done:
+    UNMOCK(connection_write_to_buf_impl_);
+    UNMOCK(get_my_v3_authority_cert);
+    connection_free_(TO_CONN(conn));
+    tor_free(header);
+    tor_free(body);
+    authority_cert_free(mock_cert); mock_cert = NULL;
+    or_options_free(mock_options); mock_options = NULL;
+
+    clear_dir_servers();
+    routerlist_free_all();
+    dirvote_free_all();
+}
+
+#define DIR_HANDLE_CMD(name,flags) \
+  { #name, test_dir_handle_get_##name, (flags), NULL, NULL }
+
+struct testcase_t dir_handle_get_tests[] = {
+  DIR_HANDLE_CMD(not_found, 0),
+  DIR_HANDLE_CMD(bad_request, 0),
+  DIR_HANDLE_CMD(v1_command_not_found, 0),
+  DIR_HANDLE_CMD(v1_command, 0),
+  DIR_HANDLE_CMD(robots_txt, 0),
+  DIR_HANDLE_CMD(bytes_txt, 0),
+  DIR_HANDLE_CMD(rendezvous2_not_found_if_not_encrypted, 0),
+  DIR_HANDLE_CMD(rendezvous2_not_found, 0),
+  DIR_HANDLE_CMD(rendezvous2_on_encrypted_conn_with_invalid_desc_id, 0),
+  DIR_HANDLE_CMD(rendezvous2_on_encrypted_conn_not_well_formed, 0),
+  DIR_HANDLE_CMD(rendezvous2_on_encrypted_conn_success, 0),
+  DIR_HANDLE_CMD(micro_d_not_found, 0),
+  DIR_HANDLE_CMD(micro_d_server_busy, 0),
+  DIR_HANDLE_CMD(micro_d, 0),
+  DIR_HANDLE_CMD(networkstatus_bridges_not_found_without_auth, 0),
+  DIR_HANDLE_CMD(networkstatus_bridges_not_found_wrong_auth, 0),
+  DIR_HANDLE_CMD(networkstatus_bridges, 0),
+  DIR_HANDLE_CMD(server_descriptors_not_found, 0),
+  DIR_HANDLE_CMD(server_descriptors_busy, TT_FORK),
+  DIR_HANDLE_CMD(server_descriptors_all, TT_FORK),
+  DIR_HANDLE_CMD(server_descriptors_authority, TT_FORK),
+  DIR_HANDLE_CMD(server_descriptors_fp, TT_FORK),
+  DIR_HANDLE_CMD(server_descriptors_d, TT_FORK),
+  DIR_HANDLE_CMD(server_keys_bad_req, 0),
+  DIR_HANDLE_CMD(server_keys_busy, 0),
+  DIR_HANDLE_CMD(server_keys_all_not_found, 0),
+  DIR_HANDLE_CMD(server_keys_all, 0),
+  DIR_HANDLE_CMD(server_keys_authority_not_found, 0),
+  DIR_HANDLE_CMD(server_keys_authority, 0),
+  DIR_HANDLE_CMD(server_keys_fp_not_found, 0),
+  DIR_HANDLE_CMD(server_keys_fp, 0),
+  DIR_HANDLE_CMD(server_keys_sk_not_found, 0),
+  DIR_HANDLE_CMD(server_keys_sk, 0),
+  DIR_HANDLE_CMD(server_keys_fpsk_not_found, 0),
+  DIR_HANDLE_CMD(server_keys_fpsk, 0),
+  DIR_HANDLE_CMD(status_vote_current_not_found, 0),
+  DIR_HANDLE_CMD(status_vote_next_not_found, 0),
+  DIR_HANDLE_CMD(status_vote_current_authority_not_found, 0),
+  DIR_HANDLE_CMD(status_vote_current_authority, 0),
+  DIR_HANDLE_CMD(status_vote_next_authority_not_found, 0),
+  DIR_HANDLE_CMD(status_vote_next_authority, 0),
+  DIR_HANDLE_CMD(status_vote_current_consensus_ns_not_enough_sigs, 0),
+  DIR_HANDLE_CMD(status_vote_current_consensus_ns_not_found, 0),
+  DIR_HANDLE_CMD(status_vote_current_consensus_ns_busy, 0),
+  DIR_HANDLE_CMD(status_vote_current_consensus_ns, 0),
+  DIR_HANDLE_CMD(status_vote_current_d_not_found, 0),
+  DIR_HANDLE_CMD(status_vote_next_d_not_found, 0),
+  DIR_HANDLE_CMD(status_vote_d, 0),
+  DIR_HANDLE_CMD(status_vote_next_consensus_not_found, 0),
+  DIR_HANDLE_CMD(status_vote_next_consensus_busy, 0),
+  DIR_HANDLE_CMD(status_vote_next_consensus, 0),
+  DIR_HANDLE_CMD(status_vote_next_consensus_signatures_not_found, 0),
+  DIR_HANDLE_CMD(status_vote_next_consensus_signatures_busy, 0),
+  DIR_HANDLE_CMD(status_vote_next_consensus_signatures, 0),
+  END_OF_TESTCASES
+};
+
diff --git a/src/test/test_dns.c b/src/test/test_dns.c
index ad81914..5289ca5 100644
--- a/src/test/test_dns.c
+++ b/src/test/test_dns.c
@@ -5,9 +5,14 @@
 
 #include "dns.h"
 #include "connection.h"
+#include "router.h"
+
+#define NS_MODULE dns
+
+#define NS_SUBMODULE clip_ttl
 
 static void
-test_dns_clip_ttl(void *arg)
+NS(test_main)(void *arg)
 {
   (void)arg;
 
@@ -21,8 +26,12 @@ test_dns_clip_ttl(void *arg)
   return;
 }
 
+#undef NS_SUBMODULE
+
+#define NS_SUBMODULE expiry_ttl
+
 static void
-test_dns_expiry_ttl(void *arg)
+NS(test_main)(void *arg)
 {
   (void)arg;
 
@@ -36,6 +45,10 @@ test_dns_expiry_ttl(void *arg)
   return;
 }
 
+#undef NS_SUBMODULE
+
+#define NS_SUBMODULE resolve
+
 static int resolve_retval = 0;
 static int resolve_made_conn_pending = 0;
 static char *resolved_name = NULL;
@@ -43,6 +56,11 @@ static cached_resolve_t *cache_entry = NULL;
 
 static int n_fake_impl = 0;
 
+NS_DECL(int, dns_resolve_impl, (edge_connection_t *exitconn, int is_resolve,
+                                or_circuit_t *oncirc, char **hostname_out,
+                                int *made_connection_pending_out,
+                                cached_resolve_t **resolve_out));
+
 /** This will be our configurable substitute for <b>dns_resolve_impl</b> in
  * dns.c. It will return <b>resolve_retval</b>,
  * and set <b>resolve_made_conn_pending</b> to
@@ -52,10 +70,10 @@ static int n_fake_impl = 0;
  * 1.
  */
 static int
-dns_resolve_fake_impl(edge_connection_t *exitconn, int is_resolve,
-                      or_circuit_t *oncirc, char **hostname_out,
-                      int *made_connection_pending_out,
-                      cached_resolve_t **resolve_out)
+NS(dns_resolve_impl)(edge_connection_t *exitconn, int is_resolve,
+                     or_circuit_t *oncirc, char **hostname_out,
+                     int *made_connection_pending_out,
+                     cached_resolve_t **resolve_out)
 {
   (void)oncirc;
   (void)exitconn;
@@ -82,8 +100,8 @@ static uint8_t last_answer_type = 0;
 static cached_resolve_t *last_resolved;
 
 static void
-send_resolved_cell_replacement(edge_connection_t *conn, uint8_t answer_type,
-                               const cached_resolve_t *resolved)
+NS(send_resolved_cell)(edge_connection_t *conn, uint8_t answer_type,
+                       const cached_resolve_t *resolved)
 {
   conn_for_resolved_cell = conn;
 
@@ -98,8 +116,8 @@ static int n_send_resolved_hostname_cell_replacement = 0;
 static char *last_resolved_hostname = NULL;
 
 static void
-send_resolved_hostname_cell_replacement(edge_connection_t *conn,
-                                        const char *hostname)
+NS(send_resolved_hostname_cell)(edge_connection_t *conn,
+                                const char *hostname)
 {
   conn_for_resolved_cell = conn;
 
@@ -112,7 +130,7 @@ send_resolved_hostname_cell_replacement(edge_connection_t *conn,
 static int n_dns_cancel_pending_resolve_replacement = 0;
 
 static void
-dns_cancel_pending_resolve_replacement(const char *address)
+NS(dns_cancel_pending_resolve)(const char *address)
 {
   (void) address;
   n_dns_cancel_pending_resolve_replacement++;
@@ -122,7 +140,7 @@ static int n_connection_free = 0;
 static connection_t *last_freed_conn = NULL;
 
 static void
-connection_free_replacement(connection_t *conn)
+NS(connection_free)(connection_t *conn)
 {
    n_connection_free++;
 
@@ -130,7 +148,7 @@ connection_free_replacement(connection_t *conn)
 }
 
 static void
-test_dns_resolve_outer(void *arg)
+NS(test_main)(void *arg)
 {
   (void) arg;
   int retval;
@@ -149,9 +167,9 @@ test_dns_resolve_outer(void *arg)
   memset(exitconn,0,sizeof(edge_connection_t));
   memset(nextconn,0,sizeof(edge_connection_t));
 
-  MOCK(dns_resolve_impl,dns_resolve_fake_impl);
-  MOCK(send_resolved_cell,send_resolved_cell_replacement);
-  MOCK(send_resolved_hostname_cell,send_resolved_hostname_cell_replacement);
+  NS_MOCK(dns_resolve_impl);
+  NS_MOCK(send_resolved_cell);
+  NS_MOCK(send_resolved_hostname_cell);
 
   /*
    * CASE 1: dns_resolve_impl returns 1 and sets a hostname. purpose is
@@ -264,8 +282,8 @@ test_dns_resolve_outer(void *arg)
    * on exitconn with type being RESOLVED_TYPE_ERROR.
    */
 
-  MOCK(dns_cancel_pending_resolve,dns_cancel_pending_resolve_replacement);
-  MOCK(connection_free,connection_free_replacement);
+  NS_MOCK(dns_cancel_pending_resolve);
+  NS_MOCK(connection_free);
 
   exitconn->on_circuit = &(on_circuit->base_);
   exitconn->base_.purpose = EXIT_PURPOSE_RESOLVE;
@@ -288,11 +306,11 @@ test_dns_resolve_outer(void *arg)
   tt_assert(last_freed_conn == TO_CONN(exitconn));
 
   done:
-  UNMOCK(dns_resolve_impl);
-  UNMOCK(send_resolved_cell);
-  UNMOCK(send_resolved_hostname_cell);
-  UNMOCK(dns_cancel_pending_resolve);
-  UNMOCK(connection_free);
+  NS_UNMOCK(dns_resolve_impl);
+  NS_UNMOCK(send_resolved_cell);
+  NS_UNMOCK(send_resolved_hostname_cell);
+  NS_UNMOCK(dns_cancel_pending_resolve);
+  NS_UNMOCK(connection_free);
   tor_free(on_circuit);
   tor_free(exitconn);
   tor_free(nextconn);
@@ -302,10 +320,446 @@ test_dns_resolve_outer(void *arg)
   return;
 }
 
+#undef NS_SUBMODULE
+
+/** Create an <b>edge_connection_t</b> instance that is considered a
+ * valid exit connection by asserts in dns_resolve_impl.
+ */
+static edge_connection_t *
+create_valid_exitconn(void)
+{
+  edge_connection_t *exitconn = tor_malloc_zero(sizeof(edge_connection_t));
+  TO_CONN(exitconn)->type = CONN_TYPE_EXIT;
+  TO_CONN(exitconn)->magic = EDGE_CONNECTION_MAGIC;
+  TO_CONN(exitconn)->purpose = EXIT_PURPOSE_RESOLVE;
+  TO_CONN(exitconn)->state = EXIT_CONN_STATE_RESOLVING;
+  exitconn->base_.s = TOR_INVALID_SOCKET;
+
+  return exitconn;
+}
+
+#define NS_SUBMODULE ASPECT(resolve_impl, addr_is_ip_no_need_to_resolve)
+
+/*
+ * Given that <b>exitconn->base_.address</b> is IP address string, we
+ * want dns_resolve_impl() to parse it and store in
+ * <b>exitconn->base_.addr</b>. We expect dns_resolve_impl to return 1.
+ * Lastly, we want it to set the TTL value to default one for DNS queries.
+ */
+
+static void
+NS(test_main)(void *arg)
+{
+  int retval;
+  int made_pending;
+  const tor_addr_t *resolved_addr;
+  tor_addr_t addr_to_compare;
+
+  (void)arg;
+
+  tor_addr_parse(&addr_to_compare, "8.8.8.8");
+
+  or_circuit_t *on_circ = tor_malloc_zero(sizeof(or_circuit_t));
+
+  edge_connection_t *exitconn = create_valid_exitconn();
+
+  TO_CONN(exitconn)->address = tor_strdup("8.8.8.8");
+
+  retval = dns_resolve_impl(exitconn, 1, on_circ, NULL, &made_pending,
+                            NULL);
+
+  resolved_addr = &(exitconn->base_.addr);
+
+  tt_int_op(retval,==,1);
+  tt_assert(tor_addr_eq(resolved_addr, (const tor_addr_t *)&addr_to_compare));
+  tt_int_op(exitconn->address_ttl,==,DEFAULT_DNS_TTL);
+
+  done:
+  tor_free(on_circ);
+  tor_free(TO_CONN(exitconn)->address);
+  tor_free(exitconn);
+  return;
+}
+
+#undef NS_SUBMODULE
+
+#define NS_SUBMODULE ASPECT(resolve_impl, non_exit)
+
+/** Given that Tor instance is not configured as an exit node, we want
+ * dns_resolve_impl() to fail with return value -1.
+ */
+static int
+NS(router_my_exit_policy_is_reject_star)(void)
+{
+  return 1;
+}
+
+static void
+NS(test_main)(void *arg)
+{
+  int retval;
+  int made_pending;
+
+  edge_connection_t *exitconn = create_valid_exitconn();
+  or_circuit_t *on_circ = tor_malloc_zero(sizeof(or_circuit_t));
+
+  (void)arg;
+
+  TO_CONN(exitconn)->address = tor_strdup("torproject.org");
+
+  NS_MOCK(router_my_exit_policy_is_reject_star);
+
+  retval = dns_resolve_impl(exitconn, 1, on_circ, NULL, &made_pending,
+                            NULL);
+
+  tt_int_op(retval,==,-1);
+
+  done:
+  tor_free(TO_CONN(exitconn)->address);
+  tor_free(exitconn);
+  tor_free(on_circ);
+  NS_UNMOCK(router_my_exit_policy_is_reject_star);
+  return;
+}
+
+#undef NS_SUBMODULE
+
+#define NS_SUBMODULE ASPECT(resolve_impl, addr_is_invalid_dest)
+
+/** Given that address is not a valid destination (as judged by
+ * address_is_invalid_destination() function), we want dns_resolve_impl()
+ * function to fail with return value -1.
+ */
+
+static int
+NS(router_my_exit_policy_is_reject_star)(void)
+{
+  return 0;
+}
+
+static void
+NS(test_main)(void *arg)
+{
+  int retval;
+  int made_pending;
+
+  edge_connection_t *exitconn = create_valid_exitconn();
+  or_circuit_t *on_circ = tor_malloc_zero(sizeof(or_circuit_t));
+
+  (void)arg;
+
+  NS_MOCK(router_my_exit_policy_is_reject_star);
+
+  TO_CONN(exitconn)->address = tor_strdup("invalid#@!.org");
+
+  retval = dns_resolve_impl(exitconn, 1, on_circ, NULL, &made_pending,
+                            NULL);
+
+  tt_int_op(retval,==,-1);
+
+  done:
+  NS_UNMOCK(router_my_exit_policy_is_reject_star);
+  tor_free(TO_CONN(exitconn)->address);
+  tor_free(exitconn);
+  tor_free(on_circ);
+  return;
+}
+
+#undef NS_SUBMODULE
+
+#define NS_SUBMODULE ASPECT(resolve_impl, malformed_ptr)
+
+/** Given that address is a malformed PTR name, we want dns_resolve_impl to
+ * fail.
+ */
+
+static int
+NS(router_my_exit_policy_is_reject_star)(void)
+{
+  return 0;
+}
+
+static void
+NS(test_main)(void *arg)
+{
+  int retval;
+  int made_pending;
+
+  edge_connection_t *exitconn = create_valid_exitconn();
+  or_circuit_t *on_circ = tor_malloc_zero(sizeof(or_circuit_t));
+
+  (void)arg;
+
+  TO_CONN(exitconn)->address = tor_strdup("1.0.0.127.in-addr.arpa");
+
+  NS_MOCK(router_my_exit_policy_is_reject_star);
+
+  retval = dns_resolve_impl(exitconn, 1, on_circ, NULL, &made_pending,
+                            NULL);
+
+  tt_int_op(retval,==,-1);
+
+  tor_free(TO_CONN(exitconn)->address);
+
+  TO_CONN(exitconn)->address =
+  tor_strdup("z01234567890123456789.in-addr.arpa");
+
+  retval = dns_resolve_impl(exitconn, 1, on_circ, NULL, &made_pending,
+                            NULL);
+
+  tt_int_op(retval,==,-1);
+
+  done:
+  NS_UNMOCK(router_my_exit_policy_is_reject_star);
+  tor_free(TO_CONN(exitconn)->address);
+  tor_free(exitconn);
+  tor_free(on_circ);
+  return;
+}
+
+#undef NS_SUBMODULE
+
+#define NS_SUBMODULE ASPECT(resolve_impl, cache_hit_pending)
+
+/* Given that there is already a pending resolve for the given address,
+ * we want dns_resolve_impl to append our exit connection to list
+ * of pending connections for the pending DNS request and return 0.
+ */
+
+static int
+NS(router_my_exit_policy_is_reject_star)(void)
+{
+  return 0;
+}
+
+static void
+NS(test_main)(void *arg)
+{
+  int retval;
+  int made_pending = 0;
+
+  pending_connection_t *pending_conn = NULL;
+
+  edge_connection_t *exitconn = create_valid_exitconn();
+  or_circuit_t *on_circ = tor_malloc_zero(sizeof(or_circuit_t));
+
+  cached_resolve_t *cache_entry = tor_malloc_zero(sizeof(cached_resolve_t));
+  cache_entry->magic = CACHED_RESOLVE_MAGIC;
+  cache_entry->state = CACHE_STATE_PENDING;
+  cache_entry->minheap_idx = -1;
+  cache_entry->expire = time(NULL) + 60 * 60;
+
+  (void)arg;
+
+  TO_CONN(exitconn)->address = tor_strdup("torproject.org");
+
+  strlcpy(cache_entry->address, TO_CONN(exitconn)->address,
+          sizeof(cache_entry->address));
+
+  NS_MOCK(router_my_exit_policy_is_reject_star);
+
+  dns_init();
+
+  dns_insert_cache_entry(cache_entry);
+
+  retval = dns_resolve_impl(exitconn, 1, on_circ, NULL, &made_pending,
+                            NULL);
+
+  tt_int_op(retval,==,0);
+  tt_int_op(made_pending,==,1);
+
+  pending_conn = cache_entry->pending_connections;
+
+  tt_assert(pending_conn != NULL);
+  tt_assert(pending_conn->conn == exitconn);
+
+  done:
+  NS_UNMOCK(router_my_exit_policy_is_reject_star);
+  tor_free(on_circ);
+  tor_free(TO_CONN(exitconn)->address);
+  tor_free(cache_entry->pending_connections);
+  tor_free(cache_entry);
+  tor_free(exitconn);
+  return;
+}
+
+#undef NS_SUBMODULE
+
+#define NS_SUBMODULE ASPECT(resolve_impl, cache_hit_cached)
+
+/* Given that a finished DNS resolve is available in our cache, we want
+ * dns_resolve_impl() return it to called via resolve_out and pass the
+ * handling to set_exitconn_info_from_resolve function.
+ */
+static int
+NS(router_my_exit_policy_is_reject_star)(void)
+{
+  return 0;
+}
+
+static edge_connection_t *last_exitconn = NULL;
+static cached_resolve_t *last_resolve = NULL;
+
+static int
+NS(set_exitconn_info_from_resolve)(edge_connection_t *exitconn,
+                                   const cached_resolve_t *resolve,
+                                   char **hostname_out)
+{
+  last_exitconn = exitconn;
+  last_resolve = (cached_resolve_t *)resolve;
+
+  (void)hostname_out;
+
+  return 0;
+}
+
+static void
+NS(test_main)(void *arg)
+{
+  int retval;
+  int made_pending = 0;
+
+  edge_connection_t *exitconn = create_valid_exitconn();
+  or_circuit_t *on_circ = tor_malloc_zero(sizeof(or_circuit_t));
+
+  cached_resolve_t *resolve_out = NULL;
+
+  cached_resolve_t *cache_entry = tor_malloc_zero(sizeof(cached_resolve_t));
+  cache_entry->magic = CACHED_RESOLVE_MAGIC;
+  cache_entry->state = CACHE_STATE_CACHED;
+  cache_entry->minheap_idx = -1;
+  cache_entry->expire = time(NULL) + 60 * 60;
+
+  (void)arg;
+
+  TO_CONN(exitconn)->address = tor_strdup("torproject.org");
+
+  strlcpy(cache_entry->address, TO_CONN(exitconn)->address,
+          sizeof(cache_entry->address));
+
+  NS_MOCK(router_my_exit_policy_is_reject_star);
+  NS_MOCK(set_exitconn_info_from_resolve);
+
+  dns_init();
+
+  dns_insert_cache_entry(cache_entry);
+
+  retval = dns_resolve_impl(exitconn, 1, on_circ, NULL, &made_pending,
+                            &resolve_out);
+
+  tt_int_op(retval,==,0);
+  tt_int_op(made_pending,==,0);
+  tt_assert(resolve_out == cache_entry);
+
+  tt_assert(last_exitconn == exitconn);
+  tt_assert(last_resolve == cache_entry);
+
+  done:
+  NS_UNMOCK(router_my_exit_policy_is_reject_star);
+  NS_UNMOCK(set_exitconn_info_from_resolve);
+  tor_free(on_circ);
+  tor_free(TO_CONN(exitconn)->address);
+  tor_free(cache_entry->pending_connections);
+  tor_free(cache_entry);
+  return;
+}
+
+#undef NS_SUBMODULE
+
+#define NS_SUBMODULE ASPECT(resolve_impl, cache_miss)
+
+/* Given that there are neither pending nor pre-cached resolve for a given
+ * address, we want dns_resolve_impl() to create a new cached_resolve_t
+ * object, mark it as pending, insert it into the cache, attach the exit
+ * connection to list of pending connections and call launch_resolve()
+ * with the cached_resolve_t object it created.
+ */
+static int
+NS(router_my_exit_policy_is_reject_star)(void)
+{
+  return 0;
+}
+
+static cached_resolve_t *last_launched_resolve = NULL;
+
+static int
+NS(launch_resolve)(cached_resolve_t *resolve)
+{
+  last_launched_resolve = resolve;
+
+  return 0;
+}
+
+static void
+NS(test_main)(void *arg)
+{
+  int retval;
+  int made_pending = 0;
+
+  pending_connection_t *pending_conn = NULL;
+
+  edge_connection_t *exitconn = create_valid_exitconn();
+  or_circuit_t *on_circ = tor_malloc_zero(sizeof(or_circuit_t));
+
+  cached_resolve_t *cache_entry = NULL;
+  cached_resolve_t query;
+
+  (void)arg;
+
+  TO_CONN(exitconn)->address = tor_strdup("torproject.org");
+
+  strlcpy(query.address, TO_CONN(exitconn)->address, sizeof(query.address));
+
+  NS_MOCK(router_my_exit_policy_is_reject_star);
+  NS_MOCK(launch_resolve);
+
+  dns_init();
+
+  retval = dns_resolve_impl(exitconn, 1, on_circ, NULL, &made_pending,
+                            NULL);
+
+  tt_int_op(retval,==,0);
+  tt_int_op(made_pending,==,1);
+
+  cache_entry = dns_get_cache_entry(&query);
+
+  tt_assert(cache_entry);
+
+  pending_conn = cache_entry->pending_connections;
+
+  tt_assert(pending_conn != NULL);
+  tt_assert(pending_conn->conn == exitconn);
+
+  tt_assert(last_launched_resolve == cache_entry);
+  tt_str_op(cache_entry->address,==,TO_CONN(exitconn)->address);
+
+  done:
+  NS_UNMOCK(router_my_exit_policy_is_reject_star);
+  NS_UNMOCK(launch_resolve);
+  tor_free(on_circ);
+  tor_free(TO_CONN(exitconn)->address);
+  if (cache_entry)
+    tor_free(cache_entry->pending_connections);
+  tor_free(cache_entry);
+  tor_free(exitconn);
+  return;
+}
+
+#undef NS_SUBMODULE
+
 struct testcase_t dns_tests[] = {
-   { "clip_ttl", test_dns_clip_ttl, 0, NULL, NULL },
-   { "expiry_ttl", test_dns_expiry_ttl, 0, NULL, NULL },
-   { "resolve_outer", test_dns_resolve_outer, TT_FORK, NULL, NULL },
+   TEST_CASE(clip_ttl),
+   TEST_CASE(expiry_ttl),
+   TEST_CASE(resolve),
+   TEST_CASE_ASPECT(resolve_impl, addr_is_ip_no_need_to_resolve),
+   TEST_CASE_ASPECT(resolve_impl, non_exit),
+   TEST_CASE_ASPECT(resolve_impl, addr_is_invalid_dest),
+   TEST_CASE_ASPECT(resolve_impl, malformed_ptr),
+   TEST_CASE_ASPECT(resolve_impl, cache_hit_pending),
+   TEST_CASE_ASPECT(resolve_impl, cache_hit_cached),
+   TEST_CASE_ASPECT(resolve_impl, cache_miss),
    END_OF_TESTCASES
 };
 
+#undef NS_MODULE
+
diff --git a/src/test/test_extorport.c b/src/test/test_extorport.c
index 2e5a32e..5d38ed8 100644
--- a/src/test/test_extorport.c
+++ b/src/test/test_extorport.c
@@ -309,15 +309,14 @@ test_ext_or_cookie_auth(void *arg)
   tor_free(client_hash2);
 }
 
-static int
+static void
 crypto_rand_return_tse_str(char *to, size_t n)
 {
   if (n != 32) {
     TT_FAIL(("Asked for %d bytes, not 32", (int)n));
-    return -1;
+    return;
   }
   memcpy(to, "te road There is always another ", 32);
-  return 0;
 }
 
 static void
diff --git a/src/test/test_nodelist.c b/src/test/test_nodelist.c
index a8693ec..b0cb87d 100644
--- a/src/test/test_nodelist.c
+++ b/src/test/test_nodelist.c
@@ -60,12 +60,53 @@ test_nodelist_node_get_verbose_nickname_not_named(void *arg)
   return;
 }
 
+/** A node should be considered a directory server if it has an open dirport
+ * of it accepts tunnelled directory requests.
+ */
+static void
+test_nodelist_node_is_dir(void *arg)
+{
+  (void)arg;
+
+  routerstatus_t rs;
+  routerinfo_t ri;
+  node_t node;
+  memset(&node, 0, sizeof(node_t));
+  memset(&rs, 0, sizeof(routerstatus_t));
+  memset(&ri, 0, sizeof(routerinfo_t));
+
+  tt_assert(!node_is_dir(&node));
+
+  node.rs = &rs;
+  tt_assert(!node_is_dir(&node));
+
+  rs.is_v2_dir = 1;
+  tt_assert(node_is_dir(&node));
+
+  rs.is_v2_dir = 0;
+  rs.dir_port = 1;
+  tt_assert(! node_is_dir(&node));
+
+  node.rs = NULL;
+  tt_assert(!node_is_dir(&node));
+  node.ri = &ri;
+  ri.supports_tunnelled_dir_requests = 1;
+  tt_assert(node_is_dir(&node));
+  ri.supports_tunnelled_dir_requests = 0;
+  ri.dir_port = 1;
+  tt_assert(! node_is_dir(&node));
+
+ done:
+  return;
+}
+
 #define NODE(name, flags) \
   { #name, test_nodelist_##name, (flags), NULL, NULL }
 
 struct testcase_t nodelist_tests[] = {
   NODE(node_get_verbose_nickname_by_id_null_node, TT_FORK),
   NODE(node_get_verbose_nickname_not_named, TT_FORK),
+  NODE(node_is_dir, TT_FORK),
   END_OF_TESTCASES
 };
 
diff --git a/src/test/test_ntor_cl.c b/src/test/test_ntor_cl.c
index bfbf13a..915a5d0 100644
--- a/src/test/test_ntor_cl.c
+++ b/src/test/test_ntor_cl.c
@@ -106,6 +106,7 @@ server1(int argc, char **argv)
  done:
   tor_free(keys);
   tor_free(hexkeys);
+  dimap_free(keymap, NULL);
   return result;
 }
 
diff --git a/src/test/test_options.c b/src/test/test_options.c
index a8ebadb..dcf97f8 100644
--- a/src/test/test_options.c
+++ b/src/test/test_options.c
@@ -8,6 +8,18 @@
 #include "confparse.h"
 #include "config.h"
 #include "test.h"
+#include "geoip.h"
+
+#define ROUTERSET_PRIVATE
+#include "routerset.h"
+
+#include "log_test_helpers.h"
+
+#include "sandbox.h"
+#include "memarea.h"
+#include "policies.h"
+
+#define NS_MODULE test_options
 
 typedef struct {
   int severity;
@@ -38,6 +50,7 @@ setup_log_callback(void)
   lst.masks[LOG_WARN - LOG_ERR] = ~0;
   lst.masks[LOG_NOTICE - LOG_ERR] = ~0;
   add_callback_log(&lst, log_cback);
+  mark_logs_temp();
 }
 
 static char *
@@ -69,22 +82,41 @@ clear_log_messages(void)
   messages = NULL;
 }
 
+#define setup_options(opt,dflt)              \
+  do {                                       \
+    opt = options_new();                     \
+    opt->command = CMD_RUN_TOR;              \
+    options_init(opt);                       \
+                                             \
+    dflt = config_dup(&options_format, opt); \
+    clear_log_messages();                    \
+  } while (0)
+
+#define VALID_DIR_AUTH "DirAuthority dizum orport=443 v3ident=E8A9C45"  \
+  "EDE6D711294FADF8E7951F4DE6CA56B58 194.109.206.212:80 7EA6 EAD6 FD83" \
+  " 083C 538F 4403 8BBF A077 587D D755\n"
+#define VALID_ALT_BRIDGE_AUTH \
+  "AlternateBridgeAuthority dizum orport=443 v3ident=E8A9C45"           \
+  "EDE6D711294FADF8E7951F4DE6CA56B58 194.109.206.212:80 7EA6 EAD6 FD83" \
+  " 083C 538F 4403 8BBF A077 587D D755\n"
+#define VALID_ALT_DIR_AUTH \
+  "AlternateDirAuthority dizum orport=443 v3ident=E8A9C45"           \
+  "EDE6D711294FADF8E7951F4DE6CA56B58 194.109.206.212:80 7EA6 EAD6 FD83" \
+  " 083C 538F 4403 8BBF A077 587D D755\n"
+
 static void
 test_options_validate_impl(const char *configuration,
                            const char *expect_errmsg,
                            int expect_log_severity,
                            const char *expect_log)
 {
-  or_options_t *opt = options_new();
+  or_options_t *opt=NULL;
   or_options_t *dflt;
   config_line_t *cl=NULL;
   char *msg=NULL;
   int r;
-  opt->command = CMD_RUN_TOR;
-  options_init(opt);
 
-  dflt = config_dup(&options_format, opt);
-  clear_log_messages();
+  setup_options(opt, dflt);
 
   r = config_get_lines(configuration, &cl, 1);
   tt_int_op(r, OP_EQ, 0);
@@ -126,6 +158,9 @@ test_options_validate_impl(const char *configuration,
   }
 
  done:
+  memarea_clear_freelist();
+  escaped(NULL);
+  policies_free_all();
   config_free_lines(cl);
   or_options_free(opt);
   or_options_free(dflt);
@@ -147,6 +182,7 @@ test_options_validate(void *arg)
 {
   (void)arg;
   setup_log_callback();
+  sandbox_disable_getaddrinfo_cache();
 
   WANT_ERR("ExtORPort 500000", "Invalid ExtORPort");
 
@@ -159,12 +195,4116 @@ test_options_validate(void *arg)
                "ServerTransportOptions did not parse",
                LOG_WARN, "\"slingsnappy\" is not a k=v");
 
+  WANT_ERR("DirPort 8080\nDirCache 0",
+           "DirPort configured but DirCache disabled.");
+  WANT_ERR("BridgeRelay 1\nDirCache 0",
+           "We're a bridge but DirCache is disabled.");
+
+  close_temp_logs();
+  clear_log_messages();
+  return;
+}
+
+#define MEGABYTEIFY(mb) (U64_LITERAL(mb) << 20)
+static void
+test_have_enough_mem_for_dircache(void *arg)
+{
+  (void)arg;
+  or_options_t *opt=NULL;
+  or_options_t *dflt;
+  config_line_t *cl=NULL;
+  char *msg=NULL;;
+  int r;
+  const char *configuration = "ORPort 8080\nDirCache 1", *expect_errmsg;
+
+  setup_options(opt, dflt);
+  setup_log_callback();
+  (void)dflt;
+
+  r = config_get_lines(configuration, &cl, 1);
+  tt_int_op(r, OP_EQ, 0);
+
+  r = config_assign(&options_format, opt, cl, 0, 0, &msg);
+  tt_int_op(r, OP_EQ, 0);
+
+  /* 300 MB RAM available, DirCache enabled */
+  r = have_enough_mem_for_dircache(opt, MEGABYTEIFY(300), &msg);
+  tt_int_op(r, OP_EQ, 0);
+  tt_assert(!msg);
+
+  /* 200 MB RAM available, DirCache enabled */
+  r = have_enough_mem_for_dircache(opt, MEGABYTEIFY(200), &msg);
+  tt_int_op(r, OP_EQ, -1);
+  expect_errmsg = "Being a directory cache (default) with less than ";
+  if (!strstr(msg, expect_errmsg)) {
+    TT_DIE(("Expected error message <%s> from <%s>, but got <%s>.",
+            expect_errmsg, configuration, msg));
+  }
+  tor_free(msg);
+
+  configuration = "ORPort 8080\nDirCache 1\nBridgeRelay 1";
+  r = config_get_lines(configuration, &cl, 1);
+  tt_int_op(r, OP_EQ, 0);
+
+  r = config_assign(&options_format, opt, cl, 0, 0, &msg);
+  tt_int_op(r, OP_EQ, 0);
+
+  /* 300 MB RAM available, DirCache enabled, Bridge */
+  r = have_enough_mem_for_dircache(opt, MEGABYTEIFY(300), &msg);
+  tt_int_op(r, OP_EQ, 0);
+  tt_assert(!msg);
+
+  /* 200 MB RAM available, DirCache enabled, Bridge */
+  r = have_enough_mem_for_dircache(opt, MEGABYTEIFY(200), &msg);
+  tt_int_op(r, OP_EQ, -1);
+  expect_errmsg = "Running a Bridge with less than ";
+  if (!strstr(msg, expect_errmsg)) {
+    TT_DIE(("Expected error message <%s> from <%s>, but got <%s>.",
+            expect_errmsg, configuration, msg));
+  }
+  tor_free(msg);
+
+  configuration = "ORPort 8080\nDirCache 0";
+  r = config_get_lines(configuration, &cl, 1);
+  tt_int_op(r, OP_EQ, 0);
+
+  r = config_assign(&options_format, opt, cl, 0, 0, &msg);
+  tt_int_op(r, OP_EQ, 0);
+
+  /* 200 MB RAM available, DirCache disabled */
+  r = have_enough_mem_for_dircache(opt, MEGABYTEIFY(200), &msg);
+  tt_int_op(r, OP_EQ, 0);
+  tt_assert(!msg);
+
+  /* 300 MB RAM available, DirCache disabled */
+  r = have_enough_mem_for_dircache(opt, MEGABYTEIFY(300), &msg);
+  tt_int_op(r, OP_EQ, -1);
+  expect_errmsg = "DirCache is disabled and we are configured as a ";
+  if (!strstr(msg, expect_errmsg)) {
+    TT_DIE(("Expected error message <%s> from <%s>, but got <%s>.",
+            expect_errmsg, configuration, msg));
+  }
+  tor_free(msg);
+
   clear_log_messages();
+
+ done:
+  if (msg)
+    tor_free(msg);
+  tor_free(dflt);
+  tor_free(opt);
+  tor_free(cl);
   return;
 }
 
+static const char *fixed_get_uname_result = NULL;
+
+static const char *
+fixed_get_uname(void)
+{
+  return fixed_get_uname_result;
+}
+
+#define TEST_OPTIONS_OLD_VALUES   "TestingV3AuthInitialVotingInterval 1800\n" \
+  "TestingClientBootstrapConsensusMaxDownloadTries 7\n" \
+  "TestingClientBootstrapConsensusAuthorityOnlyMaxDownloadTries 4\n" \
+  "TestingClientBootstrapConsensusMaxInProgressTries 3\n" \
+  "TestingV3AuthInitialVoteDelay 300\n"   \
+  "TestingV3AuthInitialDistDelay 300\n" \
+  "TestingClientMaxIntervalWithoutRequest 600\n" \
+  "TestingDirConnectionMaxStall 600\n" \
+  "TestingConsensusMaxDownloadTries 8\n" \
+  "TestingDescriptorMaxDownloadTries 8\n" \
+  "TestingMicrodescMaxDownloadTries 8\n" \
+  "TestingCertMaxDownloadTries 8\n"
+
+#define TEST_OPTIONS_DEFAULT_VALUES TEST_OPTIONS_OLD_VALUES \
+  "MaxClientCircuitsPending 1\n"                                        \
+  "RendPostPeriod 1000\n"                                               \
+  "KeepAlivePeriod 1\n"                                                 \
+  "ConnLimit 1\n"                                                       \
+  "V3AuthVotingInterval 300\n"                                          \
+  "V3AuthVoteDelay 20\n"                                                \
+  "V3AuthDistDelay 20\n"                                                \
+  "V3AuthNIntervalsValid 3\n"                                           \
+  "VirtualAddrNetworkIPv4 127.192.0.0/10\n"                             \
+  "VirtualAddrNetworkIPv6 [FE80::]/10\n"                                \
+  "SchedulerHighWaterMark__ 42\n"                                       \
+  "SchedulerLowWaterMark__ 10\n"
+
+typedef struct {
+  or_options_t *old_opt;
+  or_options_t *opt;
+  or_options_t *def_opt;
+} options_test_data_t;
+
+static void free_options_test_data(options_test_data_t *td);
+
+static options_test_data_t *
+get_options_test_data(const char *conf)
+{
+  int rv = -1;
+  char *msg = NULL;
+  config_line_t *cl=NULL;
+  options_test_data_t *result = tor_malloc(sizeof(options_test_data_t));
+  result->opt = options_new();
+  result->old_opt = options_new();
+  result->def_opt = options_new();
+  rv = config_get_lines(conf, &cl, 1);
+  tt_assert(rv == 0);
+  rv = config_assign(&options_format, result->opt, cl, 0, 0, &msg);
+  if (msg) {
+    /* Display the parse error message by comparing it with an empty string */
+    tt_str_op(msg, OP_EQ, "");
+  }
+  tt_assert(rv == 0);
+  config_free_lines(cl);
+  result->opt->LogTimeGranularity = 1;
+  result->opt->TokenBucketRefillInterval = 1;
+  rv = config_get_lines(TEST_OPTIONS_OLD_VALUES, &cl, 1);
+  tt_assert(rv == 0);
+  rv = config_assign(&options_format, result->def_opt, cl, 0, 0, &msg);
+  if (msg) {
+    /* Display the parse error message by comparing it with an empty string */
+    tt_str_op(msg, OP_EQ, "");
+  }
+  tt_assert(rv == 0);
+
+ done:
+  config_free_lines(cl);
+  if (rv != 0) {
+    free_options_test_data(result);
+    result = NULL;
+    /* Callers expect a non-NULL result, so just die if we can't provide one.
+     */
+    tor_assert(0);
+  }
+  return result;
+}
+
+static void
+free_options_test_data(options_test_data_t *td)
+{
+  if (!td) return;
+  or_options_free(td->old_opt);
+  or_options_free(td->opt);
+  or_options_free(td->def_opt);
+  tor_free(td);
+}
+
+static void
+test_options_validate__uname_for_server(void *ignored)
+{
+  (void)ignored;
+  char *msg;
+  options_test_data_t *tdata = get_options_test_data(
+                                      "ORListenAddress 127.0.0.1:5555");
+  int previous_log = setup_capture_of_logs(LOG_WARN);
+
+  MOCK(get_uname, fixed_get_uname);
+  fixed_get_uname_result = "Windows 95";
+  options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  expect_log_msg("Tor is running as a server, but you"
+           " are running Windows 95; this probably won't work. See https://www"
+           ".torproject.org/docs/faq.html#BestOSForRelay for details.\n");
+  tor_free(msg);
+
+  fixed_get_uname_result = "Windows 98";
+  mock_clean_saved_logs();
+  options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  expect_log_msg("Tor is running as a server, but you"
+           " are running Windows 98; this probably won't work. See https://www"
+           ".torproject.org/docs/faq.html#BestOSForRelay for details.\n");
+  tor_free(msg);
+
+  fixed_get_uname_result = "Windows Me";
+  mock_clean_saved_logs();
+  options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  expect_log_msg("Tor is running as a server, but you"
+           " are running Windows Me; this probably won't work. See https://www"
+           ".torproject.org/docs/faq.html#BestOSForRelay for details.\n");
+  tor_free(msg);
+
+  fixed_get_uname_result = "Windows 2000";
+  mock_clean_saved_logs();
+  options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  expect_log_entry();
+  tor_free(msg);
+
+ done:
+  UNMOCK(get_uname);
+  free_options_test_data(tdata);
+  tor_free(msg);
+  teardown_capture_of_logs(previous_log);
+}
+
+static void
+test_options_validate__outbound_addresses(void *ignored)
+{
+  (void)ignored;
+  int ret;
+  char *msg;
+  options_test_data_t *tdata = get_options_test_data(
+                                    "OutboundBindAddress xxyy!!!sdfaf");
+
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, -1);
+
+ done:
+  free_options_test_data(tdata);
+  tor_free(msg);
+}
+
+static void
+test_options_validate__data_directory(void *ignored)
+{
+  (void)ignored;
+  int ret;
+  char *msg;
+  options_test_data_t *tdata = get_options_test_data(
+                                                "DataDirectory longreallyl"
+                                                "ongLONGLONGlongreallylong"
+                                                "LONGLONGlongreallylongLON"
+                                                "GLONGlongreallylongLONGLO"
+                                                "NGlongreallylongLONGLONGl"
+                                                "ongreallylongLONGLONGlong"
+                                                "reallylongLONGLONGlongrea"
+                                                "llylongLONGLONGlongreally"
+                                                "longLONGLONGlongreallylon"
+                                                "gLONGLONGlongreallylongLO"
+                                                "NGLONGlongreallylongLONGL"
+                                                "ONGlongreallylongLONGLONG"
+                                                "longreallylongLONGLONGlon"
+                                                "greallylongLONGLONGlongre"
+                                                "allylongLONGLONGlongreall"
+                                                "ylongLONGLONGlongreallylo"
+                                                "ngLONGLONGlongreallylongL"
+                                                "ONGLONGlongreallylongLONG"
+                                                "LONG"); // 440 characters
+
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, -1);
+  tt_str_op(msg, OP_EQ, "Invalid DataDirectory");
+
+ done:
+  free_options_test_data(tdata);
+  tor_free(msg);
+}
+
+static void
+test_options_validate__nickname(void *ignored)
+{
+  (void)ignored;
+  int ret;
+  char *msg;
+  options_test_data_t *tdata = get_options_test_data(
+                                        "Nickname ThisNickNameIsABitTooLong");
+
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, -1);
+  tt_str_op(msg, OP_EQ,
+            "Nickname 'ThisNickNameIsABitTooLong' is wrong length or"
+            " contains illegal characters.");
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data("Nickname AMoreValidNick");
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, -1);
+  tt_assert(!msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data("DataDirectory /tmp/somewhere");
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, -1);
+  tt_assert(!msg);
+
+ done:
+  free_options_test_data(tdata);
+  tor_free(msg);
+}
+
+static void
+test_options_validate__contactinfo(void *ignored)
+{
+  (void)ignored;
+  int ret;
+  char *msg;
+  options_test_data_t *tdata = get_options_test_data(
+                                "ORListenAddress 127.0.0.1:5555\nORPort 955");
+  int previous_log = setup_capture_of_logs(LOG_DEBUG);
+  tdata->opt->ContactInfo = NULL;
+
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, -1);
+  expect_log_msg(
+            "Your ContactInfo config option is not"
+            " set. Please consider setting it, so we can contact you if your"
+            " server is misconfigured or something else goes wrong.\n");
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data("ORListenAddress 127.0.0.1:5555\nORPort 955\n"
+                                "ContactInfo hella@example.org");
+  mock_clean_saved_logs();
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, -1);
+  expect_no_log_msg(
+            "Your ContactInfo config option is not"
+            " set. Please consider setting it, so we can contact you if your"
+            " server is misconfigured or something else goes wrong.\n");
+  tor_free(msg);
+
+ done:
+  teardown_capture_of_logs(previous_log);
+  free_options_test_data(tdata);
+  tor_free(msg);
+}
+
+extern int quiet_level;
+
+static void
+test_options_validate__logs(void *ignored)
+{
+  (void)ignored;
+  int ret;
+  (void)ret;
+  char *msg;
+  int orig_quiet_level = quiet_level;
+  options_test_data_t *tdata = get_options_test_data("");
+  tdata->opt->Logs = NULL;
+  tdata->opt->RunAsDaemon = 0;
+
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_str_op(tdata->opt->Logs->key, OP_EQ, "Log");
+  tt_str_op(tdata->opt->Logs->value, OP_EQ, "notice stdout");
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data("");
+  tdata->opt->Logs = NULL;
+  tdata->opt->RunAsDaemon = 0;
+  quiet_level = 1;
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_str_op(tdata->opt->Logs->key, OP_EQ, "Log");
+  tt_str_op(tdata->opt->Logs->value, OP_EQ, "warn stdout");
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data("");
+  tdata->opt->Logs = NULL;
+  tdata->opt->RunAsDaemon = 0;
+  quiet_level = 2;
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_assert(!tdata->opt->Logs);
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data("");
+  tdata->opt->Logs = NULL;
+  tdata->opt->RunAsDaemon = 0;
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 1, &msg);
+  tt_assert(!tdata->opt->Logs);
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data("");
+  tdata->opt->Logs = NULL;
+  tdata->opt->RunAsDaemon = 1;
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_assert(!tdata->opt->Logs);
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data("");
+  tdata->opt->RunAsDaemon = 0;
+  config_line_t *cl=NULL;
+  config_get_lines("Log foo", &cl, 1);
+  tdata->opt->Logs = cl;
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op((intptr_t)tdata->opt->Logs, OP_EQ, (intptr_t)cl);
+
+ done:
+  quiet_level = orig_quiet_level;
+  free_options_test_data(tdata);
+  tor_free(msg);
+}
+
+/* static config_line_t * */
+/* mock_config_line(const char *key, const char *val) */
+/* { */
+/*   config_line_t *config_line = tor_malloc(sizeof(config_line_t)); */
+/*   memset(config_line, 0, sizeof(config_line_t)); */
+/*   config_line->key = tor_strdup(key); */
+/*   config_line->value = tor_strdup(val); */
+/*   return config_line; */
+/* } */
+
+static void
+test_options_validate__authdir(void *ignored)
+{
+  (void)ignored;
+  int ret;
+  char *msg;
+  int previous_log = setup_capture_of_logs(LOG_INFO);
+  options_test_data_t *tdata = get_options_test_data(
+                                 "AuthoritativeDirectory 1\n"
+                                 "Address this.should.not_exist.example.org");
+
+  sandbox_disable_getaddrinfo_cache();
+
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, -1);
+  tt_str_op(msg, OP_EQ, "Failed to resolve/guess local address. See logs for"
+            " details.");
+  expect_log_msg("Could not resolve local Address "
+            "'this.should.not_exist.example.org'. Failing.\n");
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data("AuthoritativeDirectory 1\n"
+                                "Address 100.200.10.1");
+  mock_clean_saved_logs();
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, -1);
+  tt_assert(!msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data("AuthoritativeDirectory 1\n"
+                                "Address 100.200.10.1\n"
+                                "SchedulerHighWaterMark__ 42\n"
+                                "SchedulerLowWaterMark__ 10\n");
+  mock_clean_saved_logs();
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, -1);
+  tt_str_op(msg, OP_EQ,
+            "Authoritative directory servers must set ContactInfo");
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data("AuthoritativeDirectory 1\n"
+                                "Address 100.200.10.1\n"
+                                "TestingTorNetwork 1\n"
+                                "SchedulerHighWaterMark__ 42\n"
+                                "SchedulerLowWaterMark__ 10\n");
+  mock_clean_saved_logs();
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, -1);
+  tt_str_op(msg, OP_EQ, "AuthoritativeDir is set, but none of (Bridge/V3)"
+            "AuthoritativeDir is set.");
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data("AuthoritativeDirectory 1\n"
+                                "Address 100.200.10.1\n"
+                                "ContactInfo hello@hello.com\n"
+                                "SchedulerHighWaterMark__ 42\n"
+                                "SchedulerLowWaterMark__ 10\n");
+  mock_clean_saved_logs();
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, -1);
+  tt_str_op(msg, OP_EQ, "AuthoritativeDir is set, but none of (Bridge/V3)"
+            "AuthoritativeDir is set.");
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data("AuthoritativeDirectory 1\n"
+                                "Address 100.200.10.1\n"
+                                "RecommendedVersions 1.2, 3.14\n"
+                                "ContactInfo hello@hello.com\n"
+                                "SchedulerHighWaterMark__ 42\n"
+                                "SchedulerLowWaterMark__ 10\n");
+  mock_clean_saved_logs();
+  options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_str_op(tdata->opt->RecommendedClientVersions->value, OP_EQ, "1.2, 3.14");
+  tt_str_op(tdata->opt->RecommendedServerVersions->value, OP_EQ, "1.2, 3.14");
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data("AuthoritativeDirectory 1\n"
+                                "Address 100.200.10.1\n"
+                                "RecommendedVersions 1.2, 3.14\n"
+                                "RecommendedClientVersions 25\n"
+                                "RecommendedServerVersions 4.18\n"
+                                "ContactInfo hello@hello.com\n"
+                                "SchedulerHighWaterMark__ 42\n"
+                                "SchedulerLowWaterMark__ 10\n");
+  mock_clean_saved_logs();
+  options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_str_op(tdata->opt->RecommendedClientVersions->value, OP_EQ, "25");
+  tt_str_op(tdata->opt->RecommendedServerVersions->value, OP_EQ, "4.18");
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data("AuthoritativeDirectory 1\n"
+                                "Address 100.200.10.1\n"
+                                "VersioningAuthoritativeDirectory 1\n"
+                                "RecommendedVersions 1.2, 3.14\n"
+                                "RecommendedClientVersions 25\n"
+                                "RecommendedServerVersions 4.18\n"
+                                "ContactInfo hello@hello.com\n"
+                                "SchedulerHighWaterMark__ 42\n"
+                                "SchedulerLowWaterMark__ 10\n");
+  mock_clean_saved_logs();
+  options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_str_op(msg, OP_EQ, "AuthoritativeDir is set, but none of (Bridge/V3)"
+            "AuthoritativeDir is set.");
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data("AuthoritativeDirectory 1\n"
+                                "Address 100.200.10.1\n"
+                                "VersioningAuthoritativeDirectory 1\n"
+                                "RecommendedServerVersions 4.18\n"
+                                "ContactInfo hello@hello.com\n"
+                                "SchedulerHighWaterMark__ 42\n"
+                                "SchedulerLowWaterMark__ 10\n");
+  mock_clean_saved_logs();
+  options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_str_op(msg, OP_EQ, "Versioning authoritative dir servers must set "
+            "Recommended*Versions.");
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data("AuthoritativeDirectory 1\n"
+                                "Address 100.200.10.1\n"
+                                "VersioningAuthoritativeDirectory 1\n"
+                                "RecommendedClientVersions 4.18\n"
+                                "ContactInfo hello@hello.com\n"
+                                "SchedulerHighWaterMark__ 42\n"
+                                "SchedulerLowWaterMark__ 10\n");
+  mock_clean_saved_logs();
+  options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_str_op(msg, OP_EQ, "Versioning authoritative dir servers must set "
+            "Recommended*Versions.");
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data("AuthoritativeDirectory 1\n"
+                                "Address 100.200.10.1\n"
+                                "UseEntryGuards 1\n"
+                                "ContactInfo hello@hello.com\n"
+                                "SchedulerHighWaterMark__ 42\n"
+                                "SchedulerLowWaterMark__ 10\n");
+  mock_clean_saved_logs();
+  options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  expect_log_msg("Authoritative directory servers "
+            "can't set UseEntryGuards. Disabling.\n");
+  tt_int_op(tdata->opt->UseEntryGuards, OP_EQ, 0);
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data("AuthoritativeDirectory 1\n"
+                                "Address 100.200.10.1\n"
+                                "V3AuthoritativeDir 1\n"
+                                "ContactInfo hello@hello.com\n"
+                                "SchedulerHighWaterMark__ 42\n"
+                                "SchedulerLowWaterMark__ 10\n");
+  mock_clean_saved_logs();
+  options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  expect_log_msg("Authoritative directories always try"
+            " to download extra-info documents. Setting DownloadExtraInfo.\n");
+  tt_int_op(tdata->opt->DownloadExtraInfo, OP_EQ, 1);
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data("AuthoritativeDirectory 1\n"
+                                "Address 100.200.10.1\n"
+                                "DownloadExtraInfo 1\n"
+                                "V3AuthoritativeDir 1\n"
+                                "ContactInfo hello@hello.com\n"
+                                "SchedulerHighWaterMark__ 42\n"
+                                "SchedulerLowWaterMark__ 10\n");
+  mock_clean_saved_logs();
+  options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  expect_no_log_msg("Authoritative directories always try"
+            " to download extra-info documents. Setting DownloadExtraInfo.\n");
+  tt_int_op(tdata->opt->DownloadExtraInfo, OP_EQ, 1);
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data("AuthoritativeDirectory 1\n"
+                                "Address 100.200.10.1\n"
+                                "ContactInfo hello@hello.com\n"
+                                "SchedulerHighWaterMark__ 42\n"
+                                "SchedulerLowWaterMark__ 10\n");
+  mock_clean_saved_logs();
+  options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_str_op(msg, OP_EQ, "AuthoritativeDir is set, but none of (Bridge/V3)"
+            "AuthoritativeDir is set.");
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data("AuthoritativeDirectory 1\n"
+                                "Address 100.200.10.1\n"
+                                "BridgeAuthoritativeDir 1\n"
+                                "ContactInfo hello@hello.com\n"
+                                "V3BandwidthsFile non-existant-file\n"
+                                "SchedulerHighWaterMark__ 42\n"
+                                "SchedulerLowWaterMark__ 10\n");
+  mock_clean_saved_logs();
+  options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_str_op(msg, OP_EQ,
+            "Running as authoritative directory, but no DirPort set.");
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data("AuthoritativeDirectory 1\n"
+                                "Address 100.200.10.1\n"
+                                "BridgeAuthoritativeDir 1\n"
+                                "ContactInfo hello@hello.com\n"
+                                "V3BandwidthsFile non-existant-file\n"
+                                "SchedulerHighWaterMark__ 42\n"
+                                "SchedulerLowWaterMark__ 10\n");
+  mock_clean_saved_logs();
+  options_validate(NULL, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_str_op(msg, OP_EQ,
+            "Running as authoritative directory, but no DirPort set.");
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data("AuthoritativeDirectory 1\n"
+                                "Address 100.200.10.1\n"
+                                "BridgeAuthoritativeDir 1\n"
+                                "ContactInfo hello@hello.com\n"
+                                "GuardfractionFile non-existant-file\n"
+                                "SchedulerHighWaterMark__ 42\n"
+                                "SchedulerLowWaterMark__ 10\n");
+  mock_clean_saved_logs();
+  options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_str_op(msg, OP_EQ,
+            "Running as authoritative directory, but no DirPort set.");
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data("AuthoritativeDirectory 1\n"
+                                "Address 100.200.10.1\n"
+                                "BridgeAuthoritativeDir 1\n"
+                                "ContactInfo hello@hello.com\n"
+                                "GuardfractionFile non-existant-file\n"
+                                "SchedulerHighWaterMark__ 42\n"
+                                "SchedulerLowWaterMark__ 10\n");
+  mock_clean_saved_logs();
+  options_validate(NULL, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_str_op(msg, OP_EQ,
+            "Running as authoritative directory, but no DirPort set.");
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data("AuthoritativeDirectory 1\n"
+                                "Address 100.200.10.1\n"
+                                "BridgeAuthoritativeDir 1\n"
+                                "ContactInfo hello@hello.com\n"
+                                "SchedulerHighWaterMark__ 42\n"
+                                "SchedulerLowWaterMark__ 10\n");
+  mock_clean_saved_logs();
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, -1);
+  tt_str_op(msg, OP_EQ,
+            "Running as authoritative directory, but no DirPort set.");
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data("AuthoritativeDirectory 1\n"
+                                "Address 100.200.10.1\n"
+                                "DirPort 999\n"
+                                "BridgeAuthoritativeDir 1\n"
+                                "ContactInfo hello@hello.com\n"
+                                "SchedulerHighWaterMark__ 42\n"
+                                "SchedulerLowWaterMark__ 10\n");
+  mock_clean_saved_logs();
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, -1);
+  tt_str_op(msg, OP_EQ,
+            "Running as authoritative directory, but no ORPort set.");
+  tor_free(msg);
+
+  // TODO: This case can't be reached, since clientonly is used to
+  // check when parsing port lines as well.
+  /* free_options_test_data(tdata); */
+  /* tdata = get_options_test_data("AuthoritativeDirectory 1\n" */
+  /*                               "Address 100.200.10.1\n" */
+  /*                               "DirPort 999\n" */
+  /*                               "ORPort 888\n" */
+  /*                               "ClientOnly 1\n" */
+  /*                               "BridgeAuthoritativeDir 1\n" */
+  /*                               "ContactInfo hello@hello.com\n" */
+  /*                               "SchedulerHighWaterMark__ 42\n" */
+  /*                               "SchedulerLowWaterMark__ 10\n"); */
+  /* mock_clean_saved_logs(); */
+  /* ret = options_validate(tdata->old_opt, tdata->opt, */
+  /*                        tdata->def_opt, 0, &msg); */
+  /* tt_int_op(ret, OP_EQ, -1); */
+  /* tt_str_op(msg, OP_EQ, "Running as authoritative directory, " */
+  /*           "but ClientOnly also set."); */
+
+ done:
+  teardown_capture_of_logs(previous_log);
+  //  sandbox_free_getaddrinfo_cache();
+  free_options_test_data(tdata);
+  tor_free(msg);
+}
+
+static void
+test_options_validate__relay_with_hidden_services(void *ignored)
+{
+  (void)ignored;
+  char *msg;
+  int previous_log = setup_capture_of_logs(LOG_DEBUG);
+  options_test_data_t *tdata = get_options_test_data(
+                                  "ORListenAddress 127.0.0.1:5555\n"
+                                  "ORPort 955\n"
+                                  "HiddenServiceDir "
+                                  "/Library/Tor/var/lib/tor/hidden_service/\n"
+                                  "HiddenServicePort 80 127.0.0.1:8080\n"
+                                                     );
+
+  options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  expect_log_msg(
+            "Tor is currently configured as a relay and a hidden service. "
+            "That's not very secure: you should probably run your hidden servi"
+            "ce in a separate Tor process, at least -- see "
+            "https://trac.torproject.org/8742\n");
+
+ done:
+  teardown_capture_of_logs(previous_log);
+  free_options_test_data(tdata);
+  tor_free(msg);
+}
+
+// TODO: it doesn't seem possible to hit the case of having no port lines at
+// all, since there will be a default created for SocksPort
+/* static void */
+/* test_options_validate__ports(void *ignored) */
+/* { */
+/*   (void)ignored; */
+/*   int ret; */
+/*   char *msg; */
+/*   int previous_log = setup_capture_of_logs(LOG_WARN); */
+/*   options_test_data_t *tdata = get_options_test_data(""); */
+/*   ret = options_validate(tdata->old_opt, tdata->opt, */
+/*                          tdata->def_opt, 0, &msg); */
+/*   expect_log_msg("SocksPort, TransPort, NATDPort, DNSPort, and ORPort " */
+/*           "are all undefined, and there aren't any hidden services " */
+/*           "configured. " */
+/*           " Tor will still run, but probably won't do anything.\n"); */
+/*  done: */
+/*   teardown_capture_of_logs(previous_log); */
+/*   free_options_test_data(tdata); */
+/*   tor_free(msg); */
+/* } */
+
+static void
+test_options_validate__transproxy(void *ignored)
+{
+  (void)ignored;
+  int ret;
+  char *msg;
+  options_test_data_t *tdata;
+
+#ifdef USE_TRANSPARENT
+  // Test default trans proxy
+  tdata = get_options_test_data("TransProxyType default\n");
+
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, -1);
+  tt_int_op(tdata->opt->TransProxyType_parsed, OP_EQ, TPT_DEFAULT);
+  tor_free(msg);
+
+  // Test pf-divert trans proxy
+  free_options_test_data(tdata);
+  tdata = get_options_test_data("TransProxyType pf-divert\n");
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, -1);
+
+#if !defined(__OpenBSD__) && !defined( DARWIN )
+  tt_str_op(msg, OP_EQ,
+          "pf-divert is a OpenBSD-specific and OS X/Darwin-specific feature.");
+#else
+  tt_int_op(tdata->opt->TransProxyType_parsed, OP_EQ, TPT_PF_DIVERT);
+  tt_str_op(msg, OP_EQ, "Cannot use TransProxyType without "
+            "any valid TransPort or TransListenAddress.");
+#endif
+  tor_free(msg);
+
+  // Test tproxy trans proxy
+  free_options_test_data(tdata);
+  tdata = get_options_test_data("TransProxyType tproxy\n");
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, -1);
+
+#if !defined(__linux__)
+  tt_str_op(msg, OP_EQ, "TPROXY is a Linux-specific feature.");
+#else
+  tt_int_op(tdata->opt->TransProxyType_parsed, OP_EQ, TPT_TPROXY);
+  tt_str_op(msg, OP_EQ, "Cannot use TransProxyType without any valid "
+            "TransPort or TransListenAddress.");
+#endif
+  tor_free(msg);
+
+  // Test ipfw trans proxy
+  free_options_test_data(tdata);
+  tdata = get_options_test_data("TransProxyType ipfw\n");
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, -1);
+
+#if !defined(__FreeBSD__) && !defined( DARWIN )
+  tt_str_op(msg, OP_EQ, "ipfw is a FreeBSD-specificand OS X/Darwin-specific "
+            "feature.");
+#else
+  tt_int_op(tdata->opt->TransProxyType_parsed, OP_EQ, TPT_IPFW);
+  tt_str_op(msg, OP_EQ, "Cannot use TransProxyType without any valid "
+            "TransPort or TransListenAddress.");
+#endif
+  tor_free(msg);
+
+  // Test unknown trans proxy
+  free_options_test_data(tdata);
+  tdata = get_options_test_data("TransProxyType non-existant\n");
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, -1);
+  tt_str_op(msg, OP_EQ, "Unrecognized value for TransProxyType");
+  tor_free(msg);
+
+  // Test trans proxy success
+  free_options_test_data(tdata);
+
+#if defined(linux)
+  tdata = get_options_test_data("TransProxyType tproxy\n"
+                                "TransPort 127.0.0.1:123\n");
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, -1);
+  tt_assert(!msg);
+#endif
+#if defined(__FreeBSD__) || defined( DARWIN )
+  tdata = get_options_test_data("TransProxyType ipfw\n"
+                                "TransPort 127.0.0.1:123\n");
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, -1);
+  tt_assert(!msg);
+#endif
+#if defined(__OpenBSD__)
+  tdata = get_options_test_data("TransProxyType pf-divert\n"
+                                "TransPort 127.0.0.1:123\n");
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, -1);
+  tt_assert(!msg);
+#endif
+
+#else
+  tdata = get_options_test_data("TransPort 127.0.0.1:555\n");
+
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, -1);
+  tt_str_op(msg, OP_EQ, "TransPort and TransListenAddress are disabled in "
+            "this build.");
+  tor_free(msg);
+#endif
+
+ done:
+  free_options_test_data(tdata);
+  tor_free(msg);
+}
+
+NS_DECL(country_t, geoip_get_country, (const char *country));
+
+static country_t
+NS(geoip_get_country)(const char *countrycode)
+{
+  (void)countrycode;
+  CALLED(geoip_get_country)++;
+
+  return 1;
+}
+
+static void
+test_options_validate__exclude_nodes(void *ignored)
+{
+  (void)ignored;
+
+  NS_MOCK(geoip_get_country);
+
+  int ret;
+  char *msg;
+  int previous_log = setup_capture_of_logs(LOG_WARN);
+  options_test_data_t *tdata = get_options_test_data(
+                                                  "ExcludeExitNodes {us}\n");
+
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, -1);
+  tt_int_op(smartlist_len(tdata->opt->ExcludeExitNodesUnion_->list), OP_EQ, 1);
+  tt_str_op((char *)
+            (smartlist_get(tdata->opt->ExcludeExitNodesUnion_->list, 0)),
+            OP_EQ, "{us}");
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data("ExcludeNodes {cn}\n");
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, -1);
+  tt_int_op(smartlist_len(tdata->opt->ExcludeExitNodesUnion_->list), OP_EQ, 1);
+  tt_str_op((char *)
+            (smartlist_get(tdata->opt->ExcludeExitNodesUnion_->list, 0)),
+            OP_EQ, "{cn}");
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data("ExcludeNodes {cn}\n"
+                                "ExcludeExitNodes {us} {cn}\n");
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, -1);
+  tt_int_op(smartlist_len(tdata->opt->ExcludeExitNodesUnion_->list), OP_EQ, 2);
+  tt_str_op((char *)
+            (smartlist_get(tdata->opt->ExcludeExitNodesUnion_->list, 0)),
+            OP_EQ, "{us} {cn}");
+  tt_str_op((char *)
+            (smartlist_get(tdata->opt->ExcludeExitNodesUnion_->list, 1)),
+            OP_EQ, "{cn}");
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data("ExcludeNodes {cn}\n"
+                                "StrictNodes 1\n"
+                                "SchedulerHighWaterMark__ 42\n"
+                                "SchedulerLowWaterMark__ 10\n");
+  mock_clean_saved_logs();
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, -1);
+  expect_log_msg(
+            "You have asked to exclude certain relays from all positions "
+            "in your circuits. Expect hidden services and other Tor "
+            "features to be broken in unpredictable ways.\n");
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data("ExcludeNodes {cn}\n"
+                                "SchedulerHighWaterMark__ 42\n"
+                                "SchedulerLowWaterMark__ 10\n");
+  mock_clean_saved_logs();
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, -1);
+  expect_no_log_msg(
+            "You have asked to exclude certain relays from all positions "
+            "in your circuits. Expect hidden services and other Tor "
+            "features to be broken in unpredictable ways.\n");
+  tor_free(msg);
+
+ done:
+  NS_UNMOCK(geoip_get_country);
+  teardown_capture_of_logs(previous_log);
+  free_options_test_data(tdata);
+  tor_free(msg);
+}
+
+static void
+test_options_validate__scheduler(void *ignored)
+{
+  (void)ignored;
+  int ret;
+  char *msg;
+  int previous_log = setup_capture_of_logs(LOG_DEBUG);
+  options_test_data_t *tdata = get_options_test_data(
+                                            "SchedulerLowWaterMark__ 0\n");
+
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, -1);
+  expect_log_msg("Bad SchedulerLowWaterMark__ option\n");
+  tor_free(msg);
+
+  // TODO: this test cannot run on platforms where UINT32_MAX == UINT64_MAX.
+  // I suspect it's unlikely this branch can actually happen
+  /* free_options_test_data(tdata); */
+  /* tdata = get_options_test_data( */
+  /*                      "SchedulerLowWaterMark 10000000000000000000\n"); */
+  /* tdata->opt->SchedulerLowWaterMark__ = (uint64_t)UINT32_MAX; */
+  /* tdata->opt->SchedulerLowWaterMark__++; */
+  /* mock_clean_saved_logs(); */
+  /* ret = options_validate(tdata->old_opt, tdata->opt, */
+  /*                        tdata->def_opt, 0, &msg); */
+  /* tt_int_op(ret, OP_EQ, -1); */
+  /* expect_log_msg("Bad SchedulerLowWaterMark__ option\n"); */
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data("SchedulerLowWaterMark__ 42\n"
+                                "SchedulerHighWaterMark__ 42\n");
+  mock_clean_saved_logs();
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, -1);
+  expect_log_msg("Bad SchedulerHighWaterMark option\n");
+  tor_free(msg);
+
+ done:
+  teardown_capture_of_logs(previous_log);
+  free_options_test_data(tdata);
+  tor_free(msg);
+}
+
+static void
+test_options_validate__node_families(void *ignored)
+{
+  (void)ignored;
+  int ret;
+  char *msg;
+  options_test_data_t *tdata = get_options_test_data(
+                                     "NodeFamily flux, flax\n"
+                                     "NodeFamily somewhere\n"
+                                     "SchedulerHighWaterMark__ 42\n"
+                                     "SchedulerLowWaterMark__ 10\n");
+
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, -1);
+  tt_assert(tdata->opt->NodeFamilySets);
+  tt_int_op(smartlist_len(tdata->opt->NodeFamilySets), OP_EQ, 2);
+  tt_str_op((char *)(smartlist_get(
+    ((routerset_t *)smartlist_get(tdata->opt->NodeFamilySets, 0))->list, 0)),
+            OP_EQ, "flux");
+  tt_str_op((char *)(smartlist_get(
+    ((routerset_t *)smartlist_get(tdata->opt->NodeFamilySets, 0))->list, 1)),
+            OP_EQ, "flax");
+  tt_str_op((char *)(smartlist_get(
+    ((routerset_t *)smartlist_get(tdata->opt->NodeFamilySets, 1))->list, 0)),
+            OP_EQ, "somewhere");
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data("SchedulerHighWaterMark__ 42\n"
+                                "SchedulerLowWaterMark__ 10\n");
+
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, -1);
+  tt_assert(!tdata->opt->NodeFamilySets);
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data("NodeFamily !flux\n"
+                                "SchedulerHighWaterMark__ 42\n"
+                                "SchedulerLowWaterMark__ 10\n");
+
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, -1);
+  tt_assert(tdata->opt->NodeFamilySets);
+  tt_int_op(smartlist_len(tdata->opt->NodeFamilySets), OP_EQ, 0);
+  tor_free(msg);
+
+ done:
+  free_options_test_data(tdata);
+  tor_free(msg);
+}
+
+static void
+test_options_validate__tlsec(void *ignored)
+{
+  (void)ignored;
+  int ret;
+  char *msg;
+  int previous_log = setup_capture_of_logs(LOG_DEBUG);
+  options_test_data_t *tdata = get_options_test_data(
+                                 "TLSECGroup ed25519\n"
+                                 "SchedulerHighWaterMark__ 42\n"
+                                 "SchedulerLowWaterMark__ 10\n");
+
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, -1);
+  expect_log_msg("Unrecognized TLSECGroup: Falling back to the default.\n");
+  tt_assert(!tdata->opt->TLSECGroup);
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data("TLSECGroup P224\n"
+                                "SchedulerHighWaterMark__ 42\n"
+                                "SchedulerLowWaterMark__ 10\n");
+  mock_clean_saved_logs();
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, -1);
+  expect_no_log_msg(
+            "Unrecognized TLSECGroup: Falling back to the default.\n");
+  tt_assert(tdata->opt->TLSECGroup);
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data("TLSECGroup P256\n"
+                                "SchedulerHighWaterMark__ 42\n"
+                                "SchedulerLowWaterMark__ 10\n");
+  mock_clean_saved_logs();
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, -1);
+  expect_no_log_msg(
+            "Unrecognized TLSECGroup: Falling back to the default.\n");
+  tt_assert(tdata->opt->TLSECGroup);
+  tor_free(msg);
+
+ done:
+  teardown_capture_of_logs(previous_log);
+  free_options_test_data(tdata);
+  tor_free(msg);
+}
+
+static void
+test_options_validate__token_bucket(void *ignored)
+{
+  (void)ignored;
+  int ret;
+  char *msg;
+  options_test_data_t *tdata = get_options_test_data("");
+
+  tdata->opt->TokenBucketRefillInterval = 0;
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, -1);
+  tt_str_op(msg, OP_EQ,
+            "TokenBucketRefillInterval must be between 1 and 1000 inclusive.");
+  tor_free(msg);
+
+  tdata->opt->TokenBucketRefillInterval = 1001;
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, -1);
+  tt_str_op(msg, OP_EQ,
+            "TokenBucketRefillInterval must be between 1 and 1000 inclusive.");
+  tor_free(msg);
+
+ done:
+  free_options_test_data(tdata);
+  tor_free(msg);
+}
+
+static void
+test_options_validate__recommended_packages(void *ignored)
+{
+  (void)ignored;
+  int ret;
+  char *msg;
+  int previous_log = setup_capture_of_logs(LOG_WARN);
+  options_test_data_t *tdata = get_options_test_data(
+            "RecommendedPackages foo 1.2 http://foo.com sha1=123123123123\n"
+            "RecommendedPackages invalid-package-line\n"
+            "SchedulerHighWaterMark__ 42\n"
+            "SchedulerLowWaterMark__ 10\n");
+
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, -1);
+  expect_no_log_msg("Invalid RecommendedPackage line "
+            "invalid-package-line will be ignored\n");
+
+ done:
+  escaped(NULL); // This will free the leaking memory from the previous escaped
+  teardown_capture_of_logs(previous_log);
+  free_options_test_data(tdata);
+  tor_free(msg);
+}
+
+static void
+test_options_validate__fetch_dir(void *ignored)
+{
+  (void)ignored;
+  int ret;
+  char *msg;
+  options_test_data_t *tdata = get_options_test_data(
+                                            "FetchDirInfoExtraEarly 1\n"
+                                            "FetchDirInfoEarly 0\n"
+                                            "SchedulerHighWaterMark__ 42\n"
+                                            "SchedulerLowWaterMark__ 10\n");
+
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, -1);
+  tt_str_op(msg, OP_EQ, "FetchDirInfoExtraEarly requires that you"
+            " also set FetchDirInfoEarly");
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data("FetchDirInfoExtraEarly 1\n"
+                                "FetchDirInfoEarly 1\n"
+                                "SchedulerHighWaterMark__ 42\n"
+                                "SchedulerLowWaterMark__ 10\n");
+
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, -1);
+  tt_str_op(msg, OP_NE, "FetchDirInfoExtraEarly requires that you"
+            " also set FetchDirInfoEarly");
+  tor_free(msg);
+
+ done:
+  free_options_test_data(tdata);
+  tor_free(msg);
+}
+
+static void
+test_options_validate__conn_limit(void *ignored)
+{
+  (void)ignored;
+  int ret;
+  char *msg;
+  options_test_data_t *tdata = get_options_test_data(
+                                            "ConnLimit 0\n"
+                                            "SchedulerHighWaterMark__ 42\n"
+                                            "SchedulerLowWaterMark__ 10\n");
+
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, -1);
+  tt_str_op(msg, OP_EQ, "ConnLimit must be greater than 0, but was set to 0");
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data("ConnLimit 1\n"
+                                "SchedulerHighWaterMark__ 42\n"
+                                "SchedulerLowWaterMark__ 10\n");
+
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, -1);
+  tt_str_op(msg, OP_EQ, "MaxClientCircuitsPending must be between 1 and 1024, "
+            "but was set to 0");
+  tor_free(msg);
+
+ done:
+  free_options_test_data(tdata);
+  tor_free(msg);
+}
+
+static void
+test_options_validate__paths_needed(void *ignored)
+{
+  (void)ignored;
+  int ret;
+  char *msg;
+  int previous_log = setup_capture_of_logs(LOG_WARN);
+  options_test_data_t *tdata = get_options_test_data(
+                                      "PathsNeededToBuildCircuits 0.1\n"
+                                      "ConnLimit 1\n"
+                                      "SchedulerHighWaterMark__ 42\n"
+                                      "SchedulerLowWaterMark__ 10\n");
+
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, -1);
+  tt_assert(tdata->opt->PathsNeededToBuildCircuits > 0.24 &&
+            tdata->opt->PathsNeededToBuildCircuits < 0.26);
+  expect_log_msg("PathsNeededToBuildCircuits is too low. "
+                 "Increasing to 0.25\n");
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  mock_clean_saved_logs();
+  tdata = get_options_test_data("PathsNeededToBuildCircuits 0.99\n"
+                                "ConnLimit 1\n"
+                                "SchedulerHighWaterMark__ 42\n"
+                                "SchedulerLowWaterMark__ 10\n");
+
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, -1);
+  tt_assert(tdata->opt->PathsNeededToBuildCircuits > 0.94 &&
+            tdata->opt->PathsNeededToBuildCircuits < 0.96);
+  expect_log_msg("PathsNeededToBuildCircuits is "
+            "too high. Decreasing to 0.95\n");
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  mock_clean_saved_logs();
+  tdata = get_options_test_data("PathsNeededToBuildCircuits 0.91\n"
+                                "ConnLimit 1\n"
+                                "SchedulerHighWaterMark__ 42\n"
+                                "SchedulerLowWaterMark__ 10\n");
+
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, -1);
+  tt_assert(tdata->opt->PathsNeededToBuildCircuits > 0.90 &&
+            tdata->opt->PathsNeededToBuildCircuits < 0.92);
+  expect_no_log_entry();
+  tor_free(msg);
+
+ done:
+  teardown_capture_of_logs(previous_log);
+  free_options_test_data(tdata);
+  tor_free(msg);
+}
+
+static void
+test_options_validate__max_client_circuits(void *ignored)
+{
+  (void)ignored;
+  int ret;
+  char *msg;
+  options_test_data_t *tdata = get_options_test_data(
+                                           "MaxClientCircuitsPending 0\n"
+                                           "ConnLimit 1\n"
+                                           "SchedulerHighWaterMark__ 42\n"
+                                           "SchedulerLowWaterMark__ 10\n");
+
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, -1);
+  tt_str_op(msg, OP_EQ, "MaxClientCircuitsPending must be between 1 and 1024,"
+            " but was set to 0");
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data("MaxClientCircuitsPending 1025\n"
+                                "ConnLimit 1\n"
+                                "SchedulerHighWaterMark__ 42\n"
+                                "SchedulerLowWaterMark__ 10\n");
+
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, -1);
+  tt_str_op(msg, OP_EQ, "MaxClientCircuitsPending must be between 1 and 1024,"
+            " but was set to 1025");
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data("MaxClientCircuitsPending 1\n"
+                                "ConnLimit 1\n"
+                                "SchedulerHighWaterMark__ 42\n"
+                                "SchedulerLowWaterMark__ 10\n");
+
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, -1);
+  tt_str_op(msg, OP_EQ, "KeepalivePeriod option must be positive.");
+  tor_free(msg);
+
+ done:
+  free_options_test_data(tdata);
+  tor_free(msg);
+}
+
+static void
+test_options_validate__ports(void *ignored)
+{
+  (void)ignored;
+  int ret;
+  char *msg;
+  options_test_data_t *tdata = get_options_test_data(
+                                      "FirewallPorts 65537\n"
+                                      "MaxClientCircuitsPending 1\n"
+                                      "ConnLimit 1\n"
+                                      "SchedulerHighWaterMark__ 42\n"
+                                      "SchedulerLowWaterMark__ 10\n");
+
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, -1);
+  tt_str_op(msg, OP_EQ, "Port '65537' out of range in FirewallPorts");
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data("FirewallPorts 1\n"
+                                "LongLivedPorts 124444\n"
+                                "MaxClientCircuitsPending 1\n"
+                                "ConnLimit 1\n"
+                                "SchedulerHighWaterMark__ 42\n"
+                                "SchedulerLowWaterMark__ 10\n");
+
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, -1);
+  tt_str_op(msg, OP_EQ, "Port '124444' out of range in LongLivedPorts");
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data("FirewallPorts 1\n"
+                                "LongLivedPorts 2\n"
+                                "RejectPlaintextPorts 112233\n"
+                                "MaxClientCircuitsPending 1\n"
+                                "ConnLimit 1\n"
+                                "SchedulerHighWaterMark__ 42\n"
+                                "SchedulerLowWaterMark__ 10\n");
+
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, -1);
+  tt_str_op(msg, OP_EQ, "Port '112233' out of range in RejectPlaintextPorts");
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data("FirewallPorts 1\n"
+                                "LongLivedPorts 2\n"
+                                "RejectPlaintextPorts 3\n"
+                                "WarnPlaintextPorts 65536\n"
+                                "MaxClientCircuitsPending 1\n"
+                                "ConnLimit 1\n"
+                                "SchedulerHighWaterMark__ 42\n"
+                                "SchedulerLowWaterMark__ 10\n");
+
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, -1);
+  tt_str_op(msg, OP_EQ, "Port '65536' out of range in WarnPlaintextPorts");
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data("FirewallPorts 1\n"
+                                "LongLivedPorts 2\n"
+                                "RejectPlaintextPorts 3\n"
+                                "WarnPlaintextPorts 4\n"
+                                "MaxClientCircuitsPending 1\n"
+                                "ConnLimit 1\n"
+                                "SchedulerHighWaterMark__ 42\n"
+                                "SchedulerLowWaterMark__ 10\n");
+
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, -1);
+  tt_str_op(msg, OP_EQ, "KeepalivePeriod option must be positive.");
+  tor_free(msg);
+
+ done:
+  free_options_test_data(tdata);
+  tor_free(msg);
+}
+
+static void
+test_options_validate__reachable_addresses(void *ignored)
+{
+  (void)ignored;
+  int ret;
+  char *msg;
+  int previous_log = setup_capture_of_logs(LOG_NOTICE);
+  options_test_data_t *tdata = get_options_test_data(
+                                     "FascistFirewall 1\n"
+                                     "MaxClientCircuitsPending 1\n"
+                                     "ConnLimit 1\n"
+                                     "SchedulerHighWaterMark__ 42\n"
+                                     "SchedulerLowWaterMark__ 10\n");
+
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, -1);
+  expect_log_msg("Converting FascistFirewall config "
+            "option to new format: \"ReachableDirAddresses *:80\"\n");
+  tt_str_op(tdata->opt->ReachableDirAddresses->value, OP_EQ, "*:80");
+  expect_log_msg("Converting FascistFirewall config "
+            "option to new format: \"ReachableORAddresses *:443\"\n");
+  tt_str_op(tdata->opt->ReachableORAddresses->value, OP_EQ, "*:443");
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  mock_clean_saved_logs();
+  tdata = get_options_test_data("FascistFirewall 1\n"
+                                "ReachableDirAddresses *:81\n"
+                                "ReachableORAddresses *:444\n"
+                                "MaxClientCircuitsPending 1\n"
+                                "ConnLimit 1\n"
+                                "SchedulerHighWaterMark__ 42\n"
+                                "SchedulerLowWaterMark__ 10\n");
+  tdata->opt->FirewallPorts = smartlist_new();
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, -1);
+  expect_log_entry();
+  tt_str_op(tdata->opt->ReachableDirAddresses->value, OP_EQ, "*:81");
+  tt_str_op(tdata->opt->ReachableORAddresses->value, OP_EQ, "*:444");
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  mock_clean_saved_logs();
+  tdata = get_options_test_data("FascistFirewall 1\n"
+                                "FirewallPort 123\n"
+                                "MaxClientCircuitsPending 1\n"
+                                "ConnLimit 1\n"
+                                "SchedulerHighWaterMark__ 42\n"
+                                "SchedulerLowWaterMark__ 10\n");
+
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, -1);
+  expect_log_msg("Converting FascistFirewall and "
+            "FirewallPorts config options to new format: "
+            "\"ReachableAddresses *:123\"\n");
+  tt_str_op(tdata->opt->ReachableAddresses->value, OP_EQ, "*:123");
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  mock_clean_saved_logs();
+  tdata = get_options_test_data("FascistFirewall 1\n"
+                                "ReachableAddresses *:82\n"
+                                "ReachableAddresses *:83\n"
+                                "ReachableAddresses reject *:*\n"
+                                "MaxClientCircuitsPending 1\n"
+                                "ConnLimit 1\n"
+                                "SchedulerHighWaterMark__ 42\n"
+                                "SchedulerLowWaterMark__ 10\n");
+
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, -1);
+  expect_log_entry();
+  tt_str_op(tdata->opt->ReachableAddresses->value, OP_EQ, "*:82");
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data("ReachableAddresses *:82\n"
+                                "ORListenAddress 127.0.0.1:5555\n"
+                                "ORPort 955\n"
+                                "MaxClientCircuitsPending 1\n"
+                                "ConnLimit 1\n"
+                                "SchedulerHighWaterMark__ 42\n"
+                                "SchedulerLowWaterMark__ 10\n");
+
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, -1);
+  tt_str_op(msg, OP_EQ, "Servers must be able to freely connect to the rest of"
+            " the Internet, so they must not set Reachable*Addresses or"
+            " FascistFirewall.");
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data("ReachableORAddresses *:82\n"
+                                "ORListenAddress 127.0.0.1:5555\n"
+                                "ORPort 955\n"
+                                "MaxClientCircuitsPending 1\n"
+                                "ConnLimit 1\n"
+                                "SchedulerHighWaterMark__ 42\n"
+                                "SchedulerLowWaterMark__ 10\n");
+
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, -1);
+  tt_str_op(msg, OP_EQ, "Servers must be able to freely connect to the rest of"
+            " the Internet, so they must not set Reachable*Addresses or"
+            " FascistFirewall.");
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data("ReachableDirAddresses *:82\n"
+                                "ORListenAddress 127.0.0.1:5555\n"
+                                "ORPort 955\n"
+                                "MaxClientCircuitsPending 1\n"
+                                "ConnLimit 1\n"
+                                "SchedulerHighWaterMark__ 42\n"
+                                "SchedulerLowWaterMark__ 10\n");
+
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, -1);
+  tt_str_op(msg, OP_EQ, "Servers must be able to freely connect to the rest of"
+            " the Internet, so they must not set Reachable*Addresses or"
+            " FascistFirewall.");
+  tor_free(msg);
+
+ done:
+  teardown_capture_of_logs(previous_log);
+  free_options_test_data(tdata);
+  tor_free(msg);
+}
+
+static void
+test_options_validate__use_bridges(void *ignored)
+{
+  (void)ignored;
+  int ret;
+  char *msg;
+  options_test_data_t *tdata = get_options_test_data(
+                                   "UseBridges 1\n"
+                                   "ORListenAddress 127.0.0.1:5555\n"
+                                   "ORPort 955\n"
+                                   "MaxClientCircuitsPending 1\n"
+                                   "ConnLimit 1\n"
+                                   "SchedulerHighWaterMark__ 42\n"
+                                   "SchedulerLowWaterMark__ 10\n");
+
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, -1);
+  tt_str_op(msg, OP_EQ, "Servers must be able to freely connect to the rest of"
+            " the Internet, so they must not set UseBridges.");
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data("UseBridges 1\n"
+                                "MaxClientCircuitsPending 1\n"
+                                "ConnLimit 1\n"
+                                "SchedulerHighWaterMark__ 42\n"
+                                "SchedulerLowWaterMark__ 10\n");
+
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, -1);
+  tt_str_op(msg, OP_NE, "Servers must be able to freely connect to the rest of"
+            " the Internet, so they must not set UseBridges.");
+  tor_free(msg);
+
+  NS_MOCK(geoip_get_country);
+  free_options_test_data(tdata);
+  tdata = get_options_test_data("UseBridges 1\n"
+                                "EntryNodes {cn}\n"
+                                "MaxClientCircuitsPending 1\n"
+                                "ConnLimit 1\n"
+                                "SchedulerHighWaterMark__ 42\n"
+                                "SchedulerLowWaterMark__ 10\n");
+
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, -1);
+  tt_str_op(msg, OP_EQ, "You cannot set both UseBridges and EntryNodes.");
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data(TEST_OPTIONS_DEFAULT_VALUES
+                                "UseBridges 1\n");
+
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, -1);
+  tt_str_op(msg, OP_EQ,
+            "If you set UseBridges, you must specify at least one bridge.");
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data(TEST_OPTIONS_DEFAULT_VALUES
+                                "UseBridges 1\n"
+                                "Bridge 10.0.0.1\n"
+                                "Bridge !!!\n"
+                                );
+
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, -1);
+  tt_str_op(msg, OP_EQ, "Bridge line did not parse. See logs for details.");
+  tor_free(msg);
+
+ done:
+  NS_UNMOCK(geoip_get_country);
+  memarea_clear_freelist();
+  policies_free_all();
+  free_options_test_data(tdata);
+  tor_free(msg);
+}
+
+static void
+test_options_validate__entry_nodes(void *ignored)
+{
+  (void)ignored;
+  int ret;
+  char *msg;
+  NS_MOCK(geoip_get_country);
+  options_test_data_t *tdata = get_options_test_data(
+                                         "EntryNodes {cn}\n"
+                                         "UseEntryGuards 0\n"
+                                         "MaxClientCircuitsPending 1\n"
+                                         "ConnLimit 1\n"
+                                         "SchedulerHighWaterMark__ 42\n"
+                                         "SchedulerLowWaterMark__ 10\n");
+
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, -1);
+  tt_str_op(msg, OP_EQ,
+            "If EntryNodes is set, UseEntryGuards must be enabled.");
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data("EntryNodes {cn}\n"
+                                "UseEntryGuards 1\n"
+                                "MaxClientCircuitsPending 1\n"
+                                "ConnLimit 1\n"
+                                "SchedulerHighWaterMark__ 42\n"
+                                "SchedulerLowWaterMark__ 10\n");
+
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, -1);
+  tt_str_op(msg, OP_EQ, "KeepalivePeriod option must be positive.");
+  tor_free(msg);
+
+ done:
+  NS_UNMOCK(geoip_get_country);
+  free_options_test_data(tdata);
+  tor_free(msg);
+}
+
+static void
+test_options_validate__invalid_nodes(void *ignored)
+{
+  (void)ignored;
+  int ret;
+  char *msg;
+  options_test_data_t *tdata = get_options_test_data(
+                                  "AllowInvalidNodes something_stupid\n"
+                                  "MaxClientCircuitsPending 1\n"
+                                  "ConnLimit 1\n"
+                                  "SchedulerHighWaterMark__ 42\n"
+                                  "SchedulerLowWaterMark__ 10\n");
+
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, -1);
+  tt_str_op(msg, OP_EQ,
+            "Unrecognized value 'something_stupid' in AllowInvalidNodes");
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data("AllowInvalidNodes entry, middle, exit\n"
+                                "MaxClientCircuitsPending 1\n"
+                                "ConnLimit 1\n"
+                                "SchedulerHighWaterMark__ 42\n"
+                                "SchedulerLowWaterMark__ 10\n");
+
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, -1);
+  tt_int_op(tdata->opt->AllowInvalid_, OP_EQ, ALLOW_INVALID_ENTRY |
+            ALLOW_INVALID_EXIT | ALLOW_INVALID_MIDDLE);
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data("AllowInvalidNodes introduction, rendezvous\n"
+                                "MaxClientCircuitsPending 1\n"
+                                "ConnLimit 1\n"
+                                "SchedulerHighWaterMark__ 42\n"
+                                "SchedulerLowWaterMark__ 10\n");
+
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, -1);
+  tt_int_op(tdata->opt->AllowInvalid_, OP_EQ, ALLOW_INVALID_INTRODUCTION |
+            ALLOW_INVALID_RENDEZVOUS);
+  tor_free(msg);
+
+ done:
+  free_options_test_data(tdata);
+  tor_free(msg);
+}
+
+static void
+test_options_validate__safe_logging(void *ignored)
+{
+  (void)ignored;
+  int ret;
+  char *msg;
+  options_test_data_t *tdata = get_options_test_data(
+                                            "MaxClientCircuitsPending 1\n"
+                                            "ConnLimit 1\n"
+                                            "SchedulerHighWaterMark__ 42\n"
+                                            "SchedulerLowWaterMark__ 10\n");
+
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, -1);
+  tt_int_op(tdata->opt->SafeLogging_, OP_EQ, SAFELOG_SCRUB_NONE);
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data("SafeLogging 0\n"
+                                "MaxClientCircuitsPending 1\n"
+                                "ConnLimit 1\n"
+                                "SchedulerHighWaterMark__ 42\n"
+                                "SchedulerLowWaterMark__ 10\n");
+
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, -1);
+  tt_int_op(tdata->opt->SafeLogging_, OP_EQ, SAFELOG_SCRUB_NONE);
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data("SafeLogging Relay\n"
+                                "MaxClientCircuitsPending 1\n"
+                                "ConnLimit 1\n"
+                                "SchedulerHighWaterMark__ 42\n"
+                                "SchedulerLowWaterMark__ 10\n");
+
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, -1);
+  tt_int_op(tdata->opt->SafeLogging_, OP_EQ, SAFELOG_SCRUB_RELAY);
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data("SafeLogging 1\n"
+                                "MaxClientCircuitsPending 1\n"
+                                "ConnLimit 1\n"
+                                "SchedulerHighWaterMark__ 42\n"
+                                "SchedulerLowWaterMark__ 10\n");
+
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, -1);
+  tt_int_op(tdata->opt->SafeLogging_, OP_EQ, SAFELOG_SCRUB_ALL);
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data("SafeLogging stuffy\n"
+                                "MaxClientCircuitsPending 1\n"
+                                "ConnLimit 1\n"
+                                "SchedulerHighWaterMark__ 42\n"
+                                "SchedulerLowWaterMark__ 10\n");
+
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, -1);
+  tt_str_op(msg, OP_EQ, "Unrecognized value '\"stuffy\"' in SafeLogging");
+  tor_free(msg);
+
+ done:
+  escaped(NULL); // This will free the leaking memory from the previous escaped
+  free_options_test_data(tdata);
+  tor_free(msg);
+}
+
+static void
+test_options_validate__publish_server_descriptor(void *ignored)
+{
+  (void)ignored;
+  int ret;
+  char *msg;
+  int previous_log = setup_capture_of_logs(LOG_WARN);
+  options_test_data_t *tdata = get_options_test_data(
+             "PublishServerDescriptor bridge\n" TEST_OPTIONS_DEFAULT_VALUES
+                                                     );
+
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, 0);
+  tt_assert(!msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data("PublishServerDescriptor humma\n"
+                                TEST_OPTIONS_DEFAULT_VALUES);
+
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, -1);
+  tt_str_op(msg, OP_EQ, "Unrecognized value in PublishServerDescriptor");
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data("PublishServerDescriptor bridge, v3\n"
+                                TEST_OPTIONS_DEFAULT_VALUES);
+
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, -1);
+  tt_str_op(msg, OP_EQ, "Bridges are not supposed to publish router "
+            "descriptors to the directory authorities. Please correct your "
+            "PublishServerDescriptor line.");
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data("BridgeRelay 1\n"
+                                "PublishServerDescriptor v3\n"
+                                TEST_OPTIONS_DEFAULT_VALUES);
+
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, -1);
+  tt_str_op(msg, OP_EQ, "Bridges are not supposed to publish router "
+            "descriptors to the directory authorities. Please correct your "
+            "PublishServerDescriptor line.");
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data("BridgeRelay 1\n" TEST_OPTIONS_DEFAULT_VALUES);
+
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, -1);
+  tt_str_op(msg, OP_NE, "Bridges are not supposed to publish router "
+            "descriptors to the directory authorities. Please correct your "
+            "PublishServerDescriptor line.");
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data("BridgeRelay 1\n"
+                                "DirPort 999\n" TEST_OPTIONS_DEFAULT_VALUES);
+
+  mock_clean_saved_logs();
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, -1);
+  expect_log_msg("Can't set a DirPort on a bridge "
+            "relay; disabling DirPort\n");
+  tt_assert(!tdata->opt->DirPort_lines);
+  tt_assert(!tdata->opt->DirPort_set);
+
+ done:
+  teardown_capture_of_logs(previous_log);
+  memarea_clear_freelist();
+  policies_free_all();
+  free_options_test_data(tdata);
+  tor_free(msg);
+}
+
+static void
+test_options_validate__testing(void *ignored)
+{
+  (void)ignored;
+  int ret;
+  char *msg;
+  options_test_data_t *tdata = NULL;
+
+#define ENSURE_DEFAULT(varname, varval)                     \
+  STMT_BEGIN                                                \
+    free_options_test_data(tdata);                          \
+  tdata = get_options_test_data(TEST_OPTIONS_DEFAULT_VALUES \
+                                #varname " " #varval "\n"); \
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);\
+  tt_str_op(msg, OP_EQ, \
+            #varname " may only be changed in testing Tor networks!");  \
+  tt_int_op(ret, OP_EQ, -1);                                            \
+  tor_free(msg);                                                        \
+                                                \
+  free_options_test_data(tdata); \
+  tdata = get_options_test_data(TEST_OPTIONS_DEFAULT_VALUES \
+                                #varname " " #varval "\n"               \
+                                VALID_DIR_AUTH                          \
+                                "TestingTorNetwork 1\n");               \
+                                                                        \
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);\
+  if (msg) { \
+    tt_str_op(msg, OP_NE, \
+              #varname " may only be changed in testing Tor networks!"); \
+    tor_free(msg); \
+  } \
+                                                                        \
+  free_options_test_data(tdata);          \
+  tdata = get_options_test_data(TEST_OPTIONS_DEFAULT_VALUES \
+                                #varname " " #varval "\n"           \
+                                "___UsingTestNetworkDefaults 1\n"); \
+                                                                        \
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);\
+  if (msg) { \
+    tt_str_op(msg, OP_NE, \
+              #varname " may only be changed in testing Tor networks!"); \
+    tor_free(msg); \
+  } \
+    STMT_END
+
+  ENSURE_DEFAULT(TestingV3AuthInitialVotingInterval, 3600);
+  ENSURE_DEFAULT(TestingV3AuthInitialVoteDelay, 3000);
+  ENSURE_DEFAULT(TestingV3AuthInitialDistDelay, 3000);
+  ENSURE_DEFAULT(TestingV3AuthVotingStartOffset, 3000);
+  ENSURE_DEFAULT(TestingAuthDirTimeToLearnReachability, 3000);
+  ENSURE_DEFAULT(TestingEstimatedDescriptorPropagationTime, 3000);
+  ENSURE_DEFAULT(TestingServerDownloadSchedule, 3000);
+  ENSURE_DEFAULT(TestingClientDownloadSchedule, 3000);
+  ENSURE_DEFAULT(TestingServerConsensusDownloadSchedule, 3000);
+  ENSURE_DEFAULT(TestingClientConsensusDownloadSchedule, 3000);
+  ENSURE_DEFAULT(TestingBridgeDownloadSchedule, 3000);
+  ENSURE_DEFAULT(TestingClientMaxIntervalWithoutRequest, 3000);
+  ENSURE_DEFAULT(TestingDirConnectionMaxStall, 3000);
+  ENSURE_DEFAULT(TestingConsensusMaxDownloadTries, 3000);
+  ENSURE_DEFAULT(TestingDescriptorMaxDownloadTries, 3000);
+  ENSURE_DEFAULT(TestingMicrodescMaxDownloadTries, 3000);
+  ENSURE_DEFAULT(TestingCertMaxDownloadTries, 3000);
+  ENSURE_DEFAULT(TestingAuthKeyLifetime, 3000);
+  ENSURE_DEFAULT(TestingLinkCertLifetime, 3000);
+  ENSURE_DEFAULT(TestingSigningKeySlop, 3000);
+  ENSURE_DEFAULT(TestingAuthKeySlop, 3000);
+  ENSURE_DEFAULT(TestingLinkKeySlop, 3000);
+
+ done:
+  escaped(NULL); // This will free the leaking memory from the previous escaped
+  memarea_clear_freelist();
+  policies_free_all();
+  free_options_test_data(tdata);
+  tor_free(msg);
+}
+
+static void
+test_options_validate__hidserv(void *ignored)
+{
+  (void)ignored;
+  int ret;
+  char *msg;
+  int previous_log = setup_capture_of_logs(LOG_WARN);
+
+  options_test_data_t *tdata = get_options_test_data(
+                                                TEST_OPTIONS_DEFAULT_VALUES);
+  tdata->opt->MinUptimeHidServDirectoryV2 = -1;
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, 0);
+  expect_log_msg("MinUptimeHidServDirectoryV2 "
+            "option must be at least 0 seconds. Changing to 0.\n");
+  tt_int_op(tdata->opt->MinUptimeHidServDirectoryV2, OP_EQ, 0);
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data(TEST_OPTIONS_DEFAULT_VALUES
+                                "RendPostPeriod 1\n" );
+  mock_clean_saved_logs();
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, 0);
+  expect_log_msg("RendPostPeriod option is too short;"
+            " raising to 600 seconds.\n");
+  tt_int_op(tdata->opt->RendPostPeriod, OP_EQ, 600);
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data(TEST_OPTIONS_DEFAULT_VALUES
+                                "RendPostPeriod 302401\n" );
+  mock_clean_saved_logs();
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, 0);
+  expect_log_msg("RendPostPeriod is too large; "
+            "clipping to 302400s.\n");
+  tt_int_op(tdata->opt->RendPostPeriod, OP_EQ, 302400);
+  tor_free(msg);
+
+ done:
+  teardown_capture_of_logs(previous_log);
+  memarea_clear_freelist();
+  policies_free_all();
+  free_options_test_data(tdata);
+  tor_free(msg);
+}
+
+static void
+test_options_validate__predicted_ports(void *ignored)
+{
+  (void)ignored;
+  int ret;
+  char *msg;
+  int previous_log = setup_capture_of_logs(LOG_WARN);
+
+  options_test_data_t *tdata = get_options_test_data(
+                                     "PredictedPortsRelevanceTime 100000000\n"
+                                     TEST_OPTIONS_DEFAULT_VALUES);
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, 0);
+  expect_log_msg("PredictedPortsRelevanceTime is too "
+            "large; clipping to 3600s.\n");
+  tt_int_op(tdata->opt->PredictedPortsRelevanceTime, OP_EQ, 3600);
+
+ done:
+  teardown_capture_of_logs(previous_log);
+  memarea_clear_freelist();
+  policies_free_all();
+  free_options_test_data(tdata);
+  tor_free(msg);
+}
+
+static void
+test_options_validate__path_bias(void *ignored)
+{
+  (void)ignored;
+  int ret;
+  char *msg;
+
+  options_test_data_t *tdata = get_options_test_data(
+                                            TEST_OPTIONS_DEFAULT_VALUES
+                                            "PathBiasNoticeRate 1.1\n");
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, -1);
+  tt_str_op(msg, OP_EQ,
+            "PathBiasNoticeRate is too high. It must be between 0 and 1.0");
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data(TEST_OPTIONS_DEFAULT_VALUES
+                                "PathBiasWarnRate 1.1\n");
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, -1);
+  tt_str_op(msg, OP_EQ,
+            "PathBiasWarnRate is too high. It must be between 0 and 1.0");
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data(TEST_OPTIONS_DEFAULT_VALUES
+                                "PathBiasExtremeRate 1.1\n");
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, -1);
+  tt_str_op(msg, OP_EQ,
+            "PathBiasExtremeRate is too high. It must be between 0 and 1.0");
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data(TEST_OPTIONS_DEFAULT_VALUES
+                                "PathBiasNoticeUseRate 1.1\n");
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, -1);
+  tt_str_op(msg, OP_EQ,
+            "PathBiasNoticeUseRate is too high. It must be between 0 and 1.0");
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data(TEST_OPTIONS_DEFAULT_VALUES
+                                "PathBiasExtremeUseRate 1.1\n");
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, -1);
+  tt_str_op(msg, OP_EQ,
+           "PathBiasExtremeUseRate is too high. It must be between 0 and 1.0");
+  tor_free(msg);
+
+ done:
+  free_options_test_data(tdata);
+  tor_free(msg);
+}
+
+static void
+test_options_validate__bandwidth(void *ignored)
+{
+  (void)ignored;
+  int ret;
+  char *msg;
+  options_test_data_t *tdata = NULL;
+
+#define ENSURE_BANDWIDTH_PARAM(p) \
+  STMT_BEGIN                                                \
+  free_options_test_data(tdata); \
+  tdata = get_options_test_data(TEST_OPTIONS_DEFAULT_VALUES #p " 3Gb\n"); \
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);\
+  tt_int_op(ret, OP_EQ, -1); \
+  tt_mem_op(msg, OP_EQ, #p " (3221225471) must be at most 2147483647", 40); \
+  tor_free(msg); \
+  STMT_END
+
+  ENSURE_BANDWIDTH_PARAM(BandwidthRate);
+  ENSURE_BANDWIDTH_PARAM(BandwidthBurst);
+  ENSURE_BANDWIDTH_PARAM(MaxAdvertisedBandwidth);
+  ENSURE_BANDWIDTH_PARAM(RelayBandwidthRate);
+  ENSURE_BANDWIDTH_PARAM(RelayBandwidthBurst);
+  ENSURE_BANDWIDTH_PARAM(PerConnBWRate);
+  ENSURE_BANDWIDTH_PARAM(PerConnBWBurst);
+  ENSURE_BANDWIDTH_PARAM(AuthDirFastGuarantee);
+  ENSURE_BANDWIDTH_PARAM(AuthDirGuardBWGuarantee);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data(TEST_OPTIONS_DEFAULT_VALUES
+                                "RelayBandwidthRate 1000\n");
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, 0);
+  tt_u64_op(tdata->opt->RelayBandwidthBurst, OP_EQ, 1000);
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data(TEST_OPTIONS_DEFAULT_VALUES
+                                "RelayBandwidthBurst 1001\n");
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, 0);
+  tt_u64_op(tdata->opt->RelayBandwidthRate, OP_EQ, 1001);
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data(TEST_OPTIONS_DEFAULT_VALUES
+                                "RelayBandwidthRate 1001\n"
+                                "RelayBandwidthBurst 1000\n");
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, -1);
+  tt_str_op(msg, OP_EQ, "RelayBandwidthBurst must be at least equal to "
+            "RelayBandwidthRate.");
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data(TEST_OPTIONS_DEFAULT_VALUES
+                                "BandwidthRate 1001\n"
+                                "BandwidthBurst 1000\n");
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, -1);
+  tt_str_op(msg, OP_EQ,
+            "BandwidthBurst must be at least equal to BandwidthRate.");
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data(TEST_OPTIONS_DEFAULT_VALUES
+                                "RelayBandwidthRate 1001\n"
+                                "BandwidthRate 1000\n"
+                                "BandwidthBurst 1000\n"
+                                );
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, 0);
+  tt_u64_op(tdata->opt->BandwidthRate, OP_EQ, 1001);
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data(TEST_OPTIONS_DEFAULT_VALUES
+                                "RelayBandwidthRate 1001\n"
+                                "BandwidthRate 1000\n"
+                                "RelayBandwidthBurst 1001\n"
+                                "BandwidthBurst 1000\n"
+                                );
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, 0);
+  tt_u64_op(tdata->opt->BandwidthBurst, OP_EQ, 1001);
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data(TEST_OPTIONS_DEFAULT_VALUES
+                                "ORListenAddress 127.0.0.1:5555\n"
+                                "ORPort 955\n"
+                                "BandwidthRate 1\n"
+                                );
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, -1);
+  tt_str_op(msg, OP_EQ, "BandwidthRate is set to 1 bytes/second. For servers,"
+            " it must be at least 76800.");
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data(TEST_OPTIONS_DEFAULT_VALUES
+                                "ORListenAddress 127.0.0.1:5555\n"
+                                "ORPort 955\n"
+                                "BandwidthRate 76800\n"
+                                "MaxAdvertisedBandwidth 30000\n"
+                                );
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, -1);
+  tt_str_op(msg, OP_EQ, "MaxAdvertisedBandwidth is set to 30000 bytes/second."
+            " For servers, it must be at least 38400.");
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data(TEST_OPTIONS_DEFAULT_VALUES
+                                "ORListenAddress 127.0.0.1:5555\n"
+                                "ORPort 955\n"
+                                "BandwidthRate 76800\n"
+                                "RelayBandwidthRate 1\n"
+                                "MaxAdvertisedBandwidth 38400\n"
+                                );
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, -1);
+  tt_str_op(msg, OP_EQ, "RelayBandwidthRate is set to 1 bytes/second. For "
+            "servers, it must be at least 76800.");
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data(TEST_OPTIONS_DEFAULT_VALUES
+                                "ORListenAddress 127.0.0.1:5555\n"
+                                "ORPort 955\n"
+                                "BandwidthRate 76800\n"
+                                "BandwidthBurst 76800\n"
+                                "RelayBandwidthRate 76800\n"
+                                "MaxAdvertisedBandwidth 38400\n"
+                                );
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, 0);
+  tor_free(msg);
+
+ done:
+  memarea_clear_freelist();
+  policies_free_all();
+  free_options_test_data(tdata);
+  tor_free(msg);
+}
+
+static void
+test_options_validate__circuits(void *ignored)
+{
+  (void)ignored;
+  char *msg;
+  options_test_data_t *tdata = NULL;
+  int previous_log = setup_capture_of_logs(LOG_WARN);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data(TEST_OPTIONS_DEFAULT_VALUES
+                                "MaxCircuitDirtiness 2592001\n");
+  options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  expect_log_msg("MaxCircuitDirtiness option is too "
+            "high; setting to 30 days.\n");
+  tt_int_op(tdata->opt->MaxCircuitDirtiness, OP_EQ, 2592000);
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  mock_clean_saved_logs();
+  tdata = get_options_test_data(TEST_OPTIONS_DEFAULT_VALUES
+                                "CircuitStreamTimeout 1\n");
+  options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  expect_log_msg("CircuitStreamTimeout option is too"
+            " short; raising to 10 seconds.\n");
+  tt_int_op(tdata->opt->CircuitStreamTimeout, OP_EQ, 10);
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  mock_clean_saved_logs();
+  tdata = get_options_test_data(TEST_OPTIONS_DEFAULT_VALUES
+                                "CircuitStreamTimeout 111\n");
+  options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  expect_no_log_msg("CircuitStreamTimeout option is too"
+            " short; raising to 10 seconds.\n");
+  tt_int_op(tdata->opt->CircuitStreamTimeout, OP_EQ, 111);
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  mock_clean_saved_logs();
+  tdata = get_options_test_data(TEST_OPTIONS_DEFAULT_VALUES
+                                "HeartbeatPeriod 1\n");
+  options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  expect_log_msg("HeartbeatPeriod option is too short;"
+            " raising to 1800 seconds.\n");
+  tt_int_op(tdata->opt->HeartbeatPeriod, OP_EQ, 1800);
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  mock_clean_saved_logs();
+  tdata = get_options_test_data(TEST_OPTIONS_DEFAULT_VALUES
+                                "HeartbeatPeriod 1982\n");
+  options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  expect_no_log_msg("HeartbeatPeriod option is too short;"
+            " raising to 1800 seconds.\n");
+  tt_int_op(tdata->opt->HeartbeatPeriod, OP_EQ, 1982);
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  mock_clean_saved_logs();
+  tdata = get_options_test_data(TEST_OPTIONS_DEFAULT_VALUES
+                                "CircuitBuildTimeout 1\n"
+                                );
+  options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  expect_log_msg("CircuitBuildTimeout is shorter (1"
+            " seconds) than the recommended minimum (10 seconds), and "
+            "LearnCircuitBuildTimeout is disabled.  If tor isn't working, "
+            "raise this value or enable LearnCircuitBuildTimeout.\n");
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  mock_clean_saved_logs();
+  tdata = get_options_test_data(TEST_OPTIONS_DEFAULT_VALUES
+                                "CircuitBuildTimeout 11\n"
+                                );
+  options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  expect_no_log_msg("CircuitBuildTimeout is shorter (1 "
+            "seconds) than the recommended minimum (10 seconds), and "
+            "LearnCircuitBuildTimeout is disabled.  If tor isn't working, "
+            "raise this value or enable LearnCircuitBuildTimeout.\n");
+  tor_free(msg);
+
+ done:
+  memarea_clear_freelist();
+  policies_free_all();
+  teardown_capture_of_logs(previous_log);
+  free_options_test_data(tdata);
+  tor_free(msg);
+}
+
+static void
+test_options_validate__port_forwarding(void *ignored)
+{
+  (void)ignored;
+  int ret;
+  char *msg;
+  options_test_data_t *tdata = NULL;
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data(TEST_OPTIONS_DEFAULT_VALUES
+                                "PortForwarding 1\nSandbox 1\n");
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, -1);
+  tt_str_op(msg, OP_EQ, "PortForwarding is not compatible with Sandbox;"
+            " at most one can be set");
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data(TEST_OPTIONS_DEFAULT_VALUES
+                                "PortForwarding 1\nSandbox 0\n");
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, 0);
+  tt_assert(!msg);
+  tor_free(msg);
+
+ done:
+  free_options_test_data(tdata);
+  memarea_clear_freelist();
+  policies_free_all();
+  tor_free(msg);
+}
+
+static void
+test_options_validate__tor2web(void *ignored)
+{
+  (void)ignored;
+  int ret;
+  char *msg;
+  options_test_data_t *tdata = NULL;
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data(TEST_OPTIONS_DEFAULT_VALUES
+                                "Tor2webRendezvousPoints 1\n");
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, -1);
+  tt_str_op(msg, OP_EQ,
+            "Tor2webRendezvousPoints cannot be set without Tor2webMode.");
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data(TEST_OPTIONS_DEFAULT_VALUES
+                                "Tor2webRendezvousPoints 1\nTor2webMode 1\n");
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, 0);
+  tor_free(msg);
+
+ done:
+  memarea_clear_freelist();
+  policies_free_all();
+  free_options_test_data(tdata);
+  tor_free(msg);
+}
+
+static void
+test_options_validate__rend(void *ignored)
+{
+  (void)ignored;
+  int ret;
+  char *msg;
+  options_test_data_t *tdata = NULL;
+  int previous_log = setup_capture_of_logs(LOG_WARN);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data(TEST_OPTIONS_DEFAULT_VALUES
+                 "UseEntryGuards 0\n"
+                 "HiddenServiceDir /Library/Tor/var/lib/tor/hidden_service/\n"
+                 "HiddenServicePort 80 127.0.0.1:8080\n"
+                                );
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, 0);
+  expect_log_msg("UseEntryGuards is disabled, but you"
+            " have configured one or more hidden services on this Tor "
+            "instance.  Your hidden services will be very easy to locate using"
+            " a well-known attack -- see http://freehaven.net/anonbib/#hs-"
+            "attack06 for details.\n");
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data(
+            TEST_OPTIONS_DEFAULT_VALUES
+            "UseEntryGuards 1\n"
+            "HiddenServiceDir /Library/Tor/var/lib/tor/hidden_service/\n"
+            "HiddenServicePort 80 127.0.0.1:8080\n"
+                                );
+  mock_clean_saved_logs();
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, 0);
+  expect_no_log_msg("UseEntryGuards is disabled, but you"
+            " have configured one or more hidden services on this Tor "
+            "instance.  Your hidden services will be very easy to locate using"
+            " a well-known attack -- see http://freehaven.net/anonbib/#hs-"
+            "attack06 for details.\n");
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data(TEST_OPTIONS_DEFAULT_VALUES
+                                "HiddenServicePort 80 127.0.0.1:8080\n"
+                                );
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, -1);
+  tt_str_op(msg, OP_EQ,
+            "Failed to configure rendezvous options. See logs for details.");
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data(TEST_OPTIONS_DEFAULT_VALUES
+                                "HidServAuth failed\n"
+                                );
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, -1);
+  tt_str_op(msg, OP_EQ, "Failed to configure client authorization for hidden "
+            "services. See logs for details.");
+  tor_free(msg);
+
+ done:
+  memarea_clear_freelist();
+  policies_free_all();
+  teardown_capture_of_logs(previous_log);
+  free_options_test_data(tdata);
+  tor_free(msg);
+}
+
+static void
+test_options_validate__accounting(void *ignored)
+{
+  (void)ignored;
+  int ret;
+  char *msg;
+  options_test_data_t *tdata = NULL;
+  int previous_log = setup_capture_of_logs(LOG_WARN);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data(TEST_OPTIONS_DEFAULT_VALUES
+                                "AccountingRule something_bad\n"
+                                );
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, -1);
+  tt_str_op(msg, OP_EQ, "AccountingRule must be 'sum', 'max', 'in', or 'out'");
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data(TEST_OPTIONS_DEFAULT_VALUES
+                                "AccountingRule sum\n"
+                                );
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, 0);
+  tt_int_op(tdata->opt->AccountingRule, OP_EQ, ACCT_SUM);
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data(TEST_OPTIONS_DEFAULT_VALUES
+                                "AccountingRule max\n"
+                                );
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, 0);
+  tt_int_op(tdata->opt->AccountingRule, OP_EQ, ACCT_MAX);
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data(TEST_OPTIONS_DEFAULT_VALUES
+                                "AccountingStart fail\n"
+                                );
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, -1);
+  tt_str_op(msg, OP_EQ,
+            "Failed to parse accounting options. See logs for details.");
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data(TEST_OPTIONS_DEFAULT_VALUES
+                                "AccountingMax 10\n"
+                                );
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, 0);
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data(
+           TEST_OPTIONS_DEFAULT_VALUES
+           "ORListenAddress 127.0.0.1:5555\n"
+           "ORPort 955\n"
+           "BandwidthRate 76800\n"
+           "BandwidthBurst 76800\n"
+           "MaxAdvertisedBandwidth 38400\n"
+           "HiddenServiceDir /Library/Tor/var/lib/tor/hidden_service/\n"
+           "HiddenServicePort 80 127.0.0.1:8080\n"
+           "AccountingMax 10\n"
+                                );
+  mock_clean_saved_logs();
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, 0);
+  expect_log_msg("Using accounting with a hidden "
+            "service and an ORPort is risky: your hidden service(s) and "
+            "your public address will all turn off at the same time, "
+            "which may alert observers that they are being run by the "
+            "same party.\n");
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data(
+                TEST_OPTIONS_DEFAULT_VALUES
+                "HiddenServiceDir /Library/Tor/var/lib/tor/hidden_service/\n"
+                "HiddenServicePort 80 127.0.0.1:8080\n"
+                "AccountingMax 10\n"
+                                );
+  mock_clean_saved_logs();
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, 0);
+  expect_no_log_msg("Using accounting with a hidden "
+            "service and an ORPort is risky: your hidden service(s) and "
+            "your public address will all turn off at the same time, "
+            "which may alert observers that they are being run by the "
+            "same party.\n");
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data(
+             TEST_OPTIONS_DEFAULT_VALUES
+             "HiddenServiceDir /Library/Tor/var/lib/tor/hidden_service/\n"
+             "HiddenServicePort 80 127.0.0.1:8080\n"
+             "HiddenServiceDir /Library/Tor/var/lib/tor/hidden_service2/\n"
+             "HiddenServicePort 81 127.0.0.1:8081\n"
+             "AccountingMax 10\n"
+                                );
+  mock_clean_saved_logs();
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, 0);
+  expect_log_msg("Using accounting with multiple "
+            "hidden services is risky: they will all turn off at the same"
+            " time, which may alert observers that they are being run by "
+            "the same party.\n");
+  tor_free(msg);
+
+ done:
+  teardown_capture_of_logs(previous_log);
+  memarea_clear_freelist();
+  policies_free_all();
+  free_options_test_data(tdata);
+  tor_free(msg);
+}
+
+static void
+test_options_validate__proxy(void *ignored)
+{
+  (void)ignored;
+  int ret;
+  char *msg;
+  options_test_data_t *tdata = NULL;
+  sandbox_disable_getaddrinfo_cache();
+  int previous_log = setup_capture_of_logs(LOG_WARN);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data(TEST_OPTIONS_DEFAULT_VALUES
+                                "HttpProxy 127.0.42.1\n"
+                                );
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, 0);
+  tt_int_op(tdata->opt->HTTPProxyPort, OP_EQ, 80);
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data(TEST_OPTIONS_DEFAULT_VALUES
+                                "HttpProxy 127.0.42.1:444\n"
+                                );
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, 0);
+  tt_int_op(tdata->opt->HTTPProxyPort, OP_EQ, 444);
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data(TEST_OPTIONS_DEFAULT_VALUES
+                                "HttpProxy not_so_valid!\n"
+                                );
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, -1);
+  tt_str_op(msg, OP_EQ, "HTTPProxy failed to parse or resolve. Please fix.");
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data(TEST_OPTIONS_DEFAULT_VALUES
+                                "HttpProxyAuthenticator "
+                                "onetwothreonetwothreonetwothreonetwothreonetw"
+                                "othreonetwothreonetwothreonetwothreonetwothre"
+                                "onetwothreonetwothreonetwothreonetwothreonetw"
+                                "othreonetwothreonetwothreonetwothreonetwothre"
+                                "onetwothreonetwothreonetwothreonetwothreonetw"
+                                "othreonetwothreonetwothreonetwothreonetwothre"
+                                "onetwothreonetwothreonetwothreonetwothreonetw"
+                                "othreonetwothreonetwothreonetwothreonetwothre"
+                                "onetwothreonetwothreonetwothreonetwothreonetw"
+                                "othreonetwothreonetwothreonetwothreonetwothre"
+                                "onetwothreonetwothreonetwothreonetwothreonetw"
+                                "othreonetwothreeonetwothreeonetwothree"
+
+                                );
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, -1);
+  tt_str_op(msg, OP_EQ, "HTTPProxyAuthenticator is too long (>= 512 chars).");
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data(TEST_OPTIONS_DEFAULT_VALUES
+                                "HttpProxyAuthenticator validauth\n"
+
+                                );
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, 0);
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data(TEST_OPTIONS_DEFAULT_VALUES
+                                "HttpsProxy 127.0.42.1\n"
+                                );
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, 0);
+  tt_int_op(tdata->opt->HTTPSProxyPort, OP_EQ, 443);
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data(TEST_OPTIONS_DEFAULT_VALUES
+                                "HttpsProxy 127.0.42.1:444\n"
+                                );
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, 0);
+  tt_int_op(tdata->opt->HTTPSProxyPort, OP_EQ, 444);
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data(TEST_OPTIONS_DEFAULT_VALUES
+                                "HttpsProxy not_so_valid!\n"
+                                );
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, -1);
+  tt_str_op(msg, OP_EQ, "HTTPSProxy failed to parse or resolve. Please fix.");
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data(TEST_OPTIONS_DEFAULT_VALUES
+                                "HttpsProxyAuthenticator "
+                                "onetwothreonetwothreonetwothreonetwothreonetw"
+                                "othreonetwothreonetwothreonetwothreonetwothre"
+                                "onetwothreonetwothreonetwothreonetwothreonetw"
+                                "othreonetwothreonetwothreonetwothreonetwothre"
+                                "onetwothreonetwothreonetwothreonetwothreonetw"
+                                "othreonetwothreonetwothreonetwothreonetwothre"
+                                "onetwothreonetwothreonetwothreonetwothreonetw"
+                                "othreonetwothreonetwothreonetwothreonetwothre"
+                                "onetwothreonetwothreonetwothreonetwothreonetw"
+                                "othreonetwothreonetwothreonetwothreonetwothre"
+                                "onetwothreonetwothreonetwothreonetwothreonetw"
+                                "othreonetwothreeonetwothreeonetwothree"
+
+                                );
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, -1);
+  tt_str_op(msg, OP_EQ, "HTTPSProxyAuthenticator is too long (>= 512 chars).");
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data(TEST_OPTIONS_DEFAULT_VALUES
+                                "HttpsProxyAuthenticator validauth\n"
+                                );
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, 0);
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data(TEST_OPTIONS_DEFAULT_VALUES
+                                "Socks4Proxy 127.0.42.1\n"
+                                );
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, 0);
+  tt_int_op(tdata->opt->Socks4ProxyPort, OP_EQ, 1080);
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data(TEST_OPTIONS_DEFAULT_VALUES
+                                "Socks4Proxy 127.0.42.1:444\n"
+                                );
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, 0);
+  tt_int_op(tdata->opt->Socks4ProxyPort, OP_EQ, 444);
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data(TEST_OPTIONS_DEFAULT_VALUES
+                                "Socks4Proxy not_so_valid!\n"
+                                );
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, -1);
+  tt_str_op(msg, OP_EQ, "Socks4Proxy failed to parse or resolve. Please fix.");
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data(TEST_OPTIONS_DEFAULT_VALUES
+                                "Socks5Proxy 127.0.42.1\n"
+                                );
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, 0);
+  tt_int_op(tdata->opt->Socks5ProxyPort, OP_EQ, 1080);
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data(TEST_OPTIONS_DEFAULT_VALUES
+                                "Socks5Proxy 127.0.42.1:444\n"
+                                );
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, 0);
+  tt_int_op(tdata->opt->Socks5ProxyPort, OP_EQ, 444);
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data(TEST_OPTIONS_DEFAULT_VALUES
+                                "Socks5Proxy not_so_valid!\n"
+                                );
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, -1);
+  tt_str_op(msg, OP_EQ, "Socks5Proxy failed to parse or resolve. Please fix.");
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data(TEST_OPTIONS_DEFAULT_VALUES
+                                "Socks4Proxy 215.1.1.1\n"
+                                "Socks5Proxy 215.1.1.2\n"
+                                );
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, -1);
+  tt_str_op(msg, OP_EQ, "You have configured more than one proxy type. "
+            "(Socks4Proxy|Socks5Proxy|HTTPSProxy)");
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data(TEST_OPTIONS_DEFAULT_VALUES
+                                "HttpProxy 215.1.1.1\n"
+                                );
+  mock_clean_saved_logs();
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, 0);
+  expect_log_msg("HTTPProxy configured, but no SOCKS "
+            "proxy or HTTPS proxy configured. Watch out: this configuration "
+            "will proxy unencrypted directory connections only.\n");
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data(TEST_OPTIONS_DEFAULT_VALUES
+                                "HttpProxy 215.1.1.1\n"
+                                "Socks4Proxy 215.1.1.1\n"
+                                );
+  mock_clean_saved_logs();
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, 0);
+  expect_no_log_msg("HTTPProxy configured, but no SOCKS "
+            "proxy or HTTPS proxy configured. Watch out: this configuration "
+            "will proxy unencrypted directory connections only.\n");
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data(TEST_OPTIONS_DEFAULT_VALUES
+                                "HttpProxy 215.1.1.1\n"
+                                "Socks5Proxy 215.1.1.1\n"
+                                );
+  mock_clean_saved_logs();
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, 0);
+  expect_no_log_msg("HTTPProxy configured, but no SOCKS "
+            "proxy or HTTPS proxy configured. Watch out: this configuration "
+            "will proxy unencrypted directory connections only.\n");
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data(TEST_OPTIONS_DEFAULT_VALUES
+                                "HttpProxy 215.1.1.1\n"
+                                "HttpsProxy 215.1.1.1\n"
+                                );
+  mock_clean_saved_logs();
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, 0);
+  expect_no_log_msg(
+            "HTTPProxy configured, but no SOCKS proxy or HTTPS proxy "
+            "configured. Watch out: this configuration will proxy "
+            "unencrypted directory connections only.\n");
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data(TEST_OPTIONS_DEFAULT_VALUES
+                                );
+  tdata->opt->Socks5ProxyUsername = tor_strdup("");
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, -1);
+  tt_str_op(msg, OP_EQ,
+            "Socks5ProxyUsername must be between 1 and 255 characters.");
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data(TEST_OPTIONS_DEFAULT_VALUES
+                                );
+  tdata->opt->Socks5ProxyUsername =
+    tor_strdup("ABCDEABCDE0123456789ABCDEABCDE0123456789ABCDEABCDE0123456789AB"
+               "CDEABCDE0123456789ABCDEABCDE0123456789ABCDEABCDE0123456789ABCD"
+               "EABCDE0123456789ABCDEABCDE0123456789ABCDEABCDE0123456789ABCDEA"
+               "BCDE0123456789ABCDEABCDE0123456789ABCDEABCDE0123456789ABCDEABC"
+               "DE0123456789ABCDEABCDE0123456789ABCDEABCDE0123456789");
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, -1);
+  tt_str_op(msg, OP_EQ,
+            "Socks5ProxyUsername must be between 1 and 255 characters.");
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data(TEST_OPTIONS_DEFAULT_VALUES
+                                "Socks5ProxyUsername hello_world\n"
+                                );
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, -1);
+  tt_str_op(msg, OP_EQ, "Socks5ProxyPassword must be included with "
+            "Socks5ProxyUsername.");
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data(TEST_OPTIONS_DEFAULT_VALUES
+                                "Socks5ProxyUsername hello_world\n"
+                                );
+  tdata->opt->Socks5ProxyPassword = tor_strdup("");
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, -1);
+  tt_str_op(msg, OP_EQ,
+            "Socks5ProxyPassword must be between 1 and 255 characters.");
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data(TEST_OPTIONS_DEFAULT_VALUES
+                                "Socks5ProxyUsername hello_world\n"
+                                );
+  tdata->opt->Socks5ProxyPassword =
+    tor_strdup("ABCDEABCDE0123456789ABCDEABCDE0123456789ABCDEABCDE0123456789AB"
+               "CDEABCDE0123456789ABCDEABCDE0123456789ABCDEABCDE0123456789ABCD"
+               "EABCDE0123456789ABCDEABCDE0123456789ABCDEABCDE0123456789ABCDEA"
+               "BCDE0123456789ABCDEABCDE0123456789ABCDEABCDE0123456789ABCDEABC"
+               "DE0123456789ABCDEABCDE0123456789ABCDEABCDE0123456789");
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, -1);
+  tt_str_op(msg, OP_EQ,
+            "Socks5ProxyPassword must be between 1 and 255 characters.");
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data(TEST_OPTIONS_DEFAULT_VALUES
+                                "Socks5ProxyUsername hello_world\n"
+                                "Socks5ProxyPassword world_hello\n"
+                                );
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, 0);
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data(TEST_OPTIONS_DEFAULT_VALUES
+                                "Socks5ProxyPassword hello_world\n"
+                                );
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, -1);
+  tt_str_op(msg, OP_EQ, "Socks5ProxyPassword must be included with "
+            "Socks5ProxyUsername.");
+  tor_free(msg);
+
+ done:
+  teardown_capture_of_logs(previous_log);
+  free_options_test_data(tdata);
+  memarea_clear_freelist();
+  policies_free_all();
+  // sandbox_free_getaddrinfo_cache();
+  tor_free(msg);
+}
+
+static void
+test_options_validate__control(void *ignored)
+{
+  (void)ignored;
+  int ret;
+  char *msg;
+  options_test_data_t *tdata = NULL;
+  int previous_log = setup_capture_of_logs(LOG_WARN);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data(TEST_OPTIONS_DEFAULT_VALUES
+                                "HashedControlPassword something_incorrect\n"
+                                );
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, -1);
+  tt_str_op(msg, OP_EQ,
+            "Bad HashedControlPassword: wrong length or bad encoding");
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data(TEST_OPTIONS_DEFAULT_VALUES
+                                "HashedControlPassword 16:872860B76453A77D60CA"
+                                "2BB8C1A7042072093276A3D701AD684053EC4C\n"
+                                );
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, 0);
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data(
+                   TEST_OPTIONS_DEFAULT_VALUES
+                   "__HashedControlSessionPassword something_incorrect\n"
+                                );
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, -1);
+  tt_str_op(msg, OP_EQ, "Bad HashedControlSessionPassword: wrong length or "
+            "bad encoding");
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data(TEST_OPTIONS_DEFAULT_VALUES
+                                "__HashedControlSessionPassword 16:872860B7645"
+                                "3A77D60CA2BB8C1A7042072093276A3D701AD684053EC"
+                                "4C\n"
+                                );
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, 0);
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data(
+                           TEST_OPTIONS_DEFAULT_VALUES
+                           "__OwningControllerProcess something_incorrect\n"
+                                );
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, -1);
+  tt_str_op(msg, OP_EQ, "Bad OwningControllerProcess: invalid PID");
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data(TEST_OPTIONS_DEFAULT_VALUES
+                                "__OwningControllerProcess 123\n"
+                                );
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, 0);
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data(TEST_OPTIONS_DEFAULT_VALUES
+                                "ControlPort 127.0.0.1:1234\n"
+                                );
+  mock_clean_saved_logs();
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, 0);
+  expect_log_msg(
+            "ControlPort is open, but no authentication method has been "
+            "configured.  This means that any program on your computer can "
+            "reconfigure your Tor.  That's bad!  You should upgrade your Tor"
+            " controller as soon as possible.\n");
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data(TEST_OPTIONS_DEFAULT_VALUES
+                                "ControlPort 127.0.0.1:1234\n"
+                                "HashedControlPassword 16:872860B76453A77D60CA"
+                                "2BB8C1A7042072093276A3D701AD684053EC4C\n"
+                                );
+  mock_clean_saved_logs();
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, 0);
+  expect_no_log_msg(
+            "ControlPort is open, but no authentication method has been "
+            "configured.  This means that any program on your computer can "
+            "reconfigure your Tor.  That's bad!  You should upgrade your Tor "
+            "controller as soon as possible.\n");
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data(TEST_OPTIONS_DEFAULT_VALUES
+                                "ControlPort 127.0.0.1:1234\n"
+                                "__HashedControlSessionPassword 16:872860B7645"
+                                "3A77D60CA2BB8C1A7042072093276A3D701AD684053EC"
+                                "4C\n"
+                                );
+  mock_clean_saved_logs();
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, 0);
+  expect_no_log_msg(
+            "ControlPort is open, but no authentication method has been "
+            "configured.  This means that any program on your computer can "
+            "reconfigure your Tor.  That's bad!  You should upgrade your Tor "
+            "controller as soon as possible.\n");
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data(TEST_OPTIONS_DEFAULT_VALUES
+                                "ControlPort 127.0.0.1:1234\n"
+                                "CookieAuthentication 1\n"
+                                );
+  mock_clean_saved_logs();
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, 0);
+  expect_no_log_msg(
+            "ControlPort is open, but no authentication method has been "
+            "configured.  This means that any program on your computer can "
+            "reconfigure your Tor.  That's bad!  You should upgrade your Tor "
+            "controller as soon as possible.\n");
+  tor_free(msg);
+
+#ifdef HAVE_SYS_UN_H
+  free_options_test_data(tdata);
+  tdata = get_options_test_data(TEST_OPTIONS_DEFAULT_VALUES
+                                "ControlSocket unix:/tmp WorldWritable\n"
+                                );
+  mock_clean_saved_logs();
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, 0);
+  expect_log_msg(
+            "ControlSocket is world writable, but no authentication method has"
+            " been configured.  This means that any program on your computer "
+            "can reconfigure your Tor.  That's bad!  You should upgrade your "
+            "Tor controller as soon as possible.\n");
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data(TEST_OPTIONS_DEFAULT_VALUES
+                                "ControlSocket unix:/tmp WorldWritable\n"
+                                "HashedControlPassword 16:872860B76453A77D60CA"
+                                "2BB8C1A7042072093276A3D701AD684053EC4C\n"
+                                );
+  mock_clean_saved_logs();
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, 0);
+  expect_no_log_msg(
+            "ControlSocket is world writable, but no authentication method has"
+            " been configured.  This means that any program on your computer "
+            "can reconfigure your Tor.  That's bad!  You should upgrade your "
+            "Tor controller as soon as possible.\n");
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data(TEST_OPTIONS_DEFAULT_VALUES
+                                "ControlSocket unix:/tmp WorldWritable\n"
+                                "__HashedControlSessionPassword 16:872860B7645"
+                                "3A77D60CA2BB8C1A7042072093276A3D701AD684053EC"
+                                "4C\n"
+                                );
+  mock_clean_saved_logs();
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, 0);
+  expect_no_log_msg(
+            "ControlSocket is world writable, but no authentication method has"
+            " been configured.  This means that any program on your computer "
+            "can reconfigure your Tor.  That's bad!  You should upgrade your "
+            "Tor controller as soon as possible.\n");
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data(TEST_OPTIONS_DEFAULT_VALUES
+                                "ControlSocket unix:/tmp WorldWritable\n"
+                                "CookieAuthentication 1\n"
+                                );
+  mock_clean_saved_logs();
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, 0);
+  expect_no_log_msg(
+            "ControlSocket is world writable, but no authentication method has"
+            " been configured.  This means that any program on your computer "
+            "can reconfigure your Tor.  That's bad!  You should upgrade your "
+            "Tor controller as soon as possible.\n");
+  tor_free(msg);
+#endif
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data(TEST_OPTIONS_DEFAULT_VALUES
+                                "CookieAuthFileGroupReadable 1\n"
+                                );
+  mock_clean_saved_logs();
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, 0);
+  expect_log_msg(
+            "CookieAuthFileGroupReadable is set, but will have no effect: you "
+            "must specify an explicit CookieAuthFile to have it "
+            "group-readable.\n");
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data(TEST_OPTIONS_DEFAULT_VALUES
+                                "CookieAuthFileGroupReadable 1\n"
+                                "CookieAuthFile /tmp/somewhere\n"
+                                );
+  mock_clean_saved_logs();
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, 0);
+  expect_no_log_msg(
+            "CookieAuthFileGroupReadable is set, but will have no effect: you "
+            "must specify an explicit CookieAuthFile to have it "
+            "group-readable.\n");
+  tor_free(msg);
+
+ done:
+  teardown_capture_of_logs(previous_log);
+  memarea_clear_freelist();
+  policies_free_all();
+  free_options_test_data(tdata);
+  tor_free(msg);
+}
+
+static void
+test_options_validate__families(void *ignored)
+{
+  (void)ignored;
+  int ret;
+  char *msg;
+  options_test_data_t *tdata = NULL;
+  int previous_log = setup_capture_of_logs(LOG_WARN);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data(TEST_OPTIONS_DEFAULT_VALUES
+                                "MyFamily home\n"
+                                "BridgeRelay 1\n"
+                                "ORListenAddress 127.0.0.1:5555\n"
+                                "ORPort 955\n"
+                                "BandwidthRate 51300\n"
+                                "BandwidthBurst 51300\n"
+                                "MaxAdvertisedBandwidth 25700\n"
+                                "DirCache 1\n"
+                                );
+  mock_clean_saved_logs();
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, 0);
+  expect_log_msg(
+            "Listing a family for a bridge relay is not supported: it can "
+            "reveal bridge fingerprints to censors. You should also make sure "
+            "you aren't listing this bridge's fingerprint in any other "
+            "MyFamily.\n");
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data(TEST_OPTIONS_DEFAULT_VALUES
+                                "MyFamily home\n"
+                                );
+  mock_clean_saved_logs();
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, 0);
+  expect_no_log_msg(
+            "Listing a family for a bridge relay is not supported: it can "
+            "reveal bridge fingerprints to censors. You should also make sure "
+            "you aren't listing this bridge's fingerprint in any other "
+            "MyFamily.\n");
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data(TEST_OPTIONS_DEFAULT_VALUES
+                                "MyFamily !\n"
+                                );
+  mock_clean_saved_logs();
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, -1);
+  tt_str_op(msg, OP_EQ, "Invalid nickname '!' in MyFamily line");
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data(TEST_OPTIONS_DEFAULT_VALUES
+                                "NodeFamily foo\n"
+                                "NodeFamily !\n"
+                                );
+  mock_clean_saved_logs();
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, -1);
+  tt_assert(!msg);
+  tor_free(msg);
+
+ done:
+  teardown_capture_of_logs(previous_log);
+  memarea_clear_freelist();
+  policies_free_all();
+  free_options_test_data(tdata);
+  tor_free(msg);
+}
+
+static void
+test_options_validate__addr_policies(void *ignored)
+{
+  (void)ignored;
+  int ret;
+  char *msg;
+  options_test_data_t *tdata = NULL;
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data(TEST_OPTIONS_DEFAULT_VALUES
+                                "ExitPolicy !!!\n"
+                                "ExitRelay 1\n"
+                                );
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, -1);
+  tt_str_op(msg, OP_EQ, "Error in ExitPolicy entry.");
+  tor_free(msg);
+
+ done:
+  memarea_clear_freelist();
+  policies_free_all();
+  free_options_test_data(tdata);
+  tor_free(msg);
+}
+
+static void
+test_options_validate__dir_auth(void *ignored)
+{
+  (void)ignored;
+  int ret;
+  char *msg;
+  options_test_data_t *tdata = NULL;
+  int previous_log = setup_capture_of_logs(LOG_WARN);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data(TEST_OPTIONS_DEFAULT_VALUES
+                                VALID_DIR_AUTH
+                                VALID_ALT_DIR_AUTH
+                                );
+  mock_clean_saved_logs();
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, -1);
+  tt_str_op(msg, OP_EQ,
+            "Directory authority/fallback line did not parse. See logs for "
+            "details.");
+  expect_log_msg(
+            "You cannot set both DirAuthority and Alternate*Authority.\n");
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data(TEST_OPTIONS_DEFAULT_VALUES
+                                "TestingTorNetwork 1\n"
+                                );
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, -1);
+  tt_str_op(msg, OP_EQ,
+            "TestingTorNetwork may only be configured in combination with a "
+            "non-default set of DirAuthority or both of AlternateDirAuthority "
+            "and AlternateBridgeAuthority configured.");
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data(TEST_OPTIONS_DEFAULT_VALUES
+                                VALID_DIR_AUTH
+                                "TestingTorNetwork 1\n"
+                                );
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, 0);
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data(TEST_OPTIONS_DEFAULT_VALUES
+                                "TestingTorNetwork 1\n"
+                                VALID_ALT_DIR_AUTH
+                                );
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, -1);
+  tt_str_op(msg, OP_EQ,
+            "TestingTorNetwork may only be configured in combination with a "
+            "non-default set of DirAuthority or both of AlternateDirAuthority "
+            "and AlternateBridgeAuthority configured.");
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data(TEST_OPTIONS_DEFAULT_VALUES
+                                "TestingTorNetwork 1\n"
+                                VALID_ALT_BRIDGE_AUTH
+                                );
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, -1);
+  tt_str_op(msg, OP_EQ, "TestingTorNetwork may only be configured in "
+            "combination with a non-default set of DirAuthority or both of "
+            "AlternateDirAuthority and AlternateBridgeAuthority configured.");
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data(TEST_OPTIONS_DEFAULT_VALUES
+                                VALID_ALT_DIR_AUTH
+                                VALID_ALT_BRIDGE_AUTH
+                                "TestingTorNetwork 1\n"
+                                );
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, 0);
+  tor_free(msg);
+
+ done:
+  memarea_clear_freelist();
+  policies_free_all();
+  teardown_capture_of_logs(previous_log);
+  free_options_test_data(tdata);
+  tor_free(msg);
+}
+
+static void
+test_options_validate__transport(void *ignored)
+{
+  (void)ignored;
+  int ret;
+  char *msg;
+  options_test_data_t *tdata = NULL;
+  int previous_log = setup_capture_of_logs(LOG_NOTICE);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data(TEST_OPTIONS_DEFAULT_VALUES
+                                "ClientTransportPlugin !!\n"
+                                );
+  mock_clean_saved_logs();
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, -1);
+  tt_str_op(msg, OP_EQ,
+            "Invalid client transport line. See logs for details.");
+  expect_log_msg(
+            "Too few arguments on ClientTransportPlugin line.\n");
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data(TEST_OPTIONS_DEFAULT_VALUES
+                                "ClientTransportPlugin foo exec bar\n"
+                                );
+  mock_clean_saved_logs();
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, 0);
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data(TEST_OPTIONS_DEFAULT_VALUES
+                                "ServerTransportPlugin !!\n"
+                                );
+  mock_clean_saved_logs();
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, -1);
+  tt_str_op(msg, OP_EQ,
+            "Invalid server transport line. See logs for details.");
+  expect_log_msg(
+            "Too few arguments on ServerTransportPlugin line.\n");
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data(TEST_OPTIONS_DEFAULT_VALUES
+                                "ServerTransportPlugin foo exec bar\n"
+                                );
+  mock_clean_saved_logs();
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, 0);
+  expect_log_msg(
+            "Tor is not configured as a relay but you specified a "
+            "ServerTransportPlugin line (\"foo exec bar\"). The "
+            "ServerTransportPlugin line will be ignored.\n");
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data(TEST_OPTIONS_DEFAULT_VALUES
+                                "ServerTransportPlugin foo exec bar\n"
+                                "ORListenAddress 127.0.0.1:5555\n"
+                                "ORPort 955\n"
+                                "BandwidthRate 76900\n"
+                                "BandwidthBurst 76900\n"
+                                "MaxAdvertisedBandwidth 38500\n"
+                                );
+  mock_clean_saved_logs();
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, 0);
+  expect_no_log_msg(
+            "Tor is not configured as a relay but you specified a "
+            "ServerTransportPlugin line (\"foo exec bar\"). The "
+            "ServerTransportPlugin line will be ignored.\n");
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data(TEST_OPTIONS_DEFAULT_VALUES
+                                "ServerTransportListenAddr foo 127.0.0.42:55\n"
+                                "ServerTransportListenAddr !\n"
+                                );
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, -1);
+  tt_str_op(msg, OP_EQ,
+            "ServerTransportListenAddr did not parse. See logs for details.");
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data(TEST_OPTIONS_DEFAULT_VALUES
+                                "ServerTransportListenAddr foo 127.0.0.42:55\n"
+                                );
+  mock_clean_saved_logs();
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, 0);
+  expect_log_msg(
+            "You need at least a single managed-proxy to specify a transport "
+            "listen address. The ServerTransportListenAddr line will be "
+            "ignored.\n");
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data(TEST_OPTIONS_DEFAULT_VALUES
+                                "ServerTransportListenAddr foo 127.0.0.42:55\n"
+                                "ServerTransportPlugin foo exec bar\n"
+                                "ORListenAddress 127.0.0.1:5555\n"
+                                "ORPort 955\n"
+                                "BandwidthRate 76900\n"
+                                "BandwidthBurst 76900\n"
+                                "MaxAdvertisedBandwidth 38500\n"
+                                );
+  mock_clean_saved_logs();
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, 0);
+  expect_no_log_msg(
+            "You need at least a single managed-proxy to specify a transport "
+            "listen address. The ServerTransportListenAddr line will be "
+            "ignored.\n");
+
+ done:
+  escaped(NULL); // This will free the leaking memory from the previous escaped
+  memarea_clear_freelist();
+  policies_free_all();
+  teardown_capture_of_logs(previous_log);
+  free_options_test_data(tdata);
+  tor_free(msg);
+}
+
+static void
+test_options_validate__constrained_sockets(void *ignored)
+{
+  (void)ignored;
+  int ret;
+  char *msg;
+  options_test_data_t *tdata = NULL;
+  int previous_log = setup_capture_of_logs(LOG_WARN);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data(TEST_OPTIONS_DEFAULT_VALUES
+                                "ConstrainedSockets 1\n"
+                                "ConstrainedSockSize 0\n"
+                                );
+  mock_clean_saved_logs();
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, -1);
+  tt_str_op(msg, OP_EQ, "ConstrainedSockSize is invalid.  Must be a value "
+            "between 2048 and 262144 in 1024 byte increments.");
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data(TEST_OPTIONS_DEFAULT_VALUES
+                                "ConstrainedSockets 1\n"
+                                "ConstrainedSockSize 263168\n"
+                                );
+  mock_clean_saved_logs();
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, -1);
+  tt_str_op(msg, OP_EQ, "ConstrainedSockSize is invalid.  Must be a value "
+            "between 2048 and 262144 in 1024 byte increments.");
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data(TEST_OPTIONS_DEFAULT_VALUES
+                                "ConstrainedSockets 1\n"
+                                "ConstrainedSockSize 2047\n"
+                                );
+  mock_clean_saved_logs();
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, -1);
+  tt_str_op(msg, OP_EQ, "ConstrainedSockSize is invalid.  Must be a value "
+            "between 2048 and 262144 in 1024 byte increments.");
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data(TEST_OPTIONS_DEFAULT_VALUES
+                                "ConstrainedSockets 1\n"
+                                "ConstrainedSockSize 2048\n"
+                                "DirPort 999\n"
+                                "DirCache 1\n"
+                                );
+  mock_clean_saved_logs();
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, 0);
+  expect_log_msg("You have requested constrained "
+            "socket buffers while also serving directory entries via DirPort."
+            "  It is strongly suggested that you disable serving directory"
+            " requests when system TCP buffer resources are scarce.\n");
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data(TEST_OPTIONS_DEFAULT_VALUES
+                                "ConstrainedSockets 1\n"
+                                "ConstrainedSockSize 2048\n"
+                                );
+  mock_clean_saved_logs();
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, 0);
+  expect_no_log_msg(
+            "You have requested constrained socket buffers while also serving"
+            " directory entries via DirPort.  It is strongly suggested that "
+            "you disable serving directory requests when system TCP buffer "
+            "resources are scarce.\n");
+  tor_free(msg);
+
+ done:
+  memarea_clear_freelist();
+  policies_free_all();
+  teardown_capture_of_logs(previous_log);
+  free_options_test_data(tdata);
+  tor_free(msg);
+}
+
+static void
+test_options_validate__v3_auth(void *ignored)
+{
+  (void)ignored;
+  int ret;
+  char *msg;
+  options_test_data_t *tdata = NULL;
+  int previous_log = setup_capture_of_logs(LOG_WARN);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data(TEST_OPTIONS_DEFAULT_VALUES
+                                "V3AuthVoteDelay 1000\n"
+                                "V3AuthDistDelay 1000\n"
+                                "V3AuthVotingInterval 1000\n"
+                                );
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, -1);
+  tt_str_op(msg, OP_EQ,
+            "V3AuthVoteDelay plus V3AuthDistDelay must be less than half "
+            "V3AuthVotingInterval");
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data(TEST_OPTIONS_DEFAULT_VALUES
+                                "V3AuthVoteDelay 1\n"
+                                );
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, -1);
+  tt_str_op(msg, OP_EQ, "V3AuthVoteDelay is way too low.");
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data(TEST_OPTIONS_DEFAULT_VALUES
+                                "V3AuthVoteDelay 1\n"
+                                "TestingTorNetwork 1\n"
+                                );
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, -1);
+  tt_str_op(msg, OP_EQ, "V3AuthVoteDelay is way too low.");
+  tor_free(msg);
+
+  // TODO: we can't reach the case of v3authvotedelay lower
+  // than MIN_VOTE_SECONDS but not lower than MIN_VOTE_SECONDS_TESTING,
+  // since they are the same
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data(TEST_OPTIONS_DEFAULT_VALUES
+                                "V3AuthDistDelay 1\n"
+                                );
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, -1);
+  tt_str_op(msg, OP_EQ, "V3AuthDistDelay is way too low.");
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data(TEST_OPTIONS_DEFAULT_VALUES
+                                "V3AuthDistDelay 1\n"
+                                "TestingTorNetwork 1\n"
+                                );
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, -1);
+  tt_str_op(msg, OP_EQ, "V3AuthDistDelay is way too low.");
+  tor_free(msg);
+
+  // TODO: we can't reach the case of v3authdistdelay lower than
+  // MIN_DIST_SECONDS but not lower than MIN_DIST_SECONDS_TESTING,
+  // since they are the same
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data(TEST_OPTIONS_DEFAULT_VALUES
+                                "V3AuthNIntervalsValid 1\n"
+                                );
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, -1);
+  tt_str_op(msg, OP_EQ, "V3AuthNIntervalsValid must be at least 2.");
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data(TEST_OPTIONS_DEFAULT_VALUES
+                                "V3AuthVoteDelay 49\n"
+                                "V3AuthDistDelay 49\n"
+                                "V3AuthVotingInterval 200\n"
+                                );
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, -1);
+  tt_str_op(msg, OP_EQ, "V3AuthVotingInterval is insanely low.");
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data(TEST_OPTIONS_DEFAULT_VALUES
+                                "V3AuthVoteDelay 49\n"
+                                "V3AuthDistDelay 49\n"
+                                "V3AuthVotingInterval 200000\n"
+                                );
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, -1);
+  tt_str_op(msg, OP_EQ, "V3AuthVotingInterval is insanely high.");
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data(TEST_OPTIONS_DEFAULT_VALUES
+                                "V3AuthVoteDelay 49\n"
+                                "V3AuthDistDelay 49\n"
+                                "V3AuthVotingInterval 1441\n"
+                                );
+  mock_clean_saved_logs();
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, 0);
+  expect_log_msg("V3AuthVotingInterval does not divide"
+            " evenly into 24 hours.\n");
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data(TEST_OPTIONS_DEFAULT_VALUES
+                                "V3AuthVoteDelay 49\n"
+                                "V3AuthDistDelay 49\n"
+                                "V3AuthVotingInterval 1440\n"
+                                );
+  mock_clean_saved_logs();
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, 0);
+  expect_no_log_msg("V3AuthVotingInterval does not divide"
+            " evenly into 24 hours.\n");
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data(TEST_OPTIONS_DEFAULT_VALUES
+                                "V3AuthVoteDelay 49\n"
+                                "V3AuthDistDelay 49\n"
+                                "V3AuthVotingInterval 299\n"
+                                VALID_DIR_AUTH
+                                "TestingTorNetwork 1\n"
+                                );
+  mock_clean_saved_logs();
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, 0);
+  expect_log_msg("V3AuthVotingInterval is very low. "
+            "This may lead to failure to synchronise for a consensus.\n");
+  tor_free(msg);
+
+  // TODO: It is impossible to reach the case of testingtor network, with
+  // v3authvotinginterval too low
+  /* free_options_test_data(tdata); */
+  /* tdata = get_options_test_data(TEST_OPTIONS_DEFAULT_VALUES */
+  /*                               "V3AuthVoteDelay 1\n" */
+  /*                               "V3AuthDistDelay 1\n" */
+  /*                               "V3AuthVotingInterval 9\n" */
+                                   /* VALID_DIR_AUTH */
+  /*                               "TestingTorNetwork 1\n" */
+  /*                               ); */
+  /* ret = options_validate(tdata->old_opt, tdata->opt, */
+  /*                        tdata->def_opt, 0, &msg); */
+  /* tt_int_op(ret, OP_EQ, -1); */
+  /* tt_str_op(msg, OP_EQ, "V3AuthVotingInterval is insanely low."); */
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data(TEST_OPTIONS_DEFAULT_VALUES
+                                "TestingV3AuthInitialVoteDelay 1\n"
+                                VALID_DIR_AUTH
+                                "TestingTorNetwork 1\n"
+                                );
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, -1);
+  tt_str_op(msg, OP_EQ, "TestingV3AuthInitialVoteDelay is way too low.");
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data(TEST_OPTIONS_DEFAULT_VALUES
+                                "TestingV3AuthInitialDistDelay 1\n"
+                                VALID_DIR_AUTH
+                                "TestingTorNetwork 1\n"
+                                );
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, -1);
+  tt_str_op(msg, OP_EQ, "TestingV3AuthInitialDistDelay is way too low.");
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data(TEST_OPTIONS_DEFAULT_VALUES
+                                VALID_DIR_AUTH
+                                "TestingTorNetwork 1\n"
+                                );
+  tdata->opt->TestingV3AuthVotingStartOffset = 100000;
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, -1);
+  tt_str_op(msg, OP_EQ, "TestingV3AuthVotingStartOffset is higher than the "
+            "voting interval.");
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data(TEST_OPTIONS_DEFAULT_VALUES
+                                VALID_DIR_AUTH
+                                "TestingTorNetwork 1\n"
+                                );
+  tdata->opt->TestingV3AuthVotingStartOffset = -1;
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, -1);
+  tt_str_op(msg, OP_EQ,
+            "TestingV3AuthVotingStartOffset must be non-negative.");
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data(TEST_OPTIONS_DEFAULT_VALUES
+                                VALID_DIR_AUTH
+                                "TestingTorNetwork 1\n"
+                                "TestingV3AuthInitialVotingInterval 4\n"
+                                );
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, -1);
+  tt_str_op(msg, OP_EQ, "TestingV3AuthInitialVotingInterval is insanely low.");
+  tor_free(msg);
+
+ done:
+  memarea_clear_freelist();
+  policies_free_all();
+  teardown_capture_of_logs(previous_log);
+  free_options_test_data(tdata);
+  tor_free(msg);
+}
+
+static void
+test_options_validate__virtual_addr(void *ignored)
+{
+  (void)ignored;
+  int ret;
+  char *msg;
+  options_test_data_t *tdata = NULL;
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data(TEST_OPTIONS_DEFAULT_VALUES
+                                "VirtualAddrNetworkIPv4 !!"
+                                );
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, -1);
+  tt_str_op(msg, OP_EQ, "Error parsing VirtualAddressNetwork !!");
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data(TEST_OPTIONS_DEFAULT_VALUES
+                                "VirtualAddrNetworkIPv6 !!"
+                                );
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, -1);
+  tt_str_op(msg, OP_EQ, "Error parsing VirtualAddressNetworkIPv6 !!");
+  tor_free(msg);
+
+ done:
+  escaped(NULL); // This will free the leaking memory from the previous escaped
+  memarea_clear_freelist();
+  policies_free_all();
+  free_options_test_data(tdata);
+  tor_free(msg);
+}
+
+static void
+test_options_validate__exits(void *ignored)
+{
+  (void)ignored;
+  int ret;
+  char *msg;
+  options_test_data_t *tdata = NULL;
+  int previous_log = setup_capture_of_logs(LOG_WARN);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data(TEST_OPTIONS_DEFAULT_VALUES
+                                "AllowSingleHopExits 1"
+                                );
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, 0);
+  expect_log_msg("You have set AllowSingleHopExits; "
+            "now your relay will allow others to make one-hop exits. However,"
+            " since by default most clients avoid relays that set this option,"
+            " most clients will ignore you.\n");
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data(TEST_OPTIONS_DEFAULT_VALUES
+                                "AllowSingleHopExits 1\n"
+                                VALID_DIR_AUTH
+                                );
+  mock_clean_saved_logs();
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, 0);
+  expect_no_log_msg("You have set AllowSingleHopExits; "
+            "now your relay will allow others to make one-hop exits. However,"
+            " since by default most clients avoid relays that set this option,"
+            " most clients will ignore you.\n");
+  tor_free(msg);
+
+ done:
+  memarea_clear_freelist();
+  policies_free_all();
+  teardown_capture_of_logs(previous_log);
+  free_options_test_data(tdata);
+  tor_free(msg);
+}
+
+static void
+test_options_validate__testing_options(void *ignored)
+{
+  (void)ignored;
+  int ret;
+  char *msg;
+  options_test_data_t *tdata = NULL;
+  int previous_log = setup_capture_of_logs(LOG_WARN);
+
+#define TEST_TESTING_OPTION(name, low_val, high_val, err_low)           \
+  STMT_BEGIN                                                            \
+    free_options_test_data(tdata);                                      \
+  tdata = get_options_test_data(TEST_OPTIONS_DEFAULT_VALUES             \
+                                VALID_DIR_AUTH                          \
+                                "TestingTorNetwork 1\n"                 \
+                                );                                      \
+  tdata->opt-> name = low_val;                                       \
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);\
+  tt_int_op(ret, OP_EQ, -1);                                            \
+  tt_str_op(msg, OP_EQ, #name " " err_low);                \
+  tor_free(msg); \
+                                                                        \
+  free_options_test_data(tdata);                                        \
+  tdata = get_options_test_data(TEST_OPTIONS_DEFAULT_VALUES             \
+                                VALID_DIR_AUTH                          \
+                                "TestingTorNetwork 1\n"                 \
+                                );                                      \
+  tdata->opt->  name = high_val;                                      \
+  mock_clean_saved_logs();                                              \
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);\
+  tt_int_op(ret, OP_EQ, 0);                                             \
+  expect_log_msg( #name " is insanely high.\n"); \
+  tor_free(msg); \
+  STMT_END
+
+  TEST_TESTING_OPTION(TestingAuthDirTimeToLearnReachability, -1, 8000,
+                      "must be non-negative.");
+  TEST_TESTING_OPTION(TestingEstimatedDescriptorPropagationTime, -1, 3601,
+                      "must be non-negative.");
+  TEST_TESTING_OPTION(TestingClientMaxIntervalWithoutRequest, -1, 3601,
+                      "is way too low.");
+  TEST_TESTING_OPTION(TestingDirConnectionMaxStall, 1, 3601,
+                      "is way too low.");
+  // TODO: I think this points to a bug/regression in options_validate
+  TEST_TESTING_OPTION(TestingConsensusMaxDownloadTries, 1, 801,
+                      "must be greater than 2.");
+  TEST_TESTING_OPTION(TestingDescriptorMaxDownloadTries, 1, 801,
+                      "must be greater than 1.");
+  TEST_TESTING_OPTION(TestingMicrodescMaxDownloadTries, 1, 801,
+                      "must be greater than 1.");
+  TEST_TESTING_OPTION(TestingCertMaxDownloadTries, 1, 801,
+                      "must be greater than 1.");
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data(TEST_OPTIONS_DEFAULT_VALUES
+                                "TestingEnableConnBwEvent 1\n"
+                                );
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, -1);
+  tt_str_op(msg, OP_EQ, "TestingEnableConnBwEvent may only be changed in "
+            "testing Tor networks!");
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data(TEST_OPTIONS_DEFAULT_VALUES
+                                "TestingEnableConnBwEvent 1\n"
+                                VALID_DIR_AUTH
+                                "TestingTorNetwork 1\n"
+                                "___UsingTestNetworkDefaults 0\n"
+                                );
+
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, 0);
+  tt_assert(!msg);
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data(TEST_OPTIONS_DEFAULT_VALUES
+                                "TestingEnableConnBwEvent 1\n"
+                                VALID_DIR_AUTH
+                                "TestingTorNetwork 0\n"
+                                "___UsingTestNetworkDefaults 1\n"
+                                );
+
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, 0);
+  tt_assert(!msg);
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data(TEST_OPTIONS_DEFAULT_VALUES
+                                "TestingEnableCellStatsEvent 1\n"
+                                );
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, -1);
+  tt_str_op(msg, OP_EQ, "TestingEnableCellStatsEvent may only be changed in "
+            "testing Tor networks!");
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data(TEST_OPTIONS_DEFAULT_VALUES
+                                "TestingEnableCellStatsEvent 1\n"
+                                VALID_DIR_AUTH
+                                "TestingTorNetwork 1\n"
+                                "___UsingTestNetworkDefaults 0\n"
+                                );
+
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, 0);
+  tt_assert(!msg);
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data(TEST_OPTIONS_DEFAULT_VALUES
+                                "TestingEnableCellStatsEvent 1\n"
+                                VALID_DIR_AUTH
+                                "TestingTorNetwork 0\n"
+                                "___UsingTestNetworkDefaults 1\n"
+                                );
+
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, 0);
+  tt_assert(!msg);
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data(TEST_OPTIONS_DEFAULT_VALUES
+                                "TestingEnableTbEmptyEvent 1\n"
+                                );
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, -1);
+  tt_str_op(msg, OP_EQ, "TestingEnableTbEmptyEvent may only be changed "
+            "in testing Tor networks!");
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data(TEST_OPTIONS_DEFAULT_VALUES
+                                "TestingEnableTbEmptyEvent 1\n"
+                                VALID_DIR_AUTH
+                                "TestingTorNetwork 1\n"
+                                "___UsingTestNetworkDefaults 0\n"
+                                );
+
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, 0);
+  tt_assert(!msg);
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data(TEST_OPTIONS_DEFAULT_VALUES
+                                "TestingEnableTbEmptyEvent 1\n"
+                                VALID_DIR_AUTH
+                                "TestingTorNetwork 0\n"
+                                "___UsingTestNetworkDefaults 1\n"
+                                );
+
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, 0);
+  tt_assert(!msg);
+  tor_free(msg);
+
+ done:
+  memarea_clear_freelist();
+  policies_free_all();
+  teardown_capture_of_logs(previous_log);
+  free_options_test_data(tdata);
+  tor_free(msg);
+}
+
+static void
+test_options_validate__accel(void *ignored)
+{
+  (void)ignored;
+  int ret;
+  char *msg;
+  options_test_data_t *tdata = NULL;
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data(TEST_OPTIONS_DEFAULT_VALUES
+                                "AccelName foo\n"
+                                );
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, 0);
+  tt_int_op(tdata->opt->HardwareAccel, OP_EQ, 1);
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data(TEST_OPTIONS_DEFAULT_VALUES
+                                "AccelName foo\n"
+                                );
+  tdata->opt->HardwareAccel = 2;
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, 0);
+  tt_int_op(tdata->opt->HardwareAccel, OP_EQ, 2);
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data(TEST_OPTIONS_DEFAULT_VALUES
+                                "AccelDir 1\n"
+                                );
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, -1);
+  tt_str_op(msg, OP_EQ,
+            "Can't use hardware crypto accelerator dir without engine name.");
+  tor_free(msg);
+
+  free_options_test_data(tdata);
+  tdata = get_options_test_data(TEST_OPTIONS_DEFAULT_VALUES
+                                "AccelDir 1\n"
+                                "AccelName something\n"
+                                );
+  ret = options_validate(tdata->old_opt, tdata->opt, tdata->def_opt, 0, &msg);
+  tt_int_op(ret, OP_EQ, 0);
+  tor_free(msg);
+
+ done:
+  memarea_clear_freelist();
+  policies_free_all();
+  free_options_test_data(tdata);
+  tor_free(msg);
+}
+
+#define LOCAL_VALIDATE_TEST(name) \
+  { "validate__" #name, test_options_validate__ ## name, TT_FORK, NULL, NULL }
+
 struct testcase_t options_tests[] = {
   { "validate", test_options_validate, TT_FORK, NULL, NULL },
-  END_OF_TESTCASES
+  { "mem_dircache", test_have_enough_mem_for_dircache, TT_FORK, NULL, NULL },
+  LOCAL_VALIDATE_TEST(uname_for_server),
+  LOCAL_VALIDATE_TEST(outbound_addresses),
+  LOCAL_VALIDATE_TEST(data_directory),
+  LOCAL_VALIDATE_TEST(nickname),
+  LOCAL_VALIDATE_TEST(contactinfo),
+  LOCAL_VALIDATE_TEST(logs),
+  LOCAL_VALIDATE_TEST(authdir),
+  LOCAL_VALIDATE_TEST(relay_with_hidden_services),
+  LOCAL_VALIDATE_TEST(transproxy),
+  LOCAL_VALIDATE_TEST(exclude_nodes),
+  LOCAL_VALIDATE_TEST(scheduler),
+  LOCAL_VALIDATE_TEST(node_families),
+  LOCAL_VALIDATE_TEST(tlsec),
+  LOCAL_VALIDATE_TEST(token_bucket),
+  LOCAL_VALIDATE_TEST(recommended_packages),
+  LOCAL_VALIDATE_TEST(fetch_dir),
+  LOCAL_VALIDATE_TEST(conn_limit),
+  LOCAL_VALIDATE_TEST(paths_needed),
+  LOCAL_VALIDATE_TEST(max_client_circuits),
+  LOCAL_VALIDATE_TEST(ports),
+  LOCAL_VALIDATE_TEST(reachable_addresses),
+  LOCAL_VALIDATE_TEST(use_bridges),
+  LOCAL_VALIDATE_TEST(entry_nodes),
+  LOCAL_VALIDATE_TEST(invalid_nodes),
+  LOCAL_VALIDATE_TEST(safe_logging),
+  LOCAL_VALIDATE_TEST(publish_server_descriptor),
+  LOCAL_VALIDATE_TEST(testing),
+  LOCAL_VALIDATE_TEST(hidserv),
+  LOCAL_VALIDATE_TEST(predicted_ports),
+  LOCAL_VALIDATE_TEST(path_bias),
+  LOCAL_VALIDATE_TEST(bandwidth),
+  LOCAL_VALIDATE_TEST(circuits),
+  LOCAL_VALIDATE_TEST(port_forwarding),
+  LOCAL_VALIDATE_TEST(tor2web),
+  LOCAL_VALIDATE_TEST(rend),
+  LOCAL_VALIDATE_TEST(accounting),
+  LOCAL_VALIDATE_TEST(proxy),
+  LOCAL_VALIDATE_TEST(control),
+  LOCAL_VALIDATE_TEST(families),
+  LOCAL_VALIDATE_TEST(addr_policies),
+  LOCAL_VALIDATE_TEST(dir_auth),
+  LOCAL_VALIDATE_TEST(transport),
+  LOCAL_VALIDATE_TEST(constrained_sockets),
+  LOCAL_VALIDATE_TEST(v3_auth),
+  LOCAL_VALIDATE_TEST(virtual_addr),
+  LOCAL_VALIDATE_TEST(exits),
+  LOCAL_VALIDATE_TEST(testing_options),
+  LOCAL_VALIDATE_TEST(accel),
+  END_OF_TESTCASES              /*  */
 };
 
diff --git a/src/test/test_policy.c b/src/test/test_policy.c
index 37c36fe..794978f 100644
--- a/src/test/test_policy.c
+++ b/src/test/test_policy.c
@@ -2,8 +2,11 @@
 /* See LICENSE for licensing information */
 
 #include "or.h"
+#define CONFIG_PRIVATE
+#include "config.h"
 #include "router.h"
 #include "routerparse.h"
+#define POLICIES_PRIVATE
 #include "policies.h"
 #include "test.h"
 
@@ -49,7 +52,7 @@ test_policy_summary_helper(const char *policy_str,
 
   r = policies_parse_exit_policy(&line, &policy,
                                  EXIT_POLICY_IPV6_ENABLED |
-                                 EXIT_POLICY_ADD_DEFAULT, 0, NULL, 0);
+                                 EXIT_POLICY_ADD_DEFAULT, NULL);
   tt_int_op(r,OP_EQ, 0);
 
   summary = policy_summarize(policy, AF_INET);
@@ -80,7 +83,8 @@ test_policies_general(void *arg)
               *policy7 = NULL, *policy8 = NULL, *policy9 = NULL,
               *policy10 = NULL, *policy11 = NULL, *policy12 = NULL;
   addr_policy_t *p;
-  tor_addr_t tar;
+  tor_addr_t tar, tar2;
+  smartlist_t *addr_list = NULL;
   config_line_t line;
   smartlist_t *sm = NULL;
   char *policy_str = NULL;
@@ -115,17 +119,22 @@ test_policies_general(void *arg)
   tt_int_op(0, OP_EQ, policies_parse_exit_policy(NULL, &policy2,
                                               EXIT_POLICY_IPV6_ENABLED |
                                               EXIT_POLICY_REJECT_PRIVATE |
-                                              EXIT_POLICY_ADD_DEFAULT, 0,
-                                              NULL, 0));
+                                              EXIT_POLICY_ADD_DEFAULT, NULL));
 
   tt_assert(policy2);
 
-  tor_addr_parse(&tar, "[2000::1234]");
+  tor_addr_from_ipv4h(&tar, 0x0306090cu);
+  tor_addr_parse(&tar2, "[2000::1234]");
+  addr_list = smartlist_new();
+  smartlist_add(addr_list, &tar);
+  smartlist_add(addr_list, &tar2);
   tt_int_op(0, OP_EQ, policies_parse_exit_policy(NULL, &policy12,
                                                  EXIT_POLICY_IPV6_ENABLED |
                                                  EXIT_POLICY_REJECT_PRIVATE |
                                                  EXIT_POLICY_ADD_DEFAULT,
-                                                 0x0306090cu, &tar, 1));
+                                                 addr_list));
+  smartlist_free(addr_list);
+  addr_list = NULL;
 
   tt_assert(policy12);
 
@@ -206,15 +215,15 @@ test_policies_general(void *arg)
   tt_int_op(0, OP_EQ, policies_parse_exit_policy(NULL, &policy8,
                                                  EXIT_POLICY_IPV6_ENABLED |
                                                  EXIT_POLICY_REJECT_PRIVATE |
-                                                 EXIT_POLICY_ADD_DEFAULT, 0,
-                                                 NULL, 0));
+                                                 EXIT_POLICY_ADD_DEFAULT,
+                                                 NULL));
 
   tt_assert(policy8);
 
   tt_int_op(0, OP_EQ, policies_parse_exit_policy(NULL, &policy9,
                                                  EXIT_POLICY_REJECT_PRIVATE |
-                                                 EXIT_POLICY_ADD_DEFAULT, 0,
-                                                 NULL, 0));
+                                                 EXIT_POLICY_ADD_DEFAULT,
+                                                 NULL));
 
   tt_assert(policy9);
 
@@ -261,6 +270,93 @@ test_policies_general(void *arg)
   addr_policy_list_free(policy);
   policy = NULL;
 
+  /* make sure assume_action works */
+  malformed_list = 0;
+  p = router_parse_addr_policy_item_from_string("127.0.0.1",
+                                                ADDR_POLICY_ACCEPT,
+                                                &malformed_list);
+  tt_assert(p);
+  addr_policy_free(p);
+  tt_assert(!malformed_list);
+
+  p = router_parse_addr_policy_item_from_string("127.0.0.1:*",
+                                                ADDR_POLICY_ACCEPT,
+                                                &malformed_list);
+  tt_assert(p);
+  addr_policy_free(p);
+  tt_assert(!malformed_list);
+
+  p = router_parse_addr_policy_item_from_string("[::]",
+                                                ADDR_POLICY_ACCEPT,
+                                                &malformed_list);
+  tt_assert(p);
+  addr_policy_free(p);
+  tt_assert(!malformed_list);
+
+  p = router_parse_addr_policy_item_from_string("[::]:*",
+                                                ADDR_POLICY_ACCEPT,
+                                                &malformed_list);
+  tt_assert(p);
+  addr_policy_free(p);
+  tt_assert(!malformed_list);
+
+  p = router_parse_addr_policy_item_from_string("[face::b]",
+                                                ADDR_POLICY_ACCEPT,
+                                                &malformed_list);
+  tt_assert(p);
+  addr_policy_free(p);
+  tt_assert(!malformed_list);
+
+  p = router_parse_addr_policy_item_from_string("[b::aaaa]",
+                                                ADDR_POLICY_ACCEPT,
+                                                &malformed_list);
+  tt_assert(p);
+  addr_policy_free(p);
+  tt_assert(!malformed_list);
+
+  p = router_parse_addr_policy_item_from_string("*",
+                                                ADDR_POLICY_ACCEPT,
+                                                &malformed_list);
+  tt_assert(p);
+  addr_policy_free(p);
+  tt_assert(!malformed_list);
+
+  p = router_parse_addr_policy_item_from_string("*4",
+                                                ADDR_POLICY_ACCEPT,
+                                                &malformed_list);
+  tt_assert(p);
+  addr_policy_free(p);
+  tt_assert(!malformed_list);
+
+  p = router_parse_addr_policy_item_from_string("*6",
+                                                ADDR_POLICY_ACCEPT,
+                                                &malformed_list);
+  tt_assert(p);
+  addr_policy_free(p);
+  tt_assert(!malformed_list);
+
+  /* These are all ambiguous IPv6 addresses, it's good that we reject them */
+  p = router_parse_addr_policy_item_from_string("acce::abcd",
+                                                ADDR_POLICY_ACCEPT,
+                                                &malformed_list);
+  tt_assert(!p);
+  tt_assert(malformed_list);
+  malformed_list = 0;
+
+  p = router_parse_addr_policy_item_from_string("7:1234",
+                                                ADDR_POLICY_ACCEPT,
+                                                &malformed_list);
+  tt_assert(!p);
+  tt_assert(malformed_list);
+  malformed_list = 0;
+
+  p = router_parse_addr_policy_item_from_string("::",
+                                                ADDR_POLICY_ACCEPT,
+                                                &malformed_list);
+  tt_assert(!p);
+  tt_assert(malformed_list);
+  malformed_list = 0;
+
   /* make sure compacting logic works. */
   policy = NULL;
   line.key = (char*)"foo";
@@ -268,8 +364,7 @@ test_policies_general(void *arg)
   line.next = NULL;
   tt_int_op(0, OP_EQ, policies_parse_exit_policy(&line,&policy,
                                               EXIT_POLICY_IPV6_ENABLED |
-                                              EXIT_POLICY_ADD_DEFAULT, 0,
-                                              NULL, 0));
+                                              EXIT_POLICY_ADD_DEFAULT, NULL));
   tt_assert(policy);
 
   //test_streq(policy->string, "accept *:80");
@@ -489,6 +584,324 @@ test_policies_general(void *arg)
   short_policy_free(short_parsed);
 }
 
+/** Helper: Check that policy_list contains address */
+static int
+test_policy_has_address_helper(const smartlist_t *policy_list,
+                               const tor_addr_t *addr)
+{
+  int found = 0;
+
+  tt_assert(policy_list);
+  tt_assert(addr);
+
+  SMARTLIST_FOREACH_BEGIN(policy_list, addr_policy_t*, p) {
+    if (tor_addr_eq(&p->addr, addr)) {
+      found = 1;
+    }
+  } SMARTLIST_FOREACH_END(p);
+
+  return found;
+
+ done:
+  return 0;
+}
+
+#define TEST_IPV4_ADDR (0x01020304)
+#define TEST_IPV6_ADDR ("2002::abcd")
+
+/** Run unit tests for rejecting the configured addresses on this exit relay
+ * using policies_parse_exit_policy_reject_private */
+static void
+test_policies_reject_exit_address(void *arg)
+{
+  smartlist_t *policy = NULL;
+  tor_addr_t ipv4_addr, ipv6_addr;
+  smartlist_t *ipv4_list, *ipv6_list, *both_list, *dupl_list;
+  (void)arg;
+
+  tor_addr_from_ipv4h(&ipv4_addr, TEST_IPV4_ADDR);
+  tor_addr_parse(&ipv6_addr, TEST_IPV6_ADDR);
+
+  ipv4_list = smartlist_new();
+  ipv6_list = smartlist_new();
+  both_list = smartlist_new();
+  dupl_list = smartlist_new();
+
+  smartlist_add(ipv4_list, &ipv4_addr);
+  smartlist_add(both_list, &ipv4_addr);
+  smartlist_add(dupl_list, &ipv4_addr);
+  smartlist_add(dupl_list, &ipv4_addr);
+  smartlist_add(dupl_list, &ipv4_addr);
+
+  smartlist_add(ipv6_list, &ipv6_addr);
+  smartlist_add(both_list, &ipv6_addr);
+  smartlist_add(dupl_list, &ipv6_addr);
+  smartlist_add(dupl_list, &ipv6_addr);
+
+  /* IPv4-Only Exits */
+
+  /* test that IPv4 addresses are rejected on an IPv4-only exit */
+  policies_parse_exit_policy_reject_private(&policy, 0, ipv4_list, 0, 0);
+  tt_assert(policy);
+  tt_assert(smartlist_len(policy) == 1);
+  tt_assert(test_policy_has_address_helper(policy, &ipv4_addr));
+  addr_policy_list_free(policy);
+  policy = NULL;
+
+  /* test that IPv6 addresses are NOT rejected on an IPv4-only exit
+   * (all IPv6 addresses are rejected by policies_parse_exit_policy_internal
+   * on IPv4-only exits, so policies_parse_exit_policy_reject_private doesn't
+   * need to do anything) */
+  policies_parse_exit_policy_reject_private(&policy, 0, ipv6_list, 0, 0);
+  tt_assert(policy == NULL);
+
+  /* test that only IPv4 addresses are rejected on an IPv4-only exit */
+  policies_parse_exit_policy_reject_private(&policy, 0, both_list, 0, 0);
+  tt_assert(policy);
+  tt_assert(smartlist_len(policy) == 1);
+  tt_assert(test_policy_has_address_helper(policy, &ipv4_addr));
+  addr_policy_list_free(policy);
+  policy = NULL;
+
+  /* Test that lists with duplicate entries produce the same results */
+  policies_parse_exit_policy_reject_private(&policy, 0, dupl_list, 0, 0);
+  tt_assert(policy);
+  tt_assert(smartlist_len(policy) == 1);
+  tt_assert(test_policy_has_address_helper(policy, &ipv4_addr));
+  addr_policy_list_free(policy);
+  policy = NULL;
+
+  /* IPv4/IPv6 Exits */
+
+  /* test that IPv4 addresses are rejected on an IPv4/IPv6 exit */
+  policies_parse_exit_policy_reject_private(&policy, 1, ipv4_list, 0, 0);
+  tt_assert(policy);
+  tt_assert(smartlist_len(policy) == 1);
+  tt_assert(test_policy_has_address_helper(policy, &ipv4_addr));
+  addr_policy_list_free(policy);
+  policy = NULL;
+
+  /* test that IPv6 addresses are rejected on an IPv4/IPv6 exit */
+  policies_parse_exit_policy_reject_private(&policy, 1, ipv6_list,  0, 0);
+  tt_assert(policy);
+  tt_assert(smartlist_len(policy) == 1);
+  tt_assert(test_policy_has_address_helper(policy, &ipv6_addr));
+  addr_policy_list_free(policy);
+  policy = NULL;
+
+  /* test that IPv4 and IPv6 addresses are rejected on an IPv4/IPv6 exit */
+  policies_parse_exit_policy_reject_private(&policy, 1, both_list,  0, 0);
+  tt_assert(policy);
+  tt_assert(smartlist_len(policy) == 2);
+  tt_assert(test_policy_has_address_helper(policy, &ipv4_addr));
+  tt_assert(test_policy_has_address_helper(policy, &ipv6_addr));
+  addr_policy_list_free(policy);
+  policy = NULL;
+
+  /* Test that lists with duplicate entries produce the same results */
+  policies_parse_exit_policy_reject_private(&policy, 1, dupl_list,  0, 0);
+  tt_assert(policy);
+  tt_assert(smartlist_len(policy) == 2);
+  tt_assert(test_policy_has_address_helper(policy, &ipv4_addr));
+  tt_assert(test_policy_has_address_helper(policy, &ipv6_addr));
+  addr_policy_list_free(policy);
+  policy = NULL;
+
+ done:
+  addr_policy_list_free(policy);
+  smartlist_free(ipv4_list);
+  smartlist_free(ipv6_list);
+  smartlist_free(both_list);
+  smartlist_free(dupl_list);
+}
+
+static smartlist_t *test_configured_ports = NULL;
+const smartlist_t *mock_get_configured_ports(void);
+
+/** Returns test_configured_ports */
+const smartlist_t *
+mock_get_configured_ports(void)
+{
+  return test_configured_ports;
+}
+
+/** Run unit tests for rejecting publicly routable configured port addresses
+ * on this exit relay using policies_parse_exit_policy_reject_private */
+static void
+test_policies_reject_port_address(void *arg)
+{
+  smartlist_t *policy = NULL;
+  port_cfg_t *ipv4_port = NULL;
+  port_cfg_t *ipv6_port = NULL;
+  (void)arg;
+
+  test_configured_ports = smartlist_new();
+
+  ipv4_port = port_cfg_new(0);
+  tor_addr_from_ipv4h(&ipv4_port->addr, TEST_IPV4_ADDR);
+  smartlist_add(test_configured_ports, ipv4_port);
+
+  ipv6_port = port_cfg_new(0);
+  tor_addr_parse(&ipv6_port->addr, TEST_IPV6_ADDR);
+  smartlist_add(test_configured_ports, ipv6_port);
+
+  MOCK(get_configured_ports, mock_get_configured_ports);
+
+  /* test that an IPv4 port is rejected on an IPv4-only exit, but an IPv6 port
+   * is NOT rejected (all IPv6 addresses are rejected by
+   * policies_parse_exit_policy_internal on IPv4-only exits, so
+   * policies_parse_exit_policy_reject_private doesn't need to do anything
+   * with IPv6 addresses on IPv4-only exits) */
+  policies_parse_exit_policy_reject_private(&policy, 0, NULL, 0, 1);
+  tt_assert(policy);
+  tt_assert(smartlist_len(policy) == 1);
+  tt_assert(test_policy_has_address_helper(policy, &ipv4_port->addr));
+  addr_policy_list_free(policy);
+  policy = NULL;
+
+  /* test that IPv4 and IPv6 ports are rejected on an IPv4/IPv6 exit */
+  policies_parse_exit_policy_reject_private(&policy, 1, NULL, 0, 1);
+  tt_assert(policy);
+  tt_assert(smartlist_len(policy) == 2);
+  tt_assert(test_policy_has_address_helper(policy, &ipv4_port->addr));
+  tt_assert(test_policy_has_address_helper(policy, &ipv6_port->addr));
+  addr_policy_list_free(policy);
+  policy = NULL;
+
+ done:
+  addr_policy_list_free(policy);
+  if (test_configured_ports) {
+    SMARTLIST_FOREACH(test_configured_ports,
+                      port_cfg_t *, p, port_cfg_free(p));
+    smartlist_free(test_configured_ports);
+    test_configured_ports = NULL;
+  }
+  UNMOCK(get_configured_ports);
+}
+
+smartlist_t *mock_ipv4_addrs = NULL;
+smartlist_t *mock_ipv6_addrs = NULL;
+
+/* mock get_interface_address6_list, returning a deep copy of the template
+ * address list ipv4_interface_address_list or ipv6_interface_address_list */
+static smartlist_t *
+mock_get_interface_address6_list(int severity,
+                            sa_family_t family,
+                            int include_internal)
+{
+  (void)severity;
+  (void)include_internal;
+  smartlist_t *clone_list = smartlist_new();
+  smartlist_t *template_list = NULL;
+
+  if (family == AF_INET) {
+    template_list = mock_ipv4_addrs;
+  } else if (family == AF_INET6) {
+    template_list = mock_ipv6_addrs;
+  } else {
+    return NULL;
+  }
+
+  tt_assert(template_list);
+
+  SMARTLIST_FOREACH_BEGIN(template_list, tor_addr_t *, src_addr) {
+    tor_addr_t *dest_addr = malloc(sizeof(tor_addr_t));
+    memset(dest_addr, 0, sizeof(*dest_addr));
+    tor_addr_copy_tight(dest_addr, src_addr);
+    smartlist_add(clone_list, dest_addr);
+  } SMARTLIST_FOREACH_END(src_addr);
+
+  return clone_list;
+
+ done:
+  free_interface_address6_list(clone_list);
+  return NULL;
+}
+
+/** Run unit tests for rejecting publicly routable interface addresses on this
+ * exit relay using policies_parse_exit_policy_reject_private */
+static void
+test_policies_reject_interface_address(void *arg)
+{
+  smartlist_t *policy = NULL;
+  smartlist_t *public_ipv4_addrs =
+    get_interface_address6_list(LOG_INFO, AF_INET, 0);
+  smartlist_t *public_ipv6_addrs =
+    get_interface_address6_list(LOG_INFO, AF_INET6, 0);
+  tor_addr_t ipv4_addr, ipv6_addr;
+  (void)arg;
+
+  /* test that no addresses are rejected when none are supplied/requested */
+  policies_parse_exit_policy_reject_private(&policy, 0, NULL, 0, 0);
+  tt_assert(policy == NULL);
+
+  /* test that only IPv4 interface addresses are rejected on an IPv4-only exit
+   * (and allow for duplicates)
+   */
+  policies_parse_exit_policy_reject_private(&policy, 0, NULL, 1, 0);
+  if (policy) {
+    tt_assert(smartlist_len(policy) <= smartlist_len(public_ipv4_addrs));
+    addr_policy_list_free(policy);
+    policy = NULL;
+  }
+
+  /* test that IPv4 and IPv6 interface addresses are rejected on an IPv4/IPv6
+   * exit (and allow for duplicates) */
+  policies_parse_exit_policy_reject_private(&policy, 1, NULL, 1, 0);
+  if (policy) {
+    tt_assert(smartlist_len(policy) <= (smartlist_len(public_ipv4_addrs)
+                                        + smartlist_len(public_ipv6_addrs)));
+    addr_policy_list_free(policy);
+    policy = NULL;
+  }
+
+  /* Now do it all again, but mocked */
+  tor_addr_from_ipv4h(&ipv4_addr, TEST_IPV4_ADDR);
+  mock_ipv4_addrs = smartlist_new();
+  smartlist_add(mock_ipv4_addrs, (void *)&ipv4_addr);
+
+  tor_addr_parse(&ipv6_addr, TEST_IPV6_ADDR);
+  mock_ipv6_addrs = smartlist_new();
+  smartlist_add(mock_ipv6_addrs, (void *)&ipv6_addr);
+
+  MOCK(get_interface_address6_list, mock_get_interface_address6_list);
+
+  /* test that no addresses are rejected when none are supplied/requested */
+  policies_parse_exit_policy_reject_private(&policy, 0, NULL, 0, 0);
+  tt_assert(policy == NULL);
+
+  /* test that only IPv4 interface addresses are rejected on an IPv4-only exit
+   */
+  policies_parse_exit_policy_reject_private(&policy, 0, NULL, 1, 0);
+  tt_assert(policy);
+  tt_assert(smartlist_len(policy) == smartlist_len(mock_ipv4_addrs));
+  addr_policy_list_free(policy);
+  policy = NULL;
+
+  /* test that IPv4 and IPv6 interface addresses are rejected on an IPv4/IPv6
+   * exit */
+  policies_parse_exit_policy_reject_private(&policy, 1, NULL, 1, 0);
+  tt_assert(policy);
+  tt_assert(smartlist_len(policy) == (smartlist_len(mock_ipv4_addrs)
+                                      + smartlist_len(mock_ipv6_addrs)));
+  addr_policy_list_free(policy);
+  policy = NULL;
+
+ done:
+  addr_policy_list_free(policy);
+  free_interface_address6_list(public_ipv4_addrs);
+  free_interface_address6_list(public_ipv6_addrs);
+
+  UNMOCK(get_interface_address6_list);
+  /* we don't use free_interface_address6_list on these lists because their
+   * address pointers are stack-based */
+  smartlist_free(mock_ipv4_addrs);
+  smartlist_free(mock_ipv6_addrs);
+}
+
+#undef TEST_IPV4_ADDR
+#undef TEST_IPV6_ADDR
+
 static void
 test_dump_exit_policy_to_string(void *arg)
 {
@@ -578,10 +991,154 @@ test_dump_exit_policy_to_string(void *arg)
  tor_free(ep);
 }
 
+static routerinfo_t *mock_desc_routerinfo = NULL;
+static const routerinfo_t *
+mock_router_get_my_routerinfo(void)
+{
+  return mock_desc_routerinfo;
+}
+
+#define DEFAULT_POLICY_STRING "reject *:*"
+#define TEST_IPV4_ADDR (0x02040608)
+#define TEST_IPV6_ADDR ("2003::ef01")
+
+static or_options_t mock_options;
+
+static const or_options_t *
+mock_get_options(void)
+{
+  return &mock_options;
+}
+
+/** Run unit tests for generating summary lines of exit policies */
+static void
+test_policies_getinfo_helper_policies(void *arg)
+{
+  (void)arg;
+  int rv = 0;
+  size_t ipv4_len = 0, ipv6_len = 0;
+  char *answer = NULL;
+  const char *errmsg = NULL;
+  routerinfo_t mock_my_routerinfo;
+
+  memset(&mock_my_routerinfo, 0, sizeof(mock_my_routerinfo));
+
+  rv = getinfo_helper_policies(NULL, "exit-policy/default", &answer, &errmsg);
+  tt_assert(rv == 0);
+  tt_assert(answer != NULL);
+  tt_assert(strlen(answer) > 0);
+  tor_free(answer);
+
+  rv = getinfo_helper_policies(NULL, "exit-policy/reject-private/default",
+                               &answer, &errmsg);
+  tt_assert(rv == 0);
+  tt_assert(answer != NULL);
+  tt_assert(strlen(answer) > 0);
+  tor_free(answer);
+
+  memset(&mock_my_routerinfo, 0, sizeof(routerinfo_t));
+  MOCK(router_get_my_routerinfo, mock_router_get_my_routerinfo);
+  mock_my_routerinfo.exit_policy = smartlist_new();
+  mock_desc_routerinfo = &mock_my_routerinfo;
+
+  memset(&mock_options, 0, sizeof(or_options_t));
+  MOCK(get_options, mock_get_options);
+
+  rv = getinfo_helper_policies(NULL, "exit-policy/reject-private/relay",
+                               &answer, &errmsg);
+  tt_assert(rv == 0);
+  tt_assert(answer != NULL);
+  tt_assert(strlen(answer) == 0);
+  tor_free(answer);
+
+  rv = getinfo_helper_policies(NULL, "exit-policy/ipv4", &answer,
+                               &errmsg);
+  tt_assert(rv == 0);
+  tt_assert(answer != NULL);
+  ipv4_len = strlen(answer);
+  tt_assert(ipv4_len == 0 || ipv4_len == strlen(DEFAULT_POLICY_STRING));
+  tt_assert(ipv4_len == 0 || !strcasecmp(answer, DEFAULT_POLICY_STRING));
+  tor_free(answer);
+
+  rv = getinfo_helper_policies(NULL, "exit-policy/ipv6", &answer,
+                               &errmsg);
+  tt_assert(rv == 0);
+  tt_assert(answer != NULL);
+  ipv6_len = strlen(answer);
+  tt_assert(ipv6_len == 0 || ipv6_len == strlen(DEFAULT_POLICY_STRING));
+  tt_assert(ipv6_len == 0 || !strcasecmp(answer, DEFAULT_POLICY_STRING));
+  tor_free(answer);
+
+  rv = getinfo_helper_policies(NULL, "exit-policy/full", &answer,
+                               &errmsg);
+  tt_assert(rv == 0);
+  tt_assert(answer != NULL);
+  /* It's either empty or it's the default */
+  tt_assert(strlen(answer) == 0 || !strcasecmp(answer, DEFAULT_POLICY_STRING));
+  tor_free(answer);
+
+  mock_my_routerinfo.addr = TEST_IPV4_ADDR;
+  tor_addr_parse(&mock_my_routerinfo.ipv6_addr, TEST_IPV6_ADDR);
+  append_exit_policy_string(&mock_my_routerinfo.exit_policy, "accept *4:*");
+  append_exit_policy_string(&mock_my_routerinfo.exit_policy, "reject *6:*");
+
+  mock_options.IPv6Exit = 1;
+  mock_options.ExitPolicyRejectPrivate = 1;
+  tor_addr_from_ipv4h(&mock_options.OutboundBindAddressIPv4_, TEST_IPV4_ADDR);
+  tor_addr_parse(&mock_options.OutboundBindAddressIPv6_, TEST_IPV6_ADDR);
+
+  rv = getinfo_helper_policies(NULL, "exit-policy/reject-private/relay",
+                               &answer, &errmsg);
+  tt_assert(rv == 0);
+  tt_assert(answer != NULL);
+  tt_assert(strlen(answer) > 0);
+  tor_free(answer);
+
+  rv = getinfo_helper_policies(NULL, "exit-policy/ipv4", &answer,
+                               &errmsg);
+  tt_assert(rv == 0);
+  tt_assert(answer != NULL);
+  ipv4_len = strlen(answer);
+  tt_assert(ipv4_len > 0);
+  tor_free(answer);
+
+  rv = getinfo_helper_policies(NULL, "exit-policy/ipv6", &answer,
+                               &errmsg);
+  tt_assert(rv == 0);
+  tt_assert(answer != NULL);
+  ipv6_len = strlen(answer);
+  tt_assert(ipv6_len > 0);
+  tor_free(answer);
+
+  rv = getinfo_helper_policies(NULL, "exit-policy/full", &answer,
+                               &errmsg);
+  tt_assert(rv == 0);
+  tt_assert(answer != NULL);
+  tt_assert(strlen(answer) > 0);
+  tt_assert(strlen(answer) == ipv4_len + ipv6_len + 1);
+  tor_free(answer);
+
+ done:
+  tor_free(answer);
+  UNMOCK(get_options);
+  UNMOCK(router_get_my_routerinfo);
+  addr_policy_list_free(mock_my_routerinfo.exit_policy);
+}
+
+#undef DEFAULT_POLICY_STRING
+#undef TEST_IPV4_ADDR
+#undef TEST_IPV6_ADDR
+
 struct testcase_t policy_tests[] = {
   { "router_dump_exit_policy_to_string", test_dump_exit_policy_to_string, 0,
     NULL, NULL },
   { "general", test_policies_general, 0, NULL, NULL },
+  { "getinfo_helper_policies", test_policies_getinfo_helper_policies, 0, NULL,
+    NULL },
+  { "reject_exit_address", test_policies_reject_exit_address, 0, NULL, NULL },
+  { "reject_interface_address", test_policies_reject_interface_address, 0,
+    NULL, NULL },
+  { "reject_port_address", test_policies_reject_port_address, 0, NULL, NULL },
   END_OF_TESTCASES
 };
 
diff --git a/src/test/test_procmon.c b/src/test/test_procmon.c
new file mode 100644
index 0000000..2855178
--- /dev/null
+++ b/src/test/test_procmon.c
@@ -0,0 +1,58 @@
+/* Copyright (c) 2010-2015, The Tor Project, Inc. */
+/* See LICENSE for licensing information */
+
+#define PROCMON_PRIVATE
+#include "orconfig.h"
+#include "or.h"
+#include "test.h"
+
+#include "procmon.h"
+
+#include "log_test_helpers.h"
+
+#define NS_MODULE procmon
+
+struct event_base;
+
+static void
+test_procmon_tor_process_monitor_new(void *ignored)
+{
+  (void)ignored;
+  tor_process_monitor_t *res;
+  const char *msg;
+
+  res = tor_process_monitor_new(NULL, "probably invalid", 0, NULL, NULL, &msg);
+  tt_assert(!res);
+  tt_str_op(msg, OP_EQ, "invalid PID");
+
+  res = tor_process_monitor_new(NULL, "243443535345454", 0, NULL, NULL, &msg);
+  tt_assert(!res);
+  tt_str_op(msg, OP_EQ, "invalid PID");
+
+  res = tor_process_monitor_new(tor_libevent_get_base(), "43", 0,
+                                NULL, NULL, &msg);
+  tt_assert(res);
+  tt_assert(!msg);
+  tor_process_monitor_free(res);
+
+  res = tor_process_monitor_new(tor_libevent_get_base(), "44 hello", 0,
+                                NULL, NULL, &msg);
+  tt_assert(res);
+  tt_assert(!msg);
+  tor_process_monitor_free(res);
+
+  res = tor_process_monitor_new(tor_libevent_get_base(), "45:hello", 0,
+                                NULL, NULL, &msg);
+  tt_assert(res);
+  tt_assert(!msg);
+
+ done:
+  tor_process_monitor_free(res);
+}
+
+struct testcase_t procmon_tests[] = {
+  { "tor_process_monitor_new", test_procmon_tor_process_monitor_new,
+    TT_FORK, NULL, NULL },
+  END_OF_TESTCASES
+};
+
diff --git a/src/test/test_rendcache.c b/src/test/test_rendcache.c
new file mode 100644
index 0000000..7779699
--- /dev/null
+++ b/src/test/test_rendcache.c
@@ -0,0 +1,1340 @@
+/* Copyright (c) 2010-2015, The Tor Project, Inc. */
+/* See LICENSE for licensing information */
+
+#include "orconfig.h"
+#include "or.h"
+
+#include "test.h"
+#define RENDCACHE_PRIVATE
+#include "rendcache.h"
+#include "router.h"
+#include "routerlist.h"
+#include "config.h"
+#include <openssl/rsa.h>
+#include "rend_test_helpers.h"
+
+#define NS_MODULE rend_cache
+
+static const int RECENT_TIME = -10;
+static const int TIME_IN_THE_PAST = -(REND_CACHE_MAX_AGE + \
+                                      REND_CACHE_MAX_SKEW + 10);
+static const int TIME_IN_THE_FUTURE = REND_CACHE_MAX_SKEW + 10;
+
+extern strmap_t *rend_cache;
+extern digestmap_t *rend_cache_v2_dir;
+extern strmap_t *rend_cache_failure;
+extern size_t rend_cache_total_allocation;
+
+static rend_data_t *
+mock_rend_data(const char *onion_address)
+{
+  rend_data_t *rend_query = tor_malloc_zero(sizeof(rend_data_t));
+
+  strlcpy(rend_query->onion_address, onion_address,
+          sizeof(rend_query->onion_address));
+  rend_query->auth_type = REND_NO_AUTH;
+  rend_query->hsdirs_fp = smartlist_new();
+  smartlist_add(rend_query->hsdirs_fp, tor_memdup("aaaaaaaaaaaaaaaaaaaaaaaa",
+                                                 DIGEST_LEN));
+
+  return rend_query;
+}
+
+static void
+test_rend_cache_lookup_entry(void *data)
+{
+  int ret;
+  rend_data_t *mock_rend_query = NULL;
+  char desc_id_base32[REND_DESC_ID_V2_LEN_BASE32 + 1];
+  rend_cache_entry_t *entry = NULL;
+  rend_encoded_v2_service_descriptor_t *desc_holder = NULL;
+  char *service_id = NULL;
+  (void)data;
+
+  rend_cache_init();
+
+  generate_desc(RECENT_TIME, &desc_holder, &service_id, 3);
+
+  ret = rend_cache_lookup_entry("abababababababab", 0, NULL);
+  tt_int_op(ret, OP_EQ, -ENOENT);
+
+  ret = rend_cache_lookup_entry("invalid query", 2, NULL);
+  tt_int_op(ret, OP_EQ, -EINVAL);
+
+  ret = rend_cache_lookup_entry("abababababababab", 2, NULL);
+  tt_int_op(ret, OP_EQ, -ENOENT);
+
+  ret = rend_cache_lookup_entry("abababababababab", 4224, NULL);
+  tt_int_op(ret, OP_EQ, -ENOENT);
+
+  mock_rend_query = mock_rend_data(service_id);
+  base32_encode(desc_id_base32, sizeof(desc_id_base32), desc_holder->desc_id,
+                DIGEST_LEN);
+  rend_cache_store_v2_desc_as_client(desc_holder->desc_str, desc_id_base32,
+                                     mock_rend_query, NULL);
+
+  ret = rend_cache_lookup_entry(service_id, 2, NULL);
+  tt_int_op(ret, OP_EQ, 0);
+
+  ret = rend_cache_lookup_entry(service_id, 2, &entry);
+  tt_assert(entry);
+  tt_int_op(entry->len, OP_EQ, strlen(desc_holder->desc_str));
+  tt_str_op(entry->desc, OP_EQ, desc_holder->desc_str);
+
+ done:
+  rend_encoded_v2_service_descriptor_free(desc_holder);
+  tor_free(service_id);
+  rend_cache_free_all();
+  rend_data_free(mock_rend_query);
+}
+
+static void
+test_rend_cache_store_v2_desc_as_client(void *data)
+{
+  rend_cache_store_status_t ret;
+  rend_data_t *mock_rend_query;
+  char desc_id_base32[REND_DESC_ID_V2_LEN_BASE32 + 1];
+  rend_cache_entry_t *entry = NULL;
+  rend_encoded_v2_service_descriptor_t *desc_holder = NULL;
+  char *service_id = NULL;
+  char client_cookie[REND_DESC_COOKIE_LEN];
+  (void)data;
+
+  rend_cache_init();
+
+  generate_desc(RECENT_TIME, &desc_holder, &service_id, 3);
+
+  // Test success
+  mock_rend_query = mock_rend_data(service_id);
+  base32_encode(desc_id_base32, sizeof(desc_id_base32), desc_holder->desc_id,
+                DIGEST_LEN);
+  ret = rend_cache_store_v2_desc_as_client(desc_holder->desc_str,
+                                           desc_id_base32, mock_rend_query,
+                                           &entry);
+
+  tt_int_op(ret, OP_EQ, RCS_OKAY);
+  tt_assert(entry);
+  tt_int_op(entry->len, OP_EQ, strlen(desc_holder->desc_str));
+  tt_str_op(entry->desc, OP_EQ, desc_holder->desc_str);
+
+  // Test various failure modes
+
+  // TODO: a too long desc_id_base32 argument crashes the function
+   /* ret = rend_cache_store_v2_desc_as_client( */
+   /*                   desc_holder->desc_str, */
+   /*                   "3TOOLONG3TOOLONG3TOOLONG3TOOLONG3TOOLONG3TOOLONG", */
+   /*                   &mock_rend_query, NULL); */
+  /* tt_int_op(ret, OP_EQ, RCS_BADDESC); */
+
+  // Test bad base32 failure
+  // This causes an assertion failure if we're running with assertions.
+  // But when doing coverage, we can test it.
+#ifdef TOR_COVERAGE
+  ret = rend_cache_store_v2_desc_as_client(desc_holder->desc_str,
+                   "!xqunszqnaolrrfmtzgaki7mxelgvkj", mock_rend_query, NULL);
+  tt_int_op(ret, OP_EQ, RCS_BADDESC);
+#endif
+
+  // Test invalid descriptor
+  ret = rend_cache_store_v2_desc_as_client("invalid descriptor",
+             "3xqunszqnaolrrfmtzgaki7mxelgvkje", mock_rend_query, NULL);
+  tt_int_op(ret, OP_EQ, RCS_BADDESC);
+
+  // TODO: it doesn't seem to be possible to test invalid service ID condition.
+  // that means it is likely not possible to have that condition without
+  // earlier conditions failing first (such as signature checking of the desc)
+
+  rend_cache_free_all();
+
+  // Test mismatch between service ID and onion address
+  rend_cache_init();
+  strncpy(mock_rend_query->onion_address, "abc", REND_SERVICE_ID_LEN_BASE32+1);
+  ret = rend_cache_store_v2_desc_as_client(desc_holder->desc_str,
+                                           desc_id_base32,
+                                           mock_rend_query, NULL);
+  tt_int_op(ret, OP_EQ, RCS_BADDESC);
+  rend_cache_free_all();
+  rend_data_free(mock_rend_query);
+
+  // Test incorrect descriptor ID
+  rend_cache_init();
+  mock_rend_query = mock_rend_data(service_id);
+  desc_id_base32[0]++;
+  ret = rend_cache_store_v2_desc_as_client(desc_holder->desc_str,
+                                           desc_id_base32, mock_rend_query,
+                                           NULL);
+  tt_int_op(ret, OP_EQ, RCS_BADDESC);
+  desc_id_base32[0]--;
+  rend_cache_free_all();
+
+  // Test too old descriptor
+  rend_cache_init();
+  rend_encoded_v2_service_descriptor_free(desc_holder);
+  tor_free(service_id);
+  rend_data_free(mock_rend_query);
+
+  generate_desc(TIME_IN_THE_PAST, &desc_holder, &service_id, 3);
+  mock_rend_query = mock_rend_data(service_id);
+  base32_encode(desc_id_base32, sizeof(desc_id_base32), desc_holder->desc_id,
+                DIGEST_LEN);
+
+  ret = rend_cache_store_v2_desc_as_client(desc_holder->desc_str,
+                                           desc_id_base32,
+                                           mock_rend_query, NULL);
+  tt_int_op(ret, OP_EQ, RCS_BADDESC);
+  rend_cache_free_all();
+
+  // Test too new descriptor (in the future)
+  rend_cache_init();
+  rend_encoded_v2_service_descriptor_free(desc_holder);
+  tor_free(service_id);
+  rend_data_free(mock_rend_query);
+
+  generate_desc(TIME_IN_THE_FUTURE, &desc_holder, &service_id, 3);
+  mock_rend_query = mock_rend_data(service_id);
+  base32_encode(desc_id_base32, sizeof(desc_id_base32), desc_holder->desc_id,
+                DIGEST_LEN);
+
+  ret = rend_cache_store_v2_desc_as_client(desc_holder->desc_str,
+                                           desc_id_base32, mock_rend_query,
+                                           NULL);
+  tt_int_op(ret, OP_EQ, RCS_BADDESC);
+  rend_cache_free_all();
+
+  // Test when a descriptor is already in the cache
+  rend_cache_init();
+  rend_encoded_v2_service_descriptor_free(desc_holder);
+  tor_free(service_id);
+  rend_data_free(mock_rend_query);
+
+  generate_desc(RECENT_TIME, &desc_holder, &service_id, 3);
+  mock_rend_query = mock_rend_data(service_id);
+  base32_encode(desc_id_base32, sizeof(desc_id_base32), desc_holder->desc_id,
+                DIGEST_LEN);
+
+  rend_cache_store_v2_desc_as_client(desc_holder->desc_str, desc_id_base32,
+                                     mock_rend_query, NULL);
+  ret = rend_cache_store_v2_desc_as_client(desc_holder->desc_str,
+                                           desc_id_base32, mock_rend_query,
+                                           NULL);
+  tt_int_op(ret, OP_EQ, RCS_OKAY);
+
+  ret = rend_cache_store_v2_desc_as_client(desc_holder->desc_str,
+                                           desc_id_base32, mock_rend_query,
+                                           &entry);
+  tt_int_op(ret, OP_EQ, RCS_OKAY);
+  tt_assert(entry);
+  rend_cache_free_all();
+
+  // Test unsuccessful decrypting of introduction points
+  rend_cache_init();
+  rend_encoded_v2_service_descriptor_free(desc_holder);
+  tor_free(service_id);
+  rend_data_free(mock_rend_query);
+
+  generate_desc(RECENT_TIME, &desc_holder, &service_id, 3);
+  mock_rend_query = mock_rend_data(service_id);
+  mock_rend_query->auth_type = REND_BASIC_AUTH;
+  client_cookie[0] = 'A';
+  memcpy(mock_rend_query->descriptor_cookie, client_cookie,
+         REND_DESC_COOKIE_LEN);
+  base32_encode(desc_id_base32, sizeof(desc_id_base32), desc_holder->desc_id,
+                DIGEST_LEN);
+  ret = rend_cache_store_v2_desc_as_client(desc_holder->desc_str,
+                                           desc_id_base32, mock_rend_query,
+                                           NULL);
+  tt_int_op(ret, OP_EQ, RCS_OKAY);
+  rend_cache_free_all();
+
+  // Test successful run when we have REND_BASIC_AUTH but not cookie
+  rend_cache_init();
+  rend_encoded_v2_service_descriptor_free(desc_holder);
+  tor_free(service_id);
+  rend_data_free(mock_rend_query);
+
+  generate_desc(RECENT_TIME, &desc_holder, &service_id, 3);
+  mock_rend_query = mock_rend_data(service_id);
+  mock_rend_query->auth_type = REND_BASIC_AUTH;
+  base32_encode(desc_id_base32, sizeof(desc_id_base32), desc_holder->desc_id,
+                DIGEST_LEN);
+  ret = rend_cache_store_v2_desc_as_client(desc_holder->desc_str,
+                                           desc_id_base32, mock_rend_query,
+                                           NULL);
+  tt_int_op(ret, OP_EQ, RCS_OKAY);
+
+  rend_cache_free_all();
+
+  // Test when we have no introduction points
+  rend_cache_init();
+  rend_encoded_v2_service_descriptor_free(desc_holder);
+  tor_free(service_id);
+  rend_data_free(mock_rend_query);
+
+  generate_desc(RECENT_TIME, &desc_holder, &service_id, 0);
+  mock_rend_query = mock_rend_data(service_id);
+  base32_encode(desc_id_base32, sizeof(desc_id_base32), desc_holder->desc_id,
+                DIGEST_LEN);
+  ret = rend_cache_store_v2_desc_as_client(desc_holder->desc_str,
+                                           desc_id_base32, mock_rend_query,
+                                           NULL);
+  tt_int_op(ret, OP_EQ, RCS_BADDESC);
+  rend_cache_free_all();
+
+  // Test when we have too many intro points
+  rend_cache_init();
+  rend_encoded_v2_service_descriptor_free(desc_holder);
+  tor_free(service_id);
+  rend_data_free(mock_rend_query);
+
+  generate_desc(RECENT_TIME, &desc_holder, &service_id, MAX_INTRO_POINTS+1);
+  mock_rend_query = mock_rend_data(service_id);
+  base32_encode(desc_id_base32, sizeof(desc_id_base32), desc_holder->desc_id,
+                DIGEST_LEN);
+  ret = rend_cache_store_v2_desc_as_client(desc_holder->desc_str,
+                                           desc_id_base32, mock_rend_query,
+                                           NULL);
+  tt_int_op(ret, OP_EQ, RCS_BADDESC);
+
+ done:
+  rend_encoded_v2_service_descriptor_free(desc_holder);
+  tor_free(service_id);
+  rend_cache_free_all();
+  rend_data_free(mock_rend_query);
+}
+
+static void
+test_rend_cache_store_v2_desc_as_client_with_different_time(void *data)
+{
+  rend_cache_store_status_t ret;
+  rend_data_t *mock_rend_query;
+  char desc_id_base32[REND_DESC_ID_V2_LEN_BASE32 + 1];
+  rend_service_descriptor_t *generated = NULL;
+  smartlist_t *descs = smartlist_new();
+  time_t t;
+  char *service_id = NULL;
+  rend_encoded_v2_service_descriptor_t *desc_holder_newer;
+  rend_encoded_v2_service_descriptor_t *desc_holder_older;
+
+  t = time(NULL);
+  rend_cache_init();
+
+  create_descriptor(&generated, &service_id, 3);
+
+  generated->timestamp = t + RECENT_TIME;
+  rend_encode_v2_descriptors(descs, generated, t + RECENT_TIME, 0,
+                             REND_NO_AUTH, NULL, NULL);
+  desc_holder_newer = ((rend_encoded_v2_service_descriptor_t *)
+                       smartlist_get(descs, 0));
+  smartlist_set(descs, 0, NULL);
+
+  SMARTLIST_FOREACH(descs, rend_encoded_v2_service_descriptor_t *, d,
+                    rend_encoded_v2_service_descriptor_free(d));
+  smartlist_free(descs);
+  descs = smartlist_new();
+
+  generated->timestamp = (t + RECENT_TIME) - 20;
+  rend_encode_v2_descriptors(descs, generated, t + RECENT_TIME, 0,
+                             REND_NO_AUTH, NULL, NULL);
+  desc_holder_older = ((rend_encoded_v2_service_descriptor_t *)
+                       smartlist_get(descs, 0));
+  smartlist_set(descs, 0, NULL);
+  (void)data;
+
+  // Test when a descriptor is already in the cache and it is newer than the
+  // one we submit
+  mock_rend_query = mock_rend_data(service_id);
+  base32_encode(desc_id_base32, sizeof(desc_id_base32),
+                desc_holder_newer->desc_id, DIGEST_LEN);
+  rend_cache_store_v2_desc_as_client(desc_holder_newer->desc_str,
+                                     desc_id_base32, mock_rend_query, NULL);
+  ret = rend_cache_store_v2_desc_as_client(desc_holder_older->desc_str,
+                                           desc_id_base32, mock_rend_query,
+                                           NULL);
+  tt_int_op(ret, OP_EQ, RCS_OKAY);
+
+  rend_cache_free_all();
+
+  // Test when an old descriptor is in the cache and we submit a newer one
+  rend_cache_init();
+  rend_cache_store_v2_desc_as_client(desc_holder_older->desc_str,
+                                     desc_id_base32, mock_rend_query, NULL);
+  ret = rend_cache_store_v2_desc_as_client(desc_holder_newer->desc_str,
+                                           desc_id_base32, mock_rend_query,
+                                           NULL);
+  tt_int_op(ret, OP_EQ, RCS_OKAY);
+
+ done:
+  rend_encoded_v2_service_descriptor_free(desc_holder_newer);
+  rend_encoded_v2_service_descriptor_free(desc_holder_older);
+  SMARTLIST_FOREACH(descs, rend_encoded_v2_service_descriptor_t *, d,
+                    rend_encoded_v2_service_descriptor_free(d));
+  smartlist_free(descs);
+  rend_service_descriptor_free(generated);
+  tor_free(service_id);
+  rend_cache_free_all();
+  rend_data_free(mock_rend_query);
+}
+
+#define NS_SUBMODULE lookup_v2_desc_as_dir
+NS_DECL(const routerinfo_t *, router_get_my_routerinfo, (void));
+NS_DECL(int, hid_serv_responsible_for_desc_id, (const char *id));
+
+static routerinfo_t *mock_routerinfo;
+static int hid_serv_responsible_for_desc_id_response;
+
+static const routerinfo_t *
+NS(router_get_my_routerinfo)(void)
+{
+  if (!mock_routerinfo) {
+    mock_routerinfo = tor_malloc(sizeof(routerinfo_t));
+  }
+
+  return mock_routerinfo;
+}
+
+static int
+NS(hid_serv_responsible_for_desc_id)(const char *id)
+{
+  (void)id;
+  return hid_serv_responsible_for_desc_id_response;
+}
+
+static void
+test_rend_cache_lookup_v2_desc_as_dir(void *data)
+{
+  int ret;
+  char desc_id_base32[REND_DESC_ID_V2_LEN_BASE32 + 1];
+  rend_encoded_v2_service_descriptor_t *desc_holder = NULL;
+  char *service_id = NULL;
+  const char *ret_desc = NULL;
+
+  (void)data;
+
+  NS_MOCK(router_get_my_routerinfo);
+  NS_MOCK(hid_serv_responsible_for_desc_id);
+
+  rend_cache_init();
+
+  // Test invalid base32
+  ret = rend_cache_lookup_v2_desc_as_dir("!bababababababab", NULL);
+  tt_int_op(ret, OP_EQ, -1);
+
+  // Test non-existent descriptor but well formed
+  ret = rend_cache_lookup_v2_desc_as_dir("3xqunszqnaolrrfmtzgaki7mxelgvkje",
+                                         NULL);
+  tt_int_op(ret, OP_EQ, 0);
+
+  // Test existing descriptor
+  hid_serv_responsible_for_desc_id_response = 1;
+  generate_desc(RECENT_TIME, &desc_holder, &service_id, 3);
+  rend_cache_store_v2_desc_as_dir(desc_holder->desc_str);
+  base32_encode(desc_id_base32, sizeof(desc_id_base32), desc_holder->desc_id,
+                DIGEST_LEN);
+  ret = rend_cache_lookup_v2_desc_as_dir(desc_id_base32, &ret_desc);
+  tt_int_op(ret, OP_EQ, 1);
+  tt_assert(ret_desc);
+
+ done:
+  NS_UNMOCK(router_get_my_routerinfo);
+  NS_UNMOCK(hid_serv_responsible_for_desc_id);
+  tor_free(mock_routerinfo);
+  rend_cache_free_all();
+  rend_encoded_v2_service_descriptor_free(desc_holder);
+  tor_free(service_id);
+}
+
+#undef NS_SUBMODULE
+
+#define NS_SUBMODULE store_v2_desc_as_dir
+NS_DECL(const routerinfo_t *, router_get_my_routerinfo, (void));
+NS_DECL(int, hid_serv_responsible_for_desc_id, (const char *id));
+
+static const routerinfo_t *
+NS(router_get_my_routerinfo)(void)
+{
+  return mock_routerinfo;
+}
+
+static int
+NS(hid_serv_responsible_for_desc_id)(const char *id)
+{
+  (void)id;
+  return hid_serv_responsible_for_desc_id_response;
+}
+
+static void
+test_rend_cache_store_v2_desc_as_dir(void *data)
+{
+  (void)data;
+  rend_cache_store_status_t ret;
+  rend_encoded_v2_service_descriptor_t *desc_holder = NULL;
+  char *service_id = NULL;
+
+  NS_MOCK(router_get_my_routerinfo);
+  NS_MOCK(hid_serv_responsible_for_desc_id);
+
+  rend_cache_init();
+
+  // Test when we are not an HS dir
+  mock_routerinfo = NULL;
+  ret = rend_cache_store_v2_desc_as_dir("");
+  tt_int_op(ret, OP_EQ, RCS_NOTDIR);
+
+  // Test when we can't parse the descriptor
+  mock_routerinfo = tor_malloc(sizeof(routerinfo_t));
+  hid_serv_responsible_for_desc_id_response = 1;
+  ret = rend_cache_store_v2_desc_as_dir("unparseable");
+  tt_int_op(ret, OP_EQ, RCS_BADDESC);
+
+  // Test when we are not responsible for an HS
+  hid_serv_responsible_for_desc_id_response = 0;
+  generate_desc(RECENT_TIME, &desc_holder, &service_id, 3);
+  ret = rend_cache_store_v2_desc_as_dir(desc_holder->desc_str);
+  tt_int_op(ret, OP_EQ, RCS_OKAY);
+
+  rend_encoded_v2_service_descriptor_free(desc_holder);
+  tor_free(service_id);
+
+  // Test when we have an old descriptor
+  hid_serv_responsible_for_desc_id_response = 1;
+  generate_desc(TIME_IN_THE_PAST, &desc_holder, &service_id, 3);
+  ret = rend_cache_store_v2_desc_as_dir(desc_holder->desc_str);
+  tt_int_op(ret, OP_EQ, RCS_OKAY);
+
+  rend_encoded_v2_service_descriptor_free(desc_holder);
+  tor_free(service_id);
+
+  // Test when we have a descriptor in the future
+  generate_desc(TIME_IN_THE_FUTURE, &desc_holder, &service_id, 3);
+  ret = rend_cache_store_v2_desc_as_dir(desc_holder->desc_str);
+  tt_int_op(ret, OP_EQ, RCS_OKAY);
+
+  rend_encoded_v2_service_descriptor_free(desc_holder);
+  tor_free(service_id);
+
+  // Test when two descriptors
+  generate_desc(TIME_IN_THE_FUTURE, &desc_holder, &service_id, 3);
+  ret = rend_cache_store_v2_desc_as_dir(desc_holder->desc_str);
+  tt_int_op(ret, OP_EQ, RCS_OKAY);
+
+  rend_encoded_v2_service_descriptor_free(desc_holder);
+  tor_free(service_id);
+
+  // Test when asking for hidden service statistics  HiddenServiceStatistics
+  rend_cache_purge();
+  generate_desc(RECENT_TIME, &desc_holder, &service_id, 3);
+  get_options_mutable()->HiddenServiceStatistics = 1;
+  ret = rend_cache_store_v2_desc_as_dir(desc_holder->desc_str);
+  tt_int_op(ret, OP_EQ, RCS_OKAY);
+
+ done:
+  NS_UNMOCK(router_get_my_routerinfo);
+  NS_UNMOCK(hid_serv_responsible_for_desc_id);
+  rend_encoded_v2_service_descriptor_free(desc_holder);
+  tor_free(service_id);
+  rend_cache_free_all();
+  tor_free(mock_routerinfo);
+}
+
+static void
+test_rend_cache_store_v2_desc_as_dir_with_different_time(void *data)
+{
+  (void)data;
+
+  rend_cache_store_status_t ret;
+  rend_service_descriptor_t *generated = NULL;
+  smartlist_t *descs = smartlist_new();
+  time_t t;
+  char *service_id = NULL;
+  rend_encoded_v2_service_descriptor_t *desc_holder_newer;
+  rend_encoded_v2_service_descriptor_t *desc_holder_older;
+
+  NS_MOCK(router_get_my_routerinfo);
+  NS_MOCK(hid_serv_responsible_for_desc_id);
+
+  rend_cache_init();
+
+  t = time(NULL);
+
+  create_descriptor(&generated, &service_id, 3);
+  generated->timestamp = t + RECENT_TIME;
+  rend_encode_v2_descriptors(descs, generated, t + RECENT_TIME, 0,
+                             REND_NO_AUTH, NULL, NULL);
+  desc_holder_newer = ((rend_encoded_v2_service_descriptor_t *)
+                       smartlist_get(descs, 0));
+  smartlist_set(descs, 0, NULL);
+  SMARTLIST_FOREACH(descs, rend_encoded_v2_service_descriptor_t *, d,
+                    rend_encoded_v2_service_descriptor_free(d));
+  smartlist_free(descs);
+  descs = smartlist_new();
+
+  generated->timestamp = (t + RECENT_TIME) - 20;
+  rend_encode_v2_descriptors(descs, generated, t + RECENT_TIME, 0,
+                             REND_NO_AUTH, NULL, NULL);
+  desc_holder_older = ((rend_encoded_v2_service_descriptor_t *)
+                       smartlist_get(descs, 0));
+  smartlist_set(descs, 0, NULL);
+
+  // Test when we have a newer descriptor stored
+  mock_routerinfo = tor_malloc(sizeof(routerinfo_t));
+  hid_serv_responsible_for_desc_id_response = 1;
+  rend_cache_store_v2_desc_as_dir(desc_holder_newer->desc_str);
+  ret = rend_cache_store_v2_desc_as_dir(desc_holder_older->desc_str);
+  tt_int_op(ret, OP_EQ, RCS_OKAY);
+
+  // Test when we have an old descriptor stored
+  rend_cache_purge();
+  rend_cache_store_v2_desc_as_dir(desc_holder_older->desc_str);
+  ret = rend_cache_store_v2_desc_as_dir(desc_holder_newer->desc_str);
+  tt_int_op(ret, OP_EQ, RCS_OKAY);
+
+ done:
+  NS_UNMOCK(router_get_my_routerinfo);
+  NS_UNMOCK(hid_serv_responsible_for_desc_id);
+  rend_cache_free_all();
+  rend_service_descriptor_free(generated);
+  tor_free(service_id);
+  SMARTLIST_FOREACH(descs, rend_encoded_v2_service_descriptor_t *, d,
+                    rend_encoded_v2_service_descriptor_free(d));
+  smartlist_free(descs);
+  rend_encoded_v2_service_descriptor_free(desc_holder_newer);
+  rend_encoded_v2_service_descriptor_free(desc_holder_older);
+  tor_free(mock_routerinfo);
+}
+
+static void
+test_rend_cache_store_v2_desc_as_dir_with_different_content(void *data)
+{
+  (void)data;
+
+  rend_cache_store_status_t ret;
+  rend_service_descriptor_t *generated = NULL;
+  smartlist_t *descs = smartlist_new();
+  time_t t;
+  char *service_id = NULL;
+  rend_encoded_v2_service_descriptor_t *desc_holder_one = NULL;
+  rend_encoded_v2_service_descriptor_t *desc_holder_two = NULL;
+
+  NS_MOCK(router_get_my_routerinfo);
+  NS_MOCK(hid_serv_responsible_for_desc_id);
+
+  rend_cache_init();
+
+  t = time(NULL);
+
+  create_descriptor(&generated, &service_id, 3);
+  generated->timestamp = t + RECENT_TIME;
+  rend_encode_v2_descriptors(descs, generated, t + RECENT_TIME, 0,
+                             REND_NO_AUTH, NULL, NULL);
+  desc_holder_one = ((rend_encoded_v2_service_descriptor_t *)
+                     smartlist_get(descs, 0));
+  smartlist_set(descs, 0, NULL);
+
+  SMARTLIST_FOREACH(descs, rend_encoded_v2_service_descriptor_t *, d,
+                    rend_encoded_v2_service_descriptor_free(d));
+  smartlist_free(descs);
+  descs = smartlist_new();
+
+  generated->timestamp = t + RECENT_TIME;
+  generated->protocols = 41;
+  rend_encode_v2_descriptors(descs, generated, t + RECENT_TIME, 0,
+                             REND_NO_AUTH, NULL, NULL);
+  desc_holder_two = ((rend_encoded_v2_service_descriptor_t *)
+                     smartlist_get(descs, 0));
+  smartlist_set(descs, 0, NULL);
+
+  // Test when we have another descriptor stored, with a different descriptor
+  mock_routerinfo = tor_malloc(sizeof(routerinfo_t));
+  hid_serv_responsible_for_desc_id_response = 1;
+  rend_cache_store_v2_desc_as_dir(desc_holder_one->desc_str);
+  ret = rend_cache_store_v2_desc_as_dir(desc_holder_two->desc_str);
+  tt_int_op(ret, OP_EQ, RCS_OKAY);
+
+ done:
+  NS_UNMOCK(router_get_my_routerinfo);
+  NS_UNMOCK(hid_serv_responsible_for_desc_id);
+  rend_cache_free_all();
+  rend_service_descriptor_free(generated);
+  tor_free(service_id);
+  SMARTLIST_FOREACH(descs, rend_encoded_v2_service_descriptor_t *, d,
+                    rend_encoded_v2_service_descriptor_free(d));
+  smartlist_free(descs);
+  rend_encoded_v2_service_descriptor_free(desc_holder_one);
+  rend_encoded_v2_service_descriptor_free(desc_holder_two);
+}
+
+#undef NS_SUBMODULE
+
+static void
+test_rend_cache_init(void *data)
+{
+  (void)data;
+
+  tt_assert_msg(!rend_cache, "rend_cache should be NULL when starting");
+  tt_assert_msg(!rend_cache_v2_dir, "rend_cache_v2_dir should be NULL "
+                "when starting");
+  tt_assert_msg(!rend_cache_failure, "rend_cache_failure should be NULL when "
+                "starting");
+
+  rend_cache_init();
+
+  tt_assert_msg(rend_cache, "rend_cache should not be NULL after initing");
+  tt_assert_msg(rend_cache_v2_dir, "rend_cache_v2_dir should not be NULL "
+                "after initing");
+  tt_assert_msg(rend_cache_failure, "rend_cache_failure should not be NULL "
+                "after initing");
+
+  tt_int_op(strmap_size(rend_cache), OP_EQ, 0);
+  tt_int_op(digestmap_size(rend_cache_v2_dir), OP_EQ, 0);
+  tt_int_op(strmap_size(rend_cache_failure), OP_EQ, 0);
+
+ done:
+  rend_cache_free_all();
+}
+
+static void
+test_rend_cache_decrement_allocation(void *data)
+{
+  (void)data;
+
+  // Test when the cache has enough allocations
+  rend_cache_total_allocation = 10;
+  rend_cache_decrement_allocation(3);
+  tt_int_op(rend_cache_total_allocation, OP_EQ, 7);
+
+  // Test when there are not enough allocations
+  rend_cache_total_allocation = 1;
+  rend_cache_decrement_allocation(2);
+  tt_int_op(rend_cache_total_allocation, OP_EQ, 0);
+
+  // And again
+  rend_cache_decrement_allocation(2);
+  tt_int_op(rend_cache_total_allocation, OP_EQ, 0);
+
+ done:
+  (void)0;
+}
+
+static void
+test_rend_cache_increment_allocation(void *data)
+{
+  (void)data;
+
+  // Test when the cache is not overflowing
+  rend_cache_total_allocation = 5;
+  rend_cache_increment_allocation(3);
+  tt_int_op(rend_cache_total_allocation, OP_EQ, 8);
+
+  // Test when there are too many allocations
+  rend_cache_total_allocation = SIZE_MAX-1;
+  rend_cache_increment_allocation(2);
+  tt_u64_op(rend_cache_total_allocation, OP_EQ, SIZE_MAX);
+
+  // And again
+  rend_cache_increment_allocation(2);
+  tt_u64_op(rend_cache_total_allocation, OP_EQ, SIZE_MAX);
+
+ done:
+  (void)0;
+}
+
+static void
+test_rend_cache_failure_intro_entry_new(void *data)
+{
+  time_t now;
+  rend_cache_failure_intro_t *entry;
+  rend_intro_point_failure_t failure;
+
+  (void)data;
+
+  failure = INTRO_POINT_FAILURE_TIMEOUT;
+  now = time(NULL);
+  entry = rend_cache_failure_intro_entry_new(failure);
+
+  tt_int_op(entry->failure_type, OP_EQ, INTRO_POINT_FAILURE_TIMEOUT);
+  tt_int_op(entry->created_ts, OP_GE, now-5);
+  tt_int_op(entry->created_ts, OP_LE, now+5);
+
+ done:
+  tor_free(entry);
+}
+
+static void
+test_rend_cache_failure_intro_lookup(void *data)
+{
+  (void)data;
+  int ret;
+  rend_cache_failure_t *failure;
+  rend_cache_failure_intro_t *ip;
+  rend_cache_failure_intro_t *entry;
+  const char key_ip_one[DIGEST_LEN] = "ip1";
+  const char key_ip_two[DIGEST_LEN] = "ip2";
+  const char key_foo[DIGEST_LEN] = "foo1";
+
+  rend_cache_init();
+
+  failure = rend_cache_failure_entry_new();
+  ip = rend_cache_failure_intro_entry_new(INTRO_POINT_FAILURE_TIMEOUT);
+  digestmap_set(failure->intro_failures, key_ip_one, ip);
+  strmap_set_lc(rend_cache_failure, "foo1", failure);
+
+  // Test not found
+  ret = cache_failure_intro_lookup((const uint8_t *) key_foo, "foo2", NULL);
+  tt_int_op(ret, OP_EQ, 0);
+
+  // Test found with no intro failures in it
+  ret = cache_failure_intro_lookup((const uint8_t *) key_ip_two, "foo1", NULL);
+  tt_int_op(ret, OP_EQ, 0);
+
+  // Test found
+  ret = cache_failure_intro_lookup((const uint8_t *) key_ip_one, "foo1", NULL);
+  tt_int_op(ret, OP_EQ, 1);
+
+  // Test found and asking for entry
+  cache_failure_intro_lookup((const uint8_t *) key_ip_one, "foo1", &entry);
+  tt_assert(entry);
+  tt_assert(entry == ip);
+
+ done:
+  rend_cache_free_all();
+}
+
+static void
+test_rend_cache_clean(void *data)
+{
+  rend_cache_entry_t *one, *two;
+  rend_service_descriptor_t *desc_one, *desc_two;
+  strmap_iter_t *iter = NULL;
+  const char *key;
+  void *val;
+
+  (void)data;
+
+  rend_cache_init();
+
+  // Test with empty rendcache
+  rend_cache_clean(time(NULL), REND_CACHE_TYPE_CLIENT);
+  tt_int_op(strmap_size(rend_cache), OP_EQ, 0);
+
+  // Test with two old entries
+  one = tor_malloc_zero(sizeof(rend_cache_entry_t));
+  two = tor_malloc_zero(sizeof(rend_cache_entry_t));
+  desc_one = tor_malloc_zero(sizeof(rend_service_descriptor_t));
+  desc_two = tor_malloc_zero(sizeof(rend_service_descriptor_t));
+  one->parsed = desc_one;
+  two->parsed = desc_two;
+
+  desc_one->timestamp = time(NULL) + TIME_IN_THE_PAST;
+  desc_two->timestamp = (time(NULL) + TIME_IN_THE_PAST) - 10;
+  desc_one->pk = pk_generate(0);
+  desc_two->pk = pk_generate(1);
+
+  strmap_set_lc(rend_cache, "foo1", one);
+  strmap_set_lc(rend_cache, "foo2", two);
+
+  rend_cache_clean(time(NULL), REND_CACHE_TYPE_CLIENT);
+  tt_int_op(strmap_size(rend_cache), OP_EQ, 0);
+
+  // Test with one old entry and one newer entry
+  one = tor_malloc_zero(sizeof(rend_cache_entry_t));
+  two = tor_malloc_zero(sizeof(rend_cache_entry_t));
+  desc_one = tor_malloc_zero(sizeof(rend_service_descriptor_t));
+  desc_two = tor_malloc_zero(sizeof(rend_service_descriptor_t));
+  one->parsed = desc_one;
+  two->parsed = desc_two;
+
+  desc_one->timestamp = (time(NULL) + TIME_IN_THE_PAST) - 10;
+  desc_two->timestamp = time(NULL) - 100;
+  desc_one->pk = pk_generate(0);
+  desc_two->pk = pk_generate(1);
+
+  strmap_set_lc(rend_cache, "foo1", one);
+  strmap_set_lc(rend_cache, "foo2", two);
+
+  rend_cache_clean(time(NULL), REND_CACHE_TYPE_CLIENT);
+  tt_int_op(strmap_size(rend_cache), OP_EQ, 1);
+
+  iter = strmap_iter_init(rend_cache);
+  strmap_iter_get(iter, &key, &val);
+  tt_str_op(key, OP_EQ, "foo2");
+
+ done:
+  rend_cache_free_all();
+}
+
+static void
+test_rend_cache_failure_entry_new(void *data)
+{
+  rend_cache_failure_t *failure;
+
+  (void)data;
+
+  failure = rend_cache_failure_entry_new();
+  tt_assert(failure);
+  tt_int_op(digestmap_size(failure->intro_failures), OP_EQ, 0);
+
+ done:
+  rend_cache_failure_entry_free(failure);
+}
+
+static void
+test_rend_cache_failure_entry_free(void *data)
+{
+  (void)data;
+
+  // Test that it can deal with a NULL argument
+  rend_cache_failure_entry_free(NULL);
+
+ /* done: */
+ /*  (void)0; */
+}
+
+static void
+test_rend_cache_failure_clean(void *data)
+{
+  rend_cache_failure_t *failure;
+  rend_cache_failure_intro_t *ip_one, *ip_two;
+
+  const char key_one[DIGEST_LEN] = "ip1";
+  const char key_two[DIGEST_LEN] = "ip2";
+
+  (void)data;
+
+  rend_cache_init();
+
+  // Test with empty failure cache
+  rend_cache_failure_clean(time(NULL));
+  tt_int_op(strmap_size(rend_cache_failure), OP_EQ, 0);
+
+  // Test with one empty failure entry
+  failure = rend_cache_failure_entry_new();
+  strmap_set_lc(rend_cache_failure, "foo1", failure);
+  rend_cache_failure_clean(time(NULL));
+  tt_int_op(strmap_size(rend_cache_failure), OP_EQ, 0);
+
+  // Test with one new intro point
+  failure = rend_cache_failure_entry_new();
+  ip_one = rend_cache_failure_intro_entry_new(INTRO_POINT_FAILURE_TIMEOUT);
+  digestmap_set(failure->intro_failures, key_one, ip_one);
+  strmap_set_lc(rend_cache_failure, "foo1", failure);
+  rend_cache_failure_clean(time(NULL));
+  tt_int_op(strmap_size(rend_cache_failure), OP_EQ, 1);
+
+  // Test with one old intro point
+  rend_cache_failure_purge();
+  failure = rend_cache_failure_entry_new();
+  ip_one = rend_cache_failure_intro_entry_new(INTRO_POINT_FAILURE_TIMEOUT);
+  ip_one->created_ts = time(NULL) - 7*60;
+  digestmap_set(failure->intro_failures, key_one, ip_one);
+  strmap_set_lc(rend_cache_failure, "foo1", failure);
+  rend_cache_failure_clean(time(NULL));
+  tt_int_op(strmap_size(rend_cache_failure), OP_EQ, 0);
+
+  // Test with one old intro point and one new one
+  rend_cache_failure_purge();
+  failure = rend_cache_failure_entry_new();
+  ip_one = rend_cache_failure_intro_entry_new(INTRO_POINT_FAILURE_TIMEOUT);
+  ip_one->created_ts = time(NULL) - 7*60;
+  digestmap_set(failure->intro_failures, key_one, ip_one);
+  ip_two = rend_cache_failure_intro_entry_new(INTRO_POINT_FAILURE_TIMEOUT);
+  ip_two->created_ts = time(NULL) - 2*60;
+  digestmap_set(failure->intro_failures, key_two, ip_two);
+  strmap_set_lc(rend_cache_failure, "foo1", failure);
+  rend_cache_failure_clean(time(NULL));
+  tt_int_op(strmap_size(rend_cache_failure), OP_EQ, 1);
+  tt_int_op(digestmap_size(failure->intro_failures), OP_EQ, 1);
+
+ done:
+  rend_cache_free_all();
+}
+
+static void
+test_rend_cache_failure_remove(void *data)
+{
+  rend_service_descriptor_t *desc;
+  (void)data;
+
+  rend_cache_init();
+
+  // Test that it deals well with a NULL desc
+  rend_cache_failure_remove(NULL);
+
+  // Test a descriptor that isn't in the cache
+  desc = tor_malloc_zero(sizeof(rend_service_descriptor_t));
+  desc->pk = pk_generate(0);
+  rend_cache_failure_remove(desc);
+
+  // There seems to not exist any way of getting rend_cache_failure_remove()
+  // to fail because of a problem with rend_get_service_id from here
+  rend_cache_free_all();
+
+  rend_service_descriptor_free(desc);
+ /* done: */
+ /*  (void)0; */
+}
+
+static void
+test_rend_cache_free_all(void *data)
+{
+  rend_cache_failure_t *failure;
+  rend_cache_entry_t *one;
+  rend_service_descriptor_t *desc_one;
+
+  (void)data;
+
+  rend_cache_init();
+
+  failure = rend_cache_failure_entry_new();
+  strmap_set_lc(rend_cache_failure, "foo1", failure);
+
+  one = tor_malloc_zero(sizeof(rend_cache_entry_t));
+  desc_one = tor_malloc_zero(sizeof(rend_service_descriptor_t));
+  one->parsed = desc_one;
+  desc_one->timestamp = time(NULL) + TIME_IN_THE_PAST;
+  desc_one->pk = pk_generate(0);
+  strmap_set_lc(rend_cache, "foo1", one);
+
+  rend_cache_free_all();
+
+  tt_assert(!rend_cache);
+  tt_assert(!rend_cache_v2_dir);
+  tt_assert(!rend_cache_failure);
+  tt_assert(!rend_cache_total_allocation);
+
+ done:
+  rend_cache_free_all();
+}
+
+static void
+test_rend_cache_entry_free(void *data)
+{
+  (void)data;
+  rend_cache_entry_t *e;
+
+  // Handles NULL correctly
+  rend_cache_entry_free(NULL);
+
+  // Handles NULL descriptor correctly
+  e = tor_malloc_zero(sizeof(rend_cache_entry_t));
+  rend_cache_entry_free(e);
+
+  // Handles non-NULL descriptor correctly
+  e = tor_malloc_zero(sizeof(rend_cache_entry_t));
+  e->desc = (char *)malloc(10);
+  rend_cache_entry_free(e);
+
+ /* done: */
+ /*  (void)0; */
+}
+
+static void
+test_rend_cache_purge(void *data)
+{
+  (void)data;
+
+  // Deals with a NULL rend_cache
+  rend_cache_purge();
+  tt_assert(rend_cache);
+  tt_assert(strmap_size(rend_cache) == 0);
+
+  // Deals with existing rend_cache
+  rend_cache_free_all();
+  rend_cache_init();
+  tt_assert(rend_cache);
+  tt_assert(strmap_size(rend_cache) == 0);
+
+  rend_cache_purge();
+  tt_assert(rend_cache);
+  tt_assert(strmap_size(rend_cache) == 0);
+
+ done:
+  rend_cache_free_all();
+}
+
+static void
+test_rend_cache_failure_intro_add(void *data)
+{
+  (void)data;
+  rend_cache_failure_t *fail_entry;
+  rend_cache_failure_intro_t *entry;
+  const char identity[DIGEST_LEN] = "foo1";
+
+  rend_cache_init();
+
+  // Adds non-existing entry
+  cache_failure_intro_add((const uint8_t *) identity, "foo2",
+                          INTRO_POINT_FAILURE_TIMEOUT);
+  fail_entry = strmap_get_lc(rend_cache_failure, "foo2");
+  tt_assert(fail_entry);
+  tt_int_op(digestmap_size(fail_entry->intro_failures), OP_EQ, 1);
+  entry = digestmap_get(fail_entry->intro_failures, identity);
+  tt_assert(entry);
+
+  // Adds existing entry
+  cache_failure_intro_add((const uint8_t *) identity, "foo2",
+                          INTRO_POINT_FAILURE_TIMEOUT);
+  fail_entry = strmap_get_lc(rend_cache_failure, "foo2");
+  tt_assert(fail_entry);
+  tt_int_op(digestmap_size(fail_entry->intro_failures), OP_EQ, 1);
+  entry = digestmap_get(fail_entry->intro_failures, identity);
+  tt_assert(entry);
+
+ done:
+  rend_cache_free_all();
+}
+
+static void
+test_rend_cache_intro_failure_note(void *data)
+{
+  (void)data;
+  rend_cache_failure_t *fail_entry;
+  rend_cache_failure_intro_t *entry;
+  const char key[DIGEST_LEN] = "foo1";
+
+  rend_cache_init();
+
+  // Test not found
+  rend_cache_intro_failure_note(INTRO_POINT_FAILURE_TIMEOUT,
+                                (const uint8_t *) key, "foo2");
+  fail_entry = strmap_get_lc(rend_cache_failure, "foo2");
+  tt_assert(fail_entry);
+  tt_int_op(digestmap_size(fail_entry->intro_failures), OP_EQ, 1);
+  entry = digestmap_get(fail_entry->intro_failures, key);
+  tt_assert(entry);
+  tt_int_op(entry->failure_type, OP_EQ, INTRO_POINT_FAILURE_TIMEOUT);
+
+  // Test found
+  rend_cache_intro_failure_note(INTRO_POINT_FAILURE_UNREACHABLE,
+                                (const uint8_t *) key, "foo2");
+  tt_int_op(entry->failure_type, OP_EQ, INTRO_POINT_FAILURE_UNREACHABLE);
+
+ done:
+  rend_cache_free_all();
+}
+
+#define NS_SUBMODULE clean_v2_descs_as_dir
+NS_DECL(int, hid_serv_responsible_for_desc_id, (const char *id));
+
+static int
+NS(hid_serv_responsible_for_desc_id)(const char *id)
+{
+  (void)id;
+  return hid_serv_responsible_for_desc_id_response;
+}
+
+static void
+test_rend_cache_clean_v2_descs_as_dir(void *data)
+{
+  rend_cache_entry_t *e;
+  time_t now;
+  rend_service_descriptor_t *desc;
+  now = time(NULL);
+  const char key[DIGEST_LEN] = "abcde";
+
+  (void)data;
+
+  NS_MOCK(hid_serv_responsible_for_desc_id);
+  rend_cache_init();
+
+  // Test running with an empty cache
+  rend_cache_clean_v2_descs_as_dir(now, 0);
+  tt_int_op(digestmap_size(rend_cache_v2_dir), OP_EQ, 0);
+
+  // Test with only one new entry
+  e = tor_malloc_zero(sizeof(rend_cache_entry_t));
+  e->last_served = now;
+  desc = tor_malloc_zero(sizeof(rend_service_descriptor_t));
+  desc->timestamp = now;
+  desc->pk = pk_generate(0);
+  e->parsed = desc;
+  digestmap_set(rend_cache_v2_dir, key, e);
+
+  hid_serv_responsible_for_desc_id_response = 1;
+  rend_cache_clean_v2_descs_as_dir(now, 0);
+  tt_int_op(digestmap_size(rend_cache_v2_dir), OP_EQ, 1);
+
+  // Test with one old entry
+  desc->timestamp = now - (REND_CACHE_MAX_AGE + REND_CACHE_MAX_SKEW + 1000);
+  rend_cache_clean_v2_descs_as_dir(now, 0);
+  tt_int_op(digestmap_size(rend_cache_v2_dir), OP_EQ, 0);
+
+  // Test with one entry that is not under the responsibility of this
+  // hidden service
+  e = tor_malloc_zero(sizeof(rend_cache_entry_t));
+  e->last_served = now;
+  desc = tor_malloc_zero(sizeof(rend_service_descriptor_t));
+  desc->timestamp = now;
+  desc->pk = pk_generate(0);
+  e->parsed = desc;
+  digestmap_set(rend_cache_v2_dir, key, e);
+
+  hid_serv_responsible_for_desc_id_response = 0;
+  rend_cache_clean_v2_descs_as_dir(now, 0);
+  tt_int_op(digestmap_size(rend_cache_v2_dir), OP_EQ, 0);
+
+  // Test with one entry that has an old last served
+  e = tor_malloc_zero(sizeof(rend_cache_entry_t));
+  e->last_served = now - (REND_CACHE_MAX_AGE + REND_CACHE_MAX_SKEW + 1000);
+  desc = tor_malloc_zero(sizeof(rend_service_descriptor_t));
+  desc->timestamp = now;
+  desc->pk = pk_generate(0);
+  e->parsed = desc;
+  digestmap_set(rend_cache_v2_dir, key, e);
+
+  hid_serv_responsible_for_desc_id_response = 1;
+  rend_cache_clean_v2_descs_as_dir(now, 0);
+  tt_int_op(digestmap_size(rend_cache_v2_dir), OP_EQ, 0);
+
+  // Test a run through asking for a large force_remove
+  e = tor_malloc_zero(sizeof(rend_cache_entry_t));
+  e->last_served = now;
+  desc = tor_malloc_zero(sizeof(rend_service_descriptor_t));
+  desc->timestamp = now;
+  desc->pk = pk_generate(0);
+  e->parsed = desc;
+  digestmap_set(rend_cache_v2_dir, key, e);
+
+  hid_serv_responsible_for_desc_id_response = 1;
+  rend_cache_clean_v2_descs_as_dir(now, 20000);
+  tt_int_op(digestmap_size(rend_cache_v2_dir), OP_EQ, 1);
+
+ done:
+  NS_UNMOCK(hid_serv_responsible_for_desc_id);
+  rend_cache_free_all();
+}
+
+#undef NS_SUBMODULE
+
+static void
+test_rend_cache_entry_allocation(void *data)
+{
+  (void)data;
+
+  size_t ret;
+  rend_cache_entry_t *e = NULL;
+
+  // Handles a null argument
+  ret = rend_cache_entry_allocation(NULL);
+  tt_int_op(ret, OP_EQ, 0);
+
+  // Handles a non-null argument
+  e = tor_malloc_zero(sizeof(rend_cache_entry_t));
+  ret = rend_cache_entry_allocation(e);
+  tt_int_op(ret, OP_GT, sizeof(rend_cache_entry_t));
+
+ done:
+  tor_free(e);
+}
+
+static void
+test_rend_cache_failure_intro_entry_free(void *data)
+{
+  (void)data;
+  rend_cache_failure_intro_t *entry;
+
+  // Handles a null argument
+  rend_cache_failure_intro_entry_free(NULL);
+
+  // Handles a non-null argument
+  entry = rend_cache_failure_intro_entry_new(INTRO_POINT_FAILURE_TIMEOUT);
+  rend_cache_failure_intro_entry_free(entry);
+}
+
+static void
+test_rend_cache_failure_purge(void *data)
+{
+  (void)data;
+
+  // Handles a null failure cache
+  strmap_free(rend_cache_failure, rend_cache_failure_entry_free_);
+  rend_cache_failure = NULL;
+
+  rend_cache_failure_purge();
+
+  tt_ptr_op(rend_cache_failure, OP_NE, NULL);
+  tt_int_op(strmap_size(rend_cache_failure), OP_EQ, 0);
+
+ done:
+  rend_cache_free_all();
+}
+
+static void
+test_rend_cache_validate_intro_point_failure(void *data)
+{
+  (void)data;
+  rend_service_descriptor_t *desc = NULL;
+  char *service_id = NULL;
+  rend_intro_point_t *intro = NULL;
+  const char *identity = NULL;
+  rend_cache_failure_t *failure;
+  rend_cache_failure_intro_t *ip;
+
+  rend_cache_init();
+
+  create_descriptor(&desc, &service_id, 3);
+  desc->timestamp = time(NULL) + RECENT_TIME;
+
+  intro = (rend_intro_point_t *)smartlist_get(desc->intro_nodes, 0);
+  identity = intro->extend_info->identity_digest;
+
+  failure = rend_cache_failure_entry_new();
+  ip = rend_cache_failure_intro_entry_new(INTRO_POINT_FAILURE_TIMEOUT);
+  digestmap_set(failure->intro_failures, identity, ip);
+  strmap_set_lc(rend_cache_failure, service_id, failure);
+
+  // Test when we have an intro point in our cache
+  validate_intro_point_failure(desc, service_id);
+  tt_int_op(smartlist_len(desc->intro_nodes), OP_EQ, 2);
+
+ done:
+  rend_cache_free_all();
+  rend_service_descriptor_free(desc);
+  tor_free(service_id);
+}
+
+struct testcase_t rend_cache_tests[] = {
+  { "init", test_rend_cache_init, 0, NULL, NULL },
+  { "decrement_allocation", test_rend_cache_decrement_allocation, 0,
+    NULL, NULL },
+  { "increment_allocation", test_rend_cache_increment_allocation, 0,
+    NULL, NULL },
+  { "clean", test_rend_cache_clean, TT_FORK, NULL, NULL },
+  { "clean_v2_descs_as_dir", test_rend_cache_clean_v2_descs_as_dir, 0,
+    NULL, NULL },
+  { "entry_allocation", test_rend_cache_entry_allocation, 0, NULL, NULL },
+  { "entry_free", test_rend_cache_entry_free, 0, NULL, NULL },
+  { "failure_intro_entry_free", test_rend_cache_failure_intro_entry_free, 0,
+    NULL, NULL },
+  { "free_all", test_rend_cache_free_all, 0, NULL, NULL },
+  { "purge", test_rend_cache_purge, 0, NULL, NULL },
+  { "failure_clean", test_rend_cache_failure_clean, 0, NULL, NULL },
+  { "failure_entry_new", test_rend_cache_failure_entry_new, 0, NULL, NULL },
+  { "failure_entry_free", test_rend_cache_failure_entry_free, 0, NULL, NULL },
+  { "failure_intro_add", test_rend_cache_failure_intro_add, 0, NULL, NULL },
+  { "failure_intro_entry_new", test_rend_cache_failure_intro_entry_new, 0,
+    NULL, NULL },
+  { "failure_intro_lookup", test_rend_cache_failure_intro_lookup, 0,
+    NULL, NULL },
+  { "failure_purge", test_rend_cache_failure_purge, 0, NULL, NULL },
+  { "failure_remove", test_rend_cache_failure_remove, 0, NULL, NULL },
+  { "intro_failure_note", test_rend_cache_intro_failure_note, 0, NULL, NULL },
+  { "lookup", test_rend_cache_lookup_entry, 0, NULL, NULL },
+  { "lookup_v2_desc_as_dir", test_rend_cache_lookup_v2_desc_as_dir, 0,
+    NULL, NULL },
+  { "store_v2_desc_as_client", test_rend_cache_store_v2_desc_as_client, 0,
+    NULL, NULL },
+  { "store_v2_desc_as_client_with_different_time",
+    test_rend_cache_store_v2_desc_as_client_with_different_time, 0,
+    NULL, NULL },
+  { "store_v2_desc_as_dir", test_rend_cache_store_v2_desc_as_dir, 0,
+    NULL, NULL },
+  { "store_v2_desc_as_dir_with_different_time",
+    test_rend_cache_store_v2_desc_as_dir_with_different_time, 0, NULL, NULL },
+  { "store_v2_desc_as_dir_with_different_content",
+    test_rend_cache_store_v2_desc_as_dir_with_different_content, 0,
+    NULL, NULL },
+  { "validate_intro_point_failure",
+    test_rend_cache_validate_intro_point_failure, 0, NULL, NULL },
+  END_OF_TESTCASES
+};
+
diff --git a/src/test/test_replay.c b/src/test/test_replay.c
index a02c160..7a0f098 100644
--- a/src/test/test_replay.c
+++ b/src/test/test_replay.c
@@ -17,6 +17,20 @@ static const char *test_buffer =
   " occaecat cupidatat non proident, sunt in culpa qui officia deserunt"
   " mollit anim id est laborum.";
 
+static const char *test_buffer_2 =
+  "At vero eos et accusamus et iusto odio dignissimos ducimus qui blanditiis"
+  " praesentium voluptatum deleniti atque corrupti quos dolores et quas"
+  " molestias excepturi sint occaecati cupiditate non provident, similique"
+  " sunt in culpa qui officia deserunt mollitia animi, id est laborum et"
+  " dolorum fuga. Et harum quidem rerum facilis est et expedita distinctio."
+  " Nam libero tempore, cum soluta nobis est eligendi optio cumque nihil"
+  " impedit quo minus id quod maxime placeat facere possimus, omnis voluptas"
+  " assumenda est, omnis dolor repellendus. Temporibus autem quibusdam et aut"
+  " officiis debitis aut rerum necessitatibus saepe eveniet ut et voluptates"
+  " repudiandae sint et molestiae non recusandae. Itaque earum rerum hic"
+  " tenetur a sapiente delectus, ut aut reiciendis voluptatibus maiores alias"
+  " consequatur aut perferendis doloribus asperiores repellat.";
+
 static void
 test_replaycache_alloc(void *arg)
 {
@@ -83,6 +97,12 @@ test_replaycache_miss(void *arg)
         strlen(test_buffer), NULL);
   tt_int_op(result,OP_EQ, 0);
 
+  /* make sure a different buffer misses as well */
+  result =
+  replaycache_add_and_test_internal(1200, NULL, test_buffer_2,
+                                    strlen(test_buffer_2), NULL);
+  tt_int_op(result,OP_EQ, 0);
+
   /* poke the bad-parameter error case too */
   result =
     replaycache_add_and_test_internal(1200, NULL, test_buffer,
@@ -115,6 +135,18 @@ test_replaycache_hit(void *arg)
         strlen(test_buffer), NULL);
   tt_int_op(result,OP_EQ, 1);
 
+  /* make sure a different buffer misses then hits as well */
+
+  result =
+  replaycache_add_and_test_internal(1200, r, test_buffer_2,
+                                    strlen(test_buffer_2), NULL);
+  tt_int_op(result,OP_EQ, 0);
+
+  result =
+  replaycache_add_and_test_internal(1300, r, test_buffer_2,
+                                    strlen(test_buffer_2), NULL);
+  tt_int_op(result,OP_EQ, 1);
+
  done:
   if (r) replaycache_free(r);
 
@@ -245,7 +277,7 @@ test_replaycache_scrub(void *arg)
   /* Make sure we hit the aging-out case too */
   replaycache_scrub_if_needed_internal(1500, r);
   /* Assert that we aged it */
-  tt_int_op(digestmap_size(r->digests_seen),OP_EQ, 0);
+  tt_int_op(digest256map_size(r->digests_seen),OP_EQ, 0);
 
  done:
   if (r) replaycache_free(r);
diff --git a/src/test/test_routerlist.c b/src/test/test_routerlist.c
index 381a592..8c4254c 100644
--- a/src/test/test_routerlist.c
+++ b/src/test/test_routerlist.c
@@ -1,22 +1,48 @@
 /* Copyright (c) 2014, The Tor Project, Inc. */
 /* See LICENSE for licensing information */
 
+#include "orconfig.h"
+#include <math.h>
+#include <time.h>
+
+#define DIRVOTE_PRIVATE
+#define NETWORKSTATUS_PRIVATE
 #define ROUTERLIST_PRIVATE
+#define TOR_UNIT_TESTING
 #include "or.h"
-#include "routerlist.h"
+#include "config.h"
+#include "container.h"
 #include "directory.h"
+#include "dirvote.h"
+#include "networkstatus.h"
+#include "nodelist.h"
+#include "policies.h"
+#include "routerlist.h"
+#include "routerparse.h"
 #include "test.h"
+#include "test_dir_common.h"
+
+extern const char AUTHORITY_CERT_1[];
+extern const char AUTHORITY_SIGNKEY_1[];
+extern const char AUTHORITY_CERT_2[];
+extern const char AUTHORITY_SIGNKEY_2[];
+extern const char AUTHORITY_CERT_3[];
+extern const char AUTHORITY_SIGNKEY_3[];
+
+void construct_consensus(const char **consensus_text_md);
 
 /* 4 digests + 3 sep + pre + post + NULL */
 static char output[4*BASE64_DIGEST256_LEN+3+2+2+1];
 
 static void
 mock_get_from_dirserver(uint8_t dir_purpose, uint8_t router_purpose,
-                             const char *resource, int pds_flags)
+                        const char *resource, int pds_flags,
+                        download_want_authority_t want_authority)
 {
   (void)dir_purpose;
   (void)router_purpose;
   (void)pds_flags;
+  (void)want_authority;
   tt_assert(resource);
   strlcpy(output, resource, sizeof(output));
  done:
@@ -92,12 +118,268 @@ test_routerlist_launch_descriptor_downloads(void *arg)
   smartlist_free(downloadable);
 }
 
+void
+construct_consensus(const char **consensus_text_md)
+{
+  networkstatus_t *vote = NULL;
+  networkstatus_t *v1 = NULL, *v2 = NULL, *v3 = NULL;
+  networkstatus_voter_info_t *voter = NULL;
+  authority_cert_t *cert1=NULL, *cert2=NULL, *cert3=NULL;
+  crypto_pk_t *sign_skey_1=NULL, *sign_skey_2=NULL, *sign_skey_3=NULL;
+  crypto_pk_t *sign_skey_leg=NULL;
+  time_t now = time(NULL);
+  smartlist_t *votes = NULL;
+  addr_policy_t *pol1 = NULL, *pol2 = NULL, *pol3 = NULL;
+  int n_vrs;
+
+  tt_assert(!dir_common_authority_pk_init(&cert1, &cert2, &cert3,
+                                          &sign_skey_1, &sign_skey_2,
+                                          &sign_skey_3));
+  sign_skey_leg = pk_generate(4);
+
+  dir_common_construct_vote_1(&vote, cert1, sign_skey_1,
+                              &dir_common_gen_routerstatus_for_v3ns,
+                              &v1, &n_vrs, now, 1);
+
+  tt_assert(v1);
+  tt_int_op(n_vrs, ==, 4);
+  tt_int_op(smartlist_len(v1->routerstatus_list), ==, 4);
+
+  dir_common_construct_vote_2(&vote, cert2, sign_skey_2,
+                              &dir_common_gen_routerstatus_for_v3ns,
+                              &v2, &n_vrs, now, 1);
+
+  tt_assert(v2);
+  tt_int_op(n_vrs, ==, 4);
+  tt_int_op(smartlist_len(v2->routerstatus_list), ==, 4);
+
+  dir_common_construct_vote_3(&vote, cert3, sign_skey_3,
+                              &dir_common_gen_routerstatus_for_v3ns,
+                              &v3, &n_vrs, now, 1);
+
+  tt_assert(v3);
+  tt_int_op(n_vrs, ==, 4);
+  tt_int_op(smartlist_len(v3->routerstatus_list), ==, 4);
+
+  votes = smartlist_new();
+  smartlist_add(votes, v1);
+  smartlist_add(votes, v2);
+  smartlist_add(votes, v3);
+
+  *consensus_text_md = networkstatus_compute_consensus(votes, 3,
+                                                   cert1->identity_key,
+                                                   sign_skey_1,
+                                                   "AAAAAAAAAAAAAAAAAAAA",
+                                                   sign_skey_leg,
+                                                   FLAV_MICRODESC);
+
+  tt_assert(*consensus_text_md);
+
+ done:
+  if (vote)
+    tor_free(vote);
+  if (voter)
+    tor_free(voter);
+  if (pol1)
+    tor_free(pol1);
+  if (pol2)
+    tor_free(pol2);
+  if (pol3)
+    tor_free(pol3);
+}
+
+static void
+test_router_pick_directory_server_impl(void *arg)
+{
+  (void)arg;
+
+  networkstatus_t *con_md = NULL;
+  const char *consensus_text_md = NULL;
+  int flags = PDS_IGNORE_FASCISTFIREWALL|PDS_RETRY_IF_NO_SERVERS;
+  or_options_t *options = get_options_mutable();
+  const routerstatus_t *rs = NULL;
+  options->UseMicrodescriptors = 1;
+  char *router1_id = NULL, *router2_id = NULL, *router3_id = NULL;
+  node_t *node_router1 = NULL, *node_router2 = NULL, *node_router3 = NULL;
+  config_line_t *policy_line = NULL;
+  time_t now = time(NULL);
+  int tmp_dirport1, tmp_dirport3;
+
+  (void)arg;
+
+  /* No consensus available, fail early */
+  rs = router_pick_directory_server_impl(V3_DIRINFO, (const int) 0, NULL);
+  tt_assert(rs == NULL);
+
+  construct_consensus(&consensus_text_md);
+  tt_assert(consensus_text_md);
+  con_md = networkstatus_parse_vote_from_string(consensus_text_md, NULL,
+                                                NS_TYPE_CONSENSUS);
+  tt_assert(con_md);
+  tt_int_op(con_md->flavor,==, FLAV_MICRODESC);
+  tt_assert(con_md->routerstatus_list);
+  tt_int_op(smartlist_len(con_md->routerstatus_list), ==, 3);
+  tt_assert(!networkstatus_set_current_consensus_from_ns(con_md,
+                                                 "microdesc"));
+  nodelist_set_consensus(con_md);
+  nodelist_assert_ok();
+
+  rs = router_pick_directory_server_impl(V3_DIRINFO, flags, NULL);
+  /* We should not fail now we have a consensus and routerstatus_list
+   * and nodelist are populated. */
+  tt_assert(rs != NULL);
+
+  /* Manipulate the nodes so we get the dir server we expect */
+  router1_id = tor_malloc(DIGEST_LEN);
+  memset(router1_id, TEST_DIR_ROUTER_ID_1, DIGEST_LEN);
+  router2_id = tor_malloc(DIGEST_LEN);
+  memset(router2_id, TEST_DIR_ROUTER_ID_2, DIGEST_LEN);
+  router3_id = tor_malloc(DIGEST_LEN);
+  memset(router3_id, TEST_DIR_ROUTER_ID_3, DIGEST_LEN);
+
+  node_router1 = node_get_mutable_by_id(router1_id);
+  node_router2 = node_get_mutable_by_id(router2_id);
+  node_router3 = node_get_mutable_by_id(router3_id);
+
+  node_router1->is_possible_guard = 1;
+
+  node_router1->is_running = 0;
+  node_router3->is_running = 0;
+  rs = router_pick_directory_server_impl(V3_DIRINFO, flags, NULL);
+  tt_assert(rs != NULL);
+  tt_assert(tor_memeq(rs->identity_digest, router2_id, DIGEST_LEN));
+  rs = NULL;
+  node_router1->is_running = 1;
+  node_router3->is_running = 1;
+
+  node_router1->rs->is_v2_dir = 0;
+  node_router3->rs->is_v2_dir = 0;
+  tmp_dirport1 = node_router1->rs->dir_port;
+  tmp_dirport3 = node_router3->rs->dir_port;
+  node_router1->rs->dir_port = 0;
+  node_router3->rs->dir_port = 0;
+  rs = router_pick_directory_server_impl(V3_DIRINFO, flags, NULL);
+  tt_assert(rs != NULL);
+  tt_assert(tor_memeq(rs->identity_digest, router2_id, DIGEST_LEN));
+  rs = NULL;
+  node_router1->rs->is_v2_dir = 1;
+  node_router3->rs->is_v2_dir = 1;
+  node_router1->rs->dir_port = tmp_dirport1;
+  node_router3->rs->dir_port = tmp_dirport3;
+
+  node_router1->is_valid = 0;
+  node_router3->is_valid = 0;
+  rs = router_pick_directory_server_impl(V3_DIRINFO, flags, NULL);
+  tt_assert(rs != NULL);
+  tt_assert(tor_memeq(rs->identity_digest, router2_id, DIGEST_LEN));
+  rs = NULL;
+  node_router1->is_valid = 1;
+  node_router3->is_valid = 1;
+
+  flags |= PDS_FOR_GUARD;
+  node_router1->using_as_guard = 1;
+  node_router2->using_as_guard = 1;
+  node_router3->using_as_guard = 1;
+  rs = router_pick_directory_server_impl(V3_DIRINFO, flags, NULL);
+  tt_assert(rs == NULL);
+  node_router1->using_as_guard = 0;
+  rs = router_pick_directory_server_impl(V3_DIRINFO, flags, NULL);
+  tt_assert(rs != NULL);
+  tt_assert(tor_memeq(rs->identity_digest, router1_id, DIGEST_LEN));
+  rs = NULL;
+  node_router2->using_as_guard = 0;
+  node_router3->using_as_guard = 0;
+
+  /* One not valid, one guard. This should leave one remaining */
+  node_router1->is_valid = 0;
+  node_router2->using_as_guard = 1;
+  rs = router_pick_directory_server_impl(V3_DIRINFO, flags, NULL);
+  tt_assert(rs != NULL);
+  tt_assert(tor_memeq(rs->identity_digest, router3_id, DIGEST_LEN));
+  rs = NULL;
+  node_router1->is_valid = 1;
+  node_router2->using_as_guard = 0;
+
+  /* Manipulate overloaded */
+
+  node_router2->rs->last_dir_503_at = now;
+  node_router3->rs->last_dir_503_at = now;
+  rs = router_pick_directory_server_impl(V3_DIRINFO, flags, NULL);
+  tt_assert(rs != NULL);
+  tt_assert(tor_memeq(rs->identity_digest, router1_id, DIGEST_LEN));
+  node_router2->rs->last_dir_503_at = 0;
+  node_router3->rs->last_dir_503_at = 0;
+
+  /* Set a Fascist firewall */
+  flags &= ~ PDS_IGNORE_FASCISTFIREWALL;
+  policy_line = tor_malloc_zero(sizeof(config_line_t));
+  policy_line->key = tor_strdup("ReachableORAddresses");
+  policy_line->value = tor_strdup("accept *:442, reject *:*");
+  options->ReachableORAddresses = policy_line;
+  policies_parse_from_options(options);
+
+  node_router1->rs->or_port = 444;
+  node_router2->rs->or_port = 443;
+  node_router3->rs->or_port = 442;
+  rs = router_pick_directory_server_impl(V3_DIRINFO, flags, NULL);
+  tt_assert(rs != NULL);
+  tt_assert(tor_memeq(rs->identity_digest, router3_id, DIGEST_LEN));
+  node_router1->rs->or_port = 442;
+  node_router2->rs->or_port = 443;
+  node_router3->rs->or_port = 444;
+  rs = router_pick_directory_server_impl(V3_DIRINFO, flags, NULL);
+  tt_assert(rs != NULL);
+  tt_assert(tor_memeq(rs->identity_digest, router1_id, DIGEST_LEN));
+
+  /* Fascist firewall and overloaded */
+  node_router1->rs->or_port = 442;
+  node_router2->rs->or_port = 443;
+  node_router3->rs->or_port = 442;
+  node_router3->rs->last_dir_503_at = now;
+  rs = router_pick_directory_server_impl(V3_DIRINFO, flags, NULL);
+  tt_assert(rs != NULL);
+  tt_assert(tor_memeq(rs->identity_digest, router1_id, DIGEST_LEN));
+  node_router3->rs->last_dir_503_at = 0;
+
+  /* Fascists against OR and Dir */
+  policy_line = tor_malloc_zero(sizeof(config_line_t));
+  policy_line->key = tor_strdup("ReachableAddresses");
+  policy_line->value = tor_strdup("accept *:80, reject *:*");
+  options->ReachableDirAddresses = policy_line;
+  policies_parse_from_options(options);
+  node_router1->rs->or_port = 442;
+  node_router2->rs->or_port = 441;
+  node_router3->rs->or_port = 443;
+  node_router1->rs->dir_port = 80;
+  node_router2->rs->dir_port = 80;
+  node_router3->rs->dir_port = 81;
+  node_router1->rs->last_dir_503_at = now;
+  rs = router_pick_directory_server_impl(V3_DIRINFO, flags, NULL);
+  tt_assert(rs != NULL);
+  tt_assert(tor_memeq(rs->identity_digest, router1_id, DIGEST_LEN));
+  node_router1->rs->last_dir_503_at = 0;
+
+ done:
+  if (router1_id)
+    tor_free(router1_id);
+  if (router2_id)
+    tor_free(router2_id);
+  if (router3_id)
+    tor_free(router3_id);
+  if (options->ReachableORAddresses ||
+      options->ReachableDirAddresses)
+    policies_free_all();
+}
+
 #define NODE(name, flags) \
   { #name, test_routerlist_##name, (flags), NULL, NULL }
+#define ROUTER(name,flags) \
+  { #name, test_router_##name, (flags), NULL, NULL }
 
 struct testcase_t routerlist_tests[] = {
   NODE(initiate_descriptor_downloads, 0),
   NODE(launch_descriptor_downloads, 0),
+  ROUTER(pick_directory_server_impl, TT_FORK),
   END_OF_TESTCASES
 };
 
diff --git a/src/test/test_routerset.c b/src/test/test_routerset.c
index 90dfb28..74b39c0 100644
--- a/src/test/test_routerset.c
+++ b/src/test/test_routerset.c
@@ -423,10 +423,10 @@ NS(test_main)(void *arg)
 }
 
 #undef NS_SUBMODULE
-#define NS_SUBMODULE ASPECT(routerset_parse, policy)
+#define NS_SUBMODULE ASPECT(routerset_parse, policy_wildcard)
 
 /*
- * Structural test for routerset_parse, when given a valid policy.
+ * Structural test for routerset_parse, when given a valid wildcard policy.
  */
 
 NS_DECL(addr_policy_t *, router_parse_addr_policy_item_from_string,
@@ -470,6 +470,100 @@ NS(router_parse_addr_policy_item_from_string)(const char *s,
 }
 
 #undef NS_SUBMODULE
+#define NS_SUBMODULE ASPECT(routerset_parse, policy_ipv4)
+
+/*
+ * Structural test for routerset_parse, when given a valid IPv4 address
+ * literal policy.
+ */
+
+NS_DECL(addr_policy_t *, router_parse_addr_policy_item_from_string,
+        (const char *s, int assume_action, int *bogus));
+
+addr_policy_t *NS(mock_addr_policy);
+
+static void
+NS(test_main)(void *arg)
+{
+  routerset_t *set;
+  const char *s;
+  int r;
+  (void)arg;
+
+  NS_MOCK(router_parse_addr_policy_item_from_string);
+  NS(mock_addr_policy) = tor_malloc_zero(sizeof(addr_policy_t));
+
+  set = routerset_new();
+  s = "127.0.0.1";
+  r = routerset_parse(set, s, "");
+  tt_int_op(r, OP_EQ, 0);
+  tt_int_op(smartlist_len(set->policies), OP_NE, 0);
+  tt_int_op(CALLED(router_parse_addr_policy_item_from_string), OP_EQ, 1);
+
+ done:
+  routerset_free(set);
+}
+
+addr_policy_t *
+NS(router_parse_addr_policy_item_from_string)(const char *s, int assume_action,
+                                              int *bogus)
+{
+  (void)s;
+  (void)assume_action;
+  CALLED(router_parse_addr_policy_item_from_string)++;
+  *bogus = 0;
+
+  return NS(mock_addr_policy);
+}
+
+#undef NS_SUBMODULE
+#define NS_SUBMODULE ASPECT(routerset_parse, policy_ipv6)
+
+/*
+ * Structural test for routerset_parse, when given a valid IPv6 address
+ * literal policy.
+ */
+
+NS_DECL(addr_policy_t *, router_parse_addr_policy_item_from_string,
+        (const char *s, int assume_action, int *bad));
+
+addr_policy_t *NS(mock_addr_policy);
+
+static void
+NS(test_main)(void *arg)
+{
+  routerset_t *set;
+  const char *s;
+  int r;
+  (void)arg;
+
+  NS_MOCK(router_parse_addr_policy_item_from_string);
+  NS(mock_addr_policy) = tor_malloc_zero(sizeof(addr_policy_t));
+
+  set = routerset_new();
+  s = "::1";
+  r = routerset_parse(set, s, "");
+  tt_int_op(r, OP_EQ, 0);
+  tt_int_op(smartlist_len(set->policies), OP_NE, 0);
+  tt_int_op(CALLED(router_parse_addr_policy_item_from_string), OP_EQ, 1);
+
+ done:
+  routerset_free(set);
+}
+
+addr_policy_t *
+NS(router_parse_addr_policy_item_from_string)(const char *s,
+                                              int assume_action, int *bad)
+{
+  (void)s;
+  (void)assume_action;
+  CALLED(router_parse_addr_policy_item_from_string)++;
+  *bad = 0;
+
+  return NS(mock_addr_policy);
+}
+
+#undef NS_SUBMODULE
 #define NS_SUBMODULE ASPECT(routerset_union, source_bad)
 
 /*
@@ -2109,7 +2203,9 @@ struct testcase_t routerset_tests[] = {
   TEST_CASE_ASPECT(routerset_parse, valid_hexdigest),
   TEST_CASE_ASPECT(routerset_parse, valid_nickname),
   TEST_CASE_ASPECT(routerset_parse, get_countryname),
-  TEST_CASE_ASPECT(routerset_parse, policy),
+  TEST_CASE_ASPECT(routerset_parse, policy_wildcard),
+  TEST_CASE_ASPECT(routerset_parse, policy_ipv4),
+  TEST_CASE_ASPECT(routerset_parse, policy_ipv6),
   TEST_CASE(routerset_subtract_nodes),
   TEST_CASE_ASPECT(routerset_subtract_nodes, null_routerset),
   TEST_CASE(routerset_to_string),
diff --git a/src/test/test_status.c b/src/test/test_status.c
index cbc8af1..84a0f6c 100644
--- a/src/test/test_status.c
+++ b/src/test/test_status.c
@@ -707,15 +707,18 @@ NS(logv)(int severity, log_domain_mask_t domain,
       tt_ptr_op(strstr(funcname, "log_accounting"), OP_NE, NULL);
       tt_ptr_op(suffix, OP_EQ, NULL);
       tt_str_op(format, OP_EQ,
-          "Heartbeat: Accounting enabled. Sent: %s / %s, Received: %s / %s. "
-          "The current accounting interval ends on %s, in %s.");
+          "Heartbeat: Accounting enabled. Sent: %s, Received: %s, Used: %s / "
+          "%s, Rule: %s. The current accounting interval ends on %s, in %s.");
       tt_str_op(va_arg(ap, char *), OP_EQ, "0 kB");  /* acc_sent */
-      tt_str_op(va_arg(ap, char *), OP_EQ, "0 kB");  /* acc_max */
       tt_str_op(va_arg(ap, char *), OP_EQ, "0 kB");  /* acc_rcvd */
+      tt_str_op(va_arg(ap, char *), OP_EQ, "0 kB");  /* acc_used */
       tt_str_op(va_arg(ap, char *), OP_EQ, "0 kB");  /* acc_max */
-      /* format_local_iso_time uses local tz, just check mins and secs. */
-      tt_ptr_op(strstr(va_arg(ap, char *), ":01:00"),
-                OP_NE, NULL); /* end_buf */
+      tt_str_op(va_arg(ap, char *), OP_EQ, "max");  /* acc_rule */
+      /* format_local_iso_time uses local tz, so we can't just compare
+       * the string against a constant */
+      char datetime[ISO_TIME_LEN+1];
+      format_local_iso_time(datetime, 60);
+      tt_str_op(va_arg(ap, char *), OP_EQ, datetime); /* end_buf */
       tt_str_op(va_arg(ap, char *), OP_EQ, "0:01 hours");   /* remaining */
       break;
     case 2:
diff --git a/src/test/test_switch_id.c b/src/test/test_switch_id.c
new file mode 100644
index 0000000..3d9c1c8
--- /dev/null
+++ b/src/test/test_switch_id.c
@@ -0,0 +1,191 @@
+/* Copyright (c) 2015, The Tor Project, Inc. */
+/* See LICENSE for licensing information */
+
+#include "or.h"
+
+#ifdef HAVE_SYS_CAPABILITY_H
+#include <sys/capability.h>
+#endif
+
+#define TEST_BUILT_WITH_CAPS         0
+#define TEST_HAVE_CAPS               1
+#define TEST_ROOT_CAN_BIND_LOW       2
+#define TEST_SETUID                  3
+#define TEST_SETUID_KEEPCAPS         4
+#define TEST_SETUID_STRICT           5
+
+static const struct {
+  const char *name;
+  int test_id;
+} which_test[] = {
+  { "built-with-caps",    TEST_BUILT_WITH_CAPS },
+  { "have-caps",          TEST_HAVE_CAPS },
+  { "root-bind-low",      TEST_ROOT_CAN_BIND_LOW },
+  { "setuid",             TEST_SETUID },
+  { "setuid-keepcaps",    TEST_SETUID_KEEPCAPS },
+  { "setuid-strict",      TEST_SETUID_STRICT },
+  { NULL, 0 }
+};
+
+#if !defined(_WIN32)
+/* 0 on no, 1 on yes, -1 on failure. */
+static int
+check_can_bind_low_ports(void)
+{
+  int port;
+  struct sockaddr_in sin;
+  memset(&sin, 0, sizeof(sin));
+  sin.sin_family = AF_INET;
+
+  for (port = 600; port < 1024; ++port) {
+    sin.sin_port = htons(port);
+    tor_socket_t fd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
+    if (! SOCKET_OK(fd)) {
+      perror("socket");
+      return -1;
+    }
+
+    int one = 1;
+    if (setsockopt(fd, SOL_SOCKET,SO_REUSEADDR, (void*)&one,
+                   (socklen_t)sizeof(one))) {
+      perror("setsockopt");
+      tor_close_socket_simple(fd);
+      return -1;
+    }
+
+    int res = bind(fd, (struct sockaddr *)&sin, sizeof(sin));
+    tor_close_socket_simple(fd);
+
+    if (res == 0) {
+      /* bind was successful */
+      return 1;
+    } else if (errno == EACCES || errno == EPERM) {
+      /* Got a permission-denied error. */
+      return 0;
+    } else if (errno == EADDRINUSE) {
+      /* Huh; somebody is using that port. */
+    } else {
+      perror("bind");
+    }
+  }
+
+  return -1;
+}
+#endif
+
+int
+main(int argc, char **argv)
+{
+#if defined(_WIN32)
+  (void) argc;
+  (void) argv;
+
+  fprintf(stderr, "This test is not supported on your OS.\n");
+  return 77;
+#else
+  const char *username;
+  const char *testname;
+  if (argc != 3) {
+    fprintf(stderr, "I want 2 arguments: a username and a command.\n");
+    return 1;
+  }
+  if (getuid() != 0) {
+    fprintf(stderr, "This test only works when it's run as root.\n");
+    return 1;
+  }
+  username = argv[1];
+  testname = argv[2];
+  int test_id = -1;
+  int i;
+  for (i = 0; which_test[i].name; ++i) {
+    if (!strcmp(which_test[i].name, testname)) {
+      test_id = which_test[i].test_id;
+      break;
+    }
+  }
+  if (test_id == -1) {
+    fprintf(stderr, "Unrecognized test '%s'\n", testname);
+    return 1;
+  }
+
+#ifdef HAVE_LINUX_CAPABILITIES
+  const int have_cap_support = 1;
+#else
+  const int have_cap_support = 0;
+#endif
+
+  int okay;
+
+  init_logging(1);
+  log_severity_list_t sev;
+  memset(&sev, 0, sizeof(sev));
+  set_log_severity_config(LOG_WARN, LOG_ERR, &sev);
+  add_stream_log(&sev, "", fileno(stderr));
+
+  switch (test_id)
+    {
+    case TEST_BUILT_WITH_CAPS:
+      /* Succeed if we were built with capability support. */
+      okay = have_cap_support;
+      break;
+    case TEST_HAVE_CAPS:
+      /* Succeed if "capabilities work" == "we were built with capability
+       * support." */
+      okay = have_cap_support == have_capability_support();
+      break;
+    case TEST_ROOT_CAN_BIND_LOW:
+      /* Succeed if root can bind low ports. */
+      okay = check_can_bind_low_ports() == 1;
+      break;
+    case TEST_SETUID:
+      /* Succeed if we can do a setuid with no capability retention, and doing
+       * so makes us lose the ability to bind low ports */
+    case TEST_SETUID_KEEPCAPS:
+      /* Succeed if we can do a setuid with capability retention, and doing so
+       * does not make us lose the ability to bind low ports */
+    {
+      int keepcaps = (test_id == TEST_SETUID_KEEPCAPS);
+      okay = switch_id(username, keepcaps ? SWITCH_ID_KEEP_BINDLOW : 0) == 0;
+      if (okay) {
+        okay = check_can_bind_low_ports() == keepcaps;
+      }
+      break;
+    }
+    case TEST_SETUID_STRICT:
+      /* Succeed if, after a setuid, we cannot setuid back, and we cannot
+       * re-grab any capabilities. */
+      okay = switch_id(username, SWITCH_ID_KEEP_BINDLOW) == 0;
+      if (okay) {
+        /* We'd better not be able to setuid back! */
+        if (setuid(0) == 0 || errno != EPERM) {
+          okay = 0;
+        }
+      }
+#ifdef HAVE_LINUX_CAPABILITIES
+      if (okay) {
+        cap_t caps = cap_get_proc();
+        const cap_value_t caplist[] = {
+          CAP_SETUID,
+        };
+        cap_set_flag(caps, CAP_PERMITTED, 1, caplist, CAP_SET);
+        if (cap_set_proc(caps) == 0 || errno != EPERM) {
+          okay = 0;
+        }
+        cap_free(caps);
+      }
+#endif
+      break;
+    default:
+      fprintf(stderr, "Unsupported test '%s'\n", testname);
+      okay = 0;
+      break;
+    }
+
+  if (!okay) {
+    fprintf(stderr, "Test %s failed!\n", testname);
+  }
+
+  return (okay ? 0 : 1);
+#endif
+}
+
diff --git a/src/test/test_switch_id.sh b/src/test/test_switch_id.sh
new file mode 100755
index 0000000..1b4e099
--- /dev/null
+++ b/src/test/test_switch_id.sh
@@ -0,0 +1,25 @@
+#!/bin/sh
+
+if test "`id -u`" != '0'; then
+    echo "This test only works when run as root. Skipping." >&2
+    exit 77
+fi
+
+if test "`id -u nobody`" = ""; then
+    echo "This test requires that your system have a 'nobody' user. Sorry." >&2
+    exit 1
+fi
+
+"${builddir:-.}/src/test/test-switch-id" nobody setuid          || exit 1
+"${builddir:-.}/src/test/test-switch-id" nobody root-bind-low   || exit 1
+"${builddir:-.}/src/test/test-switch-id" nobody setuid-strict   || exit 1
+"${builddir:-.}/src/test/test-switch-id" nobody built-with-caps || exit 0
+# ... Go beyond this point only if we were built with capability support.
+
+"${builddir:-.}/src/test/test-switch-id" nobody have-caps       || exit 1
+"${builddir:-.}/src/test/test-switch-id" nobody setuid-keepcaps || exit 1
+
+
+echo "All okay"
+
+exit 0
diff --git a/src/test/test_threads.c b/src/test/test_threads.c
index 35f5dc8..fe88c94 100644
--- a/src/test/test_threads.c
+++ b/src/test/test_threads.c
@@ -73,6 +73,8 @@ thread_test_func_(void* _s)
     ++thread_fns_failed;
   tor_mutex_release(thread_test_mutex_);
 
+  tor_free(mycount);
+
   tor_mutex_release(m);
 
   spawn_exit();
diff --git a/src/test/test_tortls.c b/src/test/test_tortls.c
new file mode 100644
index 0000000..138485c
--- /dev/null
+++ b/src/test/test_tortls.c
@@ -0,0 +1,2834 @@
+/* Copyright (c) 2010-2015, The Tor Project, Inc. */
+/* See LICENSE for licensing information */
+
+#define TORTLS_PRIVATE
+#define LOG_PRIVATE
+#include "orconfig.h"
+
+#ifdef _WIN32
+#include <winsock2.h>
+#endif
+
+#ifdef __GNUC__
+#define GCC_VERSION (__GNUC__ * 100 + __GNUC_MINOR__)
+#endif
+
+#if __GNUC__ && GCC_VERSION >= 402
+#if GCC_VERSION >= 406
+#pragma GCC diagnostic push
+#endif
+/* Some versions of OpenSSL declare SSL_get_selected_srtp_profile twice in
+ * srtp.h. Suppress the GCC warning so we can build with -Wredundant-decl. */
+#pragma GCC diagnostic ignored "-Wredundant-decls"
+#endif
+
+#include <openssl/opensslv.h>
+
+#include <openssl/ssl.h>
+#include <openssl/ssl3.h>
+#include <openssl/err.h>
+#include <openssl/asn1t.h>
+#include <openssl/x509.h>
+#include <openssl/rsa.h>
+#include <openssl/evp.h>
+#include <openssl/bn.h>
+
+#if __GNUC__ && GCC_VERSION >= 402
+#if GCC_VERSION >= 406
+#pragma GCC diagnostic pop
+#else
+#pragma GCC diagnostic warning "-Wredundant-decls"
+#endif
+#endif
+
+#include "or.h"
+#include "torlog.h"
+#include "config.h"
+#include "tortls.h"
+
+#include "test.h"
+#include "log_test_helpers.h"
+#define NS_MODULE tortls
+
+extern tor_tls_context_t *server_tls_context;
+extern tor_tls_context_t *client_tls_context;
+
+#if OPENSSL_VERSION_NUMBER >= OPENSSL_V_SERIES(1,1,0) \
+    && !defined(LIBRESSL_VERSION_NUMBER)
+#define OPENSSL_OPAQUE
+#define SSL_STATE_STR "before SSL initialization"
+#else
+#define SSL_STATE_STR "before/accept initialization"
+#endif
+
+#ifndef OPENSSL_OPAQUE
+static SSL_METHOD *
+give_me_a_test_method(void)
+{
+  SSL_METHOD *method = tor_malloc_zero(sizeof(SSL_METHOD));
+  memcpy(method, TLSv1_method(), sizeof(SSL_METHOD));
+  return method;
+}
+
+static int
+fake_num_ciphers(void)
+{
+  return 0;
+}
+#endif
+
+static void
+test_tortls_errno_to_tls_error(void *data)
+{
+  (void) data;
+  tt_int_op(tor_errno_to_tls_error(SOCK_ERRNO(ECONNRESET)),OP_EQ,
+            TOR_TLS_ERROR_CONNRESET);
+  tt_int_op(tor_errno_to_tls_error(SOCK_ERRNO(ETIMEDOUT)),OP_EQ,
+            TOR_TLS_ERROR_TIMEOUT);
+  tt_int_op(tor_errno_to_tls_error(SOCK_ERRNO(EHOSTUNREACH)),OP_EQ,
+            TOR_TLS_ERROR_NO_ROUTE);
+  tt_int_op(tor_errno_to_tls_error(SOCK_ERRNO(ENETUNREACH)),OP_EQ,
+            TOR_TLS_ERROR_NO_ROUTE);
+  tt_int_op(tor_errno_to_tls_error(SOCK_ERRNO(ECONNREFUSED)),OP_EQ,
+            TOR_TLS_ERROR_CONNREFUSED);
+  tt_int_op(tor_errno_to_tls_error(0),OP_EQ,TOR_TLS_ERROR_MISC);
+ done:
+  (void)1;
+}
+
+static void
+test_tortls_err_to_string(void *data)
+{
+  (void) data;
+  tt_str_op(tor_tls_err_to_string(1),OP_EQ,"[Not an error.]");
+  tt_str_op(tor_tls_err_to_string(TOR_TLS_ERROR_MISC),OP_EQ,"misc error");
+  tt_str_op(tor_tls_err_to_string(TOR_TLS_ERROR_IO),OP_EQ,"unexpected close");
+  tt_str_op(tor_tls_err_to_string(TOR_TLS_ERROR_CONNREFUSED),OP_EQ,
+            "connection refused");
+  tt_str_op(tor_tls_err_to_string(TOR_TLS_ERROR_CONNRESET),OP_EQ,
+            "connection reset");
+  tt_str_op(tor_tls_err_to_string(TOR_TLS_ERROR_NO_ROUTE),OP_EQ,
+            "host unreachable");
+  tt_str_op(tor_tls_err_to_string(TOR_TLS_ERROR_TIMEOUT),OP_EQ,
+            "connection timed out");
+  tt_str_op(tor_tls_err_to_string(TOR_TLS_CLOSE),OP_EQ,"closed");
+  tt_str_op(tor_tls_err_to_string(TOR_TLS_WANTREAD),OP_EQ,"want to read");
+  tt_str_op(tor_tls_err_to_string(TOR_TLS_WANTWRITE),OP_EQ,"want to write");
+  tt_str_op(tor_tls_err_to_string(-100),OP_EQ,"(unknown error code)");
+ done:
+  (void)1;
+}
+
+static int
+mock_tls_cert_matches_key(const tor_tls_t *tls, const tor_x509_cert_t *cert)
+{
+  (void) tls;
+  (void) cert; // XXXX look at this.
+  return 1;
+}
+
+static void
+test_tortls_tor_tls_new(void *data)
+{
+  (void) data;
+  MOCK(tor_tls_cert_matches_key, mock_tls_cert_matches_key);
+  crypto_pk_t *key1 = NULL, *key2 = NULL;
+  SSL_METHOD *method = NULL;
+
+  key1 = pk_generate(2);
+  key2 = pk_generate(3);
+
+  tor_tls_t *tls = NULL;
+  tt_int_op(tor_tls_context_init(TOR_TLS_CTX_IS_PUBLIC_SERVER,
+                                 key1, key2, 86400), OP_EQ, 0);
+  tls = tor_tls_new(-1, 0);
+  tt_want(tls);
+  tor_tls_free(tls); tls = NULL;
+
+  SSL_CTX_free(client_tls_context->ctx);
+  client_tls_context->ctx = NULL;
+  tls = tor_tls_new(-1, 0);
+  tt_assert(!tls);
+
+#ifndef OPENSSL_OPAQUE
+  method = give_me_a_test_method();
+  SSL_CTX *ctx = SSL_CTX_new(method);
+  method->num_ciphers = fake_num_ciphers;
+  client_tls_context->ctx = ctx;
+  tls = tor_tls_new(-1, 0);
+  tt_assert(!tls);
+#endif
+
+ done:
+  UNMOCK(tor_tls_cert_matches_key);
+  crypto_pk_free(key1);
+  crypto_pk_free(key2);
+  tor_tls_free(tls);
+  tor_free(method);
+  tor_tls_free_all();
+}
+
+#define NS_MODULE tortls
+NS_DECL(void, logv, (int severity, log_domain_mask_t domain,
+                     const char *funcname, const char *suffix,
+                     const char *format, va_list ap));
+
+static void
+NS(logv)(int severity, log_domain_mask_t domain,
+         const char *funcname, const char *suffix, const char *format,
+         va_list ap)
+{
+  (void) severity;
+  (void) domain;
+  (void) funcname;
+  (void) suffix;
+  (void) format;
+  (void) ap; // XXXX look at this.
+  CALLED(logv)++;
+}
+
+static void
+test_tortls_tor_tls_get_error(void *data)
+{
+  (void) data;
+  MOCK(tor_tls_cert_matches_key, mock_tls_cert_matches_key);
+  crypto_pk_t *key1 = NULL, *key2 = NULL;
+  key1 = pk_generate(2);
+  key2 = pk_generate(3);
+
+  tor_tls_t *tls = NULL;
+  tt_int_op(tor_tls_context_init(TOR_TLS_CTX_IS_PUBLIC_SERVER,
+                                 key1, key2, 86400), OP_EQ, 0);
+  tls = tor_tls_new(-1, 0);
+  NS_MOCK(logv);
+  tt_int_op(CALLED(logv), OP_EQ, 0);
+  tor_tls_get_error(tls, 0, 0,
+                    (const char *)"test", 0, 0);
+  tt_int_op(CALLED(logv), OP_EQ, 1);
+
+ done:
+  UNMOCK(tor_tls_cert_matches_key);
+  NS_UNMOCK(logv);
+  crypto_pk_free(key1);
+  crypto_pk_free(key2);
+  tor_tls_free(tls);
+}
+
+static void
+test_tortls_get_state_description(void *ignored)
+{
+  (void)ignored;
+  tor_tls_t *tls;
+  char *buf;
+  SSL_CTX *ctx;
+
+  SSL_library_init();
+  SSL_load_error_strings();
+
+  ctx = SSL_CTX_new(SSLv23_method());
+
+  buf = tor_malloc_zero(1000);
+  tls = tor_malloc_zero(sizeof(tor_tls_t));
+
+  tor_tls_get_state_description(NULL, buf, 20);
+  tt_str_op(buf, OP_EQ, "(No SSL object)");
+
+  SSL_free(tls->ssl);
+  tls->ssl = NULL;
+  tor_tls_get_state_description(tls, buf, 20);
+  tt_str_op(buf, OP_EQ, "(No SSL object)");
+
+  tls->ssl = SSL_new(ctx);
+  tor_tls_get_state_description(tls, buf, 200);
+  tt_str_op(buf, OP_EQ, SSL_STATE_STR " in HANDSHAKE");
+
+  tls->state = TOR_TLS_ST_OPEN;
+  tor_tls_get_state_description(tls, buf, 200);
+  tt_str_op(buf, OP_EQ, SSL_STATE_STR " in OPEN");
+
+  tls->state = TOR_TLS_ST_GOTCLOSE;
+  tor_tls_get_state_description(tls, buf, 200);
+  tt_str_op(buf, OP_EQ, SSL_STATE_STR " in GOTCLOSE");
+
+  tls->state = TOR_TLS_ST_SENTCLOSE;
+  tor_tls_get_state_description(tls, buf, 200);
+  tt_str_op(buf, OP_EQ, SSL_STATE_STR " in SENTCLOSE");
+
+  tls->state = TOR_TLS_ST_CLOSED;
+  tor_tls_get_state_description(tls, buf, 200);
+  tt_str_op(buf, OP_EQ, SSL_STATE_STR " in CLOSED");
+
+  tls->state = TOR_TLS_ST_RENEGOTIATE;
+  tor_tls_get_state_description(tls, buf, 200);
+  tt_str_op(buf, OP_EQ, SSL_STATE_STR " in RENEGOTIATE");
+
+  tls->state = TOR_TLS_ST_BUFFEREVENT;
+  tor_tls_get_state_description(tls, buf, 200);
+  tt_str_op(buf, OP_EQ, SSL_STATE_STR);
+
+  tls->state = 7;
+  tor_tls_get_state_description(tls, buf, 200);
+  tt_str_op(buf, OP_EQ, SSL_STATE_STR " in unknown TLS state");
+
+ done:
+  SSL_CTX_free(ctx);
+  SSL_free(tls->ssl);
+  tor_free(buf);
+  tor_free(tls);
+}
+
+extern int tor_tls_object_ex_data_index;
+
+static void
+test_tortls_get_by_ssl(void *ignored)
+{
+  (void)ignored;
+  tor_tls_t *tls;
+  tor_tls_t *res;
+  SSL_CTX *ctx;
+  SSL *ssl;
+
+  SSL_library_init();
+  SSL_load_error_strings();
+  tor_tls_allocate_tor_tls_object_ex_data_index();
+
+  ctx = SSL_CTX_new(SSLv23_method());
+  tls = tor_malloc_zero(sizeof(tor_tls_t));
+  tls->magic = TOR_TLS_MAGIC;
+
+  ssl = SSL_new(ctx);
+
+  res = tor_tls_get_by_ssl(ssl);
+  tt_assert(!res);
+
+  SSL_set_ex_data(ssl, tor_tls_object_ex_data_index, tls);
+
+  res = tor_tls_get_by_ssl(ssl);
+  tt_assert(res == tls);
+
+ done:
+  SSL_free(ssl);
+  SSL_CTX_free(ctx);
+  tor_free(tls);
+}
+
+static void
+test_tortls_allocate_tor_tls_object_ex_data_index(void *ignored)
+{
+  (void)ignored;
+  int first;
+
+  tor_tls_allocate_tor_tls_object_ex_data_index();
+
+  first = tor_tls_object_ex_data_index;
+  tor_tls_allocate_tor_tls_object_ex_data_index();
+  tt_int_op(first, OP_EQ, tor_tls_object_ex_data_index);
+
+ done:
+  (void)0;
+}
+
+static void
+test_tortls_log_one_error(void *ignored)
+{
+  (void)ignored;
+  tor_tls_t *tls;
+  SSL_CTX *ctx;
+  SSL *ssl = NULL;
+
+  SSL_library_init();
+  SSL_load_error_strings();
+
+  ctx = SSL_CTX_new(SSLv23_method());
+  tls = tor_malloc_zero(sizeof(tor_tls_t));
+  int previous_log = setup_capture_of_logs(LOG_INFO);
+
+  tor_tls_log_one_error(NULL, 0, LOG_WARN, 0, "something");
+  expect_log_msg("TLS error while something: "
+            "(null) (in (null):(null):---)\n");
+
+  mock_clean_saved_logs();
+  tor_tls_log_one_error(tls, 0, LOG_WARN, 0, NULL);
+  expect_log_msg("TLS error: (null) "
+            "(in (null):(null):---)\n");
+
+  mock_clean_saved_logs();
+  tls->address = tor_strdup("127.hello");
+  tor_tls_log_one_error(tls, 0, LOG_WARN, 0, NULL);
+  expect_log_msg("TLS error with 127.hello: "
+            "(null) (in (null):(null):---)\n");
+  tor_free(tls->address);
+
+  mock_clean_saved_logs();
+  tls->address = tor_strdup("127.hello");
+  tor_tls_log_one_error(tls, 0, LOG_WARN, 0, "blarg");
+  expect_log_msg("TLS error while blarg with "
+            "127.hello: (null) (in (null):(null):---)\n");
+
+  mock_clean_saved_logs();
+  tor_tls_log_one_error(tls, ERR_PACK(1, 2, 3), LOG_WARN, 0, NULL);
+  expect_log_msg("TLS error with 127.hello: "
+            "BN lib (in unknown library:(null):---)\n");
+
+  mock_clean_saved_logs();
+  tor_tls_log_one_error(tls, ERR_PACK(1, 2, SSL_R_HTTP_REQUEST),
+                        LOG_WARN, 0, NULL);
+  expect_log_severity(LOG_INFO);
+
+  mock_clean_saved_logs();
+  tor_tls_log_one_error(tls, ERR_PACK(1, 2, SSL_R_HTTPS_PROXY_REQUEST),
+                        LOG_WARN, 0, NULL);
+  expect_log_severity(LOG_INFO);
+
+  mock_clean_saved_logs();
+  tor_tls_log_one_error(tls, ERR_PACK(1, 2, SSL_R_RECORD_LENGTH_MISMATCH),
+                        LOG_WARN, 0, NULL);
+  expect_log_severity(LOG_INFO);
+
+  mock_clean_saved_logs();
+  tor_tls_log_one_error(tls, ERR_PACK(1, 2, SSL_R_RECORD_TOO_LARGE),
+                        LOG_WARN, 0, NULL);
+  expect_log_severity(LOG_INFO);
+
+  mock_clean_saved_logs();
+  tor_tls_log_one_error(tls, ERR_PACK(1, 2, SSL_R_UNKNOWN_PROTOCOL),
+                        LOG_WARN, 0, NULL);
+  expect_log_severity(LOG_INFO);
+
+  mock_clean_saved_logs();
+  tor_tls_log_one_error(tls, ERR_PACK(1, 2, SSL_R_UNSUPPORTED_PROTOCOL),
+                        LOG_WARN, 0, NULL);
+  expect_log_severity(LOG_INFO);
+
+  tls->ssl = SSL_new(ctx);
+
+  mock_clean_saved_logs();
+  tor_tls_log_one_error(tls, 0, LOG_WARN, 0, NULL);
+  expect_log_msg("TLS error with 127.hello: (null)"
+            " (in (null):(null):" SSL_STATE_STR ")\n");
+
+ done:
+  teardown_capture_of_logs(previous_log);
+  SSL_free(ssl);
+  SSL_CTX_free(ctx);
+  if (tls && tls->ssl)
+    SSL_free(tls->ssl);
+  if (tls)
+    tor_free(tls->address);
+  tor_free(tls);
+}
+
+#ifndef OPENSSL_OPAQUE
+static void
+test_tortls_get_error(void *ignored)
+{
+  (void)ignored;
+  tor_tls_t *tls;
+  int ret;
+  SSL_CTX *ctx;
+
+  SSL_library_init();
+  SSL_load_error_strings();
+
+  ctx = SSL_CTX_new(SSLv23_method());
+  int previous_log = setup_capture_of_logs(LOG_INFO);
+  tls = tor_malloc_zero(sizeof(tor_tls_t));
+  tls->ssl = SSL_new(ctx);
+  SSL_set_bio(tls->ssl, BIO_new(BIO_s_mem()), NULL);
+
+  ret = tor_tls_get_error(tls, 0, 0, "something", LOG_WARN, 0);
+  tt_int_op(ret, OP_EQ, TOR_TLS_ERROR_IO);
+  expect_log_msg("TLS error: unexpected close while"
+            " something (before/accept initialization)\n");
+
+  mock_clean_saved_logs();
+  ret = tor_tls_get_error(tls, 2, 0, "something", LOG_WARN, 0);
+  tt_int_op(ret, OP_EQ, 0);
+  expect_no_log_entry();
+
+  mock_clean_saved_logs();
+  ret = tor_tls_get_error(tls, 0, 1, "something", LOG_WARN, 0);
+  tt_int_op(ret, OP_EQ, -11);
+  expect_no_log_entry();
+
+  mock_clean_saved_logs();
+  ERR_clear_error();
+  ERR_put_error(ERR_LIB_BN, 2, -1, "somewhere.c", 99);
+  ret = tor_tls_get_error(tls, 0, 0, "something", LOG_WARN, 0);
+  tt_int_op(ret, OP_EQ, TOR_TLS_ERROR_MISC);
+  expect_log_msg("TLS error while something: (null)"
+            " (in bignum routines:(null):before/accept initialization)\n");
+
+  mock_clean_saved_logs();
+  ERR_clear_error();
+  tls->ssl->rwstate = SSL_READING;
+  SSL_get_rbio(tls->ssl)->flags = BIO_FLAGS_READ;
+  ret = tor_tls_get_error(tls, -1, 0, "something", LOG_WARN, 0);
+  tt_int_op(ret, OP_EQ, TOR_TLS_WANTREAD);
+  expect_no_log_entry();
+
+  mock_clean_saved_logs();
+  ERR_clear_error();
+  tls->ssl->rwstate = SSL_READING;
+  SSL_get_rbio(tls->ssl)->flags = BIO_FLAGS_WRITE;
+  ret = tor_tls_get_error(tls, -1, 0, "something", LOG_WARN, 0);
+  tt_int_op(ret, OP_EQ, TOR_TLS_WANTWRITE);
+  expect_no_log_entry();
+
+  mock_clean_saved_logs();
+  ERR_clear_error();
+  tls->ssl->rwstate = 0;
+  tls->ssl->shutdown = SSL_RECEIVED_SHUTDOWN;
+  tls->ssl->s3->warn_alert =SSL_AD_CLOSE_NOTIFY;
+  ret = tor_tls_get_error(tls, 0, 0, "something", LOG_WARN, 0);
+  tt_int_op(ret, OP_EQ, TOR_TLS_CLOSE);
+  expect_log_entry();
+
+  mock_clean_saved_logs();
+  ret = tor_tls_get_error(tls, 0, 2, "something", LOG_WARN, 0);
+  tt_int_op(ret, OP_EQ, -10);
+  expect_no_log_entry();
+
+  mock_clean_saved_logs();
+  ERR_put_error(ERR_LIB_SYS, 2, -1, "somewhere.c", 99);
+  ret = tor_tls_get_error(tls, -1, 0, "something", LOG_WARN, 0);
+  tt_int_op(ret, OP_EQ, -9);
+  expect_log_msg("TLS error while something: (null) (in system library:"
+            "connect:before/accept initialization)\n");
+
+ done:
+  teardown_capture_of_logs(previous_log);
+  SSL_free(tls->ssl);
+  tor_free(tls);
+  SSL_CTX_free(ctx);
+}
+#endif
+
+static void
+test_tortls_always_accept_verify_cb(void *ignored)
+{
+  (void)ignored;
+  int ret;
+
+  ret = always_accept_verify_cb(0, NULL);
+  tt_int_op(ret, OP_EQ, 1);
+
+ done:
+  (void)0;
+}
+
+#ifndef OPENSSL_OPAQUE
+static void
+test_tortls_x509_cert_free(void *ignored)
+{
+  (void)ignored;
+  tor_x509_cert_t *cert;
+
+  cert = tor_malloc_zero(sizeof(tor_x509_cert_t));
+  tor_x509_cert_free(cert);
+
+  cert = tor_malloc_zero(sizeof(tor_x509_cert_t));
+  cert->cert = tor_malloc_zero(sizeof(X509));
+  cert->encoded = tor_malloc_zero(1);
+  tor_x509_cert_free(cert);
+}
+#endif
+
+static void
+test_tortls_x509_cert_get_id_digests(void *ignored)
+{
+  (void)ignored;
+  tor_x509_cert_t *cert;
+  digests_t *d;
+  const digests_t *res;
+  cert = tor_malloc_zero(sizeof(tor_x509_cert_t));
+  d = tor_malloc_zero(sizeof(digests_t));
+  d->d[0][0] = 42;
+
+  res = tor_x509_cert_get_id_digests(cert);
+  tt_assert(!res);
+
+  cert->pkey_digests_set = 1;
+  cert->pkey_digests = *d;
+  res = tor_x509_cert_get_id_digests(cert);
+  tt_int_op(res->d[0][0], OP_EQ, 42);
+
+ done:
+  tor_free(cert);
+  tor_free(d);
+}
+
+#ifndef OPENSSL_OPAQUE
+static int
+fixed_pub_cmp(const EVP_PKEY *a, const EVP_PKEY *b)
+{
+  (void) a; (void) b;
+  return 1;
+}
+
+static void
+fake_x509_free(X509 *cert)
+{
+  if (cert) {
+    if (cert->cert_info) {
+      if (cert->cert_info->key) {
+        if (cert->cert_info->key->pkey) {
+          tor_free(cert->cert_info->key->pkey);
+        }
+        tor_free(cert->cert_info->key);
+      }
+      tor_free(cert->cert_info);
+    }
+    tor_free(cert);
+  }
+}
+
+static void
+test_tortls_cert_matches_key(void *ignored)
+{
+  (void)ignored;
+  int res;
+  tor_tls_t *tls;
+  tor_x509_cert_t *cert;
+  X509 *one = NULL, *two = NULL;
+  EVP_PKEY_ASN1_METHOD *meth = EVP_PKEY_asn1_new(999, 0, NULL, NULL);
+  EVP_PKEY_asn1_set_public(meth, NULL, NULL, fixed_pub_cmp, NULL, NULL, NULL);
+
+  tls = tor_malloc_zero(sizeof(tor_tls_t));
+  cert = tor_malloc_zero(sizeof(tor_x509_cert_t));
+  one = tor_malloc_zero(sizeof(X509));
+  one->references = 1;
+  two = tor_malloc_zero(sizeof(X509));
+  two->references = 1;
+
+  res = tor_tls_cert_matches_key(tls, cert);
+  tt_int_op(res, OP_EQ, 0);
+
+  tls->ssl = tor_malloc_zero(sizeof(SSL));
+  tls->ssl->session = tor_malloc_zero(sizeof(SSL_SESSION));
+  tls->ssl->session->peer = one;
+  res = tor_tls_cert_matches_key(tls, cert);
+  tt_int_op(res, OP_EQ, 0);
+
+  cert->cert = two;
+  res = tor_tls_cert_matches_key(tls, cert);
+  tt_int_op(res, OP_EQ, 0);
+
+  one->cert_info = tor_malloc_zero(sizeof(X509_CINF));
+  one->cert_info->key = tor_malloc_zero(sizeof(X509_PUBKEY));
+  one->cert_info->key->pkey = tor_malloc_zero(sizeof(EVP_PKEY));
+  one->cert_info->key->pkey->references = 1;
+  one->cert_info->key->pkey->ameth = meth;
+  one->cert_info->key->pkey->type = 1;
+
+  two->cert_info = tor_malloc_zero(sizeof(X509_CINF));
+  two->cert_info->key = tor_malloc_zero(sizeof(X509_PUBKEY));
+  two->cert_info->key->pkey = tor_malloc_zero(sizeof(EVP_PKEY));
+  two->cert_info->key->pkey->references = 1;
+  two->cert_info->key->pkey->ameth = meth;
+  two->cert_info->key->pkey->type = 2;
+
+  res = tor_tls_cert_matches_key(tls, cert);
+  tt_int_op(res, OP_EQ, 0);
+
+  one->cert_info->key->pkey->type = 1;
+  two->cert_info->key->pkey->type = 1;
+  res = tor_tls_cert_matches_key(tls, cert);
+  tt_int_op(res, OP_EQ, 1);
+
+ done:
+  EVP_PKEY_asn1_free(meth);
+  tor_free(tls->ssl->session);
+  tor_free(tls->ssl);
+  tor_free(tls);
+  tor_free(cert);
+  fake_x509_free(one);
+  fake_x509_free(two);
+}
+
+static void
+test_tortls_cert_get_key(void *ignored)
+{
+  (void)ignored;
+  tor_x509_cert_t *cert = NULL;
+  crypto_pk_t *res = NULL;
+  cert = tor_malloc_zero(sizeof(tor_x509_cert_t));
+  X509 *key = NULL;
+  key = tor_malloc_zero(sizeof(X509));
+  key->references = 1;
+
+  res = tor_tls_cert_get_key(cert);
+  tt_assert(!res);
+
+  cert->cert = key;
+  key->cert_info = tor_malloc_zero(sizeof(X509_CINF));
+  key->cert_info->key = tor_malloc_zero(sizeof(X509_PUBKEY));
+  key->cert_info->key->pkey = tor_malloc_zero(sizeof(EVP_PKEY));
+  key->cert_info->key->pkey->references = 1;
+  key->cert_info->key->pkey->type = 2;
+  res = tor_tls_cert_get_key(cert);
+  tt_assert(!res);
+
+ done:
+  fake_x509_free(key);
+  tor_free(cert);
+  crypto_pk_free(res);
+}
+#endif
+
+static void
+test_tortls_get_my_client_auth_key(void *ignored)
+{
+  (void)ignored;
+  crypto_pk_t *ret;
+  crypto_pk_t *expected;
+  tor_tls_context_t *ctx;
+  RSA *k = tor_malloc_zero(sizeof(RSA));
+
+  ctx = tor_malloc_zero(sizeof(tor_tls_context_t));
+  expected = crypto_new_pk_from_rsa_(k);
+  ctx->auth_key = expected;
+
+  client_tls_context = NULL;
+  ret = tor_tls_get_my_client_auth_key();
+  tt_assert(!ret);
+
+  client_tls_context = ctx;
+  ret = tor_tls_get_my_client_auth_key();
+  tt_assert(ret == expected);
+
+ done:
+  tor_free(expected);
+  tor_free(k);
+  tor_free(ctx);
+}
+
+static void
+test_tortls_get_my_certs(void *ignored)
+{
+  (void)ignored;
+  int ret;
+  tor_tls_context_t *ctx;
+  const tor_x509_cert_t *link_cert_out = NULL;
+  const tor_x509_cert_t *id_cert_out = NULL;
+
+  ctx = tor_malloc_zero(sizeof(tor_tls_context_t));
+
+  client_tls_context = NULL;
+  ret = tor_tls_get_my_certs(0, NULL, NULL);
+  tt_int_op(ret, OP_EQ, -1);
+
+  server_tls_context = NULL;
+  ret = tor_tls_get_my_certs(1, NULL, NULL);
+  tt_int_op(ret, OP_EQ, -1);
+
+  client_tls_context = ctx;
+  ret = tor_tls_get_my_certs(0, NULL, NULL);
+  tt_int_op(ret, OP_EQ, 0);
+
+  client_tls_context = ctx;
+  ret = tor_tls_get_my_certs(0, &link_cert_out, &id_cert_out);
+  tt_int_op(ret, OP_EQ, 0);
+
+  server_tls_context = ctx;
+  ret = tor_tls_get_my_certs(1, &link_cert_out, &id_cert_out);
+  tt_int_op(ret, OP_EQ, 0);
+
+ done:
+  (void)1;
+}
+
+#ifndef OPENSSL_OPAQUE
+static void
+test_tortls_get_ciphersuite_name(void *ignored)
+{
+  (void)ignored;
+  const char *ret;
+  tor_tls_t *ctx;
+  ctx = tor_malloc_zero(sizeof(tor_tls_t));
+  ctx->ssl = tor_malloc_zero(sizeof(SSL));
+
+  ret = tor_tls_get_ciphersuite_name(ctx);
+  tt_str_op(ret, OP_EQ, "(NONE)");
+
+ done:
+  tor_free(ctx->ssl);
+  tor_free(ctx);
+}
+
+static SSL_CIPHER *
+get_cipher_by_name(const char *name)
+{
+  int i;
+  const SSL_METHOD *method = SSLv23_method();
+  int num = method->num_ciphers();
+  for (i = 0; i < num; ++i) {
+    const SSL_CIPHER *cipher = method->get_cipher(i);
+    const char *ciphername = SSL_CIPHER_get_name(cipher);
+    if (!strcmp(ciphername, name)) {
+      return (SSL_CIPHER *)cipher;
+    }
+  }
+
+  return NULL;
+}
+
+static SSL_CIPHER *
+get_cipher_by_id(uint16_t id)
+{
+  int i;
+  const SSL_METHOD *method = SSLv23_method();
+  int num = method->num_ciphers();
+  for (i = 0; i < num; ++i) {
+    const SSL_CIPHER *cipher = method->get_cipher(i);
+    if (id == (SSL_CIPHER_get_id(cipher) & 0xffff)) {
+      return (SSL_CIPHER *)cipher;
+    }
+  }
+
+  return NULL;
+}
+
+extern uint16_t v2_cipher_list[];
+
+static void
+test_tortls_classify_client_ciphers(void *ignored)
+{
+  (void)ignored;
+  int i;
+  int ret;
+  SSL_CTX *ctx;
+  SSL *ssl;
+  tor_tls_t *tls;
+  STACK_OF(SSL_CIPHER) *ciphers;
+  SSL_CIPHER *tmp_cipher;
+
+  SSL_library_init();
+  SSL_load_error_strings();
+  tor_tls_allocate_tor_tls_object_ex_data_index();
+
+  tls = tor_malloc_zero(sizeof(tor_tls_t));
+  tls->magic = TOR_TLS_MAGIC;
+
+  ctx = SSL_CTX_new(TLSv1_method());
+  ssl = SSL_new(ctx);
+  tls->ssl = ssl;
+
+  ciphers = sk_SSL_CIPHER_new_null();
+
+  ret = tor_tls_classify_client_ciphers(ssl, NULL);
+  tt_int_op(ret, OP_EQ, -1);
+
+  SSL_set_ex_data(ssl, tor_tls_object_ex_data_index, tls);
+  tls->client_cipher_list_type = 42;
+
+  ret = tor_tls_classify_client_ciphers(ssl, NULL);
+  tt_int_op(ret, OP_EQ, 42);
+
+  tls->client_cipher_list_type = 0;
+  ret = tor_tls_classify_client_ciphers(ssl, ciphers);
+  tt_int_op(ret, OP_EQ, 1);
+  tt_int_op(tls->client_cipher_list_type, OP_EQ, 1);
+
+  tls->client_cipher_list_type = 0;
+  ret = tor_tls_classify_client_ciphers(ssl, SSL_get_ciphers(ssl));
+  tt_int_op(ret, OP_EQ, 3);
+  tt_int_op(tls->client_cipher_list_type, OP_EQ, 3);
+
+  SSL_CIPHER *one = get_cipher_by_name(TLS1_TXT_DHE_RSA_WITH_AES_128_SHA),
+    *two = get_cipher_by_name(TLS1_TXT_DHE_RSA_WITH_AES_256_SHA),
+    *three = get_cipher_by_name(SSL3_TXT_EDH_RSA_DES_192_CBC3_SHA),
+    *four = NULL;
+  sk_SSL_CIPHER_push(ciphers, one);
+  sk_SSL_CIPHER_push(ciphers, two);
+  sk_SSL_CIPHER_push(ciphers, three);
+  sk_SSL_CIPHER_push(ciphers, four);
+
+  tls->client_cipher_list_type = 0;
+  ret = tor_tls_classify_client_ciphers(ssl, ciphers);
+  tt_int_op(ret, OP_EQ, 1);
+  tt_int_op(tls->client_cipher_list_type, OP_EQ, 1);
+
+  sk_SSL_CIPHER_zero(ciphers);
+
+  one = get_cipher_by_name("ECDH-RSA-AES256-GCM-SHA384");
+  one->id = 0x00ff;
+  two = get_cipher_by_name("ECDH-RSA-AES128-GCM-SHA256");
+  two->id = 0x0000;
+  sk_SSL_CIPHER_push(ciphers, one);
+  tls->client_cipher_list_type = 0;
+  ret = tor_tls_classify_client_ciphers(ssl, ciphers);
+  tt_int_op(ret, OP_EQ, 3);
+  tt_int_op(tls->client_cipher_list_type, OP_EQ, 3);
+
+  sk_SSL_CIPHER_push(ciphers, two);
+  tls->client_cipher_list_type = 0;
+  ret = tor_tls_classify_client_ciphers(ssl, ciphers);
+  tt_int_op(ret, OP_EQ, 3);
+  tt_int_op(tls->client_cipher_list_type, OP_EQ, 3);
+
+  one->id = 0xC00A;
+  tls->client_cipher_list_type = 0;
+  ret = tor_tls_classify_client_ciphers(ssl, ciphers);
+  tt_int_op(ret, OP_EQ, 3);
+  tt_int_op(tls->client_cipher_list_type, OP_EQ, 3);
+
+  sk_SSL_CIPHER_zero(ciphers);
+  for (i=0; v2_cipher_list[i]; i++) {
+    tmp_cipher = get_cipher_by_id(v2_cipher_list[i]);
+    tt_assert(tmp_cipher);
+    sk_SSL_CIPHER_push(ciphers, tmp_cipher);
+  }
+  tls->client_cipher_list_type = 0;
+  ret = tor_tls_classify_client_ciphers(ssl, ciphers);
+  tt_int_op(ret, OP_EQ, 2);
+  tt_int_op(tls->client_cipher_list_type, OP_EQ, 2);
+
+ done:
+  sk_SSL_CIPHER_free(ciphers);
+  SSL_free(tls->ssl);
+  tor_free(tls);
+  SSL_CTX_free(ctx);
+}
+#endif
+
+static void
+test_tortls_client_is_using_v2_ciphers(void *ignored)
+{
+  (void)ignored;
+
+#ifdef HAVE_SSL_GET_CLIENT_CIPHERS
+  tt_skip();
+ done:
+  (void)1;
+#else
+  int ret;
+  SSL_CTX *ctx;
+  SSL *ssl;
+  SSL_SESSION *sess;
+  STACK_OF(SSL_CIPHER) *ciphers;
+
+  SSL_library_init();
+  SSL_load_error_strings();
+
+  ctx = SSL_CTX_new(TLSv1_method());
+  ssl = SSL_new(ctx);
+  sess = SSL_SESSION_new();
+
+  ret = tor_tls_client_is_using_v2_ciphers(ssl);
+  tt_int_op(ret, OP_EQ, -1);
+
+  ssl->session = sess;
+  ret = tor_tls_client_is_using_v2_ciphers(ssl);
+  tt_int_op(ret, OP_EQ, 0);
+
+  ciphers = sk_SSL_CIPHER_new_null();
+  SSL_CIPHER *one = get_cipher_by_name("ECDH-RSA-AES256-GCM-SHA384");
+  one->id = 0x00ff;
+  sk_SSL_CIPHER_push(ciphers, one);
+  sess->ciphers = ciphers;
+  ret = tor_tls_client_is_using_v2_ciphers(ssl);
+  tt_int_op(ret, OP_EQ, 1);
+ done:
+  SSL_free(ssl);
+  SSL_CTX_free(ctx);
+#endif
+}
+
+#ifndef OPENSSL_OPAQUE
+static X509 *fixed_try_to_extract_certs_from_tls_cert_out_result = NULL;
+static X509 *fixed_try_to_extract_certs_from_tls_id_cert_out_result = NULL;
+
+static void
+fixed_try_to_extract_certs_from_tls(int severity, tor_tls_t *tls,
+                                    X509 **cert_out, X509 **id_cert_out)
+{
+  (void) severity;
+  (void) tls;
+  *cert_out = fixed_try_to_extract_certs_from_tls_cert_out_result;
+  *id_cert_out = fixed_try_to_extract_certs_from_tls_id_cert_out_result;
+}
+#endif
+
+#ifndef OPENSSL_OPAQUE
+static const char* notCompletelyValidCertString =
+  "-----BEGIN CERTIFICATE-----\n"
+  "MIICVjCCAb8CAg37MA0GCSqGSIb3DQEBBQUAMIGbMQswCQYDVQQGEwJKUDEOMAwG\n"
+  "A1UECBMFVG9reW8xEDAOBgNVBAcTB0NodW8ta3UxETAPBgNVBAoTCEZyYW5rNERE\n"
+  "MRgwFgYDVQQLEw9XZWJDZXJ0IFN1cHBvcnQxGDAWBgNVBAMTD0ZyYW5rNEREIFdl\n"
+  "YiBDQTEjMCEGCSqGSIb3DQEJARYUc3VwcG9ydEBmcmFuazRkZC5jb20wHhcNMTIw\n"
+  "ODIyMDUyNzIzWhcNMTcwODIxMDUyNzIzWjBKMQswCQYDVQQGEwJKUDEOMAwGA1UE\n"
+  "CAwFVG9reW8xETAPBgNVBAoMCEZyYW5rNEREMRgwFgYDVQQDDA93d3cuZXhhbXBs\n"
+  "ZS5jb20wgZ8wDQYJKoZIhvcNAQEBBQADgY0AMIGJAoGBAMYBBrx5PlP0WNI/ZdzD\n"
+  "+6Pktmurn+F2kQYbtc7XQh8/LTBvCo+P6iZoLEmUA9e7EXLRxgU1CVqeAi7QcAn9\n"
+  "MwBlc8ksFJHB0rtf9pmf8Oza9E0Bynlq/4/Kb1x+d+AyhL7oK9tQwB24uHOueHi1\n"
+  "C/iVv8CSWKiYe6hzN1txYe8rAgMBAAEwDQYJKoZIhvcNAQEFBQADgYEAASPdjigJ\n"
+  "kXCqKWpnZ/Oc75EUcMi6HztaW8abUMlYXPIgkV2F7YanHOB7K4f7OOLjiz8DTPFf\n"
+  "jC9UeuErhaA/zzWi8ewMTFZW/WshOrm3fNvcMrMLKtH534JKvcdMg6qIdjTFINIr\n"
+  "evnAhf0cwULaebn+lMs8Pdl7y37+sfluVok=\n"
+  "-----END CERTIFICATE-----\n";
+#endif
+
+static const char* validCertString = "-----BEGIN CERTIFICATE-----\n"
+  "MIIDpTCCAY0CAg3+MA0GCSqGSIb3DQEBBQUAMF4xCzAJBgNVBAYTAlVTMREwDwYD\n"
+  "VQQIDAhJbGxpbm9pczEQMA4GA1UEBwwHQ2hpY2FnbzEUMBIGA1UECgwLVG9yIFRl\n"
+  "c3RpbmcxFDASBgNVBAMMC1RvciBUZXN0aW5nMB4XDTE1MDkwNjEzMzk1OVoXDTQz\n"
+  "MDEyMjEzMzk1OVowVjELMAkGA1UEBhMCVVMxEDAOBgNVBAcMB0NoaWNhZ28xFDAS\n"
+  "BgNVBAoMC1RvciBUZXN0aW5nMR8wHQYDVQQDDBZ0ZXN0aW5nLnRvcnByb2plY3Qu\n"
+  "b3JnMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDoT6uyVVhWyOF3wkHjjYbd\n"
+  "nKaykyRv4JVtKQdZ4OpEErmX1zw4MmyzpQNV6iR4bQnWiyLfzyVJMZDIC/WILBfX\n"
+  "w2Pza/yuLgUvDc3twMuhOACzOQVO8PrEF/aVv2+hbCCy2udXvKhnYn+CCXl3ozc8\n"
+  "XcKYvujTXDyvGWY3xwAjlQIDAQABMA0GCSqGSIb3DQEBBQUAA4ICAQCUvnhzQWuQ\n"
+  "MrN+pERkE+zcTI/9dGS90rUMMLgu8VDNqTa0TUQh8uO0EQ6uDvI8Js6e8tgwS0BR\n"
+  "UBahqb7ZHv+rejGCBr5OudqD+x4STiiuPNJVs86JTLN8SpM9CHjIBH5WCCN2KOy3\n"
+  "mevNoRcRRyYJzSFULCunIK6FGulszigMYGscrO4oiTkZiHPh9KvWT40IMiHfL+Lw\n"
+  "EtEWiLex6064LcA2YQ1AMuSZyCexks63lcfaFmQbkYOKqXa1oLkIRuDsOaSVjTfe\n"
+  "vec+X6jvf12cFTKS5WIeqkKF2Irt+dJoiHEGTe5RscUMN/f+gqHPzfFz5dR23sxo\n"
+  "g+HC6MZHlFkLAOx3wW6epPS8A/m1mw3zMPoTnb2U2YYt8T0dJMMlUn/7Y1sEAa+a\n"
+  "dSTMaeUf6VnJ//11m454EZl1to9Z7oJOgqmFffSrdD4BGIWe8f7hhW6L1Enmqe/J\n"
+  "BKL3wbzZh80O1W0bndAwhnEEhlzneFY84cbBo9pmVxpODHkUcStpr5Z7pBDrcL21\n"
+  "Ss/aB/1YrsVXhdvJdOGxl3Mnl9dUY57CympLGlT8f0pPS6GAKOelECOhFMHmJd8L\n"
+  "dj3XQSmKtYHevZ6IvuMXSlB/fJvSjSlkCuLo5+kJoaqPuRu+i/S1qxeRy3CBwmnE\n"
+  "LdSNdcX4N79GQJ996PA8+mUCQG7YRtK+WA==\n"
+  "-----END CERTIFICATE-----\n";
+
+static const char* caCertString = "-----BEGIN CERTIFICATE-----\n"
+  "MIIFjzCCA3egAwIBAgIJAKd5WgyfPMYRMA0GCSqGSIb3DQEBCwUAMF4xCzAJBgNV\n"
+  "BAYTAlVTMREwDwYDVQQIDAhJbGxpbm9pczEQMA4GA1UEBwwHQ2hpY2FnbzEUMBIG\n"
+  "A1UECgwLVG9yIFRlc3RpbmcxFDASBgNVBAMMC1RvciBUZXN0aW5nMB4XDTE1MDkw\n"
+  "NjEzMzc0MVoXDTQzMDEyMjEzMzc0MVowXjELMAkGA1UEBhMCVVMxETAPBgNVBAgM\n"
+  "CElsbGlub2lzMRAwDgYDVQQHDAdDaGljYWdvMRQwEgYDVQQKDAtUb3IgVGVzdGlu\n"
+  "ZzEUMBIGA1UEAwwLVG9yIFRlc3RpbmcwggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAw\n"
+  "ggIKAoICAQCpLMUEiLW5leUgBZoEJms2V7lZRhIAjnJBhVMHD0e3UubNknmaQoxf\n"
+  "ARz3rvqOaRd0JlV+qM9qE0DjiYcCVP1cAfqAo9d83uS1vwY3YMVJzADlaIiHfyVW\n"
+  "uEgBy0vvkeUBqaua24dYlcwsemOiXYLu41yM1wkcGHW1AhBNHppY6cznb8TyLgNM\n"
+  "2x3SGUdzc5XMyAFx51faKGBA3wjs+Hg1PLY7d30nmCgEOBavpm5I1disM/0k+Mcy\n"
+  "YmAKEo/iHJX/rQzO4b9znP69juLlR8PDBUJEVIG/CYb6+uw8MjjUyiWXYoqfVmN2\n"
+  "hm/lH8b6rXw1a2Aa3VTeD0DxaWeacMYHY/i01fd5n7hCoDTRNdSw5KJ0L3Z0SKTu\n"
+  "0lzffKzDaIfyZGlpW5qdouACkWYzsaitQOePVE01PIdO30vUfzNTFDfy42ccx3Di\n"
+  "59UCu+IXB+eMtrBfsok0Qc63vtF1linJgjHW1z/8ujk8F7/qkOfODhk4l7wngc2A\n"
+  "EmwWFIFoGaiTEZHB9qteXr4unbXZ0AHpM02uGGwZEGohjFyebEb73M+J57WKKAFb\n"
+  "PqbLcGUksL1SHNBNAJcVLttX55sO4nbidOS/kA3m+F1R04MBTyQF9qA6YDDHqdI3\n"
+  "h/3pw0Z4fxVouTYT4/NfRnX4JTP4u+7Mpcoof28VME0qWqD1LnRhFQIDAQABo1Aw\n"
+  "TjAdBgNVHQ4EFgQUMoAgIXH7pZ3QMRwTjT+DM9Yo/v0wHwYDVR0jBBgwFoAUMoAg\n"
+  "IXH7pZ3QMRwTjT+DM9Yo/v0wDAYDVR0TBAUwAwEB/zANBgkqhkiG9w0BAQsFAAOC\n"
+  "AgEAUJxacjXR9sT+Xs6ISFiUsyd0T6WVKMnV46xrYJHirGfx+krWHrjxMY+ZtxYD\n"
+  "DBDGlo11Qc4v6QrclNf5QUBfIiGQsP9Cm6hHcQ+Tpg9HHCgSqG1YNPwCPReCR4br\n"
+  "BLvLfrfkcBL2IWM0PdQdCze+59DBfipsULD2mEn9fjYRXQEwb2QWtQ9qRc20Yb/x\n"
+  "Q4b/+CvUodLkaq7B8MHz0BV8HHcBoph6DYaRmO/N+hPauIuSp6XyaGYcEefGKVKj\n"
+  "G2+fcsdyXsoijNdL8vNKwm4j2gVwCBnw16J00yfFoV46YcbfqEdJB2je0XSvwXqt\n"
+  "14AOTngxso2h9k9HLtrfpO1ZG/B5AcCMs1lzbZ2fp5DPHtjvvmvA2RJqgo3yjw4W\n"
+  "4DHAuTglYFlC3mDHNfNtcGP20JvepcQNzNP2UzwcpOc94hfKikOFw+gf9Vf1qd0y\n"
+  "h/Sk6OZHn2+JVUPiWHIQV98Vtoh4RmUZDJD+b55ia3fQGTGzt4z1XFzQYSva5sfs\n"
+  "wocS/papthqWldQU7x+3wofNd5CNU1x6WKXG/yw30IT/4F8ADJD6GeygNT8QJYvt\n"
+  "u/8lAkbOy6B9xGmSvr0Kk1oq9P2NshA6kalxp1Oz/DTNDdL4AeBXV3JmM6WWCjGn\n"
+  "Yy1RT69d0rwYc5u/vnqODz1IjvT90smsrkBumGt791FAFeg=\n"
+  "-----END CERTIFICATE-----\n";
+
+static X509 *
+read_cert_from(const char *str)
+{
+  BIO *bio = BIO_new(BIO_s_mem());
+  BIO_write(bio, str, (int) strlen(str));
+  X509 *res = PEM_read_bio_X509(bio, NULL, NULL, NULL);
+  BIO_free(bio);
+  return res;
+}
+
+#ifndef OPENSSL_OPAQUE
+static void
+test_tortls_verify(void *ignored)
+{
+  (void)ignored;
+  int ret;
+  tor_tls_t *tls;
+  crypto_pk_t *k = NULL;
+  X509 *cert1 = NULL, *cert2 = NULL, *invalidCert = NULL,
+    *validCert = NULL, *caCert = NULL;
+
+  cert1 = tor_malloc_zero(sizeof(X509));
+  cert1->references = 10;
+
+  cert2 = tor_malloc_zero(sizeof(X509));
+  cert2->references = 10;
+
+  validCert = read_cert_from(validCertString);
+  caCert = read_cert_from(caCertString);
+  invalidCert = read_cert_from(notCompletelyValidCertString);
+
+  tls = tor_malloc_zero(sizeof(tor_tls_t));
+  ret = tor_tls_verify(LOG_WARN, tls, &k);
+  tt_int_op(ret, OP_EQ, -1);
+
+  MOCK(try_to_extract_certs_from_tls, fixed_try_to_extract_certs_from_tls);
+
+  fixed_try_to_extract_certs_from_tls_cert_out_result = cert1;
+  ret = tor_tls_verify(LOG_WARN, tls, &k);
+  tt_int_op(ret, OP_EQ, -1);
+
+  fixed_try_to_extract_certs_from_tls_id_cert_out_result = cert2;
+  ret = tor_tls_verify(LOG_WARN, tls, &k);
+  tt_int_op(ret, OP_EQ, -1);
+
+  fixed_try_to_extract_certs_from_tls_cert_out_result = invalidCert;
+  fixed_try_to_extract_certs_from_tls_id_cert_out_result = invalidCert;
+
+  ret = tor_tls_verify(LOG_WARN, tls, &k);
+  tt_int_op(ret, OP_EQ, -1);
+
+  fixed_try_to_extract_certs_from_tls_cert_out_result = validCert;
+  fixed_try_to_extract_certs_from_tls_id_cert_out_result = caCert;
+
+  ret = tor_tls_verify(LOG_WARN, tls, &k);
+  tt_int_op(ret, OP_EQ, 0);
+  tt_assert(k);
+
+ done:
+  UNMOCK(try_to_extract_certs_from_tls);
+  tor_free(cert1);
+  tor_free(cert2);
+  tor_free(tls);
+  tor_free(k);
+}
+#endif
+
+#ifndef OPENSSL_OPAQUE
+static void
+test_tortls_check_lifetime(void *ignored)
+{
+  (void)ignored;
+  int ret;
+  tor_tls_t *tls;
+  X509 *validCert = read_cert_from(validCertString);
+  time_t now = time(NULL);
+
+  tls = tor_malloc_zero(sizeof(tor_tls_t));
+  ret = tor_tls_check_lifetime(LOG_WARN, tls, 0, 0);
+  tt_int_op(ret, OP_EQ, -1);
+
+  tls->ssl = tor_malloc_zero(sizeof(SSL));
+  tls->ssl->session = tor_malloc_zero(sizeof(SSL_SESSION));
+  tls->ssl->session->peer = validCert;
+  ret = tor_tls_check_lifetime(LOG_WARN, tls, 0, 0);
+  tt_int_op(ret, OP_EQ, 0);
+
+  ASN1_STRING_free(validCert->cert_info->validity->notBefore);
+  validCert->cert_info->validity->notBefore = ASN1_TIME_set(NULL, now-10);
+  ASN1_STRING_free(validCert->cert_info->validity->notAfter);
+  validCert->cert_info->validity->notAfter = ASN1_TIME_set(NULL, now+60);
+
+  ret = tor_tls_check_lifetime(LOG_WARN, tls, 0, -1000);
+  tt_int_op(ret, OP_EQ, -1);
+
+  ret = tor_tls_check_lifetime(LOG_WARN, tls, -1000, 0);
+  tt_int_op(ret, OP_EQ, -1);
+
+ done:
+  tor_free(tls->ssl->session);
+  tor_free(tls->ssl);
+  tor_free(tls);
+  X509_free(validCert);
+}
+#endif
+
+#ifndef OPENSSL_OPAQUE
+static int fixed_ssl_pending_result = 0;
+
+static int
+fixed_ssl_pending(const SSL *ignored)
+{
+  (void)ignored;
+  return fixed_ssl_pending_result;
+}
+
+static void
+test_tortls_get_pending_bytes(void *ignored)
+{
+  (void)ignored;
+  int ret;
+  tor_tls_t *tls;
+  SSL_METHOD *method;
+
+  tls = tor_malloc_zero(sizeof(tor_tls_t));
+  tls->ssl = tor_malloc_zero(sizeof(SSL));
+  method = tor_malloc_zero(sizeof(SSL_METHOD));
+  method->ssl_pending = fixed_ssl_pending;
+  tls->ssl->method = method;
+
+  fixed_ssl_pending_result = 42;
+  ret = tor_tls_get_pending_bytes(tls);
+  tt_int_op(ret, OP_EQ, 42);
+
+ done:
+  tor_free(method);
+  tor_free(tls->ssl);
+  tor_free(tls);
+}
+#endif
+
+static void
+test_tortls_get_forced_write_size(void *ignored)
+{
+  (void)ignored;
+  long ret;
+  tor_tls_t *tls;
+
+  tls = tor_malloc_zero(sizeof(tor_tls_t));
+
+  tls->wantwrite_n = 43;
+  ret = tor_tls_get_forced_write_size(tls);
+  tt_int_op(ret, OP_EQ, 43);
+
+ done:
+  tor_free(tls);
+}
+
+extern uint64_t total_bytes_written_over_tls;
+extern uint64_t total_bytes_written_by_tls;
+
+static void
+test_tortls_get_write_overhead_ratio(void *ignored)
+{
+  (void)ignored;
+  double ret;
+
+  total_bytes_written_over_tls = 0;
+  ret = tls_get_write_overhead_ratio();
+  tt_int_op(ret, OP_EQ, 1.0);
+
+  total_bytes_written_by_tls = 10;
+  total_bytes_written_over_tls = 1;
+  ret = tls_get_write_overhead_ratio();
+  tt_int_op(ret, OP_EQ, 10.0);
+
+  total_bytes_written_by_tls = 10;
+  total_bytes_written_over_tls = 2;
+  ret = tls_get_write_overhead_ratio();
+  tt_int_op(ret, OP_EQ, 5.0);
+
+ done:
+  (void)0;
+}
+
+static void
+test_tortls_used_v1_handshake(void *ignored)
+{
+  (void)ignored;
+  int ret;
+  tor_tls_t *tls;
+  tls = tor_malloc_zero(sizeof(tor_tls_t));
+
+  // These tests assume both V2 handshake server and client are enabled
+  tls->wasV2Handshake = 0;
+  ret = tor_tls_used_v1_handshake(tls);
+  tt_int_op(ret, OP_EQ, 1);
+
+  tls->wasV2Handshake = 1;
+  ret = tor_tls_used_v1_handshake(tls);
+  tt_int_op(ret, OP_EQ, 0);
+
+ done:
+  tor_free(tls);
+}
+
+static void
+test_tortls_get_num_server_handshakes(void *ignored)
+{
+  (void)ignored;
+  int ret;
+  tor_tls_t *tls;
+
+  tls = tor_malloc_zero(sizeof(tor_tls_t));
+
+  tls->server_handshake_count = 3;
+  ret = tor_tls_get_num_server_handshakes(tls);
+  tt_int_op(ret, OP_EQ, 3);
+
+ done:
+  tor_free(tls);
+}
+
+static void
+test_tortls_server_got_renegotiate(void *ignored)
+{
+  (void)ignored;
+  int ret;
+  tor_tls_t *tls;
+
+  tls = tor_malloc_zero(sizeof(tor_tls_t));
+
+  tls->got_renegotiate = 1;
+  ret = tor_tls_server_got_renegotiate(tls);
+  tt_int_op(ret, OP_EQ, 1);
+
+ done:
+  tor_free(tls);
+}
+
+#ifndef OPENSSL_OPAQUE
+static void
+test_tortls_SSL_SESSION_get_master_key(void *ignored)
+{
+  (void)ignored;
+  size_t ret;
+  tor_tls_t *tls;
+  uint8_t *out;
+  out = tor_malloc_zero(1);
+  tls = tor_malloc_zero(sizeof(tor_tls_t));
+  tls->ssl = tor_malloc_zero(sizeof(SSL));
+  tls->ssl->session = tor_malloc_zero(sizeof(SSL_SESSION));
+  tls->ssl->session->master_key_length = 1;
+
+#ifndef HAVE_SSL_SESSION_GET_MASTER_KEY
+  tls->ssl->session->master_key[0] = 43;
+  ret = SSL_SESSION_get_master_key(tls->ssl->session, out, 0);
+  tt_int_op(ret, OP_EQ, 1);
+  tt_int_op(out[0], OP_EQ, 0);
+
+  ret = SSL_SESSION_get_master_key(tls->ssl->session, out, 1);
+  tt_int_op(ret, OP_EQ, 1);
+  tt_int_op(out[0], OP_EQ, 43);
+
+ done:
+#endif
+  tor_free(tls->ssl->session);
+  tor_free(tls->ssl);
+  tor_free(tls);
+  tor_free(out);
+}
+#endif
+
+#ifndef OPENSSL_OPAQUE
+static void
+test_tortls_get_tlssecrets(void *ignored)
+{
+  (void)ignored;
+  int ret;
+  uint8_t *secret_out = tor_malloc_zero(DIGEST256_LEN);;
+  tor_tls_t *tls;
+  tls = tor_malloc_zero(sizeof(tor_tls_t));
+  tls->ssl = tor_malloc_zero(sizeof(SSL));
+  tls->ssl->session = tor_malloc_zero(sizeof(SSL_SESSION));
+  tls->ssl->session->master_key_length = 1;
+  tls->ssl->s3 = tor_malloc_zero(sizeof(SSL3_STATE));
+
+  ret = tor_tls_get_tlssecrets(tls, secret_out);
+  tt_int_op(ret, OP_EQ, 0);
+
+ done:
+  tor_free(secret_out);
+  tor_free(tls->ssl->s3);
+  tor_free(tls->ssl->session);
+  tor_free(tls->ssl);
+  tor_free(tls);
+}
+#endif
+
+#ifndef OPENSSL_OPAQUE
+static void
+test_tortls_get_buffer_sizes(void *ignored)
+{
+  (void)ignored;
+  int ret;
+  tor_tls_t *tls;
+  size_t rbuf_c=-1, rbuf_b=-1, wbuf_c=-1, wbuf_b=-1;
+
+  tls = tor_malloc_zero(sizeof(tor_tls_t));
+  tls->ssl = tor_malloc_zero(sizeof(SSL));
+  tls->ssl->s3 = tor_malloc_zero(sizeof(SSL3_STATE));
+
+  tls->ssl->s3->rbuf.buf = NULL;
+  tls->ssl->s3->rbuf.len = 1;
+  tls->ssl->s3->rbuf.offset = 0;
+  tls->ssl->s3->rbuf.left = 42;
+
+  tls->ssl->s3->wbuf.buf = NULL;
+  tls->ssl->s3->wbuf.len = 2;
+  tls->ssl->s3->wbuf.offset = 0;
+  tls->ssl->s3->wbuf.left = 43;
+
+  ret = tor_tls_get_buffer_sizes(tls, &rbuf_c, &rbuf_b, &wbuf_c, &wbuf_b);
+#if OPENSSL_VERSION_NUMBER >= OPENSSL_V_SERIES(1,1,0)
+  tt_int_op(ret, OP_EQ, -1);
+#else
+  tt_int_op(ret, OP_EQ, 0);
+  tt_int_op(rbuf_c, OP_EQ, 0);
+  tt_int_op(wbuf_c, OP_EQ, 0);
+  tt_int_op(rbuf_b, OP_EQ, 42);
+  tt_int_op(wbuf_b, OP_EQ, 43);
+
+  tls->ssl->s3->rbuf.buf = tor_malloc_zero(1);
+  tls->ssl->s3->wbuf.buf = tor_malloc_zero(1);
+  ret = tor_tls_get_buffer_sizes(tls, &rbuf_c, &rbuf_b, &wbuf_c, &wbuf_b);
+  tt_int_op(ret, OP_EQ, 0);
+  tt_int_op(rbuf_c, OP_EQ, 1);
+  tt_int_op(wbuf_c, OP_EQ, 2);
+
+#endif
+
+ done:
+  tor_free(tls->ssl->s3->rbuf.buf);
+  tor_free(tls->ssl->s3->wbuf.buf);
+  tor_free(tls->ssl->s3);
+  tor_free(tls->ssl);
+  tor_free(tls);
+}
+#endif
+
+static void
+test_tortls_evaluate_ecgroup_for_tls(void *ignored)
+{
+  (void)ignored;
+  int ret;
+
+  ret = evaluate_ecgroup_for_tls(NULL);
+  tt_int_op(ret, OP_EQ, 1);
+
+  ret = evaluate_ecgroup_for_tls("foobar");
+  tt_int_op(ret, OP_EQ, 0);
+
+  ret = evaluate_ecgroup_for_tls("P256");
+  tt_int_op(ret, OP_EQ, 1);
+
+  ret = evaluate_ecgroup_for_tls("P224");
+  //  tt_int_op(ret, OP_EQ, 1); This varies between machines
+
+ done:
+  (void)0;
+}
+
+#ifndef OPENSSL_OPAQUE
+typedef struct cert_pkey_st_local
+{
+  X509 *x509;
+  EVP_PKEY *privatekey;
+  const EVP_MD *digest;
+} CERT_PKEY_local;
+
+typedef struct sess_cert_st_local
+{
+  STACK_OF(X509) *cert_chain;
+  int peer_cert_type;
+  CERT_PKEY_local *peer_key;
+  CERT_PKEY_local peer_pkeys[8];
+  int references;
+} SESS_CERT_local;
+
+static void
+test_tortls_try_to_extract_certs_from_tls(void *ignored)
+{
+  (void)ignored;
+  tor_tls_t *tls;
+  X509 *cert = NULL, *id_cert = NULL, *c1 = NULL, *c2 = NULL;
+  SESS_CERT_local *sess = NULL;
+
+  c1 = read_cert_from(validCertString);
+  c2 = read_cert_from(caCertString);
+
+  tls = tor_malloc_zero(sizeof(tor_tls_t));
+  tls->ssl = tor_malloc_zero(sizeof(SSL));
+  tls->ssl->session = tor_malloc_zero(sizeof(SSL_SESSION));
+  sess = tor_malloc_zero(sizeof(SESS_CERT_local));
+  tls->ssl->session->sess_cert = (void *)sess;
+
+  try_to_extract_certs_from_tls(LOG_WARN, tls, &cert, &id_cert);
+  tt_assert(!cert);
+  tt_assert(!id_cert);
+
+  tls->ssl->session->peer = c1;
+  try_to_extract_certs_from_tls(LOG_WARN, tls, &cert, &id_cert);
+  tt_assert(cert == c1);
+  tt_assert(!id_cert);
+  X509_free(cert); /* decrease refcnt */
+
+  sess->cert_chain = sk_X509_new_null();
+  try_to_extract_certs_from_tls(LOG_WARN, tls, &cert, &id_cert);
+  tt_assert(cert == c1);
+  tt_assert(!id_cert);
+  X509_free(cert); /* decrease refcnt */
+
+  sk_X509_push(sess->cert_chain, c1);
+  sk_X509_push(sess->cert_chain, c2);
+
+  try_to_extract_certs_from_tls(LOG_WARN, tls, &cert, &id_cert);
+  tt_assert(cert == c1);
+  tt_assert(id_cert);
+  X509_free(cert); /* decrease refcnt */
+
+ done:
+  sk_X509_free(sess->cert_chain);
+  tor_free(sess);
+  tor_free(tls->ssl->session);
+  tor_free(tls->ssl);
+  tor_free(tls);
+  X509_free(c1);
+  X509_free(c2);
+}
+#endif
+
+#ifndef OPENSSL_OPAQUE
+static void
+test_tortls_get_peer_cert(void *ignored)
+{
+  (void)ignored;
+  tor_x509_cert_t *ret;
+  tor_tls_t *tls;
+  X509 *cert = NULL;
+
+  cert = read_cert_from(validCertString);
+
+  tls = tor_malloc_zero(sizeof(tor_tls_t));
+  tls->ssl = tor_malloc_zero(sizeof(SSL));
+  tls->ssl->session = tor_malloc_zero(sizeof(SSL_SESSION));
+
+  ret = tor_tls_get_peer_cert(tls);
+  tt_assert(!ret);
+
+  tls->ssl->session->peer = cert;
+  ret = tor_tls_get_peer_cert(tls);
+  tt_assert(ret);
+  tt_assert(ret->cert == cert);
+
+ done:
+  tor_x509_cert_free(ret);
+  tor_free(tls->ssl->session);
+  tor_free(tls->ssl);
+  tor_free(tls);
+  X509_free(cert);
+}
+#endif
+
+#ifndef OPENSSL_OPAQUE
+static void
+test_tortls_peer_has_cert(void *ignored)
+{
+  (void)ignored;
+  int ret;
+  tor_tls_t *tls;
+  X509 *cert = NULL;
+
+  cert = read_cert_from(validCertString);
+
+  tls = tor_malloc_zero(sizeof(tor_tls_t));
+  tls->ssl = tor_malloc_zero(sizeof(SSL));
+  tls->ssl->session = tor_malloc_zero(sizeof(SSL_SESSION));
+
+  ret = tor_tls_peer_has_cert(tls);
+  tt_assert(!ret);
+
+  tls->ssl->session->peer = cert;
+  ret = tor_tls_peer_has_cert(tls);
+  tt_assert(ret);
+
+ done:
+  tor_free(tls->ssl->session);
+  tor_free(tls->ssl);
+  tor_free(tls);
+  X509_free(cert);
+}
+#endif
+
+static void
+test_tortls_is_server(void *ignored)
+{
+  (void)ignored;
+  tor_tls_t *tls;
+  int ret;
+
+  tls = tor_malloc_zero(sizeof(tor_tls_t));
+  tls->isServer = 1;
+  ret = tor_tls_is_server(tls);
+  tt_int_op(ret, OP_EQ, 1);
+
+ done:
+  tor_free(tls);
+}
+
+#ifndef OPENSSL_OPAQUE
+static void
+test_tortls_session_secret_cb(void *ignored)
+{
+  (void)ignored;
+  tor_tls_t *tls;
+  SSL_CTX *ctx;
+  STACK_OF(SSL_CIPHER) *ciphers = NULL;
+  SSL_CIPHER *one;
+
+  SSL_library_init();
+  SSL_load_error_strings();
+  tor_tls_allocate_tor_tls_object_ex_data_index();
+
+  tls = tor_malloc_zero(sizeof(tor_tls_t));
+
+  tls->magic = TOR_TLS_MAGIC;
+
+  ctx = SSL_CTX_new(TLSv1_method());
+  tls->ssl = SSL_new(ctx);
+  SSL_set_ex_data(tls->ssl, tor_tls_object_ex_data_index, tls);
+
+  SSL_set_session_secret_cb(tls->ssl, tor_tls_session_secret_cb, NULL);
+
+  tor_tls_session_secret_cb(tls->ssl, NULL, NULL, NULL, NULL, NULL);
+  tt_assert(!tls->ssl->tls_session_secret_cb);
+
+  one = get_cipher_by_name("ECDH-RSA-AES256-GCM-SHA384");
+  one->id = 0x00ff;
+  ciphers = sk_SSL_CIPHER_new_null();
+  sk_SSL_CIPHER_push(ciphers, one);
+
+  tls->client_cipher_list_type = 0;
+  tor_tls_session_secret_cb(tls->ssl, NULL, NULL, ciphers, NULL, NULL);
+  tt_assert(!tls->ssl->tls_session_secret_cb);
+
+ done:
+  sk_SSL_CIPHER_free(ciphers);
+  SSL_free(tls->ssl);
+  SSL_CTX_free(ctx);
+  tor_free(tls);
+}
+#endif
+
+#ifndef OPENSSL_OPAQUE
+/* TODO: It seems block_renegotiation and unblock_renegotiation and
+ * using different blags. This might not be correct */
+static void
+test_tortls_block_renegotiation(void *ignored)
+{
+  (void)ignored;
+  tor_tls_t *tls;
+
+  tls = tor_malloc_zero(sizeof(tor_tls_t));
+  tls->ssl = tor_malloc_zero(sizeof(SSL));
+  tls->ssl->s3 = tor_malloc_zero(sizeof(SSL3_STATE));
+#ifndef SUPPORT_UNSAFE_RENEGOTIATION_FLAG
+#define SSL3_FLAGS_ALLOW_UNSAFE_LEGACY_RENEGOTIATION 0
+#endif
+
+  tls->ssl->s3->flags = SSL3_FLAGS_ALLOW_UNSAFE_LEGACY_RENEGOTIATION;
+
+  tor_tls_block_renegotiation(tls);
+
+#ifndef OPENSSL_1_1_API
+  tt_assert(!(tls->ssl->s3->flags &
+              SSL3_FLAGS_ALLOW_UNSAFE_LEGACY_RENEGOTIATION));
+#endif
+
+ done:
+  tor_free(tls->ssl->s3);
+  tor_free(tls->ssl);
+  tor_free(tls);
+}
+
+static void
+test_tortls_unblock_renegotiation(void *ignored)
+{
+  (void)ignored;
+  tor_tls_t *tls;
+
+  tls = tor_malloc_zero(sizeof(tor_tls_t));
+  tls->ssl = tor_malloc_zero(sizeof(SSL));
+  tor_tls_unblock_renegotiation(tls);
+
+  tt_uint_op(SSL_get_options(tls->ssl) &
+             SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION, OP_EQ,
+             SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION);
+
+ done:
+  tor_free(tls->ssl);
+  tor_free(tls);
+}
+#endif
+
+#ifndef OPENSSL_OPAQUE
+static void
+test_tortls_assert_renegotiation_unblocked(void *ignored)
+{
+  (void)ignored;
+  tor_tls_t *tls;
+
+  tls = tor_malloc_zero(sizeof(tor_tls_t));
+  tls->ssl = tor_malloc_zero(sizeof(SSL));
+  tor_tls_unblock_renegotiation(tls);
+  tor_tls_assert_renegotiation_unblocked(tls);
+  /* No assertion here - this test will fail if tor_assert is turned on
+   * and things are bad. */
+
+  tor_free(tls->ssl);
+  tor_free(tls);
+}
+#endif
+
+static void
+test_tortls_set_logged_address(void *ignored)
+{
+  (void)ignored;
+  tor_tls_t *tls;
+
+  tls = tor_malloc_zero(sizeof(tor_tls_t));
+
+  tor_tls_set_logged_address(tls, "foo bar");
+
+  tt_str_op(tls->address, OP_EQ, "foo bar");
+
+  tor_tls_set_logged_address(tls, "foo bar 2");
+  tt_str_op(tls->address, OP_EQ, "foo bar 2");
+
+ done:
+  tor_free(tls->address);
+  tor_free(tls);
+}
+
+#ifndef OPENSSL_OPAQUE
+static void
+example_cb(tor_tls_t *t, void *arg)
+{
+  (void)t;
+  (void)arg;
+}
+
+static void
+test_tortls_set_renegotiate_callback(void *ignored)
+{
+  (void)ignored;
+  tor_tls_t *tls;
+  const char *arg = "hello";
+
+  tls = tor_malloc_zero(sizeof(tor_tls_t));
+  tls->ssl = tor_malloc_zero(sizeof(SSL));
+
+  tor_tls_set_renegotiate_callback(tls, example_cb, (void*)arg);
+  tt_assert(tls->negotiated_callback == example_cb);
+  tt_assert(tls->callback_arg == arg);
+  tt_assert(!tls->got_renegotiate);
+
+  /* Assumes V2_HANDSHAKE_SERVER */
+  tt_assert(tls->ssl->info_callback == tor_tls_server_info_callback);
+
+  tor_tls_set_renegotiate_callback(tls, NULL, (void*)arg);
+  tt_assert(tls->ssl->info_callback == tor_tls_debug_state_callback);
+
+ done:
+  tor_free(tls->ssl);
+  tor_free(tls);
+}
+#endif
+
+#ifndef OPENSSL_OPAQUE
+static SSL_CIPHER *fixed_cipher1 = NULL;
+static SSL_CIPHER *fixed_cipher2 = NULL;
+static const SSL_CIPHER *
+fake_get_cipher(unsigned ncipher)
+{
+
+  switch (ncipher) {
+  case 1:
+    return fixed_cipher1;
+  case 2:
+    return fixed_cipher2;
+  default:
+    return NULL;
+  }
+}
+#endif
+
+#ifndef OPENSSL_OPAQUE
+static void
+test_tortls_find_cipher_by_id(void *ignored)
+{
+  (void)ignored;
+  int ret;
+  SSL *ssl;
+  SSL_CTX *ctx;
+  const SSL_METHOD *m = TLSv1_method();
+  SSL_METHOD *empty_method = tor_malloc_zero(sizeof(SSL_METHOD));
+
+  fixed_cipher1 = tor_malloc_zero(sizeof(SSL_CIPHER));
+  fixed_cipher2 = tor_malloc_zero(sizeof(SSL_CIPHER));
+  fixed_cipher2->id = 0xC00A;
+
+  SSL_library_init();
+  SSL_load_error_strings();
+
+  ctx = SSL_CTX_new(m);
+  ssl = SSL_new(ctx);
+
+  ret = find_cipher_by_id(ssl, NULL, 0xC00A);
+  tt_int_op(ret, OP_EQ, 1);
+
+  ret = find_cipher_by_id(ssl, m, 0xC00A);
+  tt_int_op(ret, OP_EQ, 1);
+
+  ret = find_cipher_by_id(ssl, m, 0xFFFF);
+  tt_int_op(ret, OP_EQ, 0);
+
+  ret = find_cipher_by_id(ssl, empty_method, 0xC00A);
+  tt_int_op(ret, OP_EQ, 1);
+
+  ret = find_cipher_by_id(ssl, empty_method, 0xFFFF);
+#ifdef HAVE_SSL_CIPHER_FIND
+  tt_int_op(ret, OP_EQ, 0);
+#else
+  tt_int_op(ret, OP_EQ, 1);
+#endif
+
+  empty_method->get_cipher = fake_get_cipher;
+  ret = find_cipher_by_id(ssl, empty_method, 0xC00A);
+  tt_int_op(ret, OP_EQ, 1);
+
+  empty_method->get_cipher = m->get_cipher;
+  empty_method->num_ciphers = m->num_ciphers;
+  ret = find_cipher_by_id(ssl, empty_method, 0xC00A);
+  tt_int_op(ret, OP_EQ, 1);
+
+  empty_method->get_cipher = fake_get_cipher;
+  empty_method->num_ciphers = m->num_ciphers;
+  ret = find_cipher_by_id(ssl, empty_method, 0xC00A);
+  tt_int_op(ret, OP_EQ, 1);
+
+  empty_method->num_ciphers = fake_num_ciphers;
+  ret = find_cipher_by_id(ssl, empty_method, 0xC00A);
+#ifdef HAVE_SSL_CIPHER_FIND
+  tt_int_op(ret, OP_EQ, 1);
+#else
+  tt_int_op(ret, OP_EQ, 0);
+#endif
+
+ done:
+  tor_free(empty_method);
+  SSL_free(ssl);
+  SSL_CTX_free(ctx);
+  tor_free(fixed_cipher1);
+}
+#endif
+
+#ifndef OPENSSL_OPAQUE
+static void
+test_tortls_debug_state_callback(void *ignored)
+{
+  (void)ignored;
+  SSL *ssl;
+  char *buf = tor_malloc_zero(1000);
+  int n;
+
+  int previous_log = setup_capture_of_logs(LOG_DEBUG);
+
+  ssl = tor_malloc_zero(sizeof(SSL));
+
+  tor_tls_debug_state_callback(ssl, 32, 45);
+
+  n = tor_snprintf(buf, 1000, "SSL %p is now in state unknown"
+               " state [type=32,val=45].\n", ssl);
+  /* tor's snprintf returns -1 on error */
+  tt_int_op(n, OP_NE, -1);
+  expect_log_msg(buf);
+
+ done:
+  teardown_capture_of_logs(previous_log);
+  tor_free(buf);
+  tor_free(ssl);
+}
+#endif
+
+#ifndef OPENSSL_OPAQUE
+static void
+test_tortls_server_info_callback(void *ignored)
+{
+  (void)ignored;
+  tor_tls_t *tls;
+  SSL_CTX *ctx;
+  SSL *ssl;
+  int previous_log = setup_capture_of_logs(LOG_WARN);
+
+  SSL_library_init();
+  SSL_load_error_strings();
+
+  ctx = SSL_CTX_new(TLSv1_method());
+  ssl = SSL_new(ctx);
+
+  tor_tls_allocate_tor_tls_object_ex_data_index();
+
+  tls = tor_malloc_zero(sizeof(tor_tls_t));
+  tls->magic = TOR_TLS_MAGIC;
+  tls->ssl = ssl;
+
+  tor_tls_server_info_callback(NULL, 0, 0);
+
+  SSL_set_state(ssl, SSL3_ST_SW_SRVR_HELLO_A);
+  mock_clean_saved_logs();
+  tor_tls_server_info_callback(ssl, SSL_CB_ACCEPT_LOOP, 0);
+  expect_log_msg("Couldn't look up the tls for an SSL*. How odd!\n");
+
+  SSL_set_state(ssl, SSL3_ST_SW_SRVR_HELLO_B);
+  mock_clean_saved_logs();
+  tor_tls_server_info_callback(ssl, SSL_CB_ACCEPT_LOOP, 0);
+  expect_log_msg("Couldn't look up the tls for an SSL*. How odd!\n");
+
+  SSL_set_state(ssl, 99);
+  mock_clean_saved_logs();
+  tor_tls_server_info_callback(ssl, SSL_CB_ACCEPT_LOOP, 0);
+  expect_no_log_entry();
+
+  SSL_set_ex_data(tls->ssl, tor_tls_object_ex_data_index, tls);
+  SSL_set_state(ssl, SSL3_ST_SW_SRVR_HELLO_B);
+  tls->negotiated_callback = 0;
+  tls->server_handshake_count = 120;
+  tor_tls_server_info_callback(ssl, SSL_CB_ACCEPT_LOOP, 0);
+  tt_int_op(tls->server_handshake_count, OP_EQ, 121);
+
+  tls->server_handshake_count = 127;
+  tls->negotiated_callback = (void *)1;
+  tor_tls_server_info_callback(ssl, SSL_CB_ACCEPT_LOOP, 0);
+  tt_int_op(tls->server_handshake_count, OP_EQ, 127);
+  tt_int_op(tls->got_renegotiate, OP_EQ, 1);
+
+  tls->ssl->session = SSL_SESSION_new();
+  tls->wasV2Handshake = 0;
+  tor_tls_server_info_callback(ssl, SSL_CB_ACCEPT_LOOP, 0);
+  tt_int_op(tls->wasV2Handshake, OP_EQ, 0);
+
+ done:
+  teardown_capture_of_logs(previous_log);
+  SSL_free(ssl);
+  SSL_CTX_free(ctx);
+  tor_free(tls);
+}
+#endif
+
+#ifndef OPENSSL_OPAQUE
+static int fixed_ssl_read_result_index;
+static int fixed_ssl_read_result[5];
+static int fixed_ssl_shutdown_result;
+
+static int
+fixed_ssl_read(SSL *s, void *buf, int len)
+{
+  (void)s;
+  (void)buf;
+  (void)len;
+  return fixed_ssl_read_result[fixed_ssl_read_result_index++];
+}
+
+static int
+fixed_ssl_shutdown(SSL *s)
+{
+  (void)s;
+  return fixed_ssl_shutdown_result;
+}
+
+#ifndef LIBRESSL_VERSION_NUMBER
+static int fixed_ssl_state_to_set;
+static tor_tls_t *fixed_tls;
+
+static int
+setting_version_ssl_shutdown(SSL *s)
+{
+  s->version = SSL2_VERSION;
+  return fixed_ssl_shutdown_result;
+}
+
+static int
+setting_version_and_state_ssl_shutdown(SSL *s)
+{
+  fixed_tls->state = fixed_ssl_state_to_set;
+  s->version = SSL2_VERSION;
+  return fixed_ssl_shutdown_result;
+}
+#endif
+
+static int
+dummy_handshake_func(SSL *s)
+{
+  (void)s;
+  return 1;
+}
+
+static void
+test_tortls_shutdown(void *ignored)
+{
+  (void)ignored;
+  int ret;
+  tor_tls_t *tls;
+  SSL_METHOD *method = give_me_a_test_method();
+  int previous_log = setup_capture_of_logs(LOG_WARN);
+
+  tls = tor_malloc_zero(sizeof(tor_tls_t));
+  tls->ssl = tor_malloc_zero(sizeof(SSL));
+  tls->ssl->method = method;
+  method->ssl_read = fixed_ssl_read;
+  method->ssl_shutdown = fixed_ssl_shutdown;
+
+  ret = tor_tls_shutdown(tls);
+  tt_int_op(ret, OP_EQ, -9);
+
+  tls->state = TOR_TLS_ST_SENTCLOSE;
+  fixed_ssl_read_result_index = 0;
+  fixed_ssl_read_result[0] = 10;
+  fixed_ssl_read_result[1] = -1;
+  ret = tor_tls_shutdown(tls);
+  tt_int_op(ret, OP_EQ, -9);
+
+#ifndef LIBRESSL_VERSION_NUMBER
+  tls->ssl->handshake_func = dummy_handshake_func;
+
+  fixed_ssl_read_result_index = 0;
+  fixed_ssl_read_result[0] = 10;
+  fixed_ssl_read_result[1] = 42;
+  fixed_ssl_read_result[2] = 0;
+  fixed_ssl_shutdown_result = 1;
+  ERR_clear_error();
+  tls->ssl->version = SSL2_VERSION;
+  ret = tor_tls_shutdown(tls);
+  tt_int_op(ret, OP_EQ, TOR_TLS_DONE);
+  tt_int_op(tls->state, OP_EQ, TOR_TLS_ST_CLOSED);
+
+  fixed_ssl_read_result_index = 0;
+  fixed_ssl_read_result[0] = 10;
+  fixed_ssl_read_result[1] = 42;
+  fixed_ssl_read_result[2] = 0;
+  fixed_ssl_shutdown_result = 0;
+  ERR_clear_error();
+  tls->ssl->version = 0;
+  ret = tor_tls_shutdown(tls);
+  tt_int_op(ret, OP_EQ, TOR_TLS_DONE);
+  tt_int_op(tls->state, OP_EQ, TOR_TLS_ST_CLOSED);
+
+  fixed_ssl_read_result_index = 0;
+  fixed_ssl_read_result[0] = 10;
+  fixed_ssl_read_result[1] = 42;
+  fixed_ssl_read_result[2] = 0;
+  fixed_ssl_shutdown_result = 0;
+  ERR_clear_error();
+  tls->ssl->version = 0;
+  method->ssl_shutdown = setting_version_ssl_shutdown;
+  ret = tor_tls_shutdown(tls);
+  tt_int_op(ret, OP_EQ, TOR_TLS_ERROR_MISC);
+
+  fixed_ssl_read_result_index = 0;
+  fixed_ssl_read_result[0] = 10;
+  fixed_ssl_read_result[1] = 42;
+  fixed_ssl_read_result[2] = 0;
+  fixed_ssl_shutdown_result = 0;
+  fixed_tls = tls;
+  fixed_ssl_state_to_set = TOR_TLS_ST_GOTCLOSE;
+  ERR_clear_error();
+  tls->ssl->version = 0;
+  method->ssl_shutdown = setting_version_and_state_ssl_shutdown;
+  ret = tor_tls_shutdown(tls);
+  tt_int_op(ret, OP_EQ, TOR_TLS_ERROR_MISC);
+
+  fixed_ssl_read_result_index = 0;
+  fixed_ssl_read_result[0] = 10;
+  fixed_ssl_read_result[1] = 42;
+  fixed_ssl_read_result[2] = 0;
+  fixed_ssl_read_result[3] = -1;
+  fixed_ssl_shutdown_result = 0;
+  fixed_tls = tls;
+  fixed_ssl_state_to_set = 0;
+  ERR_clear_error();
+  tls->ssl->version = 0;
+  method->ssl_shutdown = setting_version_and_state_ssl_shutdown;
+  ret = tor_tls_shutdown(tls);
+  tt_int_op(ret, OP_EQ, TOR_TLS_ERROR_MISC);
+#endif
+
+ done:
+  teardown_capture_of_logs(previous_log);
+  tor_free(method);
+  tor_free(tls->ssl);
+  tor_free(tls);
+}
+
+static int negotiated_callback_called;
+
+static void
+negotiated_callback_setter(tor_tls_t *t, void *arg)
+{
+  (void)t;
+  (void)arg;
+  negotiated_callback_called++;
+}
+
+static void
+test_tortls_read(void *ignored)
+{
+  (void)ignored;
+  int ret;
+  tor_tls_t *tls;
+  char buf[100];
+  SSL_METHOD *method = give_me_a_test_method();
+  int previous_log = setup_capture_of_logs(LOG_WARN);
+
+  tls = tor_malloc_zero(sizeof(tor_tls_t));
+  tls->ssl = tor_malloc_zero(sizeof(SSL));
+  tls->state = TOR_TLS_ST_OPEN;
+
+  ret = tor_tls_read(tls, buf, 10);
+  tt_int_op(ret, OP_EQ, -9);
+
+  /* These tests assume that V2_HANDSHAKE_SERVER is set */
+  tls->ssl->handshake_func = dummy_handshake_func;
+  tls->ssl->method = method;
+  method->ssl_read = fixed_ssl_read;
+  fixed_ssl_read_result_index = 0;
+  fixed_ssl_read_result[0] = 42;
+  tls->state = TOR_TLS_ST_OPEN;
+  ERR_clear_error();
+  ret = tor_tls_read(tls, buf, 10);
+  tt_int_op(ret, OP_EQ, 42);
+
+  tls->state = TOR_TLS_ST_OPEN;
+  tls->got_renegotiate = 1;
+  fixed_ssl_read_result_index = 0;
+  ERR_clear_error();
+  ret = tor_tls_read(tls, buf, 10);
+  tt_int_op(tls->got_renegotiate, OP_EQ, 0);
+
+  tls->state = TOR_TLS_ST_OPEN;
+  tls->got_renegotiate = 1;
+  negotiated_callback_called = 0;
+  tls->negotiated_callback = negotiated_callback_setter;
+  fixed_ssl_read_result_index = 0;
+  ERR_clear_error();
+  ret = tor_tls_read(tls, buf, 10);
+  tt_int_op(negotiated_callback_called, OP_EQ, 1);
+
+#ifndef LIBRESSL_VERSION_NUMBER
+  fixed_ssl_read_result_index = 0;
+  fixed_ssl_read_result[0] = 0;
+  tls->ssl->version = SSL2_VERSION;
+  ERR_clear_error();
+  ret = tor_tls_read(tls, buf, 10);
+  tt_int_op(ret, OP_EQ, TOR_TLS_CLOSE);
+  tt_int_op(tls->state, OP_EQ, TOR_TLS_ST_CLOSED);
+#endif
+  // TODO: fill up
+
+ done:
+  teardown_capture_of_logs(previous_log);
+  tor_free(tls->ssl);
+  tor_free(tls);
+  tor_free(method);
+}
+
+static int fixed_ssl_write_result;
+
+static int
+fixed_ssl_write(SSL *s, const void *buf, int len)
+{
+  (void)s;
+  (void)buf;
+  (void)len;
+  return fixed_ssl_write_result;
+}
+
+static void
+test_tortls_write(void *ignored)
+{
+  (void)ignored;
+  int ret;
+  tor_tls_t *tls;
+  SSL_METHOD *method = give_me_a_test_method();
+  char buf[100];
+  int previous_log = setup_capture_of_logs(LOG_WARN);
+
+  tls = tor_malloc_zero(sizeof(tor_tls_t));
+  tls->ssl = tor_malloc_zero(sizeof(SSL));
+  tls->state = TOR_TLS_ST_OPEN;
+
+  ret = tor_tls_write(tls, buf, 0);
+  tt_int_op(ret, OP_EQ, 0);
+
+  ret = tor_tls_write(tls, buf, 10);
+  tt_int_op(ret, OP_EQ, -9);
+
+  tls->ssl->method = method;
+  tls->wantwrite_n = 1;
+  ret = tor_tls_write(tls, buf, 10);
+  tt_int_op(tls->wantwrite_n, OP_EQ, 0);
+
+  method->ssl_write = fixed_ssl_write;
+  tls->ssl->handshake_func = dummy_handshake_func;
+  fixed_ssl_write_result = 1;
+  ERR_clear_error();
+  ret = tor_tls_write(tls, buf, 10);
+  tt_int_op(ret, OP_EQ, 1);
+
+  fixed_ssl_write_result = -1;
+  ERR_clear_error();
+  tls->ssl->rwstate = SSL_READING;
+  SSL_set_bio(tls->ssl, BIO_new(BIO_s_mem()), NULL);
+  SSL_get_rbio(tls->ssl)->flags = BIO_FLAGS_READ;
+  ret = tor_tls_write(tls, buf, 10);
+  tt_int_op(ret, OP_EQ, TOR_TLS_WANTREAD);
+
+  ERR_clear_error();
+  tls->ssl->rwstate = SSL_READING;
+  SSL_set_bio(tls->ssl, BIO_new(BIO_s_mem()), NULL);
+  SSL_get_rbio(tls->ssl)->flags = BIO_FLAGS_WRITE;
+  ret = tor_tls_write(tls, buf, 10);
+  tt_int_op(ret, OP_EQ, TOR_TLS_WANTWRITE);
+
+ done:
+  teardown_capture_of_logs(previous_log);
+  BIO_free(tls->ssl->rbio);
+  tor_free(tls->ssl);
+  tor_free(tls);
+  tor_free(method);
+}
+#endif
+
+#ifndef OPENSSL_OPAQUE
+static int fixed_ssl_accept_result;
+static int fixed_ssl_connect_result;
+
+static int
+setting_error_ssl_accept(SSL *ssl)
+{
+  (void)ssl;
+  ERR_put_error(ERR_LIB_BN, 2, -1, "somewhere.c", 99);
+  ERR_put_error(ERR_LIB_SYS, 2, -1, "somewhere.c", 99);
+  return fixed_ssl_accept_result;
+}
+
+static int
+setting_error_ssl_connect(SSL *ssl)
+{
+  (void)ssl;
+  ERR_put_error(ERR_LIB_BN, 2, -1, "somewhere.c", 99);
+  ERR_put_error(ERR_LIB_SYS, 2, -1, "somewhere.c", 99);
+  return fixed_ssl_connect_result;
+}
+
+static int
+fixed_ssl_accept(SSL *ssl)
+{
+  (void) ssl;
+  return fixed_ssl_accept_result;
+}
+
+static void
+test_tortls_handshake(void *ignored)
+{
+  (void)ignored;
+  int ret;
+  tor_tls_t *tls;
+  SSL_CTX *ctx;
+  SSL_METHOD *method = give_me_a_test_method();
+  int previous_log = setup_capture_of_logs(LOG_INFO);
+
+  SSL_library_init();
+  SSL_load_error_strings();
+
+  ctx = SSL_CTX_new(TLSv1_method());
+
+  tls = tor_malloc_zero(sizeof(tor_tls_t));
+  tls->ssl = SSL_new(ctx);
+  tls->state = TOR_TLS_ST_HANDSHAKE;
+
+  ret = tor_tls_handshake(tls);
+  tt_int_op(ret, OP_EQ, -9);
+
+  tls->isServer = 1;
+  tls->state = TOR_TLS_ST_HANDSHAKE;
+  ret = tor_tls_handshake(tls);
+  tt_int_op(ret, OP_EQ, -9);
+
+  tls->ssl->method = method;
+  method->ssl_accept = fixed_ssl_accept;
+  fixed_ssl_accept_result = 2;
+  ERR_clear_error();
+  tls->state = TOR_TLS_ST_HANDSHAKE;
+  ret = tor_tls_handshake(tls);
+  tt_int_op(tls->state, OP_EQ, TOR_TLS_ST_OPEN);
+
+  method->ssl_accept = setting_error_ssl_accept;
+  fixed_ssl_accept_result = 1;
+  ERR_clear_error();
+  mock_clean_saved_logs();
+  tls->state = TOR_TLS_ST_HANDSHAKE;
+  ret = tor_tls_handshake(tls);
+  tt_int_op(ret, OP_EQ, TOR_TLS_ERROR_MISC);
+  expect_log_entry();
+  /* This fails on jessie.  Investigate why! */
+#if 0
+  expect_log_msg("TLS error while handshaking: (null) (in bignum routines:"
+            "(null):SSLv3 write client hello B)\n");
+  expect_log_msg("TLS error while handshaking: (null) (in system library:"
+            "connect:SSLv3 write client hello B)\n");
+#endif
+  expect_log_severity(LOG_INFO);
+
+  tls->isServer = 0;
+  method->ssl_connect = setting_error_ssl_connect;
+  fixed_ssl_connect_result = 1;
+  ERR_clear_error();
+  mock_clean_saved_logs();
+  tls->state = TOR_TLS_ST_HANDSHAKE;
+  ret = tor_tls_handshake(tls);
+  tt_int_op(ret, OP_EQ, TOR_TLS_ERROR_MISC);
+  expect_log_entry();
+#if 0
+  /* See above */
+  expect_log_msg("TLS error while handshaking: "
+            "(null) (in bignum routines:(null):SSLv3 write client hello B)\n");
+  expect_log_msg("TLS error while handshaking: "
+            "(null) (in system library:connect:SSLv3 write client hello B)\n");
+#endif
+  expect_log_severity(LOG_WARN);
+
+ done:
+  teardown_capture_of_logs(previous_log);
+  SSL_free(tls->ssl);
+  SSL_CTX_free(ctx);
+  tor_free(tls);
+  tor_free(method);
+}
+#endif
+
+#ifndef OPENSSL_OPAQUE
+static void
+test_tortls_finish_handshake(void *ignored)
+{
+  (void)ignored;
+  int ret;
+  tor_tls_t *tls;
+  SSL_CTX *ctx;
+  SSL_METHOD *method = give_me_a_test_method();
+  SSL_library_init();
+  SSL_load_error_strings();
+
+  X509 *c1 = read_cert_from(validCertString);
+  SESS_CERT_local *sess = NULL;
+
+  ctx = SSL_CTX_new(method);
+
+  tls = tor_malloc_zero(sizeof(tor_tls_t));
+  tls->ssl = SSL_new(ctx);
+  tls->state = TOR_TLS_ST_OPEN;
+
+  ret = tor_tls_finish_handshake(tls);
+  tt_int_op(ret, OP_EQ, 0);
+
+  tls->isServer = 1;
+  tls->wasV2Handshake = 0;
+  ret = tor_tls_finish_handshake(tls);
+  tt_int_op(ret, OP_EQ, 0);
+  tt_int_op(tls->wasV2Handshake, OP_EQ, 1);
+
+  tls->wasV2Handshake = 1;
+  ret = tor_tls_finish_handshake(tls);
+  tt_int_op(ret, OP_EQ, 0);
+  tt_int_op(tls->wasV2Handshake, OP_EQ, 1);
+
+  tls->wasV2Handshake = 1;
+  tls->ssl->session = SSL_SESSION_new();
+  ret = tor_tls_finish_handshake(tls);
+  tt_int_op(ret, OP_EQ, 0);
+  tt_int_op(tls->wasV2Handshake, OP_EQ, 0);
+
+  tls->isServer = 0;
+
+  sess = tor_malloc_zero(sizeof(SESS_CERT_local));
+  tls->ssl->session->sess_cert = (void *)sess;
+  sess->cert_chain = sk_X509_new_null();
+  sk_X509_push(sess->cert_chain, c1);
+  tls->ssl->session->peer = c1;
+  tls->wasV2Handshake = 0;
+  ret = tor_tls_finish_handshake(tls);
+  tt_int_op(ret, OP_EQ, 0);
+  tt_int_op(tls->wasV2Handshake, OP_EQ, 1);
+
+  method->num_ciphers = fake_num_ciphers;
+  ret = tor_tls_finish_handshake(tls);
+  tt_int_op(ret, OP_EQ, -9);
+
+ done:
+  if (sess)
+    sk_X509_free(sess->cert_chain);
+  if (tls->ssl && tls->ssl->session) {
+    tor_free(tls->ssl->session->sess_cert);
+  }
+  SSL_free(tls->ssl);
+  tor_free(tls);
+  SSL_CTX_free(ctx);
+  tor_free(method);
+}
+#endif
+
+static int fixed_crypto_pk_new_result_index;
+static crypto_pk_t *fixed_crypto_pk_new_result[5];
+
+static crypto_pk_t *
+fixed_crypto_pk_new(void)
+{
+  return fixed_crypto_pk_new_result[fixed_crypto_pk_new_result_index++];
+}
+
+#ifndef OPENSSL_OPAQUE
+static int fixed_crypto_pk_generate_key_with_bits_result_index;
+static int fixed_crypto_pk_generate_key_with_bits_result[5];
+static int fixed_tor_tls_create_certificate_result_index;
+static X509 *fixed_tor_tls_create_certificate_result[5];
+static int fixed_tor_x509_cert_new_result_index;
+static tor_x509_cert_t *fixed_tor_x509_cert_new_result[5];
+
+static int
+fixed_crypto_pk_generate_key_with_bits(crypto_pk_t *env, int bits)
+{
+  (void)env;
+  (void)bits;
+  return fixed_crypto_pk_generate_key_with_bits_result[
+                    fixed_crypto_pk_generate_key_with_bits_result_index++];
+}
+
+static X509 *
+fixed_tor_tls_create_certificate(crypto_pk_t *rsa,
+                                 crypto_pk_t *rsa_sign,
+                                 const char *cname,
+                                 const char *cname_sign,
+                                 unsigned int cert_lifetime)
+{
+  (void)rsa;
+  (void)rsa_sign;
+  (void)cname;
+  (void)cname_sign;
+  (void)cert_lifetime;
+  return fixed_tor_tls_create_certificate_result[
+                             fixed_tor_tls_create_certificate_result_index++];
+}
+
+static tor_x509_cert_t *
+fixed_tor_x509_cert_new(X509 *x509_cert)
+{
+  (void) x509_cert;
+  return fixed_tor_x509_cert_new_result[
+                                      fixed_tor_x509_cert_new_result_index++];
+}
+
+static void
+test_tortls_context_new(void *ignored)
+{
+  (void)ignored;
+  tor_tls_context_t *ret;
+  crypto_pk_t *pk1, *pk2, *pk3, *pk4, *pk5, *pk6, *pk7, *pk8, *pk9, *pk10,
+    *pk11, *pk12, *pk13, *pk14, *pk15, *pk16, *pk17, *pk18;
+
+  pk1 = crypto_pk_new();
+  pk2 = crypto_pk_new();
+  pk3 = crypto_pk_new();
+  pk4 = crypto_pk_new();
+  pk5 = crypto_pk_new();
+  pk6 = crypto_pk_new();
+  pk7 = crypto_pk_new();
+  pk8 = crypto_pk_new();
+  pk9 = crypto_pk_new();
+  pk10 = crypto_pk_new();
+  pk11 = crypto_pk_new();
+  pk12 = crypto_pk_new();
+  pk13 = crypto_pk_new();
+  pk14 = crypto_pk_new();
+  pk15 = crypto_pk_new();
+  pk16 = crypto_pk_new();
+  pk17 = crypto_pk_new();
+  pk18 = crypto_pk_new();
+
+  fixed_crypto_pk_new_result_index = 0;
+  fixed_crypto_pk_new_result[0] = NULL;
+  MOCK(crypto_pk_new, fixed_crypto_pk_new);
+  ret = tor_tls_context_new(NULL, 0, 0, 0);
+  tt_assert(!ret);
+
+  MOCK(crypto_pk_generate_key_with_bits,
+       fixed_crypto_pk_generate_key_with_bits);
+  fixed_crypto_pk_new_result_index = 0;
+  fixed_crypto_pk_new_result[0] = pk1;
+  fixed_crypto_pk_new_result[1] = NULL;
+  fixed_crypto_pk_generate_key_with_bits_result[0] = -1;
+  fixed_crypto_pk_generate_key_with_bits_result_index = 0;
+  ret = tor_tls_context_new(NULL, 0, 0, 0);
+  tt_assert(!ret);
+
+  fixed_crypto_pk_new_result_index = 0;
+  fixed_crypto_pk_new_result[0] = pk2;
+  fixed_crypto_pk_new_result[1] = NULL;
+  fixed_crypto_pk_generate_key_with_bits_result[0] = 0;
+  fixed_crypto_pk_generate_key_with_bits_result_index = 0;
+  ret = tor_tls_context_new(NULL, 0, 0, 0);
+  tt_assert(!ret);
+
+  fixed_crypto_pk_new_result_index = 0;
+  fixed_crypto_pk_new_result[0] = pk3;
+  fixed_crypto_pk_new_result[1] = pk4;
+  fixed_crypto_pk_new_result[2] = NULL;
+  fixed_crypto_pk_generate_key_with_bits_result[0] = 0;
+  fixed_crypto_pk_generate_key_with_bits_result[1] = -1;
+  fixed_crypto_pk_generate_key_with_bits_result_index = 0;
+  ret = tor_tls_context_new(NULL, 0, 0, 0);
+  tt_assert(!ret);
+
+  MOCK(tor_tls_create_certificate, fixed_tor_tls_create_certificate);
+
+  fixed_crypto_pk_new_result_index = 0;
+  fixed_crypto_pk_new_result[0] = pk5;
+  fixed_crypto_pk_new_result[1] = pk6;
+  fixed_crypto_pk_new_result[2] = NULL;
+  fixed_crypto_pk_generate_key_with_bits_result_index = 0;
+  fixed_crypto_pk_generate_key_with_bits_result[1] = 0;
+  fixed_tor_tls_create_certificate_result_index = 0;
+  fixed_tor_tls_create_certificate_result[0] = NULL;
+  fixed_tor_tls_create_certificate_result[1] = tor_malloc_zero(sizeof(X509));
+  fixed_tor_tls_create_certificate_result[2] = tor_malloc_zero(sizeof(X509));
+  ret = tor_tls_context_new(NULL, 0, 0, 0);
+  tt_assert(!ret);
+
+  fixed_crypto_pk_new_result_index = 0;
+  fixed_crypto_pk_new_result[0] = pk7;
+  fixed_crypto_pk_new_result[1] = pk8;
+  fixed_crypto_pk_new_result[2] = NULL;
+  fixed_crypto_pk_generate_key_with_bits_result_index = 0;
+  fixed_tor_tls_create_certificate_result_index = 0;
+  fixed_tor_tls_create_certificate_result[0] = tor_malloc_zero(sizeof(X509));
+  fixed_tor_tls_create_certificate_result[1] = NULL;
+  fixed_tor_tls_create_certificate_result[2] = tor_malloc_zero(sizeof(X509));
+  ret = tor_tls_context_new(NULL, 0, 0, 0);
+  tt_assert(!ret);
+
+  fixed_crypto_pk_new_result_index = 0;
+  fixed_crypto_pk_new_result[0] = pk9;
+  fixed_crypto_pk_new_result[1] = pk10;
+  fixed_crypto_pk_new_result[2] = NULL;
+  fixed_crypto_pk_generate_key_with_bits_result_index = 0;
+  fixed_tor_tls_create_certificate_result_index = 0;
+  fixed_tor_tls_create_certificate_result[0] = tor_malloc_zero(sizeof(X509));
+  fixed_tor_tls_create_certificate_result[1] = tor_malloc_zero(sizeof(X509));
+  fixed_tor_tls_create_certificate_result[2] = NULL;
+  ret = tor_tls_context_new(NULL, 0, 0, 0);
+  tt_assert(!ret);
+
+  MOCK(tor_x509_cert_new, fixed_tor_x509_cert_new);
+  fixed_crypto_pk_new_result_index = 0;
+  fixed_crypto_pk_new_result[0] = pk11;
+  fixed_crypto_pk_new_result[1] = pk12;
+  fixed_crypto_pk_new_result[2] = NULL;
+  fixed_crypto_pk_generate_key_with_bits_result_index = 0;
+  fixed_tor_tls_create_certificate_result_index = 0;
+  fixed_tor_tls_create_certificate_result[0] = tor_malloc_zero(sizeof(X509));
+  fixed_tor_tls_create_certificate_result[1] = tor_malloc_zero(sizeof(X509));
+  fixed_tor_tls_create_certificate_result[2] = tor_malloc_zero(sizeof(X509));
+  fixed_tor_x509_cert_new_result_index = 0;
+  fixed_tor_x509_cert_new_result[0] = NULL;
+  fixed_tor_x509_cert_new_result[1] = NULL;
+  fixed_tor_x509_cert_new_result[2] = NULL;
+  ret = tor_tls_context_new(NULL, 0, 0, 0);
+  tt_assert(!ret);
+
+  fixed_crypto_pk_new_result_index = 0;
+  fixed_crypto_pk_new_result[0] = pk13;
+  fixed_crypto_pk_new_result[1] = pk14;
+  fixed_crypto_pk_new_result[2] = NULL;
+  fixed_crypto_pk_generate_key_with_bits_result_index = 0;
+  fixed_tor_tls_create_certificate_result_index = 0;
+  fixed_tor_tls_create_certificate_result[0] = tor_malloc_zero(sizeof(X509));
+  fixed_tor_tls_create_certificate_result[1] = tor_malloc_zero(sizeof(X509));
+  fixed_tor_tls_create_certificate_result[2] = tor_malloc_zero(sizeof(X509));
+  fixed_tor_x509_cert_new_result_index = 0;
+  fixed_tor_x509_cert_new_result[0] = tor_malloc_zero(sizeof(tor_x509_cert_t));
+  fixed_tor_x509_cert_new_result[1] = NULL;
+  fixed_tor_x509_cert_new_result[2] = NULL;
+  ret = tor_tls_context_new(NULL, 0, 0, 0);
+  tt_assert(!ret);
+
+  fixed_crypto_pk_new_result_index = 0;
+  fixed_crypto_pk_new_result[0] = pk15;
+  fixed_crypto_pk_new_result[1] = pk16;
+  fixed_crypto_pk_new_result[2] = NULL;
+  fixed_crypto_pk_generate_key_with_bits_result_index = 0;
+  fixed_tor_tls_create_certificate_result_index = 0;
+  fixed_tor_tls_create_certificate_result[0] = tor_malloc_zero(sizeof(X509));
+  fixed_tor_tls_create_certificate_result[1] = tor_malloc_zero(sizeof(X509));
+  fixed_tor_tls_create_certificate_result[2] = tor_malloc_zero(sizeof(X509));
+  fixed_tor_x509_cert_new_result_index = 0;
+  fixed_tor_x509_cert_new_result[0] = tor_malloc_zero(sizeof(tor_x509_cert_t));
+  fixed_tor_x509_cert_new_result[1] = tor_malloc_zero(sizeof(tor_x509_cert_t));
+  fixed_tor_x509_cert_new_result[2] = NULL;
+  ret = tor_tls_context_new(NULL, 0, 0, 0);
+  tt_assert(!ret);
+
+  fixed_crypto_pk_new_result_index = 0;
+  fixed_crypto_pk_new_result[0] = pk17;
+  fixed_crypto_pk_new_result[1] = pk18;
+  fixed_crypto_pk_new_result[2] = NULL;
+  fixed_crypto_pk_generate_key_with_bits_result_index = 0;
+  fixed_tor_tls_create_certificate_result_index = 0;
+  fixed_tor_tls_create_certificate_result[0] = tor_malloc_zero(sizeof(X509));
+  fixed_tor_tls_create_certificate_result[1] = tor_malloc_zero(sizeof(X509));
+  fixed_tor_tls_create_certificate_result[2] = tor_malloc_zero(sizeof(X509));
+  fixed_tor_x509_cert_new_result_index = 0;
+  fixed_tor_x509_cert_new_result[0] = tor_malloc_zero(sizeof(tor_x509_cert_t));
+  fixed_tor_x509_cert_new_result[1] = tor_malloc_zero(sizeof(tor_x509_cert_t));
+  fixed_tor_x509_cert_new_result[2] = tor_malloc_zero(sizeof(tor_x509_cert_t));
+  ret = tor_tls_context_new(NULL, 0, 0, 0);
+  tt_assert(!ret);
+
+ done:
+  UNMOCK(tor_x509_cert_new);
+  UNMOCK(tor_tls_create_certificate);
+  UNMOCK(crypto_pk_generate_key_with_bits);
+  UNMOCK(crypto_pk_new);
+}
+#endif
+
+static int fixed_crypto_pk_get_evp_pkey_result_index = 0;
+static EVP_PKEY *fixed_crypto_pk_get_evp_pkey_result[5];
+
+static EVP_PKEY *
+fixed_crypto_pk_get_evp_pkey_(crypto_pk_t *env, int private)
+{
+  (void) env;
+  (void) private;
+  return fixed_crypto_pk_get_evp_pkey_result[
+                               fixed_crypto_pk_get_evp_pkey_result_index++];
+}
+
+static void
+test_tortls_create_certificate(void *ignored)
+{
+  (void)ignored;
+  X509 *ret;
+  crypto_pk_t *pk1, *pk2;
+
+  pk1 = crypto_pk_new();
+  pk2 = crypto_pk_new();
+
+  MOCK(crypto_pk_get_evp_pkey_, fixed_crypto_pk_get_evp_pkey_);
+  fixed_crypto_pk_get_evp_pkey_result_index = 0;
+  fixed_crypto_pk_get_evp_pkey_result[0] = NULL;
+  ret = tor_tls_create_certificate(pk1, pk2, "hello", "hello2", 1);
+  tt_assert(!ret);
+
+  fixed_crypto_pk_get_evp_pkey_result_index = 0;
+  fixed_crypto_pk_get_evp_pkey_result[0] = EVP_PKEY_new();
+  fixed_crypto_pk_get_evp_pkey_result[1] = NULL;
+  ret = tor_tls_create_certificate(pk1, pk2, "hello", "hello2", 1);
+  tt_assert(!ret);
+
+  fixed_crypto_pk_get_evp_pkey_result_index = 0;
+  fixed_crypto_pk_get_evp_pkey_result[0] = EVP_PKEY_new();
+  fixed_crypto_pk_get_evp_pkey_result[1] = EVP_PKEY_new();
+  ret = tor_tls_create_certificate(pk1, pk2, "hello", "hello2", 1);
+  tt_assert(!ret);
+
+ done:
+  UNMOCK(crypto_pk_get_evp_pkey_);
+  crypto_pk_free(pk1);
+  crypto_pk_free(pk2);
+}
+
+static void
+test_tortls_cert_new(void *ignored)
+{
+  (void)ignored;
+  tor_x509_cert_t *ret;
+  X509 *cert = read_cert_from(validCertString);
+
+  ret = tor_x509_cert_new(NULL);
+  tt_assert(!ret);
+
+  ret = tor_x509_cert_new(cert);
+  tt_assert(ret);
+  tor_x509_cert_free(ret);
+  ret = NULL;
+
+#if 0
+  cert = read_cert_from(validCertString);
+  /* XXX this doesn't do what you think: it alters a copy of the pubkey. */
+  X509_get_pubkey(cert)->type = EVP_PKEY_DSA;
+  ret = tor_x509_cert_new(cert);
+  tt_assert(ret);
+#endif
+
+#ifndef OPENSSL_OPAQUE
+  cert = read_cert_from(validCertString);
+  X509_CINF_free(cert->cert_info);
+  cert->cert_info = NULL;
+  ret = tor_x509_cert_new(cert);
+  tt_assert(ret);
+#endif
+
+ done:
+  tor_x509_cert_free(ret);
+}
+
+static void
+test_tortls_cert_is_valid(void *ignored)
+{
+  (void)ignored;
+  int ret;
+  tor_x509_cert_t *cert = NULL, *scert = NULL;
+
+  scert = tor_malloc_zero(sizeof(tor_x509_cert_t));
+  ret = tor_tls_cert_is_valid(LOG_WARN, cert, scert, 0);
+  tt_int_op(ret, OP_EQ, 0);
+
+  cert = tor_malloc_zero(sizeof(tor_x509_cert_t));
+  ret = tor_tls_cert_is_valid(LOG_WARN, cert, scert, 0);
+  tt_int_op(ret, OP_EQ, 0);
+  tor_free(scert);
+  tor_free(cert);
+
+  cert = tor_x509_cert_new(read_cert_from(validCertString));
+  scert = tor_x509_cert_new(read_cert_from(caCertString));
+  ret = tor_tls_cert_is_valid(LOG_WARN, cert, scert, 0);
+  tt_int_op(ret, OP_EQ, 1);
+
+#ifndef OPENSSL_OPAQUE
+  tor_x509_cert_free(cert);
+  tor_x509_cert_free(scert);
+  cert = tor_x509_cert_new(read_cert_from(validCertString));
+  scert = tor_x509_cert_new(read_cert_from(caCertString));
+  ASN1_TIME_free(cert->cert->cert_info->validity->notAfter);
+  cert->cert->cert_info->validity->notAfter =
+    ASN1_TIME_set(NULL, time(NULL)-1000000);
+  ret = tor_tls_cert_is_valid(LOG_WARN, cert, scert, 0);
+  tt_int_op(ret, OP_EQ, 0);
+
+  tor_x509_cert_free(cert);
+  tor_x509_cert_free(scert);
+  cert = tor_x509_cert_new(read_cert_from(validCertString));
+  scert = tor_x509_cert_new(read_cert_from(caCertString));
+  X509_PUBKEY_free(cert->cert->cert_info->key);
+  cert->cert->cert_info->key = NULL;
+  ret = tor_tls_cert_is_valid(LOG_WARN, cert, scert, 1);
+  tt_int_op(ret, OP_EQ, 0);
+#endif
+
+#if 0
+  tor_x509_cert_free(cert);
+  tor_x509_cert_free(scert);
+  cert = tor_x509_cert_new(read_cert_from(validCertString));
+  scert = tor_x509_cert_new(read_cert_from(caCertString));
+  /* This doesn't actually change the key in the cert. XXXXXX */
+  BN_one(EVP_PKEY_get1_RSA(X509_get_pubkey(cert->cert))->n);
+  ret = tor_tls_cert_is_valid(LOG_WARN, cert, scert, 1);
+  tt_int_op(ret, OP_EQ, 0);
+
+  tor_x509_cert_free(cert);
+  tor_x509_cert_free(scert);
+  cert = tor_x509_cert_new(read_cert_from(validCertString));
+  scert = tor_x509_cert_new(read_cert_from(caCertString));
+  /* This doesn't actually change the key in the cert. XXXXXX */
+  X509_get_pubkey(cert->cert)->type = EVP_PKEY_EC;
+  ret = tor_tls_cert_is_valid(LOG_WARN, cert, scert, 1);
+  tt_int_op(ret, OP_EQ, 0);
+
+  tor_x509_cert_free(cert);
+  tor_x509_cert_free(scert);
+  cert = tor_x509_cert_new(read_cert_from(validCertString));
+  scert = tor_x509_cert_new(read_cert_from(caCertString));
+  /* This doesn't actually change the key in the cert. XXXXXX */
+  X509_get_pubkey(cert->cert)->type = EVP_PKEY_EC;
+  ret = tor_tls_cert_is_valid(LOG_WARN, cert, scert, 0);
+  tt_int_op(ret, OP_EQ, 1);
+
+  tor_x509_cert_free(cert);
+  tor_x509_cert_free(scert);
+  cert = tor_x509_cert_new(read_cert_from(validCertString));
+  scert = tor_x509_cert_new(read_cert_from(caCertString));
+  /* This doesn't actually change the key in the cert. XXXXXX */
+  X509_get_pubkey(cert->cert)->type = EVP_PKEY_EC;
+  X509_get_pubkey(cert->cert)->ameth = NULL;
+  ret = tor_tls_cert_is_valid(LOG_WARN, cert, scert, 0);
+  tt_int_op(ret, OP_EQ, 0);
+#endif
+
+ done:
+  tor_x509_cert_free(cert);
+  tor_x509_cert_free(scert);
+}
+
+static void
+test_tortls_context_init_one(void *ignored)
+{
+  (void)ignored;
+  int ret;
+  tor_tls_context_t *old = NULL;
+
+  MOCK(crypto_pk_new, fixed_crypto_pk_new);
+
+  fixed_crypto_pk_new_result_index = 0;
+  fixed_crypto_pk_new_result[0] = NULL;
+  ret = tor_tls_context_init_one(&old, NULL, 0, 0, 0);
+  tt_int_op(ret, OP_EQ, -1);
+
+ done:
+  UNMOCK(crypto_pk_new);
+}
+
+#define LOCAL_TEST_CASE(name, flags)                    \
+  { #name, test_tortls_##name, (flags|TT_FORK), NULL, NULL }
+
+#ifdef OPENSSL_OPAQUE
+#define INTRUSIVE_TEST_CASE(name, flags)        \
+  { #name, NULL, TT_SKIP, NULL, NULL }
+#else
+#define INTRUSIVE_TEST_CASE(name, flags) LOCAL_TEST_CASE(name, flags)
+#endif
+
+struct testcase_t tortls_tests[] = {
+  LOCAL_TEST_CASE(errno_to_tls_error, 0),
+  LOCAL_TEST_CASE(err_to_string, 0),
+  LOCAL_TEST_CASE(tor_tls_new, TT_FORK),
+  LOCAL_TEST_CASE(tor_tls_get_error, 0),
+  LOCAL_TEST_CASE(get_state_description, TT_FORK),
+  LOCAL_TEST_CASE(get_by_ssl, TT_FORK),
+  LOCAL_TEST_CASE(allocate_tor_tls_object_ex_data_index, TT_FORK),
+  LOCAL_TEST_CASE(log_one_error, TT_FORK),
+  INTRUSIVE_TEST_CASE(get_error, TT_FORK),
+  LOCAL_TEST_CASE(always_accept_verify_cb, 0),
+  INTRUSIVE_TEST_CASE(x509_cert_free, 0),
+  LOCAL_TEST_CASE(x509_cert_get_id_digests, 0),
+  INTRUSIVE_TEST_CASE(cert_matches_key, 0),
+  INTRUSIVE_TEST_CASE(cert_get_key, 0),
+  LOCAL_TEST_CASE(get_my_client_auth_key, TT_FORK),
+  LOCAL_TEST_CASE(get_my_certs, TT_FORK),
+  INTRUSIVE_TEST_CASE(get_ciphersuite_name, 0),
+  INTRUSIVE_TEST_CASE(classify_client_ciphers, 0),
+  LOCAL_TEST_CASE(client_is_using_v2_ciphers, 0),
+  INTRUSIVE_TEST_CASE(verify, 0),
+  INTRUSIVE_TEST_CASE(check_lifetime, 0),
+  INTRUSIVE_TEST_CASE(get_pending_bytes, 0),
+  LOCAL_TEST_CASE(get_forced_write_size, 0),
+  LOCAL_TEST_CASE(get_write_overhead_ratio, TT_FORK),
+  LOCAL_TEST_CASE(used_v1_handshake, TT_FORK),
+  LOCAL_TEST_CASE(get_num_server_handshakes, 0),
+  LOCAL_TEST_CASE(server_got_renegotiate, 0),
+  INTRUSIVE_TEST_CASE(SSL_SESSION_get_master_key, 0),
+  INTRUSIVE_TEST_CASE(get_tlssecrets, 0),
+  INTRUSIVE_TEST_CASE(get_buffer_sizes, 0),
+  LOCAL_TEST_CASE(evaluate_ecgroup_for_tls, 0),
+  INTRUSIVE_TEST_CASE(try_to_extract_certs_from_tls, 0),
+  INTRUSIVE_TEST_CASE(get_peer_cert, 0),
+  INTRUSIVE_TEST_CASE(peer_has_cert, 0),
+  INTRUSIVE_TEST_CASE(shutdown, 0),
+  INTRUSIVE_TEST_CASE(finish_handshake, 0),
+  INTRUSIVE_TEST_CASE(handshake, 0),
+  INTRUSIVE_TEST_CASE(write, 0),
+  INTRUSIVE_TEST_CASE(read, 0),
+  INTRUSIVE_TEST_CASE(server_info_callback, 0),
+  LOCAL_TEST_CASE(is_server, 0),
+  INTRUSIVE_TEST_CASE(assert_renegotiation_unblocked, 0),
+  INTRUSIVE_TEST_CASE(block_renegotiation, 0),
+  INTRUSIVE_TEST_CASE(unblock_renegotiation, 0),
+  INTRUSIVE_TEST_CASE(set_renegotiate_callback, 0),
+  LOCAL_TEST_CASE(set_logged_address, 0),
+  INTRUSIVE_TEST_CASE(find_cipher_by_id, 0),
+  INTRUSIVE_TEST_CASE(session_secret_cb, 0),
+  INTRUSIVE_TEST_CASE(debug_state_callback, 0),
+  INTRUSIVE_TEST_CASE(context_new, 0),
+  LOCAL_TEST_CASE(create_certificate, 0),
+  LOCAL_TEST_CASE(cert_new, 0),
+  LOCAL_TEST_CASE(cert_is_valid, 0),
+  LOCAL_TEST_CASE(context_init_one, 0),
+  END_OF_TESTCASES
+};
+
diff --git a/src/test/test_util.c b/src/test/test_util.c
index 0a5783e..37f7d93 100644
--- a/src/test/test_util.c
+++ b/src/test/test_util.c
@@ -14,11 +14,21 @@
 #include "memarea.h"
 #include "util_process.h"
 
+#ifdef HAVE_PWD_H
+#include <pwd.h>
+#endif
+#ifdef HAVE_SYS_UTIME_H
+#include <sys/utime.h>
+#endif
+#ifdef HAVE_UTIME_H
+#include <utime.h>
+#endif
 #ifdef _WIN32
 #include <tchar.h>
 #endif
 #include <math.h>
 #include <ctype.h>
+#include <float.h>
 
 /* XXXX this is a minimal wrapper to make the unit tests compile with the
  * changed tor_timegm interface. */
@@ -4097,6 +4107,9 @@ test_util_round_to_next_multiple_of(void *arg)
   tt_u64_op(round_uint64_to_next_multiple_of(99,7), ==, 105);
   tt_u64_op(round_uint64_to_next_multiple_of(99,9), ==, 99);
 
+  tt_u64_op(round_uint64_to_next_multiple_of(UINT64_MAX,2), ==,
+            UINT64_MAX);
+
   tt_i64_op(round_int64_to_next_multiple_of(0,1), ==, 0);
   tt_i64_op(round_int64_to_next_multiple_of(0,7), ==, 0);
 
@@ -4110,7 +4123,27 @@ test_util_round_to_next_multiple_of(void *arg)
 
   tt_i64_op(round_int64_to_next_multiple_of(INT64_MIN,2), ==, INT64_MIN);
   tt_i64_op(round_int64_to_next_multiple_of(INT64_MAX,2), ==,
-                                            INT64_MAX-INT64_MAX%2);
+                                            INT64_MAX);
+
+  tt_int_op(round_uint32_to_next_multiple_of(0,1), ==, 0);
+  tt_int_op(round_uint32_to_next_multiple_of(0,7), ==, 0);
+
+  tt_int_op(round_uint32_to_next_multiple_of(99,1), ==, 99);
+  tt_int_op(round_uint32_to_next_multiple_of(99,7), ==, 105);
+  tt_int_op(round_uint32_to_next_multiple_of(99,9), ==, 99);
+
+  tt_int_op(round_uint32_to_next_multiple_of(UINT32_MAX,2), ==,
+            UINT32_MAX);
+
+  tt_uint_op(round_to_next_multiple_of(0,1), ==, 0);
+  tt_uint_op(round_to_next_multiple_of(0,7), ==, 0);
+
+  tt_uint_op(round_to_next_multiple_of(99,1), ==, 99);
+  tt_uint_op(round_to_next_multiple_of(99,7), ==, 105);
+  tt_uint_op(round_to_next_multiple_of(99,9), ==, 99);
+
+  tt_uint_op(round_to_next_multiple_of(UINT_MAX,2), ==,
+            UINT_MAX);
  done:
   ;
 }
@@ -4143,6 +4176,7 @@ test_util_laplace(void *arg)
    */
   tt_i64_op(INT64_MIN + 20, ==,
             add_laplace_noise(20, 0.0, delta_f, epsilon));
+
   tt_i64_op(-60, ==, add_laplace_noise(20, 0.1, delta_f, epsilon));
   tt_i64_op(-14, ==, add_laplace_noise(20, 0.25, delta_f, epsilon));
   tt_i64_op(20, ==, add_laplace_noise(20, 0.5, delta_f, epsilon));
@@ -4150,15 +4184,146 @@ test_util_laplace(void *arg)
   tt_i64_op(100, ==, add_laplace_noise(20, 0.9, delta_f, epsilon));
   tt_i64_op(215, ==, add_laplace_noise(20, 0.99, delta_f, epsilon));
 
+  /* Test extreme values of signal with maximally negative values of noise
+   * 1.0000000000000002 is the smallest number > 1
+   * 0.0000000000000002 is the double epsilon (error when calculating near 1)
+   * this is approximately 1/(2^52)
+   * per https://en.wikipedia.org/wiki/Double_precision
+   * (let's not descend into the world of subnormals)
+   * >>> laplace.ppf([0, 0.0000000000000002], loc = 0, scale = 1)
+   * array([        -inf, -35.45506713])
+   */
+  const double noscale_df = 1.0, noscale_eps = 1.0;
+
+  tt_i64_op(INT64_MIN, ==,
+            add_laplace_noise(0, 0.0, noscale_df, noscale_eps));
+
+  /* is it clipped to INT64_MIN? */
+  tt_i64_op(INT64_MIN, ==,
+            add_laplace_noise(-1, 0.0, noscale_df, noscale_eps));
+  tt_i64_op(INT64_MIN, ==,
+            add_laplace_noise(INT64_MIN, 0.0,
+                              noscale_df, noscale_eps));
+  /* ... even when scaled? */
+  tt_i64_op(INT64_MIN, ==,
+            add_laplace_noise(0, 0.0, delta_f, epsilon));
+  tt_i64_op(INT64_MIN, ==,
+            add_laplace_noise(0, 0.0,
+                              DBL_MAX, 1));
+  tt_i64_op(INT64_MIN, ==,
+            add_laplace_noise(INT64_MIN, 0.0,
+                              DBL_MAX, 1));
+
+  /* does it play nice with INT64_MAX? */
+  tt_i64_op((INT64_MIN + INT64_MAX), ==,
+            add_laplace_noise(INT64_MAX, 0.0,
+                              noscale_df, noscale_eps));
+
+  /* do near-zero fractional values work? */
+  const double min_dbl_error = 0.0000000000000002;
+
+  tt_i64_op(-35, ==,
+            add_laplace_noise(0, min_dbl_error,
+                              noscale_df, noscale_eps));
+  tt_i64_op(INT64_MIN, ==,
+            add_laplace_noise(INT64_MIN, min_dbl_error,
+                              noscale_df, noscale_eps));
+  tt_i64_op((-35 + INT64_MAX), ==,
+            add_laplace_noise(INT64_MAX, min_dbl_error,
+                              noscale_df, noscale_eps));
+  tt_i64_op(INT64_MIN, ==,
+            add_laplace_noise(0, min_dbl_error,
+                              DBL_MAX, 1));
+  tt_i64_op((INT64_MAX + INT64_MIN), ==,
+            add_laplace_noise(INT64_MAX, min_dbl_error,
+                              DBL_MAX, 1));
+  tt_i64_op(INT64_MIN, ==,
+            add_laplace_noise(INT64_MIN, min_dbl_error,
+                              DBL_MAX, 1));
+
+  /* does it play nice with INT64_MAX? */
+  tt_i64_op((INT64_MAX - 35), ==,
+            add_laplace_noise(INT64_MAX, min_dbl_error,
+                              noscale_df, noscale_eps));
+
+  /* Test extreme values of signal with maximally positive values of noise
+   * 1.0000000000000002 is the smallest number > 1
+   * 0.9999999999999998 is the greatest number < 1 by calculation
+   * per https://en.wikipedia.org/wiki/Double_precision
+   * >>> laplace.ppf([1.0, 0.9999999999999998], loc = 0, scale = 1)
+   * array([inf,  35.35050621])
+   * but the function rejects p == 1.0, so we just use max_dbl_lt_one
+   */
+  const double max_dbl_lt_one = 0.9999999999999998;
+
+  /* do near-one fractional values work? */
+  tt_i64_op(35, ==,
+            add_laplace_noise(0, max_dbl_lt_one, noscale_df, noscale_eps));
+
+  /* is it clipped to INT64_MAX? */
+  tt_i64_op(INT64_MAX, ==,
+            add_laplace_noise(INT64_MAX - 35, max_dbl_lt_one,
+                              noscale_df, noscale_eps));
+  tt_i64_op(INT64_MAX, ==,
+            add_laplace_noise(INT64_MAX - 34, max_dbl_lt_one,
+                              noscale_df, noscale_eps));
+  tt_i64_op(INT64_MAX, ==,
+            add_laplace_noise(INT64_MAX, max_dbl_lt_one,
+                              noscale_df, noscale_eps));
+  /* ... even when scaled? */
+  tt_i64_op(INT64_MAX, ==,
+            add_laplace_noise(INT64_MAX, max_dbl_lt_one,
+                              delta_f, epsilon));
+  tt_i64_op((INT64_MIN + INT64_MAX), ==,
+            add_laplace_noise(INT64_MIN, max_dbl_lt_one,
+                              DBL_MAX, 1));
+  tt_i64_op(INT64_MAX, ==,
+            add_laplace_noise(INT64_MAX, max_dbl_lt_one,
+                              DBL_MAX, 1));
+  /* does it play nice with INT64_MIN? */
+  tt_i64_op((INT64_MIN + 35), ==,
+            add_laplace_noise(INT64_MIN, max_dbl_lt_one,
+                              noscale_df, noscale_eps));
+
  done:
   ;
 }
 
-#define UTIL_LEGACY(name)                                               \
-  { #name, test_util_ ## name , 0, NULL, NULL }
+static void
+test_util_clamp_double_to_int64(void *arg)
+{
+  (void)arg;
 
-#define UTIL_TEST(name, flags)                          \
-  { #name, test_util_ ## name, flags, NULL, NULL }
+  tt_i64_op(INT64_MIN, ==, clamp_double_to_int64(-INFINITY));
+  tt_i64_op(INT64_MIN, ==,
+            clamp_double_to_int64(-1.0 * pow(2.0, 64.0) - 1.0));
+  tt_i64_op(INT64_MIN, ==,
+            clamp_double_to_int64(-1.0 * pow(2.0, 63.0) - 1.0));
+  tt_i64_op(((uint64_t) -1) << 53, ==,
+            clamp_double_to_int64(-1.0 * pow(2.0, 53.0)));
+  tt_i64_op((((uint64_t) -1) << 53) + 1, ==,
+            clamp_double_to_int64(-1.0 * pow(2.0, 53.0) + 1.0));
+  tt_i64_op(-1, ==, clamp_double_to_int64(-1.0));
+  tt_i64_op(0, ==, clamp_double_to_int64(-0.9));
+  tt_i64_op(0, ==, clamp_double_to_int64(-0.1));
+  tt_i64_op(0, ==, clamp_double_to_int64(0.0));
+  tt_i64_op(0, ==, clamp_double_to_int64(NAN));
+  tt_i64_op(0, ==, clamp_double_to_int64(0.1));
+  tt_i64_op(0, ==, clamp_double_to_int64(0.9));
+  tt_i64_op(1, ==, clamp_double_to_int64(1.0));
+  tt_i64_op((((int64_t) 1) << 53) - 1, ==,
+            clamp_double_to_int64(pow(2.0, 53.0) - 1.0));
+  tt_i64_op(((int64_t) 1) << 53, ==,
+            clamp_double_to_int64(pow(2.0, 53.0)));
+  tt_i64_op(INT64_MAX, ==,
+            clamp_double_to_int64(pow(2.0, 63.0)));
+  tt_i64_op(INT64_MAX, ==,
+            clamp_double_to_int64(pow(2.0, 64.0)));
+  tt_i64_op(INT64_MAX, ==, clamp_double_to_int64(INFINITY));
+
+ done:
+  ;
+}
 
 #ifdef FD_CLOEXEC
 #define CAN_CHECK_CLOEXEC
@@ -4180,9 +4345,14 @@ fd_is_nonblocking(tor_socket_t fd)
 }
 #endif
 
+#define ERRNO_IS_EPROTO(e)    (e == SOCK_ERRNO(EPROTONOSUPPORT))
+#define SOCK_ERR_IS_EPROTO(s) ERRNO_IS_EPROTO(tor_socket_errno(s))
+
+/* Test for tor_open_socket*, using IPv4 or IPv6 depending on arg. */
 static void
 test_util_socket(void *arg)
 {
+  const int domain = !strcmp(arg, "4") ? AF_INET : AF_INET6;
   tor_socket_t fd1 = TOR_INVALID_SOCKET;
   tor_socket_t fd2 = TOR_INVALID_SOCKET;
   tor_socket_t fd3 = TOR_INVALID_SOCKET;
@@ -4193,15 +4363,19 @@ test_util_socket(void *arg)
 
   (void)arg;
 
-  fd1 = tor_open_socket_with_extensions(AF_INET, SOCK_STREAM, 0, 0, 0);
-  fd2 = tor_open_socket_with_extensions(AF_INET, SOCK_STREAM, 0, 0, 1);
+  fd1 = tor_open_socket_with_extensions(domain, SOCK_STREAM, 0, 0, 0);
+  if (SOCK_ERR_IS_EPROTO(fd1)) {
+    /* Assume we're on an IPv4-only or IPv6-only system, and give up now. */
+    goto done;
+  }
+  fd2 = tor_open_socket_with_extensions(domain, SOCK_STREAM, 0, 0, 1);
   tt_assert(SOCKET_OK(fd1));
   tt_assert(SOCKET_OK(fd2));
   tt_int_op(get_n_open_sockets(), OP_EQ, n + 2);
-  //fd3 = tor_open_socket_with_extensions(AF_INET, SOCK_STREAM, 0, 1, 0);
-  //fd4 = tor_open_socket_with_extensions(AF_INET, SOCK_STREAM, 0, 1, 1);
-  fd3 = tor_open_socket(AF_INET, SOCK_STREAM, 0);
-  fd4 = tor_open_socket_nonblocking(AF_INET, SOCK_STREAM, 0);
+  //fd3 = tor_open_socket_with_extensions(domain, SOCK_STREAM, 0, 1, 0);
+  //fd4 = tor_open_socket_with_extensions(domain, SOCK_STREAM, 0, 1, 1);
+  fd3 = tor_open_socket(domain, SOCK_STREAM, 0);
+  fd4 = tor_open_socket_nonblocking(domain, SOCK_STREAM, 0);
   tt_assert(SOCKET_OK(fd3));
   tt_assert(SOCKET_OK(fd4));
   tt_int_op(get_n_open_sockets(), OP_EQ, n + 4);
@@ -4250,8 +4424,20 @@ test_util_socketpair(void *arg)
   int n = get_n_open_sockets();
   tor_socket_t fds[2] = {TOR_INVALID_SOCKET, TOR_INVALID_SOCKET};
   const int family = AF_UNIX;
+  int socketpair_result = 0;
+
+  socketpair_result = tor_socketpair_fn(family, SOCK_STREAM, 0, fds);
+  /* If there is no 127.0.0.1 or ::1, tor_ersatz_socketpair will and must fail.
+   * Otherwise, we risk exposing a socketpair on a routable IP address. (Some
+   * BSD jails use a routable address for localhost. Fortunately, they have
+   * the real AF_UNIX socketpair.) */
+  if (ersatz && ERRNO_IS_EPROTO(-socketpair_result)) {
+    /* In my testing, an IPv6-only FreeBSD jail without ::1 returned EINVAL.
+     * Assume we're on a machine without 127.0.0.1 or ::1 and give up now. */
+    goto done;
+  }
+  tt_int_op(0, OP_EQ, socketpair_result);
 
-  tt_int_op(0, OP_EQ, tor_socketpair_fn(family, SOCK_STREAM, 0, fds));
   tt_assert(SOCKET_OK(fds[0]));
   tt_assert(SOCKET_OK(fds[1]));
   tt_int_op(get_n_open_sockets(), OP_EQ, n + 2);
@@ -4271,6 +4457,8 @@ test_util_socketpair(void *arg)
     tor_close_socket(fds[1]);
 }
 
+#undef SOCKET_EPROTO
+
 static void
 test_util_max_mem(void *arg)
 {
@@ -4414,6 +4602,92 @@ test_util_get_avail_disk_space(void *arg)
   ;
 }
 
+static void
+test_util_touch_file(void *arg)
+{
+  (void) arg;
+  const char *fname = get_fname("touch");
+
+  const time_t now = time(NULL);
+  struct stat st;
+  write_bytes_to_file(fname, "abc", 3, 1);
+  tt_int_op(0, OP_EQ, stat(fname, &st));
+  /* A subtle point: the filesystem time is not necessarily equal to the
+   * system clock time, since one can be using a monotonic clock, or coarse
+   * monotonic clock, or whatever.  So we might wind up with an mtime a few
+   * microseconds ago.  Let's just give it a lot of wiggle room. */
+  tt_i64_op(st.st_mtime, OP_GE, now - 1);
+
+  const time_t five_sec_ago = now - 5;
+  struct utimbuf u = { five_sec_ago, five_sec_ago };
+  tt_int_op(0, OP_EQ, utime(fname, &u));
+  tt_int_op(0, OP_EQ, stat(fname, &st));
+  /* Let's hope that utime/stat give the same second as a round-trip? */
+  tt_i64_op(st.st_mtime, OP_EQ, five_sec_ago);
+
+  /* Finally we can touch the file */
+  tt_int_op(0, OP_EQ, touch_file(fname));
+  tt_int_op(0, OP_EQ, stat(fname, &st));
+  tt_i64_op(st.st_mtime, OP_GE, now-1);
+
+ done:
+  ;
+}
+
+#ifndef _WIN32
+static void
+test_util_pwdb(void *arg)
+{
+  (void) arg;
+  const struct passwd *me = NULL, *me2, *me3;
+  char *name = NULL;
+  char *dir = NULL;
+
+  /* Uncached case. */
+  /* Let's assume that we exist. */
+  me = tor_getpwuid(getuid());
+  tt_assert(me != NULL);
+  name = tor_strdup(me->pw_name);
+
+  /* Uncached case */
+  me2 = tor_getpwnam(name);
+  tt_assert(me2 != NULL);
+  tt_int_op(me2->pw_uid, OP_EQ, getuid());
+
+  /* Cached case */
+  me3 = tor_getpwuid(getuid());
+  tt_assert(me3 != NULL);
+  tt_str_op(me3->pw_name, OP_EQ, name);
+
+  me3 = tor_getpwnam(name);
+  tt_assert(me3 != NULL);
+  tt_int_op(me3->pw_uid, OP_EQ, getuid());
+
+  dir = get_user_homedir(name);
+  tt_assert(dir != NULL);
+
+ done:
+  tor_free(name);
+  tor_free(dir);
+}
+#endif
+
+#define UTIL_LEGACY(name)                                               \
+  { #name, test_util_ ## name , 0, NULL, NULL }
+
+#define UTIL_TEST(name, flags)                          \
+  { #name, test_util_ ## name, flags, NULL, NULL }
+
+#ifdef _WIN32
+#define UTIL_TEST_NO_WIN(n, f) { #n, NULL, TT_SKIP, NULL, NULL }
+#define UTIL_TEST_WIN_ONLY(n, f) UTIL_TEST(n, (f))
+#define UTIL_LEGACY_NO_WIN(n) UTIL_TEST_NO_WIN(n, 0)
+#else
+#define UTIL_TEST_NO_WIN(n, f) UTIL_TEST(n, (f))
+#define UTIL_TEST_WIN_ONLY(n, f) { #n, NULL, TT_SKIP, NULL, NULL }
+#define UTIL_LEGACY_NO_WIN(n) UTIL_LEGACY(n)
+#endif
+
 struct testcase_t util_tests[] = {
   UTIL_LEGACY(time),
   UTIL_TEST(parse_http_time, 0),
@@ -4421,9 +4695,7 @@ struct testcase_t util_tests[] = {
   UTIL_LEGACY(config_line_quotes),
   UTIL_LEGACY(config_line_comment_character),
   UTIL_LEGACY(config_line_escaped_content),
-#ifndef _WIN32
-  UTIL_LEGACY(expand_filename),
-#endif
+  UTIL_LEGACY_NO_WIN(expand_filename),
   UTIL_LEGACY(escape_string_socks),
   UTIL_LEGACY(string_is_key_value),
   UTIL_LEGACY(strmisc),
@@ -4441,19 +4713,16 @@ struct testcase_t util_tests[] = {
   UTIL_TEST(di_map, 0),
   UTIL_TEST(round_to_next_multiple_of, 0),
   UTIL_TEST(laplace, 0),
+  UTIL_TEST(clamp_double_to_int64, 0),
   UTIL_TEST(find_str_at_start_of_line, 0),
   UTIL_TEST(string_is_C_identifier, 0),
   UTIL_TEST(asprintf, 0),
   UTIL_TEST(listdir, 0),
   UTIL_TEST(parent_dir, 0),
   UTIL_TEST(ftruncate, 0),
-#ifdef _WIN32
-  UTIL_TEST(load_win_lib, 0),
-#endif
-#ifndef _WIN32
-  UTIL_TEST(exit_status, 0),
-  UTIL_TEST(fgets_eagain, 0),
-#endif
+  UTIL_TEST_WIN_ONLY(load_win_lib, 0),
+  UTIL_TEST_NO_WIN(exit_status, 0),
+  UTIL_TEST_NO_WIN(fgets_eagain, 0),
   UTIL_TEST(format_hex_number, 0),
   UTIL_TEST(format_dec_number, 0),
   UTIL_TEST(join_win_cmdline, 0),
@@ -4473,7 +4742,10 @@ struct testcase_t util_tests[] = {
   UTIL_TEST(write_chunks_to_file, 0),
   UTIL_TEST(mathlog, 0),
   UTIL_TEST(weak_random, 0),
-  UTIL_TEST(socket, TT_FORK),
+  { "socket_ipv4", test_util_socket, TT_FORK, &passthrough_setup,
+    (void*)"4" },
+  { "socket_ipv6", test_util_socket, TT_FORK,
+    &passthrough_setup, (void*)"6" },
   { "socketpair", test_util_socketpair, TT_FORK, &passthrough_setup,
     (void*)"0" },
   { "socketpair_ersatz", test_util_socketpair, TT_FORK,
@@ -4483,6 +4755,8 @@ struct testcase_t util_tests[] = {
   UTIL_TEST(ipv4_validation, 0),
   UTIL_TEST(writepid, 0),
   UTIL_TEST(get_avail_disk_space, 0),
+  UTIL_TEST(touch_file, 0),
+  UTIL_TEST_NO_WIN(pwdb, TT_FORK),
   END_OF_TESTCASES
 };
 
diff --git a/src/test/test_util_format.c b/src/test/test_util_format.c
new file mode 100644
index 0000000..45a28cc
--- /dev/null
+++ b/src/test/test_util_format.c
@@ -0,0 +1,302 @@
+/* Copyright (c) 2010-2015, The Tor Project, Inc. */
+/* See LICENSE for licensing information */
+
+#include "orconfig.h"
+#include "or.h"
+
+#include "test.h"
+
+#define UTIL_FORMAT_PRIVATE
+#include "util_format.h"
+
+#define NS_MODULE util_format
+
+#if !defined(HAVE_HTONLL) && !defined(htonll)
+#ifdef WORDS_BIGENDIAN
+#define htonll(x) (x)
+#else
+static uint64_t
+htonll(uint64_t a)
+{
+  return htonl((uint32_t)(a>>32)) | (((uint64_t)htonl((uint32_t)a))<<32);
+}
+#endif
+#endif
+
+static void
+test_util_format_unaligned_accessors(void *ignored)
+{
+  (void)ignored;
+  char buf[9] = "onionsoup"; // 6f6e696f6e736f7570
+
+  tt_u64_op(get_uint64(buf+1), OP_EQ, htonll(U64_LITERAL(0x6e696f6e736f7570)));
+  tt_uint_op(get_uint32(buf+1), OP_EQ, htonl(0x6e696f6e));
+  tt_uint_op(get_uint16(buf+1), OP_EQ, htons(0x6e69));
+  tt_uint_op(get_uint8(buf+1), OP_EQ, 0x6e);
+
+  set_uint8(buf+7, 0x61);
+  tt_mem_op(buf, OP_EQ, "onionsoap", 9);
+
+  set_uint16(buf+6, htons(0x746f));
+  tt_mem_op(buf, OP_EQ, "onionstop", 9);
+
+  set_uint32(buf+1, htonl(0x78696465));
+  tt_mem_op(buf, OP_EQ, "oxidestop", 9);
+
+  set_uint64(buf+1, htonll(U64_LITERAL(0x6266757363617465)));
+  tt_mem_op(buf, OP_EQ, "obfuscate", 9);
+ done:
+  ;
+}
+
+static void
+test_util_format_base64_encode(void *ignored)
+{
+  (void)ignored;
+  int res;
+  int i;
+  char *src;
+  char *dst;
+
+  src = tor_malloc_zero(256);
+  dst = tor_malloc_zero(1000);
+
+  for (i=0;i<256;i++) {
+    src[i] = (char)i;
+  }
+
+  res = base64_encode(NULL, 1, src, 1, 0);
+  tt_int_op(res, OP_EQ, -1);
+
+  res = base64_encode(dst, 1, NULL, 1, 0);
+  tt_int_op(res, OP_EQ, -1);
+
+  res = base64_encode(dst, 1, src, 10, 0);
+  tt_int_op(res, OP_EQ, -1);
+
+  res = base64_encode(dst, SSIZE_MAX-1, src, 1, 0);
+  tt_int_op(res, OP_EQ, -1);
+
+  res = base64_encode(dst, SSIZE_MAX-1, src, 10, 0);
+  tt_int_op(res, OP_EQ, -1);
+
+  res = base64_encode(dst, 1000, src, 256, 0);
+  tt_int_op(res, OP_EQ, 344);
+  tt_str_op(dst, OP_EQ, "AAECAwQFBgcICQoLDA0ODxAREhMUFRYXGBkaGxwdHh"
+            "8gISIjJCUmJygpKissLS4vMDEyMzQ1Njc4OTo7PD0+P0BBQkNERUZH"
+            "SElKS0xNTk9QUVJTVFVWV1hZWltcXV5fYGFiY2RlZmdoaWprbG1ub3"
+            "BxcnN0dXZ3eHl6e3x9fn+AgYKDhIWGh4iJiouMjY6PkJGSk5SVlpeY"
+            "mZqbnJ2en6ChoqOkpaanqKmqq6ytrq+wsbKztLW2t7i5uru8vb6/wM"
+            "HCw8TFxsfIycrLzM3Oz9DR0tPU1dbX2Nna29zd3t/g4eLj5OXm5+jp"
+            "6uvs7e7v8PHy8/T19vf4+fr7/P3+/w==");
+
+  res = base64_encode(dst, 1000, src, 256, BASE64_ENCODE_MULTILINE);
+  tt_int_op(res, OP_EQ, 350);
+  tt_str_op(dst, OP_EQ,
+          "AAECAwQFBgcICQoLDA0ODxAREhMUFRYXGBkaGxwdHh8gISIjJCUmJygpKissLS4v\n"
+          "MDEyMzQ1Njc4OTo7PD0+P0BBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWltcXV5f\n"
+          "YGFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6e3x9fn+AgYKDhIWGh4iJiouMjY6P\n"
+          "kJGSk5SVlpeYmZqbnJ2en6ChoqOkpaanqKmqq6ytrq+wsbKztLW2t7i5uru8vb6/\n"
+          "wMHCw8TFxsfIycrLzM3Oz9DR0tPU1dbX2Nna29zd3t/g4eLj5OXm5+jp6uvs7e7v\n"
+          "8PHy8/T19vf4+fr7/P3+/w==\n");
+
+  res = base64_encode(dst, 1000, src+1, 255, BASE64_ENCODE_MULTILINE);
+  tt_int_op(res, OP_EQ, 346);
+
+  for (i = 0;i<50;i++) {
+    src[i] = 0;
+  }
+  src[50] = 255;
+  src[51] = 255;
+  src[52] = 255;
+  src[53] = 255;
+
+  res = base64_encode(dst, 1000, src, 54, BASE64_ENCODE_MULTILINE);
+  tt_int_op(res, OP_EQ, 74);
+
+  res = base64_encode(dst, 1000, src+1, 53, BASE64_ENCODE_MULTILINE);
+  tt_int_op(res, OP_EQ, 74);
+
+  res = base64_encode(dst, 1000, src+2, 52, BASE64_ENCODE_MULTILINE);
+  tt_int_op(res, OP_EQ, 74);
+
+  res = base64_encode(dst, 1000, src+3, 51, BASE64_ENCODE_MULTILINE);
+  tt_int_op(res, OP_EQ, 70);
+
+  res = base64_encode(dst, 1000, src+4, 50, BASE64_ENCODE_MULTILINE);
+  tt_int_op(res, OP_EQ, 70);
+
+  res = base64_encode(dst, 1000, src+5, 49, BASE64_ENCODE_MULTILINE);
+  tt_int_op(res, OP_EQ, 70);
+
+  res = base64_encode(dst, 1000, src+6, 48, BASE64_ENCODE_MULTILINE);
+  tt_int_op(res, OP_EQ, 65);
+
+  res = base64_encode(dst, 1000, src+7, 47, BASE64_ENCODE_MULTILINE);
+  tt_int_op(res, OP_EQ, 65);
+
+  res = base64_encode(dst, 1000, src+8, 46, BASE64_ENCODE_MULTILINE);
+  tt_int_op(res, OP_EQ, 65);
+
+ done:
+  tor_free(src);
+  tor_free(dst);
+}
+
+static void
+test_util_format_base64_decode_nopad(void *ignored)
+{
+  (void)ignored;
+  int res;
+  int i;
+  char *src;
+  uint8_t *dst, *real_dst;
+  uint8_t expected[] = {0x65, 0x78, 0x61, 0x6D, 0x70, 0x6C, 0x65};
+  char real_src[] = "ZXhhbXBsZQ";
+
+  src = tor_malloc_zero(256);
+  dst = tor_malloc_zero(1000);
+  real_dst = tor_malloc_zero(10);
+
+  for (i=0;i<256;i++) {
+    src[i] = (char)i;
+  }
+
+  res = base64_decode_nopad(dst, 1, src, SIZE_T_CEILING);
+  tt_int_op(res, OP_EQ, -1);
+
+  res = base64_decode_nopad(dst, 1, src, 5);
+  tt_int_op(res, OP_EQ, -1);
+
+  const char *s = "SGVsbG8gd29ybGQ";
+  res = base64_decode_nopad(dst, 1000, s, strlen(s));
+  tt_int_op(res, OP_EQ, 11);
+  tt_mem_op(dst, OP_EQ, "Hello world", 11);
+
+  s = "T3BhIG11bmRv";
+  res = base64_decode_nopad(dst, 9, s, strlen(s));
+  tt_int_op(res, OP_EQ, 9);
+  tt_mem_op(dst, OP_EQ, "Opa mundo", 9);
+
+  res = base64_decode_nopad(real_dst, 10, real_src, 10);
+  tt_int_op(res, OP_EQ, 7);
+  tt_mem_op(real_dst, OP_EQ, expected, 7);
+
+ done:
+  tor_free(src);
+  tor_free(dst);
+  tor_free(real_dst);
+}
+
+static void
+test_util_format_base64_decode(void *ignored)
+{
+  (void)ignored;
+  int res;
+  int i;
+  char *src;
+  char *dst, *real_dst;
+  uint8_t expected[] = {0x65, 0x78, 0x61, 0x6D, 0x70, 0x6C, 0x65};
+  char real_src[] = "ZXhhbXBsZQ==";
+
+  src = tor_malloc_zero(256);
+  dst = tor_malloc_zero(1000);
+  real_dst = tor_malloc_zero(10);
+
+  for (i=0;i<256;i++) {
+    src[i] = (char)i;
+  }
+
+  res = base64_decode(dst, 1, src, SIZE_T_CEILING);
+  tt_int_op(res, OP_EQ, -1);
+
+  res = base64_decode(dst, SIZE_T_CEILING+1, src, 10);
+  tt_int_op(res, OP_EQ, -1);
+
+  const char *s = "T3BhIG11bmRv";
+  res = base64_decode(dst, 9, s, strlen(s));
+  tt_int_op(res, OP_EQ, 9);
+  tt_mem_op(dst, OP_EQ, "Opa mundo", 9);
+
+  memset(dst, 0, 1000);
+  res = base64_decode(dst, 100, s, strlen(s));
+  tt_int_op(res, OP_EQ, 9);
+  tt_mem_op(dst, OP_EQ, "Opa mundo", 9);
+
+  s = "SGVsbG8gd29ybGQ=";
+  res = base64_decode(dst, 100, s, strlen(s));
+  tt_int_op(res, OP_EQ, 11);
+  tt_mem_op(dst, OP_EQ, "Hello world", 11);
+
+  res = base64_decode(real_dst, 10, real_src, 10);
+  tt_int_op(res, OP_EQ, 7);
+  tt_mem_op(real_dst, OP_EQ, expected, 7);
+
+ done:
+  tor_free(src);
+  tor_free(dst);
+  tor_free(real_dst);
+}
+
+static void
+test_util_format_base16_decode(void *ignored)
+{
+  (void)ignored;
+  int res;
+  int i;
+  char *src;
+  char *dst, *real_dst;
+  char expected[] = {0x65, 0x78, 0x61, 0x6D, 0x70, 0x6C, 0x65};
+  char real_src[] = "6578616D706C65";
+
+  src = tor_malloc_zero(256);
+  dst = tor_malloc_zero(1000);
+  real_dst = tor_malloc_zero(10);
+
+  for (i=0;i<256;i++) {
+    src[i] = (char)i;
+  }
+
+  res = base16_decode(dst, 3, src, 3);
+  tt_int_op(res, OP_EQ, -1);
+
+  res = base16_decode(dst, 1, src, 10);
+  tt_int_op(res, OP_EQ, -1);
+
+  res = base16_decode(dst, SIZE_T_CEILING+2, src, 10);
+  tt_int_op(res, OP_EQ, -1);
+
+  res = base16_decode(dst, 1000, "", 0);
+  tt_int_op(res, OP_EQ, 0);
+
+  res = base16_decode(dst, 1000, "aabc", 4);
+  tt_int_op(res, OP_EQ, 0);
+  tt_mem_op(dst, OP_EQ, "\xaa\xbc", 2);
+
+  res = base16_decode(dst, 1000, "aabcd", 6);
+  tt_int_op(res, OP_EQ, -1);
+
+  res = base16_decode(dst, 1000, "axxx", 4);
+  tt_int_op(res, OP_EQ, -1);
+
+  res = base16_decode(real_dst, 10, real_src, 14);
+  tt_int_op(res, OP_EQ, 0);
+  tt_mem_op(real_dst, OP_EQ, expected, 7);
+
+ done:
+  tor_free(src);
+  tor_free(dst);
+  tor_free(real_dst);
+}
+
+struct testcase_t util_format_tests[] = {
+  { "unaligned_accessors", test_util_format_unaligned_accessors, 0,
+    NULL, NULL },
+  { "base64_encode", test_util_format_base64_encode, 0, NULL, NULL },
+  { "base64_decode_nopad", test_util_format_base64_decode_nopad, 0,
+    NULL, NULL },
+  { "base64_decode", test_util_format_base64_decode, 0, NULL, NULL },
+  { "base16_decode", test_util_format_base16_decode, 0, NULL, NULL },
+  END_OF_TESTCASES
+};
+
diff --git a/src/test/test_util_process.c b/src/test/test_util_process.c
new file mode 100644
index 0000000..0a4354c
--- /dev/null
+++ b/src/test/test_util_process.c
@@ -0,0 +1,82 @@
+/* Copyright (c) 2010-2015, The Tor Project, Inc. */
+/* See LICENSE for licensing information */
+
+#define UTIL_PROCESS_PRIVATE
+#include "orconfig.h"
+#include "or.h"
+
+#include "test.h"
+
+#include "util_process.h"
+
+#include "log_test_helpers.h"
+
+#ifndef _WIN32
+#define NS_MODULE util_process
+
+static void
+temp_callback(int r, void *s)
+{
+  (void)r;
+  (void)s;
+}
+
+static void
+test_util_process_set_waitpid_callback(void *ignored)
+{
+  (void)ignored;
+  waitpid_callback_t *res1 = NULL, *res2 = NULL;
+  int previous_log = setup_capture_of_logs(LOG_WARN);
+  pid_t pid = (pid_t)42;
+
+  res1 = set_waitpid_callback(pid, temp_callback, NULL);
+  tt_assert(res1);
+
+  res2 = set_waitpid_callback(pid, temp_callback, NULL);
+  tt_assert(res2);
+  expect_log_msg("Replaced a waitpid monitor on pid 42. That should be "
+            "impossible.\n");
+
+ done:
+  teardown_capture_of_logs(previous_log);
+  clear_waitpid_callback(res1);
+  clear_waitpid_callback(res2);
+}
+
+static void
+test_util_process_clear_waitpid_callback(void *ignored)
+{
+  (void)ignored;
+  waitpid_callback_t *res;
+  int previous_log = setup_capture_of_logs(LOG_WARN);
+  pid_t pid = (pid_t)43;
+
+  clear_waitpid_callback(NULL);
+
+  res = set_waitpid_callback(pid, temp_callback, NULL);
+  clear_waitpid_callback(res);
+  expect_no_log_entry();
+
+#if 0
+  /* No.  This is use-after-free.  We don't _do_ that. XXXX */
+  clear_waitpid_callback(res);
+  expect_log_msg("Couldn't remove waitpid monitor for pid 43.\n");
+#endif
+
+ done:
+  teardown_capture_of_logs(previous_log);
+}
+#endif /* _WIN32 */
+
+#ifndef _WIN32
+#define TEST(name) { #name, test_util_process_##name, 0, NULL, NULL }
+#else
+#define TEST(name) { #name, NULL, TT_SKIP, NULL, NULL }
+#endif
+
+struct testcase_t util_process_tests[] = {
+  TEST(set_waitpid_callback),
+  TEST(clear_waitpid_callback),
+  END_OF_TESTCASES
+};
+
diff --git a/src/test/test_workqueue.c b/src/test/test_workqueue.c
index 0d79733..1202f80 100644
--- a/src/test/test_workqueue.c
+++ b/src/test/test_workqueue.c
@@ -390,8 +390,14 @@ main(int argc, char **argv)
 
   init_logging(1);
   network_init();
-  crypto_global_init(1, NULL, NULL);
-  crypto_seed_rng();
+  if (crypto_global_init(1, NULL, NULL) < 0) {
+    printf("Couldn't initialize crypto subsystem; exiting.\n");
+    return 1;
+  }
+  if (crypto_seed_rng() < 0) {
+    printf("Couldn't seed RNG; exiting.\n");
+    return 1;
+  }
 
   rq = replyqueue_new(as_flags);
   tor_assert(rq);
diff --git a/src/test/testing_common.c b/src/test/testing_common.c
index 441024b..9c7fca0 100644
--- a/src/test/testing_common.c
+++ b/src/test/testing_common.c
@@ -238,6 +238,11 @@ main(int c, const char **v)
   update_approx_time(time(NULL));
   options = options_new();
   tor_threads_init();
+
+  struct tor_libevent_cfg cfg;
+  memset(&cfg, 0, sizeof(cfg));
+  tor_libevent_initialize(&cfg);
+
   control_initialize_event_queue();
   init_logging(1);
   configure_backtrace_handler(get_version());
@@ -272,7 +277,10 @@ main(int c, const char **v)
     return 1;
   }
   crypto_set_tls_dh_prime();
-  crypto_seed_rng();
+  if (crypto_seed_rng() < 0) {
+    printf("Couldn't seed RNG; exiting.\n");
+    return 1;
+  }
   rep_hist_init();
   network_init();
   setup_directory();
@@ -294,6 +302,7 @@ main(int c, const char **v)
   tor_free_all(0);
   dmalloc_log_unfreed();
 #endif
+  crypto_global_cleanup();
 
   if (have_failed)
     return 1;
diff --git a/src/test/vote_descriptors.inc b/src/test/vote_descriptors.inc
new file mode 100644
index 0000000..c5ce21f
--- /dev/null
+++ b/src/test/vote_descriptors.inc
@@ -0,0 +1,94 @@
+const char* VOTE_BODY_V3 = 
+"network-status-version 3\n"
+"vote-status vote\n"
+"consensus-methods 13 14 15 16 17 18 19 20 21\n"
+"published 2015-09-02 19:34:15\n"
+"valid-after 2015-09-02 19:50:55\n"
+"fresh-until 2015-09-02 20:07:38\n"
+"valid-until 2015-09-02 20:24:15\n"
+"voting-delay 100 250\n"
+"client-versions 0.1.2.14,0.1.2.17\n"
+"server-versions 0.1.2.10,0.1.2.15,0.1.2.16\n"
+"known-flags Authority Exit Fast Guard MadeOfCheese MadeOfTin Running Stable V2Dir Valid\n"
+"flag-thresholds stable-uptime=0 stable-mtbf=0 fast-speed=0 guard-wfu=0.000% guard-tk=0 guard-bw-inc-exits=0 guard-bw-exc-exits=0 enough-mtbf=0 ignoring-advertised-bws=0\n"
+"params circuitwindow=80 foo=660\n"
+"dir-source Voter3 D867ACF56A9D229B35C25F0090BC9867E906BE69 3.4.5.6 3.4.5.6 80 9000\n"
+"contact voter@example.com\n"
+"legacy-dir-key 4141414141414141414141414141414141414141\n"
+"dir-key-certificate-version 3\n"
+"fingerprint D867ACF56A9D229B35C25F0090BC9867E906BE69\n"
+"dir-key-published 2008-12-12 18:07:24\n"
+"dir-key-expires 2009-12-12 18:07:24\n"
+"dir-identity-key\n"
+"-----BEGIN RSA PUBLIC KEY-----\n"
+"MIIBigKCAYEAveMpKlw8oD1YqFqpJchuwSR82BDhutbqgHiez3QO9FmzOctJpV+Y\n"
+"mpTYIJLS/qC+4GBKFF1VK0C4SoBrS3zri0qdXdE+vBGcyrxrjMklpxoqSKRY2011\n"
+"4eqYPghKlo5RzuqteBclGCHyNxWjUJeRKDWgvh+U/gr2uYM6fRm5q0fCzg4aECE7\n"
+"VP6fDGZrMbQI8jHpiMSoC9gkUASNEa6chLInlnP8/H5qUEW4TB9CN/q095pefuwL\n"
+"P+F+1Nz5hnM7fa5XmeMB8iM4RriUmOQlLBZgpQBMpEfWMIPcR9F1Gh3MxERqqUcH\n"
+"tmij+IZdeXg9OkCXykcabaYIhZD3meErn9Tax4oA/THduLfgli9zM0ExwzH1OooN\n"
+"L8rIcJ+2eBo3bQiQUbdYW71sl9w7nSPtircbJUa1mUvWYLPWQxFliPiQSetgJLMj\n"
+"VQqtPmV2hvN2Xk3lLfJO50qMTK7w7Gsaw8UtV4YDM1Hcjp/hQaIB1xfwhXgl+eUU\n"
+"btUa4c+cUTjHAgMBAAE=\n"
+"-----END RSA PUBLIC KEY-----\n"
+"dir-signing-key\n"
+"-----BEGIN RSA PUBLIC KEY-----\n"
+"MIGJAoGBALPSUInyuEu6NV3NjozplaniIEBzQXEjv1x9/+mqnwZABpYVmuy9A8nx\n"
+"eoyY3sZFsnYwNW/IZjAgG23pEmevu3F+L4myMjjaa6ORl3MgRYQ4gmuFqpefrGdm\n"
+"ywRCleh2JerkQ4VxOuq10dn/abITzLyaZzMw30KXWp5pxKXOLtxFAgMBAAE=\n"
+"-----END RSA PUBLIC KEY-----\n"
+"dir-key-crosscert\n"
+"-----BEGIN ID SIGNATURE-----\n"
+"FTBJNR/Hlt4T53yUMp1r/QCSMCpkHJCbYBT0R0pvYqhqFfYN5qHRSICRXaFFImIF\n"
+"0DGWmwRza6DxPKNzkm5/b7I0de9zJW1jNNdQAQK5xppAtQcAafRdu8cBonnmh9KX\n"
+"k1NrAK/X00FYywju3yl/SxCn1GddVNkHYexEudmJMPM=\n"
+"-----END ID SIGNATURE-----\n"
+"dir-key-certification\n"
+"-----BEGIN SIGNATURE-----\n"
+"pjWguLFBfELZDc6DywL6Do21SCl7LcutfpM92MEn4WYeSNcTXNR6lRX7reOEJk4e\n"
+"NwEaMt+Hl7slgeR5wjnW3OmMmRPZK9bquNWbfD+sAOV9bRFZTpXIdleAQFPlwvMF\n"
+"z/Gzwspzn4i2Yh6hySShrctMmW8YL3OM8LsBXzBhp/rG2uHlsxmIsc13DA6HWt61\n"
+"ffY72uNE6KckDGsQ4wPGP9q69y6g+X+TNio1KPbsILbePv6EjbO+rS8FiS4njPlg\n"
+"SPYry1RaUvxzxTkswIzdE1tjJrUiqpbWlTGxrH9N4OszoLm45Pc784KLULrjKIoi\n"
+"Q+vRsGrcMBAa+kDowWU6H1ryKR7KOhzRTcf2uqLE/W3ezaRwmOG+ETmoVFwbhk2X\n"
+"OlbXEM9fWP+INvFkr6Z93VYL2jGkCjV7e3xXmre/Lb92fUcYi6t5dwzfV8gJnIoG\n"
+"eCHd0K8NrQK0ipVk/7zcPDKOPeo9Y5aj/f6X/pDHtb+Dd5sT+l82G/Tqy4DIYUYR\n"
+"-----END SIGNATURE-----\n"
+"r router2 AwMDAwMDAwMDAwMDAwMDAwMDAwM Tk5OTk5OTk5OTk5OTk5OTk5OTk4 2015-09-02 19:09:15 153.0.136.1 443 8000\n"
+"s Running V2Dir\n"
+"v 0.1.2.14\n"
+"w Bandwidth=30 Measured=30\n"
+"p reject 1-65535\n"
+"id ed25519 none\n"
+"m 9,10,11,12,13,14,15,16,17 sha256=xyzajkldsdsajdadlsdjaslsdksdjlsdjsdaskdaaa0\n"
+"r router1 BQUFBQUFBQUFBQUFBQUFBQUFBQU TU1NTU1NTU1NTU1NTU1NTU1NTU0 2015-09-02 19:17:35 153.0.153.1 443 0\n"
+"a [1:2:3::4]:4711\n"
+"s Exit Fast Guard Running Stable Valid\n"
+"v 0.2.0.5\n"
+"w Bandwidth=120 Measured=120\n"
+"p reject 1-65535\n"
+"id ed25519 none\n"
+"m 9,10,11,12,13,14,15,16,17 sha256=xyzajkldsdsajdadlsdjaslsdksdjlsdjsdaskdaaa1\n"
+"r router3 MzMzMzMzMzMzMzMzMzMzMzMzMzM T09PT09PT09PT09PT09PT09PT08 2015-09-02 19:17:35 170.0.153.1 400 9999\n"
+"s Authority Exit Fast Guard Running Stable V2Dir Valid\n"
+"v 0.1.0.3\n"
+"w Bandwidth=120\n"
+"p reject 1-65535\n"
+"id ed25519 none\n"
+"m 9,10,11,12,13,14,15,16,17 "
+"sha256=xyzajkldsdsajdadlsdjaslsdksdjlsdjsdaskdaaa2\n"
+"r router4 NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ Ly8vLy8vLy8vLy8vLy8vLy8vLy8 2015-09-02 19:17:35 192.0.2.3 500 1999\n"
+"s Running V2Dir\n"
+"v 0.1.6.3\n"
+"w Bandwidth=30\n"
+"p reject 1-65535\n"
+"id ed25519 none\n"
+"m 9,10,11,12,13,14,15,16,17 sha256=xyzajkldsdsajdadlsdjaslsdksdjlsdjsdaskdaaa3\n"
+"directory-footer\n"
+"directory-signature D867ACF56A9D229B35C25F0090BC9867E906BE69 CBF56A83368A5150F1A9AAADAFB4D77F8C4170E2\n"
+"-----BEGIN SIGNATURE-----\n"
+"AHiWcHe+T3XbnlQqvqSAk6RY3XmEy1+hM2u9Xk6BNi7BpQkEQM1f0vzRpgn5Dnf2\n"
+"TXQWGUq9Z7jdSVnzWT3xqPA4zjw6eZkj+DKUtwq+oEDZGlf8eHTFmr0NAWfwZbk9\n"
+"NAjbMTUXUP37N2XAZwkoCWwFCrrfMwXrL7OhZbj7ifo=\n"
+"-----END SIGNATURE-----\n";
+
diff --git a/src/tools/include.am b/src/tools/include.am
index ebdd349..38ed575 100644
--- a/src/tools/include.am
+++ b/src/tools/include.am
@@ -20,6 +20,7 @@ endif
 src_tools_tor_gencert_SOURCES = src/tools/tor-gencert.c
 src_tools_tor_gencert_LDFLAGS = @TOR_LDFLAGS_zlib@ @TOR_LDFLAGS_openssl@
 src_tools_tor_gencert_LDADD = src/common/libor.a src/common/libor-crypto.a \
+    $(LIBKECCAK_TINY) \
     $(LIBDONNA) \
         @TOR_LIB_MATH@ @TOR_ZLIB_LIBS@ @TOR_OPENSSL_LIBS@ \
         @TOR_LIB_WS32@ @TOR_LIB_GDI@ @CURVE25519_LIBS@
@@ -31,6 +32,7 @@ src_tools_tor_cov_gencert_CFLAGS = $(AM_CFLAGS) $(TEST_CFLAGS)
 src_tools_tor_cov_gencert_LDFLAGS = @TOR_LDFLAGS_zlib@ @TOR_LDFLAGS_openssl@
 src_tools_tor_cov_gencert_LDADD = src/common/libor-testing.a \
     src/common/libor-crypto-testing.a \
+    $(LIBKECCAK_TINY) \
     $(LIBDONNA) \
         @TOR_LIB_MATH@ @TOR_ZLIB_LIBS@ @TOR_OPENSSL_LIBS@ \
         @TOR_LIB_WS32@ @TOR_LIB_GDI@ @CURVE25519_LIBS@
@@ -39,6 +41,7 @@ endif
 src_tools_tor_checkkey_SOURCES = src/tools/tor-checkkey.c
 src_tools_tor_checkkey_LDFLAGS = @TOR_LDFLAGS_zlib@ @TOR_LDFLAGS_openssl@
 src_tools_tor_checkkey_LDADD = src/common/libor.a src/common/libor-crypto.a \
+    $(LIBKECCAK_TINY) \
     $(LIBDONNA) \
         @TOR_LIB_MATH@ @TOR_ZLIB_LIBS@ @TOR_OPENSSL_LIBS@ \
         @TOR_LIB_WS32@ @TOR_LIB_GDI@ @CURVE25519_LIBS@
diff --git a/src/trunnel/README b/src/trunnel/README
new file mode 100644
index 0000000..e24aea0
--- /dev/null
+++ b/src/trunnel/README
@@ -0,0 +1,21 @@
+This directory contains code for use with, and code made by, the
+automatic code generation tool "Trunnel".
+
+Trunnel generates binary parsers and formatters for simple data
+structures. It aims for human-readable, obviously-correct outputs over
+maximum efficiency or flexibility.
+
+The .trunnel files are the inputs here; the .c and .h files are the outputs.
+
+To add a new structure:
+   - Add a new .trunnel file or expand an existing one to describe the format
+     of the structure.
+   - Regenerate the .c and .h files.  To do this, you run
+     "scripts/codegen/run_trunnel.sh".  You'll need trunnel installed.
+   - Add the .trunnel, .c, and .h files to include.am
+
+For the Trunnel source code, and more documentation about using Trunnel,
+see https://gitweb.torproject.org/trunnel.git , especially
+    https://gitweb.torproject.org/trunnel.git/tree/README
+and https://gitweb.torproject.org/trunnel.git/tree/doc/trunnel.md
+
diff --git a/src/trunnel/include.am b/src/trunnel/include.am
index 9bf37fe..b1448b7 100644
--- a/src/trunnel/include.am
+++ b/src/trunnel/include.am
@@ -36,3 +36,7 @@ src_trunnel_libor_trunnel_testing_a_CPPFLAGS = -DTRUNNEL_LOCAL_H $(AM_CPPFLAGS)
 src_trunnel_libor_trunnel_testing_a_CFLAGS = $(AM_CFLAGS) $(TEST_CFLAGS)
 
 noinst_HEADERS+= $(TRUNNELHEADERS)
+
+EXTRA_DIST += \
+	src/trunnel/README
+
diff --git a/src/win32/orconfig.h b/src/win32/orconfig.h
index 0b39221..0c02b19 100644
--- a/src/win32/orconfig.h
+++ b/src/win32/orconfig.h
@@ -232,7 +232,7 @@
 #define USING_TWOS_COMPLEMENT
 
 /* Version number of package */
-#define VERSION "0.2.7.5"
+#define VERSION "0.2.8.1-alpha-dev"
 
 
 
