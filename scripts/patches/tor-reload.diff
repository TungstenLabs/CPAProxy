diff --git a/src/or/connection.c b/src/or/connection.c
index d30ec46..c5e1139 100644
--- a/src/or/connection.c
+++ b/src/or/connection.c
@@ -2540,7 +2540,7 @@ retry_listener_ports(smartlist_t *old_conns,
       }
     } SMARTLIST_FOREACH_END(wanted);
 
-    if (found_port) {
+    if (found_port && ! control_listeners_only) {
       /* This listener is already running; we don't need to launch it. */
       //log_debug(LD_NET, "Already have %s on %s:%d",
       //    conn_type_to_string(found_port->type), conn->address, conn->port);
diff --git a/src/or/main.c b/src/or/main.c
index 66a8571..d75f2c2 100644
--- a/src/or/main.c
+++ b/src/or/main.c
@@ -96,6 +96,7 @@ static void connection_start_reading_from_linked_conn(connection_t *conn);
 static int connection_should_read_from_linked_conn(connection_t *conn);
 static int run_main_loop_until_done(void);
 static void process_signal(int sig);
+static void tor_reload_inner(void);
 
 /********* START VARIABLES **********/
 int global_read_bucket; /**< Max number of bytes I can read this second. */
@@ -170,6 +171,11 @@ static int can_complete_circuits = 0;
  */
 int quiet_level = 0;
 
+/** Flag: Set to true if you want to reload tor */
+static int should_reload = 0;
+
+static tor_mutex_t *reload_lock = NULL;
+
 /********* END VARIABLES ************/
 
 /****************************************************************************
@@ -2368,6 +2374,13 @@ run_main_loop_once(void)
 
   if (nt_service_is_stopping())
     return 0;
+    
+  tor_mutex_acquire(reload_lock);
+  if (should_reload == 1) {
+    should_reload = 0;
+    tor_reload_inner();    
+  }
+  tor_mutex_release(reload_lock);
 
 #ifndef _WIN32
   /* Make it easier to tell whether libevent failure is our fault or not. */
@@ -2789,7 +2802,9 @@ tor_init(int argc, char *argv[])
   /* Initialize the service cache. */
   rend_cache_init();
   addressmap_init(); /* Init the client dns cache. Do it always, since it's
-                      * cheap. */
+                      * cheap. */                  
+  
+  reload_lock = tor_mutex_new();
 
   {
   /* We search for the "quiet" option first, since it decides whether we
@@ -3020,6 +3035,7 @@ tor_free_all(int postfork)
     esc_router_info(NULL);
     logs_free_all(); /* free log strings. do this last so logs keep working. */
   }
+  tor_mutex_free(reload_lock);
 }
 
 /** Do whatever cleanup is necessary before shutting Tor down. */
@@ -3058,7 +3074,7 @@ tor_cleanup(void)
 #ifdef USE_DMALLOC
   dmalloc_log_stats();
 #endif
-  tor_free_all(0); /* We could move tor_free_all back into the ifdef below
+  tor_free_all(1); /* We could move tor_free_all back into the ifdef below
                       later, if it makes shutdown unacceptably slow.  But for
                       now, leave it here: it's helped us catch bugs in the
                       past. */
@@ -3417,6 +3433,67 @@ sandbox_init_filter(void)
   return cfg;
 }
 
+void
+tor_reload(void)
+{
+  tor_mutex_acquire(reload_lock);
+
+  should_reload = 1;
+  /* Breaking the event loop so the main loop can make another turn & tor_reload_inner can get executed */
+  tell_event_loop_to_finish();
+
+  tor_mutex_release(reload_lock);
+}
+
+static void
+tor_reload_inner(void)
+{
+  log_info(LD_GENERAL, "Tor reloading itself now!");
+ 
+  const or_options_t *options = get_options();
+
+#ifdef USE_DMALLOC
+  dmalloc_log_stats();
+  dmalloc_log_changed(0, 1, 0, 0);
+#endif
+
+  if (accounting_is_enabled(options))
+    accounting_record_bandwidth_usage(time(NULL), get_or_state());
+
+  router_reset_warnings();
+  routerlist_reset_warnings();
+  if (options_init_from_torrc(0, NULL) < 0) {
+      return;
+  }
+  options = get_options();
+  if (authdir_mode_handles_descs(options, -1)) {
+    if (dirserv_load_fingerprint_file() < 0) {
+      log_info(LD_GENERAL, "Error reloading fingerprints. "
+               "Continuing with old list.");
+    }
+  }
+
+  circuit_mark_all_dirty_circs_as_unusable();
+  router_reset_status_download_failures();
+  router_reset_descriptor_download_failures();
+  if (!options->DisableNetwork)
+    update_networkstatus_downloads(time(NULL));
+
+  if (server_mode(options)) {
+    time_t now = approx_time();
+    if (load_ed_keys(options, now) < 0 ||
+         generate_ed_link_cert(options, now)) {
+      log_warn(LD_OR, "Problem reloading Ed25519 keys; still using old keys.");
+    }
+
+    cpuworkers_rotate_keyinfo();
+    dns_reset();
+  }
+    
+  retry_all_listeners(NULL, NULL, 1);
+  retry_all_listeners(NULL, NULL, 0);
+}
+
 /** Main entry point for the Tor process.  Called from main(). */
 /* This function is distinct from main() only so we can link main.c into
  * the unittest binary without conflicting with the unittests' main. */
