diff --git a/src/or/main.c b/src/or/main.c
index 478316b..991e4d6 100644
--- a/src/or/main.c
+++ b/src/or/main.c
@@ -135,6 +135,7 @@ static void connection_start_reading_from_linked_conn(connection_t *conn);
 static int connection_should_read_from_linked_conn(connection_t *conn);
 static int run_main_loop_until_done(void);
 static void process_signal(int sig);
+static void tor_reload_inner(void);
 
 /********* START VARIABLES **********/
 int global_read_bucket; /**< Max number of bytes I can read this second. */
@@ -209,6 +210,11 @@ static int can_complete_circuits = 0;
  */
 int quiet_level = 0;
 
+/** Flag: Set to true if you want to reload tor */
+static int should_reload = 0;
+
+static tor_mutex_t *reload_lock = NULL;
+
 /********* END VARIABLES ************/
 
 /****************************************************************************
@@ -2499,6 +2505,13 @@ run_main_loop_once(void)
   if (nt_service_is_stopping())
     return 0;
 
+  tor_mutex_acquire(reload_lock);
+  if (should_reload == 1) {
+    should_reload = 0;
+    tor_reload_inner();    
+  }
+  tor_mutex_release(reload_lock);
+
 #ifndef _WIN32
   /* Make it easier to tell whether libevent failure is our fault or not. */
   errno = 0;
@@ -2937,6 +2950,8 @@ tor_init(int argc, char *argv[])
   addressmap_init(); /* Init the client dns cache. Do it always, since it's
                       * cheap. */
 
+  reload_lock = tor_mutex_new();
+
   {
   /* We search for the "quiet" option first, since it decides whether we
    * will log anything at all to the command line. */
@@ -3169,6 +3184,7 @@ tor_free_all(int postfork)
     esc_router_info(NULL);
     logs_free_all(); /* free log strings. do this last so logs keep working. */
   }
+  tor_mutex_free(reload_lock);
 }
 
 /** Do whatever cleanup is necessary before shutting Tor down. */
@@ -3565,6 +3581,67 @@ sandbox_init_filter(void)
 
   return cfg;
 }
+void
+tor_reload(void)
+{
+  tor_mutex_acquire(reload_lock);
+
+  should_reload = 1;
+  /* Breaking the event loop so the main loop can make another turn & tor_reload_inner can get executed */
+  tell_event_loop_to_finish();
+
+  tor_mutex_release(reload_lock);
+}
+
+static void
+tor_reload_inner(void)
+{
+  log_info(LD_GENERAL, "Tor reloading itself now!");
+ 
+  const or_options_t *options = get_options();
+
+#ifdef USE_DMALLOC
+  dmalloc_log_stats();
+  dmalloc_log_changed(0, 1, 0, 0);
+#endif
+
+  if (accounting_is_enabled(options))
+    accounting_record_bandwidth_usage(time(NULL), get_or_state());
+
+  router_reset_warnings();
+  routerlist_reset_warnings();
+  if (options_init_from_torrc(0, NULL) < 0) {
+      return;
+  }
+  options = get_options();
+  if (authdir_mode_handles_descs(options, -1)) {
+    if (dirserv_load_fingerprint_file() < 0) {
+      log_info(LD_GENERAL, "Error reloading fingerprints. "
+               "Continuing with old list.");
+    }
+  }
+
+  circuit_mark_all_dirty_circs_as_unusable();
+  router_reset_status_download_failures();
+  router_reset_descriptor_download_failures();
+  if (!options->DisableNetwork)
+    update_networkstatus_downloads(time(NULL));
+
+  if (server_mode(options)) {
+    time_t now = approx_time();
+    int new_signing_key = load_ed_keys(options, now);
+    if (new_signing_key < 0 ||
+        generate_ed_link_cert(options, now, new_signing_key > 0)) {
+      log_warn(LD_OR, "Problem reloading Ed25519 keys; still using old keys.");
+    }
+
+    cpuworkers_rotate_keyinfo();
+    dns_reset();
+  }
+    
+  retry_all_listeners(NULL, NULL, 1);
+  retry_all_listeners(NULL, NULL, 0);
+}
 
 /** Main entry point for the Tor process.  Called from main(). */
 /* This function is distinct from main() only so we can link main.c into
